[{"filePath":"/Users/ryanrabideau/doublecheck-field-view/demo-vrbo-scraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/photo-extraction-comparison.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/photo-strategy-demo.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/quick-test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[392,395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[392,395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[557,560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[557,560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[724,727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[724,727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[857,860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[857,860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7099,7102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7099,7102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":206,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7864,7867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7864,7867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Quick test script to demonstrate current VRBO scraper output\n// This will show what the scraper actually returns with the current implementation\n\nimport { scrapeVRBOProperty } from './src/lib/scrapers/vrbo-scraper.ts';\nimport type { VRBOPropertyData } from './src/lib/scrapers/types.ts';\n\n// Mock logger to avoid external dependencies\nconst mockLogger = {\n  info: (message: string, data?: any, context?: string) => {\n    console.log(`[INFO] ${context || ''}: ${message}`, data ? JSON.stringify(data, null, 2) : '');\n  },\n  warn: (message: string, data?: any, context?: string) => {\n    console.log(`[WARN] ${context || ''}: ${message}`, data ? JSON.stringify(data, null, 2) : '');\n  },\n  error: (message: string, error?: any, context?: string) => {\n    console.log(`[ERROR] ${context || ''}: ${message}`, error);\n  }\n};\n\n// Replace the logger\n(global as any).logger = mockLogger;\n\nasync function quickTest() {\n  console.log('ðŸš€ VRBO Scraper Quick Test');\n  console.log('===========================\\n');\n\n  // Test with a mock URL (will return fallback data)\n  const testUrl = 'https://www.vrbo.com/1234567';\n  \n  console.log(`ðŸ” Testing with URL: ${testUrl}`);\n  console.log('ðŸ“ Note: This will return fallback data since we\\'re not using a real URL\\n');\n\n  try {\n    const startTime = Date.now();\n    \n    // Call the scraper\n    const result = await scrapeVRBOProperty(testUrl);\n    \n    const duration = Date.now() - startTime;\n    \n    console.log('âœ… Scraper completed successfully!');\n    console.log(`â±ï¸  Duration: ${duration}ms\\n`);\n    \n    // Display the results\n    console.log('ðŸ“Š SCRAPER OUTPUT:');\n    console.log('==================');\n    console.log(`ðŸ  Property ID: ${result.vrboId}`);\n    console.log(`ðŸ“„ Title: ${result.title}`);\n    console.log(`ðŸ›ï¸  Bedrooms: ${result.specifications?.bedrooms || 'N/A'}`);\n    console.log(`ðŸš¿ Bathrooms: ${result.specifications?.bathrooms || 'N/A'}`);\n    console.log(`ðŸ‘¥ Max Guests: ${result.specifications?.maxGuests || 'N/A'}`);\n    console.log(`ðŸ“ Location: ${result.location?.city || 'N/A'}, ${result.location?.state || 'N/A'}`);\n    console.log(`ðŸ·ï¸  Amenities: ${result.amenities?.length || 0}`);\n    console.log(`ðŸ“¸ Photos: ${result.photos?.length || 0}`);\n    console.log(`ðŸ  Rooms: ${result.rooms?.length || 0}`);\n    console.log(`ðŸ“ Description: ${result.description?.length || 0} characters`);\n    console.log(`ðŸ”— Source URL: ${result.sourceUrl}`);\n    console.log(`â° Last Updated: ${result.lastUpdated}`);\n    console.log('');\n\n    // Show amenities\n    if (result.amenities && result.amenities.length > 0) {\n      console.log('ðŸ·ï¸  AMENITIES:');\n      result.amenities.forEach((amenity, index) => {\n        console.log(`   ${index + 1}. ${amenity.name} (${amenity.category}) - ${amenity.priority}`);\n      });\n      console.log('');\n    }\n\n    // Show photos\n    if (result.photos && result.photos.length > 0) {\n      console.log('ðŸ“¸ PHOTOS:');\n      result.photos.forEach((photo, index) => {\n        console.log(`   ${index + 1}. ${photo}`);\n      });\n      console.log('');\n    }\n\n    // Show rooms\n    if (result.rooms && result.rooms.length > 0) {\n      console.log('ðŸ  ROOMS:');\n      result.rooms.forEach((room, index) => {\n        console.log(`   ${index + 1}. ${room.type} (${room.count})`);\n        if (room.photos && room.photos.length > 0) {\n          console.log(`      Photos: ${room.photos.length}`);\n        }\n        if (room.amenities && room.amenities.length > 0) {\n          console.log(`      Amenities: ${room.amenities.join(', ')}`);\n        }\n      });\n      console.log('');\n    }\n\n    // Show specifications\n    if (result.specifications) {\n      console.log('ðŸ“‹ SPECIFICATIONS:');\n      console.log(`   Property Type: ${result.specifications.propertyType || 'N/A'}`);\n      console.log(`   Bedrooms: ${result.specifications.bedrooms || 'N/A'}`);\n      console.log(`   Bathrooms: ${result.specifications.bathrooms || 'N/A'}`);\n      console.log(`   Max Guests: ${result.specifications.maxGuests || 'N/A'}`);\n      if (result.specifications.squareFootage) {\n        console.log(`   Square Footage: ${result.specifications.squareFootage}`);\n      }\n      if (result.specifications.yearBuilt) {\n        console.log(`   Year Built: ${result.specifications.yearBuilt}`);\n      }\n      console.log('');\n    }\n\n    // Show location details\n    if (result.location) {\n      console.log('ðŸ“ LOCATION:');\n      console.log(`   City: ${result.location.city || 'N/A'}`);\n      console.log(`   State: ${result.location.state || 'N/A'}`);\n      console.log(`   Country: ${result.location.country || 'N/A'}`);\n      if (result.location.zipCode) {\n        console.log(`   ZIP Code: ${result.location.zipCode}`);\n      }\n      if (result.location.coordinates) {\n        console.log(`   Coordinates: ${result.location.coordinates.latitude}, ${result.location.coordinates.longitude}`);\n      }\n      if (result.location.neighborhood) {\n        console.log(`   Neighborhood: ${result.location.neighborhood}`);\n      }\n      console.log('');\n    }\n\n    // Show house rules\n    if (result.houseRules && result.houseRules.length > 0) {\n      console.log('ðŸ“œ HOUSE RULES:');\n      result.houseRules.forEach((rule, index) => {\n        console.log(`   ${index + 1}. ${rule}`);\n      });\n      console.log('');\n    }\n\n    // Calculate and show data completeness\n    const completeness = calculateDataCompleteness(result);\n    console.log(`ðŸ“Š Data Completeness: ${completeness}%`);\n    console.log('');\n\n    // Show current implementation status\n    console.log('ðŸ”§ CURRENT IMPLEMENTATION STATUS:');\n    console.log('==================================');\n    console.log('âœ… Basic scraper structure implemented');\n    console.log('âœ… Fallback data mechanism working');\n    console.log('âœ… TypeScript types and interfaces defined');\n    console.log('âš ï¸  Browser automation not tested with real URLs');\n    console.log('âš ï¸  Photo extraction effectiveness unknown');\n    console.log('âš ï¸  Real VRBO site compatibility unverified');\n    console.log('');\n\n    console.log('ðŸŽ¯ NEXT STEPS FOR REAL TESTING:');\n    console.log('================================');\n    console.log('1. Replace test URLs with actual VRBO property URLs');\n    console.log('2. Test browser automation with real pages');\n    console.log('3. Measure actual photo extraction counts');\n    console.log('4. Validate amenity and description accuracy');\n    console.log('5. Test error handling with various property types');\n    console.log('');\n\n    console.log('ðŸ¤– EXPECTED RESULTS WITH BROWSER AUTOMATION:');\n    console.log('=============================================');\n    console.log('ðŸ“¸ Photos: 15-30 (vs current fallback: 0)');\n    console.log('ðŸ·ï¸  Amenities: 8-15 (vs current fallback: 3)');\n    console.log('ðŸ“ Description: 200-1000 chars (vs current fallback: ~150)');\n    console.log('ðŸ  Rooms: 3-6 (vs current fallback: 0)');\n    console.log('â±ï¸  Processing time: 15-45 seconds');\n    console.log('');\n\n    return result;\n\n  } catch (error) {\n    console.error('âŒ Test failed:', error);\n    throw error;\n  }\n}\n\nfunction calculateDataCompleteness(data: any): number {\n  const requiredFields = ['title', 'description', 'amenities', 'photos', 'specifications', 'location'];\n  const optionalFields = ['rooms', 'pricing', 'host', 'reviews'];\n  \n  let completedRequired = 0;\n  let completedOptional = 0;\n\n  requiredFields.forEach(field => {\n    const value = data[field];\n    if (isFieldComplete(value)) {\n      completedRequired++;\n    }\n  });\n\n  optionalFields.forEach(field => {\n    const value = data[field];\n    if (isFieldComplete(value)) {\n      completedOptional++;\n    }\n  });\n\n  const requiredScore = (completedRequired / requiredFields.length) * 80;\n  const optionalScore = (completedOptional / optionalFields.length) * 20;\n\n  return Math.round(requiredScore + optionalScore);\n}\n\nfunction isFieldComplete(value: any): boolean {\n  if (value === null || value === undefined) return false;\n  if (typeof value === 'string') return value.trim().length > 0;\n  if (Array.isArray(value)) return value.length > 0;\n  if (typeof value === 'object') return Object.keys(value).length > 0;\n  return true;\n}\n\n// Run the test\nif (require.main === module) {\n  quickTest().catch(console.error);\n}\n\nexport { quickTest };","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/scraper-output-demo.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/App.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2079,2082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2079,2082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2542,2545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2542,2545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useEffect, Suspense } from 'react';\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { Toaster as Sonner } from \"@/components/ui/sonner\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\nimport { AuthProvider } from \"@/components/AuthProvider\";\nimport { ProtectedRoute } from \"@/components/ProtectedRoute\";\nimport { ErrorBoundary } from \"@/lib/error/error-boundary\";\nimport { ErrorFallback } from \"@/components/error/ErrorFallback\";\nimport { errorReporter } from \"@/lib/monitoring/error-reporter\";\nimport { performanceTracker } from \"@/lib/monitoring/performance-tracker\";\nimport { env } from \"@/lib/config/environment\";\nimport { validateRequiredEnvVars } from \"@/lib/config/environment\";\nimport { AppType, getAppTypeFromDomain, isInspectorDomain, isAdminDomain, logAppConfiguration } from \"@/lib/config/app-type\";\n\n// Core Pages\nimport Index from \"./pages/Index.tsx\";\nimport AddProperty from \"./pages/AddProperty\";\nimport InspectionComplete from \"./pages/InspectionComplete\";\nimport PropertySelection from \"./pages/PropertySelection\";\nimport NotFound from \"./pages/NotFound\";\nimport { InspectionPage } from \"./pages/InspectionPage\";\nimport { DebugInspectionPage } from \"@/components/DebugInspectionPage\";\n\n// New Integrated Pages\nimport { InspectorWorkflow } from \"./pages/InspectorWorkflow\";\n// AuditorDashboard is lazy loaded based on app type\n\n// AI and Mobile Components (temporarily commented out)\n// import { AIProviders } from \"@/components/ai/AIProviders\";\n// import { MobileProvider } from \"@/components/mobile/MobileProvider\";\n// import { OfflineProvider } from \"@/components/mobile/OfflineProvider\";\n\n// Loading Components\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { DomainAwarePWA } from \"@/components/DomainAwarePWA\";\n\n// Enhanced Query Client with error handling\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: (failureCount, error: any) => {\n        // Don't retry on 4xx errors\n        if (error?.status >= 400 && error?.status < 500) return false;\n        return failureCount < 3;\n      },\n      staleTime: 30000,\n      gcTime: 300000,\n      refetchOnWindowFocus: false,\n      onError: (error: any) => {\n        errorReporter.reportError(error, {\n          category: 'query',\n          source: 'react-query',\n        });\n      },\n    },\n    mutations: {\n      retry: 1,\n      onError: (error: any) => {\n        errorReporter.reportError(error, {\n          category: 'mutation',\n          source: 'react-query',\n        });\n      },\n    },\n  },\n});\n\n// Loading fallback component\nfunction LoadingFallback() {\n  return (\n    <div className=\"min-h-screen flex items-center justify-center\">\n      <div className=\"space-y-4 w-full max-w-md\">\n        <Skeleton className=\"h-12 w-full\" />\n        <Skeleton className=\"h-4 w-3/4\" />\n        <Skeleton className=\"h-4 w-1/2\" />\n      </div>\n    </div>\n  );\n}\n\n// System Health Check Component\nfunction SystemHealthCheck({ children }: { children: React.ReactNode }) {\n  useEffect(() => {\n    // Validate environment on app start\n    try {\n      validateRequiredEnvVars();\n    } catch (error) {\n      console.error('Environment validation failed:', error);\n      if (env.isProduction()) {\n        // In production, we might want to show a maintenance page\n        throw error;\n      }\n    }\n\n    // Initialize monitoring services\n    if (env.isProduction()) {\n      errorReporter.initialize({\n        enableConsoleCapture: false, // Disable in production\n        enableNetworkCapture: true,\n        enableClickCapture: true,\n        enableNavigationCapture: true,\n      });\n    }\n\n    performanceTracker.initialize({\n      enableWebVitals: true,\n      enableResourceTiming: true,\n      enableAIMetrics: true,\n      sampleRate: env.isProduction() ? 0.1 : 1.0,\n    });\n\n    // Track app initialization\n    performanceTracker.trackMetric('app_initialization', Date.now(), 'ms', {\n      category: 'startup',\n      environment: env.getEnvironment(),\n    });\n\n  }, []);\n\n  return <>{children}</>;\n}\n\nfunction App() {\n  const appType = getAppTypeFromDomain();\n  \n  // Log app configuration in development\n  React.useEffect(() => {\n    if (env.isDevelopment()) {\n      logAppConfiguration();\n    }\n  }, []);\n  \n  return (\n    <ErrorBoundary\n      level=\"page\"\n      fallback={({ error, resetError, errorId }) => (\n        <ErrorFallback\n          error={error}\n          resetError={resetError}\n          errorId={errorId}\n          showDetails={env.isDevelopment()}\n        />\n      )}\n      onError={(error, errorInfo) => {\n        console.error('App-level error:', error, errorInfo);\n      }}\n    >\n      <SystemHealthCheck>\n        <QueryClientProvider client={queryClient}>\n          <TooltipProvider>\n            <ErrorBoundary level=\"section\" isolate>\n              <AuthProvider>\n                <DomainAwarePWA />\n                <Toaster />\n                <Sonner />\n                <BrowserRouter>\n                  <Suspense fallback={<LoadingFallback />}>\n                    {appType === AppType.INSPECTOR ? <InspectorRoutes /> : <AdminRoutesComponent />}\n                  </Suspense>\n                </BrowserRouter>\n              </AuthProvider>\n            </ErrorBoundary>\n          </TooltipProvider>\n        </QueryClientProvider>\n      </SystemHealthCheck>\n    </ErrorBoundary>\n  );\n}\n\n// Inspector Routes Component - Mobile-optimized for app.doublecheckverified.com\nfunction InspectorRoutes() {\n  React.useEffect(() => {\n    // Set mobile-specific viewport and PWA metadata\n    const metaViewport = document.querySelector('meta[name=\"viewport\"]');\n    if (metaViewport) {\n      metaViewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');\n    }\n    \n    // Add mobile-specific CSS class\n    document.body.classList.add('mobile-app', 'inspector-app');\n    \n    return () => {\n      document.body.classList.remove('mobile-app', 'inspector-app');\n    };\n  }, []);\n\n  return (\n    <Routes>\n      {/* Dashboard Routes */}\n      <Route path=\"/\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <Index />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Inspector Workflow */}\n      <Route path=\"/inspector\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <InspectorWorkflow />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Property Management */}\n      <Route path=\"/properties\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <PropertySelection />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      <Route path=\"/add-property\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <AddProperty />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Inspection Routes */}\n      <Route path=\"/inspection/:id\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <InspectionPage />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      <Route path=\"/inspection-complete/:id\" element={\n        <ProtectedRoute requiredRole=\"inspector\">\n          <ErrorBoundary level=\"component\">\n            <InspectionComplete />\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Health Check Route */}\n      <Route path=\"/health\" element={<HealthCheckPage />} />\n\n      {/* Catch-all Route - Redirect admin attempts to admin domain */}\n      <Route path=\"/admin/*\" element={<AdminRedirect />} />\n      <Route path=\"/auditor\" element={<AdminRedirect />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  );\n}\n\n// Admin Routes Component - Desktop-optimized for admin.doublecheckverified.com\nfunction AdminRoutesComponent() {\n  const LazyAuditorDashboard = React.lazy(() => import(\"./pages/AuditorDashboard\"));\n  const LazyDebugInspectionPage = React.lazy(() => import(\"./components/DebugInspectionPage\"));\n  \n  React.useEffect(() => {\n    // Set desktop-specific viewport and metadata\n    const metaViewport = document.querySelector('meta[name=\"viewport\"]');\n    if (metaViewport) {\n      metaViewport.setAttribute('content', 'width=device-width, initial-scale=1.0');\n    }\n    \n    // Add desktop-specific CSS class\n    document.body.classList.add('desktop-app', 'admin-app');\n    \n    return () => {\n      document.body.classList.remove('desktop-app', 'admin-app');\n    };\n  }, []);\n  \n  return (\n    <Routes>\n      {/* Dashboard Routes */}\n      <Route path=\"/\" element={\n        <ProtectedRoute requiredRole=\"auditor\">\n          <ErrorBoundary level=\"component\">\n            <Suspense fallback={<LoadingFallback />}>\n              <LazyAuditorDashboard />\n            </Suspense>\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Auditor Dashboard */}\n      <Route path=\"/auditor\" element={\n        <ProtectedRoute requiredRole=\"auditor\">\n          <ErrorBoundary level=\"component\">\n            <Suspense fallback={<LoadingFallback />}>\n              <LazyAuditorDashboard />\n            </Suspense>\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Debug Tools */}\n      <Route path=\"/debug-inspection/:id\" element={\n        <ProtectedRoute requiredRole=\"admin\">\n          <ErrorBoundary level=\"component\" showErrorDetails>\n            <Suspense fallback={<LoadingFallback />}>\n              <LazyDebugInspectionPage />\n            </Suspense>\n          </ErrorBoundary>\n        </ProtectedRoute>\n      } />\n\n      {/* Admin Routes */}\n      <Route path=\"/admin/*\" element={\n        <ProtectedRoute requiredRole=\"admin\">\n          <Suspense fallback={<LoadingFallback />}>\n            <AdminRoutes />\n          </Suspense>\n        </ProtectedRoute>\n      } />\n\n      {/* Health Check Route */}\n      <Route path=\"/health\" element={<HealthCheckPage />} />\n\n      {/* Catch-all Route - Redirect inspector attempts to inspector domain */}\n      <Route path=\"/inspector\" element={<InspectorRedirect />} />\n      <Route path=\"/properties\" element={<InspectorRedirect />} />\n      <Route path=\"/inspection/*\" element={<InspectorRedirect />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  );\n}\n\n// Lazy load admin routes to reduce bundle size\nconst AdminRoutes = React.lazy(() => import(\"@/components/admin/AdminRoutes\"));\n\n// Domain redirect components\nfunction AdminRedirect() {\n  React.useEffect(() => {\n    // Redirect to admin domain with current path\n    const currentPath = window.location.pathname + window.location.search;\n    const adminUrl = `https://admin.doublecheckverified.com${currentPath}`;\n    window.location.href = adminUrl;\n  }, []);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex items-center justify-center px-4\">\n      <div className=\"text-center\">\n        <div className=\"w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4\"></div>\n        <h1 className=\"text-xl font-semibold text-gray-900 mb-2\">Redirecting to Admin Portal</h1>\n        <p className=\"text-gray-600\">Taking you to admin.doublecheckverified.com...</p>\n      </div>\n    </div>\n  );\n}\n\nfunction InspectorRedirect() {\n  React.useEffect(() => {\n    // Redirect to inspector domain with current path\n    const currentPath = window.location.pathname + window.location.search;\n    const inspectorUrl = `https://app.doublecheckverified.com${currentPath}`;\n    window.location.href = inspectorUrl;\n  }, []);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 flex items-center justify-center px-4\">\n      <div className=\"text-center\">\n        <div className=\"w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4\"></div>\n        <h1 className=\"text-xl font-semibold text-gray-900 mb-2\">Redirecting to Inspector App</h1>\n        <p className=\"text-gray-600\">Taking you to app.doublecheckverified.com...</p>\n      </div>\n    </div>\n  );\n}\n\n// Health check page for monitoring\nfunction HealthCheckPage() {\n  return (\n    <div className=\"p-4\">\n      <h1>System Health</h1>\n      <p>All systems operational</p>\n    </div>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/__mocks__/mediaDevices.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2747,2750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2747,2750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\n\nexport const mockMediaDevices = {\n  mediaDevices: {\n    getUserMedia: vi.fn().mockResolvedValue({\n      getTracks: vi.fn(() => [\n        {\n          kind: 'video',\n          stop: vi.fn(),\n          getSettings: vi.fn(() => ({\n            width: 1920,\n            height: 1080,\n            facingMode: 'environment',\n          })),\n        },\n      ]),\n      getVideoTracks: vi.fn(() => [\n        {\n          stop: vi.fn(),\n          getSettings: vi.fn(() => ({\n            width: 1920,\n            height: 1080,\n          })),\n        },\n      ]),\n      getAudioTracks: vi.fn(() => [\n        {\n          stop: vi.fn(),\n        },\n      ]),\n    }),\n    enumerateDevices: vi.fn().mockResolvedValue([\n      {\n        deviceId: 'camera-1',\n        kind: 'videoinput',\n        label: 'Back Camera',\n      },\n      {\n        deviceId: 'camera-2',\n        kind: 'videoinput',\n        label: 'Front Camera',\n      },\n      {\n        deviceId: 'mic-1',\n        kind: 'audioinput',\n        label: 'Default Microphone',\n      },\n    ]),\n    getDisplayMedia: vi.fn().mockResolvedValue({\n      getTracks: vi.fn(() => [\n        {\n          kind: 'video',\n          stop: vi.fn(),\n        },\n      ]),\n    }),\n  },\n  \n  MediaRecorder: vi.fn().mockImplementation((stream, options) => ({\n    state: 'inactive',\n    start: vi.fn().mockImplementation(function() {\n      this.state = 'recording';\n      if (this.onstart) this.onstart();\n    }),\n    stop: vi.fn().mockImplementation(function() {\n      this.state = 'inactive';\n      if (this.onstop) this.onstop();\n      if (this.ondataavailable) {\n        this.ondataavailable({\n          data: new Blob(['mock video data'], { type: 'video/webm' }),\n        });\n      }\n    }),\n    pause: vi.fn().mockImplementation(function() {\n      this.state = 'paused';\n      if (this.onpause) this.onpause();\n    }),\n    resume: vi.fn().mockImplementation(function() {\n      this.state = 'recording';\n      if (this.onresume) this.onresume();\n    }),\n    requestData: vi.fn(),\n    onstart: null,\n    onstop: null,\n    onpause: null,\n    onresume: null,\n    ondataavailable: null,\n    onerror: null,\n  })),\n  \n  geolocation: {\n    getCurrentPosition: vi.fn().mockImplementation((success, error, options) => {\n      setTimeout(() => {\n        success({\n          coords: {\n            latitude: 40.7128,\n            longitude: -74.0060,\n            accuracy: 10,\n            altitude: null,\n            altitudeAccuracy: null,\n            heading: null,\n            speed: null,\n          },\n          timestamp: Date.now(),\n        });\n      }, 100);\n    }),\n    watchPosition: vi.fn().mockReturnValue(1),\n    clearWatch: vi.fn(),\n  },\n};\n\n// Mock static methods\n(mockMediaDevices.MediaRecorder as any).isTypeSupported = vi.fn((type: string) => {\n  const supportedTypes = [\n    'video/webm',\n    'video/webm;codecs=vp8',\n    'video/webm;codecs=vp9',\n    'video/mp4',\n  ];\n  return supportedTypes.includes(type);\n});","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/__mocks__/openai.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/__mocks__/supabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/inspection-workflow.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2679,2682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2679,2682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3140,3143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3140,3143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3744,3747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3744,3747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3991,3994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3991,3994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4229,4232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4229,4232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { BrowserRouter } from 'react-router-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport React from 'react';\nimport { InspectorWorkflow } from '../pages/InspectorWorkflow';\n\n// Mock the services\nvi.mock('@/services/inspectionService', () => ({\n  inspectionService: {\n    createInspection: vi.fn().mockResolvedValue({\n      success: true,\n      data: { id: 'test-inspection-123' }\n    }),\n    getInspectionById: vi.fn().mockResolvedValue({\n      success: true,\n      data: { id: 'test-inspection-123', status: 'in_progress' }\n    }),\n    updateInspectionProgress: vi.fn().mockResolvedValue({ success: true })\n  }\n}));\n\nvi.mock('@/services/offlineStorageService', () => ({\n  offlineStorageService: {\n    storeInspectionOffline: vi.fn().mockResolvedValue(true),\n    storeMediaOffline: vi.fn().mockResolvedValue('media-123')\n  }\n}));\n\nvi.mock('@/services/syncService', () => ({\n  syncService: {\n    addSyncListener: vi.fn(),\n    addStatusListener: vi.fn(),\n    removeSyncListener: vi.fn(),\n    removeStatusListener: vi.fn(),\n    queueInspectionSync: vi.fn(),\n    queueMediaUpload: vi.fn(),\n    triggerSync: vi.fn()\n  }\n}));\n\nvi.mock('@/hooks/useErrorHandling', () => ({\n  useErrorHandling: () => ({\n    error: { isError: false, error: null },\n    handleError: vi.fn(),\n    clearError: vi.fn(),\n    withErrorHandling: vi.fn((fn) => fn())\n  })\n}));\n\nvi.mock('@/hooks/usePerformanceMonitoring', () => ({\n  usePerformanceMonitoring: () => ({\n    startTracking: vi.fn(() => vi.fn()),\n    trackEvent: vi.fn()\n  })\n}));\n\nvi.mock('@/components/AuthProvider', () => ({\n  useAuth: () => ({\n    user: { id: 'test-user-123', email: 'test@example.com' }\n  })\n}));\n\nvi.mock('@/lib/supabase', () => ({\n  supabase: {\n    from: vi.fn(() => ({\n      select: vi.fn().mockReturnValue({\n        eq: vi.fn().mockResolvedValue({\n          data: {\n            id: 'test-property-123',\n            name: 'Test Property',\n            address: '123 Test St',\n            type: 'apartment'\n          },\n          error: null\n        })\n      }),\n      insert: vi.fn().mockResolvedValue({\n        data: { id: 'test-inspection-123' },\n        error: null\n      }),\n      update: vi.fn().mockResolvedValue({\n        data: { id: 'test-inspection-123' },\n        error: null\n      })\n    }))\n  },\n  uploadMedia: vi.fn().mockResolvedValue({\n    url: 'https://test.com/media/test.jpg',\n    error: null\n  })\n}));\n\n// Mock components\nvi.mock('@/components/scrapers/PropertySelector', () => ({\n  PropertySelector: ({ onPropertySelected }: any) => (\n    <div data-testid=\"property-selector\">\n      <button\n        onClick={() => onPropertySelected({\n          id: 'test-property-123',\n          address: '123 Test St',\n          type: 'apartment',\n          bedrooms: 2,\n          bathrooms: 1,\n          sqft: 1000\n        })}\n      >\n        Select Property\n      </button>\n    </div>\n  )\n}));\n\nvi.mock('@/components/ai/ChecklistGenerator', () => ({\n  ChecklistGenerator: ({ onChecklistGenerated }: any) => (\n    <div data-testid=\"checklist-generator\">\n      <button\n        onClick={() => onChecklistGenerated({\n          items: [\n            {\n              id: 'item-1',\n              title: 'Check Kitchen Sink',\n              description: 'Test kitchen sink functionality',\n              category: 'kitchen',\n              required: true\n            }\n          ],\n          estimatedTime: 30,\n          totalItems: 1\n        })}\n      >\n        Generate Checklist\n      </button>\n    </div>\n  )\n}));\n\nvi.mock('@/components/photo/PhotoGuidance', () => ({\n  PhotoGuidance: ({ onAllPhotosComplete }: any) => (\n    <div data-testid=\"photo-guidance\">\n      <button onClick={onAllPhotosComplete}>\n        Complete Photos\n      </button>\n    </div>\n  )\n}));\n\nvi.mock('@/components/video/VideoRecorder', () => ({\n  VideoRecorder: ({ onStopRecording }: any) => (\n    <div data-testid=\"video-recorder\">\n      <button onClick={onStopRecording}>\n        Stop Recording\n      </button>\n    </div>\n  )\n}));\n\nvi.mock('@/components/mobile/OfflineSync', () => ({\n  OfflineSync: ({ onSyncComplete }: any) => (\n    <div data-testid=\"offline-sync\">\n      <button onClick={onSyncComplete}>\n        Complete Sync\n      </button>\n    </div>\n  )\n}));\n\nconst createTestQueryClient = () => new QueryClient({\n  defaultOptions: {\n    queries: { retry: false, gcTime: 0 },\n    mutations: { retry: false }\n  }\n});\n\nconst TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const queryClient = createTestQueryClient();\n  return (\n    <QueryClientProvider client={queryClient}>\n      <BrowserRouter>\n        {children}\n      </BrowserRouter>\n    </QueryClientProvider>\n  );\n};\n\ndescribe('InspectorWorkflow Integration', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    // Mock navigator.onLine\n    Object.defineProperty(navigator, 'onLine', {\n      writable: true,\n      value: true\n    });\n  });\n\n  it('should render the workflow with initial property selection step', async () => {\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Check that the property selection step is active\n    expect(screen.getByText('Select Property for Inspection')).toBeInTheDocument();\n    expect(screen.getByTestId('property-selector')).toBeInTheDocument();\n  });\n\n  it('should progress through the complete workflow', async () => {\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Step 1: Select property\n    const selectPropertyButton = screen.getByText('Select Property');\n    fireEvent.click(selectPropertyButton);\n\n    // Wait for checklist generation step\n    await waitFor(() => {\n      expect(screen.getByText('AI-Generated Inspection Checklist')).toBeInTheDocument();\n    });\n\n    // Step 2: Generate checklist\n    const generateChecklistButton = screen.getByText('Generate Checklist');\n    fireEvent.click(generateChecklistButton);\n\n    // Wait for photo capture step\n    await waitFor(() => {\n      expect(screen.getByText('Photo Documentation')).toBeInTheDocument();\n    });\n\n    // Step 3: Complete photos\n    const completePhotosButton = screen.getByText('Complete Photos');\n    fireEvent.click(completePhotosButton);\n\n    // Wait for video recording step\n    await waitFor(() => {\n      expect(screen.getByText('Video Walkthrough')).toBeInTheDocument();\n    });\n\n    // Step 4: Complete video recording\n    const stopRecordingButton = screen.getByText('Stop Recording');\n    fireEvent.click(stopRecordingButton);\n\n    // Wait for sync step\n    await waitFor(() => {\n      expect(screen.getByText('Upload & Sync Data')).toBeInTheDocument();\n    });\n\n    // Step 5: Complete sync\n    const completeSyncButton = screen.getByText('Complete Sync');\n    fireEvent.click(completeSyncButton);\n\n    // Verify workflow completion\n    await waitFor(() => {\n      expect(screen.getByText('Complete Inspection')).toBeInTheDocument();\n    });\n  });\n\n  it('should handle offline mode gracefully', async () => {\n    // Simulate offline mode\n    Object.defineProperty(navigator, 'onLine', {\n      writable: true,\n      value: false\n    });\n\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Check that offline indicator is shown\n    expect(screen.getByText('Working Offline')).toBeInTheDocument();\n    expect(screen.getByText(/data is being saved locally/i)).toBeInTheDocument();\n  });\n\n  it('should track progress correctly', async () => {\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Initial progress should be 0%\n    expect(screen.getByText('0%')).toBeInTheDocument();\n\n    // Complete property selection\n    const selectPropertyButton = screen.getByText('Select Property');\n    fireEvent.click(selectPropertyButton);\n\n    // Progress should increase after completing a step\n    await waitFor(() => {\n      expect(screen.getByText('20%')).toBeInTheDocument();\n    });\n  });\n\n  it('should display step validation correctly', async () => {\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Next step button should be disabled initially\n    const nextButton = screen.getByText('Next Step');\n    expect(nextButton).toBeDisabled();\n\n    // Complete property selection\n    const selectPropertyButton = screen.getByText('Select Property');\n    fireEvent.click(selectPropertyButton);\n\n    // Next step button should be enabled after completing required step\n    await waitFor(() => {\n      expect(nextButton).not.toBeDisabled();\n    });\n  });\n\n  it('should handle errors gracefully', async () => {\n    const mockError = new Error('Test error');\n    const mockHandleError = vi.fn();\n\n    vi.mock('@/hooks/useErrorHandling', () => ({\n      useErrorHandling: () => ({\n        error: { isError: true, error: mockError },\n        handleError: mockHandleError,\n        clearError: vi.fn(),\n        withErrorHandling: vi.fn((fn) => {\n          try {\n            return fn();\n          } catch (error) {\n            mockHandleError(error);\n            throw error;\n          }\n        })\n      })\n    }));\n\n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Error should be displayed\n    expect(screen.getByText('Test error')).toBeInTheDocument();\n  });\n});\n\ndescribe('Inspection Workflow Service Integration', () => {\n  it('should call inspection service when creating inspection', async () => {\n    const { inspectionService } = await import('@/services/inspectionService');\n    \n    render(\n      <TestWrapper>\n        <InspectorWorkflow />\n      </TestWrapper>\n    );\n\n    // Complete property selection and checklist generation\n    fireEvent.click(screen.getByText('Select Property'));\n    \n    await waitFor(() => {\n      fireEvent.click(screen.getByText('Generate Checklist'));\n    });\n\n    // Verify inspection service was called\n    await waitFor(() => {\n      expect(inspectionService.createInspection).toHaveBeenCalledWith({\n        propertyId: 'test-property-123',\n        inspectorId: 'test-user-123',\n        checklistItems: expect.arrayContaining([\n          expect.objectContaining({\n            title: 'Check Kitchen Sink',\n            description: 'Test kitchen sink functionality',\n            category: 'kitchen',\n            required: true\n          })\n        ])\n      });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/integration.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: '>' expected.","line":40,"column":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeAll, afterAll, beforeEach, vi, Mock } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { BrowserRouter } from 'react-router-dom';\nimport React from 'react';\n\n// Components to test\nimport { InspectorWorkflow } from '../pages/InspectorWorkflow';\nimport { AuditorDashboard } from '../pages/AuditorDashboard';\nimport { ErrorBoundary } from '../lib/error/error-boundary';\n\n// Services to test\nimport { systemHealthValidator } from '../lib/integration/system-health';\nimport { apiErrorHandler } from '../lib/error/api-error-handler';\nimport { errorReporter } from '../lib/monitoring/error-reporter';\nimport { performanceTracker } from '../lib/monitoring/performance-tracker';\n\n// Mocks\nimport { mockSupabase } from './__mocks__/supabase';\nimport { mockMediaDevices } from './__mocks__/mediaDevices';\nimport { mockOpenAI } from './__mocks__/openai';\n\n// Test utilities\nconst createTestQueryClient = () => new QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: false,\n      gcTime: 0,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n\nconst TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const queryClient = createTestQueryClient();\n  \n  return (\n    <QueryClientProvider client={queryClient}>\n      <BrowserRouter>\n        <ErrorBoundary level=\"page\">\n          {children}\n        </ErrorBoundary>\n      </BrowserRouter>\n    </QueryClientProvider>\n  );\n};\n\ndescribe('STR Certified Integration Tests', () => {\n  let mockInspectionData: any;\n  let mockPropertyData: any;\n\n  beforeAll(() => {\n    // Setup global mocks\n    global.fetch = vi.fn();\n    global.MediaRecorder = mockMediaDevices.MediaRecorder as any;\n    global.navigator.mediaDevices = mockMediaDevices.mediaDevices as any;\n    global.navigator.geolocation = mockMediaDevices.geolocation as any;\n    \n    // Mock Supabase\n    vi.mock('@supabase/supabase-js', () => ({\n      createClient: vi.fn(() => mockSupabase),\n    }));\n\n    // Setup test data\n    mockPropertyData = {\n      id: 'test-property-1',\n      address: '123 Test St, Test City, TS 12345',\n      type: 'single_family',\n      bedrooms: 3,\n      bathrooms: 2,\n      sqft: 1500,\n      listingUrl: 'https://test-listing.com/property/123',\n    };\n\n    mockInspectionData = {\n      id: 'test-inspection-1',\n      propertyId: mockPropertyData.id,\n      inspectorId: 'test-inspector-1',\n      status: 'pending_review',\n      photos: Array.from({ length: 10 }, (_, i) => ({\n        id: `photo-${i}`,\n        url: `https://test.com/photo-${i}.jpg`,\n        room: 'Living Room',\n        analysis: { score: 85, issues: [] },\n      })),\n      videos: [{\n        id: 'video-1',\n        url: 'https://test.com/video.mp4',\n        duration: 180,\n      }],\n      checklist: {\n        items: [\n          { id: 'check-1', room: 'Kitchen', item: 'Check faucets', completed: true },\n          { id: 'check-2', room: 'Bathroom', item: 'Check toilet', completed: false },\n        ],\n      },\n    };\n  });\n\n  afterAll(() => {\n    vi.restoreAllMocks();\n  });\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  describe('System Health Validation', () => {\n    it('should validate all system components', async () => {\n      const healthReport = await systemHealthValidator.performFullHealthCheck();\n      \n      expect(healthReport).toBeDefined();\n      expect(healthReport.overall).toMatch(/healthy|degraded|unhealthy/);\n      expect(healthReport.checks).toHaveLength(8);\n      expect(healthReport.summary.totalChecks).toBe(8);\n      \n      // Check that all required components are tested\n      const componentNames = healthReport.checks.map(c => c.component);\n      expect(componentNames).toContain('database');\n      expect(componentNames).toContain('ai_services');\n      expect(componentNames).toContain('file_upload');\n      expect(componentNames).toContain('video_processing');\n      expect(componentNames).toContain('mobile_compatibility');\n      expect(componentNames).toContain('offline_capabilities');\n      expect(componentNames).toContain('authentication');\n      expect(componentNames).toContain('environment_config');\n    });\n\n    it('should detect unhealthy components', async () => {\n      // Mock a failing service\n      (global.fetch as Mock).mockRejectedValueOnce(new Error('Service unavailable'));\n      \n      const healthReport = await systemHealthValidator.performFullHealthCheck();\n      \n      const aiServicesCheck = healthReport.checks.find(c => c.component === 'ai_services');\n      expect(aiServicesCheck?.status).toBe('unhealthy');\n      expect(healthReport.overall).toMatch(/degraded|unhealthy/);\n    });\n\n    it('should provide actionable recommendations', async () => {\n      const healthReport = await systemHealthValidator.performFullHealthCheck();\n      \n      expect(healthReport.recommendations).toBeDefined();\n      expect(Array.isArray(healthReport.recommendations)).toBe(true);\n      expect(healthReport.recommendations!.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Inspector Workflow Integration', () => {\n    beforeEach(() => {\n      // Mock successful API responses\n      mockSupabase.from.mockReturnValue({\n        select: vi.fn().mockReturnValue({\n          eq: vi.fn().mockResolvedValue({\n            data: [mockPropertyData],\n            error: null,\n          }),\n        }),\n        insert: vi.fn().mockResolvedValue({\n          data: mockInspectionData,\n          error: null,\n        }),\n        update: vi.fn().mockResolvedValue({\n          data: mockInspectionData,\n          error: null,\n        }),\n      });\n\n      mockSupabase.storage.from.mockReturnValue({\n        upload: vi.fn().mockResolvedValue({\n          data: { path: 'test-photo.jpg' },\n          error: null,\n        }),\n      });\n    });\n\n    it('should complete full inspection workflow', async () => {\n      render(\n        <TestWrapper>\n          <InspectorWorkflow />\n        </TestWrapper>\n      );\n\n      // Step 1: Property Selection\n      expect(screen.getByText('Select Property for Inspection')).toBeInTheDocument();\n      \n      // Mock property selection\n      const propertySelector = screen.getByTestId('property-selector');\n      fireEvent.click(propertySelector);\n\n      await waitFor(() => {\n        expect(screen.getByText('Generate Checklist')).toBeInTheDocument();\n      });\n\n      // Step 2: Checklist Generation\n      const generateButton = screen.getByRole('button', { name: /generate/i });\n      fireEvent.click(generateButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Photo Documentation')).toBeInTheDocument();\n      });\n\n      // Step 3: Photo Capture\n      const captureButton = screen.getByRole('button', { name: /capture/i });\n      fireEvent.click(captureButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Video Walkthrough')).toBeInTheDocument();\n      });\n\n      // Step 4: Video Recording\n      const recordButton = screen.getByRole('button', { name: /record/i });\n      fireEvent.click(recordButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Upload & Sync')).toBeInTheDocument();\n      });\n\n      // Step 5: Sync and Upload\n      const syncButton = screen.getByRole('button', { name: /sync/i });\n      fireEvent.click(syncButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Inspection Complete')).toBeInTheDocument();\n      });\n    });\n\n    it('should handle offline mode gracefully', async () => {\n      // Simulate offline mode\n      Object.defineProperty(navigator, 'onLine', {\n        writable: true,\n        value: false,\n      });\n\n      render(\n        <TestWrapper>\n          <InspectorWorkflow />\n        </TestWrapper>\n      );\n\n      expect(screen.getByText('Working Offline')).toBeInTheDocument();\n      expect(screen.getByText(/data is being saved locally/i)).toBeInTheDocument();\n\n      // Verify sync button is disabled\n      const syncButton = screen.getByRole('button', { name: /complete inspection/i });\n      expect(syncButton).toBeDisabled();\n    });\n\n    it('should validate required steps completion', async () => {\n      render(\n        <TestWrapper>\n          <InspectorWorkflow />\n        </TestWrapper>\n      );\n\n      // Try to skip to final step without completing required steps\n      const nextButton = screen.getByRole('button', { name: /next step/i });\n      \n      // Should be disabled initially\n      expect(nextButton).toBeDisabled();\n\n      // Complete property selection\n      const propertySelector = screen.getByTestId('property-selector');\n      fireEvent.click(propertySelector);\n\n      await waitFor(() => {\n        expect(nextButton).not.toBeDisabled();\n      });\n    });\n  });\n\n  describe('Auditor Dashboard Integration', () => {\n    beforeEach(() => {\n      // Mock inspection queue data\n      mockSupabase.from.mockReturnValue({\n        select: vi.fn().mockReturnValue({\n          eq: vi.fn().mockResolvedValue({\n            data: [\n              {\n                ...mockInspectionData,\n                status: 'pending_review',\n              },\n              {\n                ...mockInspectionData,\n                id: 'test-inspection-2',\n                status: 'in_review',\n              },\n            ],\n            error: null,\n          }),\n        }),\n        update: vi.fn().mockResolvedValue({\n          data: mockInspectionData,\n          error: null,\n        }),\n      });\n    });\n\n    it('should display inspection queue', async () => {\n      render(\n        <TestWrapper>\n          <AuditorDashboard />\n        </TestWrapper>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByText('Inspection Queue')).toBeInTheDocument();\n        expect(screen.getByText('123 Test St, Test City, TS 12345')).toBeInTheDocument();\n      });\n\n      // Check metrics are displayed\n      expect(screen.getByText('Total Reviews')).toBeInTheDocument();\n      expect(screen.getByText('Avg Review Time')).toBeInTheDocument();\n      expect(screen.getByText('Approval Rate')).toBeInTheDocument();\n    });\n\n    it('should allow inspection review and approval', async () => {\n      render(\n        <TestWrapper>\n          <AuditorDashboard />\n        </TestWrapper>\n      );\n\n      // Click on review button\n      const reviewButton = await screen.findByRole('button', { name: /review/i });\n      fireEvent.click(reviewButton);\n\n      // Switch to review tab\n      await waitFor(() => {\n        expect(screen.getByText('Video Walkthrough')).toBeInTheDocument();\n        expect(screen.getByText('Photo Documentation')).toBeInTheDocument();\n      });\n\n      // Select approval decision\n      const approveButton = screen.getByRole('button', { name: /approve/i });\n      fireEvent.click(approveButton);\n\n      // Add feedback\n      const feedbackTextarea = screen.getByPlaceholderText(/add feedback/i);\n      fireEvent.change(feedbackTextarea, { target: { value: 'Excellent work!' } });\n\n      // Submit review\n      const submitButton = screen.getByRole('button', { name: /submit review/i });\n      fireEvent.click(submitButton);\n\n      await waitFor(() => {\n        expect(mockSupabase.from().update).toHaveBeenCalledWith({\n          status: 'approved',\n          reviewer_feedback: 'Excellent work!',\n          reviewed_at: expect.any(String),\n        });\n      });\n    });\n\n    it('should filter and search inspections', async () => {\n      render(\n        <TestWrapper>\n          <AuditorDashboard />\n        </TestWrapper>\n      );\n\n      // Test search functionality\n      const searchInput = screen.getByPlaceholderText(/search inspections/i);\n      fireEvent.change(searchInput, { target: { value: 'Test St' } });\n\n      await waitFor(() => {\n        expect(screen.getByText('123 Test St, Test City, TS 12345')).toBeInTheDocument();\n      });\n\n      // Test status filter\n      const statusFilter = screen.getByRole('combobox', { name: /status/i });\n      fireEvent.click(statusFilter);\n      \n      const pendingOption = screen.getByText('Pending');\n      fireEvent.click(pendingOption);\n\n      await waitFor(() => {\n        const pendingRows = screen.getAllByText(/pending/i);\n        expect(pendingRows.length).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  describe('AI Service Integration', () => {\n    it('should integrate with OpenAI for analysis', async () => {\n      const mockAnalysis = {\n        score: 85,\n        issues: [\n          {\n            type: 'plumbing',\n            severity: 'medium',\n            description: 'Minor leak detected',\n            confidence: 0.8,\n          },\n        ],\n        recommendations: ['Check plumbing in kitchen'],\n      };\n\n      (global.fetch as Mock).mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          choices: [{ message: { content: JSON.stringify(mockAnalysis) } }],\n        }),\n      });\n\n      // Test AI analysis call\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': 'Bearer test-key',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: 'gpt-4-vision-preview',\n          messages: [\n            {\n              role: 'user',\n              content: [\n                { type: 'text', text: 'Analyze this property photo for issues' },\n                { type: 'image_url', image_url: { url: 'test-image.jpg' } },\n              ],\n            },\n          ],\n        }),\n      });\n\n      expect(response.ok).toBe(true);\n      const result = await response.json();\n      expect(result.choices[0].message.content).toContain('score');\n    });\n\n    it('should handle AI service failures gracefully', async () => {\n      (global.fetch as Mock).mockRejectedValueOnce(new Error('AI service unavailable'));\n\n      const errorContext = {\n        url: 'https://api.openai.com/v1/chat/completions',\n        method: 'POST',\n      };\n\n      const error = await apiErrorHandler.handleError(\n        new Error('AI service unavailable'),\n        errorContext\n      );\n\n      expect(error.category).toBe('network');\n      expect(error.retry).toBe(true);\n      expect(error.userMessage).toContain('Network connection error');\n    });\n  });\n\n  describe('Mobile Photo Capture Integration', () => {\n    it('should access camera and capture photos', async () => {\n      const mockStream = {\n        getTracks: vi.fn(() => [{ stop: vi.fn() }]),\n      };\n\n      mockMediaDevices.mediaDevices.getUserMedia.mockResolvedValueOnce(mockStream);\n\n      // Test camera access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: { facingMode: 'environment' },\n      });\n\n      expect(stream).toBeDefined();\n      expect(mockMediaDevices.mediaDevices.getUserMedia).toHaveBeenCalledWith({\n        video: { facingMode: 'environment' },\n      });\n    });\n\n    it('should handle camera permission denial', async () => {\n      mockMediaDevices.mediaDevices.getUserMedia.mockRejectedValueOnce(\n        new Error('Permission denied')\n      );\n\n      try {\n        await navigator.mediaDevices.getUserMedia({\n          video: { facingMode: 'environment' },\n        });\n      } catch (error) {\n        expect(error).toBeInstanceOf(Error);\n        expect((error as Error).message).toBe('Permission denied');\n      }\n    });\n\n    it('should capture and analyze photos with AI', async () => {\n      // Mock successful photo capture\n      const mockCanvas = {\n        toBlob: vi.fn((callback) => {\n          callback(new Blob(['mock-image'], { type: 'image/jpeg' }));\n        }),\n        getContext: vi.fn(() => ({\n          drawImage: vi.fn(),\n        })),\n      };\n\n      global.HTMLCanvasElement.prototype.getContext = mockCanvas.getContext;\n      global.HTMLCanvasElement.prototype.toBlob = mockCanvas.toBlob;\n\n      // Mock AI analysis response\n      (global.fetch as Mock).mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          analysis: {\n            score: 90,\n            issues: [],\n            recommendations: ['Good photo quality'],\n          },\n        }),\n      });\n\n      const canvas = document.createElement('canvas');\n      const blob = await new Promise<Blob>((resolve) => {\n        canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', 0.8);\n      });\n\n      expect(blob).toBeInstanceOf(Blob);\n      expect(blob.type).toBe('image/jpeg');\n    });\n  });\n\n  describe('Error Handling Integration', () => {\n    it('should report errors to monitoring service', async () => {\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n      \n      const testError = new Error('Test error for monitoring');\n      const errorId = errorReporter.reportError(testError, {\n        component: 'test',\n        severity: 'high',\n      });\n\n      expect(errorId).toBeDefined();\n      expect(errorId).toMatch(/^err_/);\n      \n      consoleSpy.mockRestore();\n    });\n\n    it('should handle API errors with retry logic', async () => {\n      let callCount = 0;\n      (global.fetch as Mock).mockImplementation(() => {\n        callCount++;\n        if (callCount < 3) {\n          return Promise.reject(new Error('Network error'));\n        }\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ success: true }),\n        });\n      });\n\n      const context = {\n        url: 'https://api.test.com/endpoint',\n        method: 'GET',\n      };\n\n      const result = await apiErrorHandler.executeWithRetry(\n        () => fetch(context.url),\n        context,\n        { maxAttempts: 3 }\n      );\n\n      expect(callCount).toBe(3);\n      expect(result).toBeDefined();\n    });\n\n    it('should gracefully handle component errors', async () => {\n      const ErrorComponent = () => {\n        throw new Error('Component error');\n      };\n\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n\n      render(\n        <TestWrapper>\n          <ErrorBoundary level=\"component\">\n            <ErrorComponent />\n          </ErrorBoundary>\n        </TestWrapper>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n\n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('Performance Monitoring Integration', () => {\n    it('should track performance metrics', async () => {\n      const stopTimer = performanceTracker.startTimer('test-operation');\n      \n      // Simulate some work\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      const duration = stopTimer();\n      \n      expect(duration).toBeGreaterThan(90);\n      expect(duration).toBeLessThan(200);\n    });\n\n    it('should track AI processing metrics', async () => {\n      const metrics = {\n        operationType: 'image_analysis',\n        duration: 1500,\n        modelUsed: 'gpt-4-vision',\n        inputSize: 1024000,\n        outputSize: 500,\n        success: true,\n      };\n\n      performanceTracker.trackAIProcessing(metrics);\n\n      // Verify metric was tracked (would normally check monitoring dashboard)\n      expect(true).toBe(true); // Placeholder for actual metric verification\n    });\n\n    it('should detect slow operations', async () => {\n      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});\n\n      // Simulate slow API call\n      performanceTracker.trackApiCall(\n        'https://api.test.com/slow-endpoint',\n        'GET',\n        2500, // Exceeds threshold\n        200\n      );\n\n      // Verify warning was logged for slow operation\n      expect(consoleSpy).toHaveBeenCalledWith(\n        expect.stringContaining('Slow api operation'),\n        expect.any(Object)\n      );\n\n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('Complete Workflow Integration', () => {\n    it('should complete end-to-end inspection workflow', async () => {\n      // Test the complete workflow from property selection to audit approval\n      const workflow = {\n        // Step 1: Inspector selects property\n        selectProperty: async () => {\n          const property = await mockSupabase.from('properties').select('*').eq('id', 'test-1');\n          return property.data?.[0];\n        },\n\n        // Step 2: Generate AI checklist\n        generateChecklist: async (property: any) => {\n          const response = await fetch('/api/ai/generate-checklist', {\n            method: 'POST',\n            body: JSON.stringify({ property }),\n          });\n          return response.json();\n        },\n\n        // Step 3: Capture photos with AI guidance\n        capturePhotos: async (checklist: any) => {\n          const photos = [];\n          for (const item of checklist.items.slice(0, 3)) {\n            const photo = await mockMediaDevices.mediaDevices.getUserMedia({ video: true });\n            photos.push({ item: item.id, photo });\n          }\n          return photos;\n        },\n\n        // Step 4: Record video walkthrough\n        recordVideo: async () => {\n          const stream = await mockMediaDevices.mediaDevices.getUserMedia({\n            video: true,\n            audio: true,\n          });\n          return { stream, duration: 180 };\n        },\n\n        // Step 5: Upload and sync data\n        syncData: async (inspectionData: any) => {\n          const result = await mockSupabase.from('inspections').insert(inspectionData);\n          return result.data;\n        },\n\n        // Step 6: Auditor reviews and approves\n        auditReview: async (inspectionId: string) => {\n          const result = await mockSupabase\n            .from('inspections')\n            .update({ status: 'approved', reviewed_at: new Date().toISOString() })\n            .eq('id', inspectionId);\n          return result.data;\n        },\n      };\n\n      // Execute complete workflow\n      const property = await workflow.selectProperty();\n      expect(property).toBeDefined();\n\n      (global.fetch as Mock).mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          items: [\n            { id: 'check-1', room: 'Kitchen', item: 'Check sink' },\n            { id: 'check-2', room: 'Bathroom', item: 'Check toilet' },\n          ],\n        }),\n      });\n\n      const checklist = await workflow.generateChecklist(property);\n      expect(checklist.items).toHaveLength(2);\n\n      const photos = await workflow.capturePhotos(checklist);\n      expect(photos).toHaveLength(2);\n\n      const video = await workflow.recordVideo();\n      expect(video.stream).toBeDefined();\n\n      const inspection = await workflow.syncData({\n        propertyId: property.id,\n        photos,\n        video,\n        checklist,\n      });\n      expect(inspection).toBeDefined();\n\n      const auditResult = await workflow.auditReview(inspection.id);\n      expect(auditResult).toBeDefined();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/__tests__/vrbo-scraper.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":340,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10632,10635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10632,10635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// VRBO Scraper Test Suite\n// Tests for browser automation and dynamic image loading\n\nimport { describe, expect, it, vi, beforeEach } from 'vitest';\n\n// Mock the environment dependencies\nprocess.env.NODE_ENV = 'test';\nprocess.env.VITE_SUPABASE_URL = 'test-url';\nprocess.env.VITE_SUPABASE_ANON_KEY = 'test-key';\n\nconst mockLogger = {\n  info: vi.fn(),\n  warn: vi.fn(),\n  error: vi.fn(),\n  debug: vi.fn()\n};\n\nconst mockAiDecisionLogger = {\n  logSimpleDecision: vi.fn().mockResolvedValue(undefined)\n};\n\nconst mockErrorReporter = {\n  reportError: vi.fn()\n};\n\n// Mock the dependencies\nvi.mock('../utils/logger', () => ({\n  logger: mockLogger\n}));\n\nvi.mock('../lib/ai/decision-logger', () => ({\n  aiDecisionLogger: mockAiDecisionLogger\n}));\n\nvi.mock('../lib/monitoring/error-reporter', () => ({\n  errorReporter: mockErrorReporter\n}));\n\n// Mock Puppeteer\nvi.mock('puppeteer', () => ({\n  default: {\n    launch: vi.fn().mockResolvedValue({\n      newPage: vi.fn().mockResolvedValue({\n        goto: vi.fn(),\n        content: vi.fn().mockResolvedValue('<html><body>Mock content</body></html>'),\n        close: vi.fn(),\n        setUserAgent: vi.fn(),\n        setExtraHTTPHeaders: vi.fn(),\n        setRequestInterception: vi.fn(),\n        setDefaultTimeout: vi.fn(),\n        setDefaultNavigationTimeout: vi.fn(),\n        evaluateOnNewDocument: vi.fn(),\n        on: vi.fn(),\n        evaluate: vi.fn(),\n        viewport: vi.fn().mockResolvedValue({ width: 1920, height: 1080 }),\n        metrics: vi.fn().mockResolvedValue({ JSHeapUsedSize: 1000000 })\n      }),\n      close: vi.fn(),\n      connected: vi.fn().mockReturnValue(true)\n    })\n  }\n}));\n\ndescribe('VRBO Scraper Implementation', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('URL Validation', () => {\n    it('should validate VRBO URLs correctly', () => {\n      const validUrls = [\n        'https://www.vrbo.com/12345',\n        'https://vrbo.com/12345/test-property',\n        'https://www.homeaway.com/12345'\n      ];\n\n      const invalidUrls = [\n        'https://airbnb.com/rooms/12345',\n        'not-a-url',\n        '',\n        'https://booking.com/hotel/test'\n      ];\n\n      // Test URL validation pattern\n      const vrboPattern = /^https?:\\/\\/(www\\.)?(vrbo|homeaway|vacationrentals)\\.com\\/\\d+/;\n      \n      validUrls.forEach(url => {\n        expect(vrboPattern.test(url)).toBe(true);\n      });\n\n      invalidUrls.forEach(url => {\n        expect(vrboPattern.test(url)).toBe(false);\n      });\n    });\n\n    it('should extract property ID from URL', () => {\n      const testCases = [\n        { url: 'https://www.vrbo.com/12345', expected: '12345' },\n        { url: 'https://vrbo.com/67890/test-property', expected: '67890' },\n        { url: 'https://www.homeaway.com/555/nice-place', expected: '555' }\n      ];\n\n      testCases.forEach(({ url, expected }) => {\n        const match = url.match(/\\/(\\d+)/);\n        const propertyId = match ? match[1] : null;\n        expect(propertyId).toBe(expected);\n      });\n    });\n  });\n\n  describe('Image Processing', () => {\n    it('should categorize images correctly', () => {\n      const testImages = [\n        { url: 'https://images.vrbo.com/kitchen-1.jpg', expected: 'kitchen' },\n        { url: 'https://images.vrbo.com/bedroom-master.jpg', expected: 'bedroom' },\n        { url: 'https://images.vrbo.com/exterior-view.jpg', expected: 'exterior' },\n        { url: 'https://images.vrbo.com/bathroom-1.jpg', expected: 'bathroom' },\n        { url: 'https://images.vrbo.com/living-room.jpg', expected: 'living_area' },\n        { url: 'https://images.vrbo.com/pool-deck.jpg', expected: 'outdoor_space' },\n        { url: 'https://images.vrbo.com/random-image.jpg', expected: 'interior' }\n      ];\n\n      testImages.forEach(({ url, expected }) => {\n        const category = categorizeImageByUrl(url);\n        expect(category).toBe(expected);\n      });\n    });\n\n    it('should deduplicate images correctly', () => {\n      const images = [\n        { url: 'https://images.vrbo.com/image1.jpg', alt: 'Image 1' },\n        { url: 'https://images.vrbo.com/image2.jpg', alt: 'Image 2' },\n        { url: 'https://images.vrbo.com/image1.jpg?version=2', alt: 'Image 1 duplicate' },\n        { url: 'https://images.vrbo.com/image3.jpg', alt: 'Image 3' }\n      ];\n\n      const deduped = deduplicateImages(images);\n      expect(deduped).toHaveLength(3);\n      \n      // Should keep the first occurrence\n      expect(deduped.find(img => img.alt === 'Image 1')).toBeDefined();\n      expect(deduped.find(img => img.alt === 'Image 1 duplicate')).toBeUndefined();\n    });\n  });\n\n  describe('Browser Configuration', () => {\n    it('should validate browser configuration', () => {\n      const config = {\n        headless: true,\n        scrollCycles: 5,\n        scrollWaitTime: 3000,\n        browserTimeout: 120000,\n        enableStealth: true\n      };\n\n      expect(config.headless).toBe(true);\n      expect(config.scrollCycles).toBeGreaterThan(0);\n      expect(config.scrollCycles).toBeLessThanOrEqual(10);\n      expect(config.scrollWaitTime).toBeGreaterThan(1000);\n      expect(config.browserTimeout).toBeGreaterThan(30000);\n    });\n\n    it('should handle gallery automation result correctly', () => {\n      const mockGalleryResult = {\n        images: [\n          { url: 'https://images.vrbo.com/gallery1.jpg', alt: 'Gallery 1' },\n          { url: 'https://images.vrbo.com/gallery2.jpg', alt: 'Gallery 2' }\n        ],\n        totalImagesFound: 2,\n        scrollCyclesCompleted: 5,\n        loadingTime: 5000,\n        screenshots: [],\n        errors: []\n      };\n\n      expect(mockGalleryResult.images).toHaveLength(2);\n      expect(mockGalleryResult.scrollCyclesCompleted).toBe(5);\n      expect(mockGalleryResult.loadingTime).toBeGreaterThan(0);\n      expect(mockGalleryResult.errors).toHaveLength(0);\n    });\n  });\n\n  describe('Data Completeness', () => {\n    it('should calculate data completeness score', () => {\n      const testData = {\n        title: 'Test Property',\n        description: 'A great property',\n        amenities: ['WiFi', 'Pool', 'Kitchen'],\n        images: Array(15).fill(null).map((_, i) => ({ url: `image${i}.jpg` })),\n        specifications: {\n          bedrooms: 3,\n          bathrooms: 2,\n          maxGuests: 6\n        }\n      };\n\n      const score = calculateDataCompleteness(testData);\n      expect(score).toBeGreaterThan(50);\n      expect(score).toBeLessThanOrEqual(100);\n    });\n\n    it('should handle empty data gracefully', () => {\n      const emptyData = {\n        title: '',\n        description: '',\n        amenities: [],\n        images: [],\n        specifications: {}\n      };\n\n      const score = calculateDataCompleteness(emptyData);\n      expect(score).toBe(0);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle network errors gracefully', () => {\n      const mockError = new Error('Network timeout');\n      \n      // Test that error objects are properly structured\n      expect(mockError.message).toBe('Network timeout');\n      expect(mockError instanceof Error).toBe(true);\n    });\n\n    it('should create proper error responses', () => {\n      const scrapingError = {\n        code: 'BROWSER_SCRAPING_FAILED',\n        message: 'Browser automation failed',\n        severity: 'high',\n        recoverable: true\n      };\n\n      expect(scrapingError.code).toBe('BROWSER_SCRAPING_FAILED');\n      expect(scrapingError.severity).toBe('high');\n      expect(scrapingError.recoverable).toBe(true);\n    });\n  });\n\n  describe('Gallery Automation Logic', () => {\n    it('should implement correct scroll sequence', () => {\n      const scrollConfig = {\n        cycles: 5,\n        waitTime: 3000,\n        scrollDistance: 400\n      };\n\n      // Test scroll sequence validation\n      expect(scrollConfig.cycles).toBe(5);\n      expect(scrollConfig.waitTime).toBe(3000);\n      expect(scrollConfig.scrollDistance).toBeGreaterThan(0);\n    });\n\n    it('should handle gallery modal detection', () => {\n      const modalSelectors = [\n        '[data-testid=\"photo-gallery-modal\"]',\n        '.photo-gallery-modal',\n        '.gallery-modal',\n        '.image-gallery-modal'\n      ];\n\n      expect(modalSelectors).toHaveLength(4);\n      expect(modalSelectors.every(selector => typeof selector === 'string')).toBe(true);\n    });\n  });\n\n  describe('Production Readiness', () => {\n    it('should implement rate limiting', () => {\n      const rateLimitConfig = {\n        requests: 10,\n        windowSize: 60000, // 1 minute\n        windowStart: Date.now()\n      };\n\n      expect(rateLimitConfig.requests).toBeLessThanOrEqual(10);\n      expect(rateLimitConfig.windowSize).toBe(60000);\n      expect(rateLimitConfig.windowStart).toBeGreaterThan(0);\n    });\n\n    it('should support stealth mode features', () => {\n      const stealthFeatures = [\n        'userAgent',\n        'viewport',\n        'headers',\n        'webdriver',\n        'plugins',\n        'languages'\n      ];\n\n      expect(stealthFeatures).toContain('userAgent');\n      expect(stealthFeatures).toContain('viewport');\n      expect(stealthFeatures).toContain('webdriver');\n    });\n\n    it('should handle cleanup properly', () => {\n      const cleanupTasks = [\n        'closeBrowser',\n        'closeSession',\n        'clearCache',\n        'removeListeners'\n      ];\n\n      expect(cleanupTasks).toContain('closeBrowser');\n      expect(cleanupTasks).toContain('closeSession');\n    });\n  });\n});\n\n// Helper functions for testing\nfunction categorizeImageByUrl(url: string): string {\n  const lowerUrl = url.toLowerCase();\n  \n  if (lowerUrl.includes('exterior') || lowerUrl.includes('outside')) return 'exterior';\n  if (lowerUrl.includes('kitchen')) return 'kitchen';\n  if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n  if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n  if (lowerUrl.includes('living') || lowerUrl.includes('lounge')) return 'living_area';\n  if (lowerUrl.includes('pool') || lowerUrl.includes('deck') || lowerUrl.includes('patio')) return 'outdoor_space';\n  if (lowerUrl.includes('view') || lowerUrl.includes('scenic')) return 'view';\n  if (lowerUrl.includes('amenity')) return 'amenity';\n  \n  return 'interior';\n}\n\nfunction deduplicateImages(images: Array<{url: string, alt: string}>): Array<{url: string, alt: string}> {\n  const seen = new Set<string>();\n  const unique: Array<{url: string, alt: string}> = [];\n  \n  images.forEach(img => {\n    const normalizedUrl = img.url.replace(/\\?.*$/, '').toLowerCase();\n    \n    if (!seen.has(normalizedUrl)) {\n      seen.add(normalizedUrl);\n      unique.push(img);\n    }\n  });\n  \n  return unique;\n}\n\nfunction calculateDataCompleteness(data: any): number {\n  let score = 0;\n  \n  // Base property data (40%)\n  if (data.title) score += 10;\n  if (data.description) score += 10;\n  if (data.amenities && data.amenities.length > 0) score += 10;\n  if (data.specifications?.bedrooms) score += 5;\n  if (data.specifications?.bathrooms) score += 5;\n  \n  // Image extraction (50%)\n  if (data.images && data.images.length > 0) score += 20;\n  if (data.images && data.images.length >= 10) score += 10;\n  if (data.images && data.images.length >= 20) score += 10;\n  if (data.images && data.images.length >= 30) score += 10;\n  \n  // Additional completeness (10%)\n  if (data.specifications?.maxGuests) score += 5;\n  if (data.amenities && data.amenities.length >= 5) score += 5;\n  \n  return Math.round(Math.min(score, 100));\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/AddItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/AddPropertyButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/AuthForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/AuthProvider.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":9,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":9,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useContext } from 'react';\nimport { AuthContext, AuthContextType } from '@/contexts/AuthContext';\nimport { MobileAuthLoading } from '@/components/MobileAuthLoading';\nimport { useAuthState } from '@/hooks/useAuthState';\nimport { useAuthInitialization } from '@/hooks/useAuthInitialization';\nimport { useAuthStateListener } from '@/hooks/useAuthStateListener';\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const authState = useAuthState();\n  const { initializeAuth } = useAuthInitialization(authState);\n  \n  useAuthStateListener({\n    ...authState,\n    initializeAuth\n  });\n\n  const value: AuthContextType = {\n    user: authState.user,\n    userRole: authState.userRole,\n    loading: authState.loading,\n    error: authState.error,\n    signIn: authState.handleSignIn,\n    signUp: authState.handleSignUp,\n    signOut: authState.handleSignOut,\n    forceRefresh: authState.forceRefresh,\n    clearSession: authState.handleClearSession,\n    loadUserRole: authState.loadUserRole,\n  };\n\n  // Mobile-optimized loading screen\n  if (authState.loading) {\n    return <MobileAuthLoading onRefresh={() => {\n      authState.handleClearSession();\n      authState.forceRefresh();\n    }} />;\n  }\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistDiagnostics.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[455,458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[455,458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2923,2926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2923,2926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useEffect, useState } from \"react\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { AlertCircle, CheckCircle, AlertTriangle } from \"lucide-react\";\n\ninterface AuditEntry {\n  id: string;\n  inspection_id: string;\n  operation_type: string;\n  items_affected: number;\n  created_at: string;\n  metadata?: any;\n}\n\ninterface ChecklistDiagnosticsProps {\n  inspectionId: string;\n}\n\nexport const ChecklistDiagnostics = ({ inspectionId }: ChecklistDiagnosticsProps) => {\n  const [auditEntries, setAuditEntries] = useState<AuditEntry[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchAuditData = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('checklist_operations_audit')\n          .select('*')\n          .eq('inspection_id', inspectionId)\n          .order('created_at', { ascending: false });\n\n        if (error) {\n          console.error('Error fetching audit data:', error);\n          return;\n        }\n\n        setAuditEntries(data || []);\n      } catch (error) {\n        console.error('Error in audit fetch:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    if (inspectionId) {\n      fetchAuditData();\n    }\n  }, [inspectionId]);\n\n  if (isLoading) {\n    return <div>Loading diagnostics...</div>;\n  }\n\n  if (auditEntries.length === 0) {\n    return null; // Don't show if no audit entries\n  }\n\n  const getIcon = (operationType: string) => {\n    switch (operationType) {\n      case 'populate':\n        return <CheckCircle className=\"w-4 h-4 text-green-500\" />;\n      case 'duplicate_detected':\n        return <AlertTriangle className=\"w-4 h-4 text-yellow-500\" />;\n      case 'cleanup':\n        return <AlertCircle className=\"w-4 h-4 text-blue-500\" />;\n      default:\n        return <AlertCircle className=\"w-4 h-4 text-gray-500\" />;\n    }\n  };\n\n  const getVariant = (operationType: string) => {\n    switch (operationType) {\n      case 'populate':\n        return 'default';\n      case 'duplicate_detected':\n        return 'destructive';\n      case 'cleanup':\n        return 'secondary';\n      default:\n        return 'outline';\n    }\n  };\n\n  return (\n    <Card className=\"mb-4\">\n      <CardHeader className=\"pb-3\">\n        <CardTitle className=\"text-sm font-medium flex items-center gap-2\">\n          <AlertCircle className=\"w-4 h-4\" />\n          Checklist Operations Log\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-2\">\n        {auditEntries.map((entry) => (\n          <div key={entry.id} className=\"flex items-center justify-between p-2 bg-gray-50 rounded-lg\">\n            <div className=\"flex items-center gap-2\">\n              {getIcon(entry.operation_type)}\n              <Badge variant={getVariant(entry.operation_type) as any}>\n                {entry.operation_type}\n              </Badge>\n              <span className=\"text-sm text-gray-600\">\n                {entry.items_affected} items\n              </span>\n            </div>\n            <span className=\"text-xs text-gray-500\">\n              {new Date(entry.created_at).toLocaleTimeString()}\n            </span>\n          </div>\n        ))}\n      </CardContent>\n    </Card>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistGenerationStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemCore.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemNotes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemPresenceTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemPriorityBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ChecklistItemUploadSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/CollaborationConflictAlert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/CompletedChecklistItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugAuthStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugDatabaseTester.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugEmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugInfo.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41,44],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41,44],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\ninterface DebugInfoProps {\n  debugInfo: any;\n}\n\nexport const DebugInfo = ({ debugInfo }: DebugInfoProps) => {\n  const showDebugInfo = process.env.NODE_ENV === 'development' && Object.keys(debugInfo).length > 0;\n\n  if (!showDebugInfo) {\n    return null;\n  }\n\n  return (\n    <div className=\"mt-6 p-4 bg-gray-100 rounded-lg\">\n      <h3 className=\"text-sm font-semibold mb-2\">Debug Information:</h3>\n      <pre className=\"text-xs overflow-auto max-h-40\">\n        {JSON.stringify(debugInfo, null, 2)}\n      </pre>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugInspectionContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[884,887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[884,887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect } from \"react\";\nimport { ChecklistItemType } from \"@/types/inspection\";\nimport { InspectionProgress } from \"@/components/InspectionProgress\";\nimport { InspectionHeader } from \"@/components/InspectionHeader\";\nimport { ChecklistItem } from \"@/components/ChecklistItem\";\nimport { DebugPanel } from \"@/components/DebugPanel\";\nimport { DebugEmptyState } from \"@/components/DebugEmptyState\";\nimport { useDebugDatabaseTester } from \"@/components/DebugDatabaseTester\";\nimport { debugLogger } from \"@/utils/debugLogger\";\n\ninterface DebugInspectionContentProps {\n  inspectionId: string;\n  checklistItems: ChecklistItemType[];\n  onRefetch: () => void;\n  isRefetching: boolean;\n}\n\nexport const DebugInspectionContent = ({\n  inspectionId,\n  checklistItems,\n  onRefetch,\n  isRefetching\n}: DebugInspectionContentProps) => {\n  const [debugInfo, setDebugInfo] = useState<any>(null);\n  const [showCompleted, setShowCompleted] = useState(true);\n  const { runDatabaseTests } = useDebugDatabaseTester(inspectionId);\n\n  const completedCount = checklistItems.filter(item => item.status === 'completed').length;\n  const totalCount = checklistItems.length;\n  const progressPercentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;\n\n  useEffect(() => {\n    debugLogger.info('DebugInspectionContent', 'Component mounted', {\n      inspectionId,\n      itemCount: checklistItems.length,\n      completedCount,\n      progressPercentage\n    });\n  }, [inspectionId, checklistItems.length, completedCount, progressPercentage]);\n\n  const handleRunDatabaseTests = async () => {\n    const result = await runDatabaseTests();\n    setDebugInfo(result);\n  };\n\n  // Filter items based on showCompleted state\n  const filteredItems = showCompleted \n    ? checklistItems \n    : checklistItems.filter(item => item.status !== 'completed');\n\n  const handleItemComplete = () => {\n    debugLogger.info('DebugInspectionContent', 'Item completed, refetching data', {\n      inspectionId\n    });\n    onRefetch();\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <InspectionHeader \n        inspectionId={inspectionId}\n        showCompleted={showCompleted}\n        onToggleCompleted={() => setShowCompleted(!showCompleted)}\n        completedCount={completedCount}\n        totalCount={totalCount}\n        checklistItems={checklistItems}\n      />\n      \n      <DebugPanel\n        inspectionId={inspectionId}\n        checklistItemsCount={checklistItems.length}\n        completedCount={completedCount}\n        totalCount={totalCount}\n        progressPercentage={progressPercentage}\n        onRunDatabaseTests={handleRunDatabaseTests}\n        onRefetch={onRefetch}\n        isRefetching={isRefetching}\n        debugInfo={debugInfo}\n      />\n\n      <InspectionProgress items={filteredItems} />\n\n      <div className=\"p-4 space-y-4\">\n        {filteredItems.length === 0 ? (\n          <DebugEmptyState\n            checklistItemsLength={checklistItems.length}\n            showCompleted={showCompleted}\n            onRefetch={onRefetch}\n            isRefetching={isRefetching}\n          />\n        ) : (\n          filteredItems.map((item) => (\n            <ChecklistItem\n              key={item.id}\n              item={item}\n              onComplete={handleItemComplete}\n            />\n          ))\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugInspectionPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1859,1862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1859,1862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1886,1889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1886,1889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadInspectionDebugData'. Either include it or remove the dependency array.","line":88,"column":6,"nodeType":"ArrayExpression","endLine":88,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [inspectionId, loadInspectionDebugData]","fix":{"range":[2467,2481],"text":"[inspectionId, loadInspectionDebugData]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":546,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":546,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20753,20756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20753,20756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Textarea } from '@/components/ui/textarea';\nimport { \n  ArrowLeft, \n  Database, \n  Camera, \n  Video, \n  AlertTriangle, \n  CheckCircle, \n  Clock, \n  User, \n  MapPin,\n  Lightbulb,\n  Bug,\n  RefreshCw,\n  Download,\n  Eye,\n  Settings\n} from 'lucide-react';\n\n// Services and hooks\nimport { supabase } from '@/lib/supabase';\nimport { useErrorHandling } from '@/hooks/useErrorHandling';\nimport { performanceTracker } from '@/lib/monitoring/performance-tracker';\nimport { systemHealthValidator } from '@/lib/integration/system-health';\n\n// Types\ninterface InspectionDebugData {\n  inspection: {\n    id: string;\n    property_id: string;\n    inspector_id: string | null;\n    status: string | null;\n    start_time: string | null;\n    end_time: string | null;\n    completed: boolean | null;\n    certification_status: string | null;\n  };\n  property: {\n    id: string;\n    name: string | null;\n    address: string | null;\n    vrbo_url: string | null;\n    airbnb_url: string | null;\n    status: string | null;\n  };\n  checklistItems: Array<{\n    id: string;\n    label: string;\n    category: string | null;\n    evidence_type: string;\n    status: string | null;\n    ai_status: string | null;\n    notes: string | null;\n    media_count: number;\n  }>;\n  media: Array<{\n    id: string;\n    type: string;\n    url: string | null;\n    checklist_item_id: string;\n    created_at: string | null;\n  }>;\n  systemHealth: any;\n  performanceMetrics: any;\n}\n\nexport const DebugInspectionPage = () => {\n  const { inspectionId } = useParams<{ inspectionId: string }>();\n  const navigate = useNavigate();\n  const { error, handleError, clearError, withErrorHandling } = useErrorHandling();\n  \n  const [debugData, setDebugData] = useState<InspectionDebugData | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [activeTab, setActiveTab] = useState('overview');\n  const [debugNotes, setDebugNotes] = useState('');\n\n  useEffect(() => {\n    if (inspectionId) {\n      loadInspectionDebugData(inspectionId);\n    }\n  }, [inspectionId]);\n\n  const loadInspectionDebugData = async (id: string) => {\n    await withErrorHandling(async () => {\n      setIsLoading(true);\n      \n      try {\n        // Load inspection with property details\n        const { data: inspection, error: inspectionError } = await supabase\n          .from('inspections')\n          .select(`\n            *,\n            properties (\n              id, name, address, vrbo_url, airbnb_url, status\n            )\n          `)\n          .eq('id', id)\n          .single();\n\n        if (inspectionError) throw inspectionError;\n\n        // Load checklist items with media count\n        const { data: checklistItems, error: itemsError } = await supabase\n          .from('checklist_items')\n          .select(`\n            id, label, category, evidence_type, status, ai_status, notes,\n            media!media_checklist_item_id_fkey(count)\n          `)\n          .eq('inspection_id', id);\n\n        if (itemsError) throw itemsError;\n\n        // Load all media for this inspection\n        const { data: media, error: mediaError } = await supabase\n          .from('media')\n          .select(`\n            id, type, url, checklist_item_id, created_at,\n            checklist_items!inner(inspection_id)\n          `)\n          .eq('checklist_items.inspection_id', id);\n\n        if (mediaError) throw mediaError;\n\n        // Get system health\n        const systemHealth = await systemHealthValidator.performFullHealthCheck();\n        \n        // Get performance metrics\n        const performanceMetrics = performanceTracker.getMetrics();\n\n        // Process checklist items with media counts\n        const processedItems = checklistItems?.map(item => ({\n          ...item,\n          media_count: Array.isArray(item.media) ? item.media.length : 0\n        })) || [];\n\n        setDebugData({\n          inspection: inspection,\n          property: inspection.properties,\n          checklistItems: processedItems,\n          media: media || [],\n          systemHealth,\n          performanceMetrics\n        });\n        \n      } catch (error) {\n        console.error('Error loading debug data:', error);\n        handleError(error as Error);\n      } finally {\n        setIsLoading(false);\n      }\n    });\n  };\n\n  const getStatusBadge = (status: string | null) => {\n    const statusColors: Record<string, string> = {\n      'completed': 'bg-green-100 text-green-800',\n      'in_progress': 'bg-blue-100 text-blue-800',\n      'pending': 'bg-yellow-100 text-yellow-800',\n      'failed': 'bg-red-100 text-red-800',\n      'pass': 'bg-green-100 text-green-800',\n      'needs_review': 'bg-orange-100 text-orange-800'\n    };\n    \n    return (\n      <Badge className={statusColors[status || 'pending'] || 'bg-gray-100 text-gray-800'}>\n        {status || 'unknown'}\n      </Badge>\n    );\n  };\n\n  const refreshData = () => {\n    if (inspectionId) {\n      loadInspectionDebugData(inspectionId);\n    }\n  };\n\n  const exportDebugData = () => {\n    if (debugData) {\n      const exportData = {\n        ...debugData,\n        timestamp: new Date().toISOString(),\n        debugNotes\n      };\n      \n      const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n        type: 'application/json'\n      });\n      \n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `inspection-debug-${inspectionId}-${Date.now()}.json`;\n      a.click();\n      URL.revokeObjectURL(url);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin h-8 w-8 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4\"></div>\n          <p className=\"text-gray-600 dark:text-gray-400\">Loading debug data...</p>\n        </div>\n      </div>\n    );\n  }\n\n  if (!debugData) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 p-6\">\n        <div className=\"max-w-4xl mx-auto\">\n          <Alert variant=\"destructive\">\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertTitle>Debug Data Not Found</AlertTitle>\n            <AlertDescription>\n              Could not load debug information for inspection {inspectionId}\n            </AlertDescription>\n          </Alert>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Header */}\n      <div className=\"bg-white dark:bg-gray-800 border-b shadow-sm\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex items-center justify-between h-16\">\n            <div className=\"flex items-center space-x-4\">\n              <Button \n                variant=\"ghost\" \n                onClick={() => navigate(-1)}\n                className=\"text-gray-600 hover:text-gray-900\"\n              >\n                <ArrowLeft className=\"h-5 w-5 mr-2\" />\n                Back\n              </Button>\n              <div className=\"h-6 border-l border-gray-300\" />\n              <div>\n                <h1 className=\"text-xl font-semibold text-gray-900 dark:text-gray-100\">\n                  Debug Inspector - {debugData.inspection.id}\n                </h1>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                  {debugData.property.name || debugData.property.address}\n                </p>\n              </div>\n            </div>\n            \n            <div className=\"flex items-center space-x-3\">\n              <Button variant=\"outline\" onClick={refreshData}>\n                <RefreshCw className=\"h-4 w-4 mr-2\" />\n                Refresh\n              </Button>\n              <Button variant=\"outline\" onClick={exportDebugData}>\n                <Download className=\"h-4 w-4 mr-2\" />\n                Export\n              </Button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Error Display */}\n      {error.isError && (\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-4\">\n          <Alert variant=\"destructive\">\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertTitle>Error</AlertTitle>\n            <AlertDescription>\n              {error.error?.message}\n              <Button variant=\"outline\" size=\"sm\" onClick={clearError} className=\"ml-2\">\n                Dismiss\n              </Button>\n            </AlertDescription>\n          </Alert>\n        </div>\n      )}\n\n      {/* Main Content */}\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        <Tabs value={activeTab} onValueChange={setActiveTab} className=\"space-y-6\">\n          <TabsList className=\"grid w-full grid-cols-6\">\n            <TabsTrigger value=\"overview\">Overview</TabsTrigger>\n            <TabsTrigger value=\"checklist\">Checklist</TabsTrigger>\n            <TabsTrigger value=\"media\">Media</TabsTrigger>\n            <TabsTrigger value=\"performance\">Performance</TabsTrigger>\n            <TabsTrigger value=\"system\">System</TabsTrigger>\n            <TabsTrigger value=\"debug\">Debug</TabsTrigger>\n          </TabsList>\n\n          {/* Overview Tab */}\n          <TabsContent value=\"overview\" className=\"space-y-6\">\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              {/* Inspection Info */}\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <Database className=\"h-5 w-5\" />\n                    Inspection Details\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-4\">\n                  <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                    <div>\n                      <span className=\"font-medium\">ID:</span>\n                      <p className=\"font-mono text-xs break-all\">{debugData.inspection.id}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Status:</span>\n                      <div className=\"mt-1\">{getStatusBadge(debugData.inspection.status)}</div>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Started:</span>\n                      <p>{debugData.inspection.start_time \n                        ? new Date(debugData.inspection.start_time).toLocaleString()\n                        : 'Not started'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Completed:</span>\n                      <p>{debugData.inspection.end_time \n                        ? new Date(debugData.inspection.end_time).toLocaleString()\n                        : 'Not completed'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Inspector:</span>\n                      <p>{debugData.inspection.inspector_id || 'Not assigned'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Certification:</span>\n                      <p>{debugData.inspection.certification_status || 'Pending'}</p>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n\n              {/* Property Info */}\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <MapPin className=\"h-5 w-5\" />\n                    Property Details\n                  </CardTitle>\n                </CardHeader>\n                <CardContent className=\"space-y-4\">\n                  <div className=\"space-y-3 text-sm\">\n                    <div>\n                      <span className=\"font-medium\">Name:</span>\n                      <p>{debugData.property.name || 'Unnamed Property'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Address:</span>\n                      <p>{debugData.property.address || 'No address'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">VRBO URL:</span>\n                      <p className=\"break-all\">{debugData.property.vrbo_url || 'Not provided'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Airbnb URL:</span>\n                      <p className=\"break-all\">{debugData.property.airbnb_url || 'Not provided'}</p>\n                    </div>\n                    <div>\n                      <span className=\"font-medium\">Status:</span>\n                      <div className=\"mt-1\">{getStatusBadge(debugData.property.status)}</div>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n            </div>\n\n            {/* Quick Stats */}\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n              <Card>\n                <CardContent className=\"p-6 text-center\">\n                  <div className=\"text-2xl font-bold text-blue-600\">\n                    {debugData.checklistItems.length}\n                  </div>\n                  <div className=\"text-sm text-gray-600\">Total Items</div>\n                </CardContent>\n              </Card>\n              <Card>\n                <CardContent className=\"p-6 text-center\">\n                  <div className=\"text-2xl font-bold text-green-600\">\n                    {debugData.checklistItems.filter(item => item.status === 'completed').length}\n                  </div>\n                  <div className=\"text-sm text-gray-600\">Completed</div>\n                </CardContent>\n              </Card>\n              <Card>\n                <CardContent className=\"p-6 text-center\">\n                  <div className=\"text-2xl font-bold text-purple-600\">\n                    {debugData.media.length}\n                  </div>\n                  <div className=\"text-sm text-gray-600\">Media Files</div>\n                </CardContent>\n              </Card>\n              <Card>\n                <CardContent className=\"p-6 text-center\">\n                  <div className=\"text-2xl font-bold text-orange-600\">\n                    {debugData.checklistItems.filter(item => item.ai_status === 'needs_review').length}\n                  </div>\n                  <div className=\"text-sm text-gray-600\">Need Review</div>\n                </CardContent>\n              </Card>\n            </div>\n          </TabsContent>\n\n          {/* Checklist Tab */}\n          <TabsContent value=\"checklist\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Checklist Items Analysis</CardTitle>\n                <CardDescription>\n                  Detailed view of all checklist items and their status\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {debugData.checklistItems.map((item) => (\n                    <div key={item.id} className=\"border rounded-lg p-4\">\n                      <div className=\"flex items-start justify-between\">\n                        <div className=\"flex-1\">\n                          <h4 className=\"font-medium\">{item.label}</h4>\n                          <div className=\"flex items-center gap-2 mt-2\">\n                            <Badge variant=\"outline\">{item.category || 'No category'}</Badge>\n                            <Badge variant=\"outline\">{item.evidence_type}</Badge>\n                            {getStatusBadge(item.status)}\n                            {item.ai_status && getStatusBadge(item.ai_status)}\n                          </div>\n                          {item.notes && (\n                            <p className=\"text-sm text-gray-600 mt-2\">{item.notes}</p>\n                          )}\n                        </div>\n                        <div className=\"text-right text-sm text-gray-500\">\n                          <div className=\"flex items-center gap-1\">\n                            <Camera className=\"h-4 w-4\" />\n                            {item.media_count} files\n                          </div>\n                          <p className=\"font-mono text-xs mt-1\">{item.id}</p>\n                        </div>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Media Tab */}\n          <TabsContent value=\"media\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Media Files</CardTitle>\n                <CardDescription>\n                  All photos and videos associated with this inspection\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n                  {debugData.media.map((mediaItem) => (\n                    <div key={mediaItem.id} className=\"border rounded-lg p-4\">\n                      <div className=\"flex items-center gap-2 mb-2\">\n                        {mediaItem.type === 'photo' ? (\n                          <Camera className=\"h-4 w-4\" />\n                        ) : (\n                          <Video className=\"h-4 w-4\" />\n                        )}\n                        <span className=\"font-medium capitalize\">{mediaItem.type}</span>\n                      </div>\n                      <div className=\"text-sm text-gray-600 space-y-1\">\n                        <p><span className=\"font-medium\">Item ID:</span> {mediaItem.checklist_item_id}</p>\n                        <p><span className=\"font-medium\">Created:</span> {\n                          mediaItem.created_at \n                            ? new Date(mediaItem.created_at).toLocaleString()\n                            : 'Unknown'\n                        }</p>\n                        {mediaItem.url && (\n                          <Button \n                            variant=\"outline\" \n                            size=\"sm\" \n                            onClick={() => window.open(mediaItem.url!, '_blank')}\n                            className=\"mt-2\"\n                          >\n                            <Eye className=\"h-4 w-4 mr-2\" />\n                            View\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n                \n                {debugData.media.length === 0 && (\n                  <div className=\"text-center py-8 text-gray-500\">\n                    <Camera className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n                    <p>No media files found</p>\n                  </div>\n                )}\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Performance Tab */}\n          <TabsContent value=\"performance\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Performance Metrics</CardTitle>\n                <CardDescription>\n                  Performance monitoring and metrics for this inspection\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <pre className=\"bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-sm overflow-auto\">\n                  {JSON.stringify(debugData.performanceMetrics, null, 2)}\n                </pre>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* System Tab */}\n          <TabsContent value=\"system\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle>System Health</CardTitle>\n                <CardDescription>\n                  Current system health and component status\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"font-medium\">Overall Status:</span>\n                    {getStatusBadge(debugData.systemHealth.overall)}\n                  </div>\n                  \n                  <div className=\"space-y-2\">\n                    {debugData.systemHealth.checks?.map((check: any, index: number) => (\n                      <div key={index} className=\"flex items-center justify-between p-3 border rounded\">\n                        <div>\n                          <span className=\"font-medium\">{check.component}</span>\n                          <p className=\"text-sm text-gray-600\">{check.description}</p>\n                        </div>\n                        {getStatusBadge(check.status)}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Debug Tab */}\n          <TabsContent value=\"debug\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <Bug className=\"h-5 w-5\" />\n                  Debug Notes & Raw Data\n                </CardTitle>\n                <CardDescription>\n                  Add debug notes and view raw inspection data\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div>\n                  <label className=\"block text-sm font-medium mb-2\">Debug Notes</label>\n                  <Textarea\n                    value={debugNotes}\n                    onChange={(e) => setDebugNotes(e.target.value)}\n                    placeholder=\"Add your debug notes here...\"\n                    className=\"min-h-[100px]\"\n                  />\n                </div>\n                \n                <div>\n                  <label className=\"block text-sm font-medium mb-2\">Raw Debug Data</label>\n                  <pre className=\"bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-sm overflow-auto max-h-96\">\n                    {JSON.stringify(debugData, null, 2)}\n                  </pre>\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n        </Tabs>\n      </div>\n    </div>\n  );\n};\n\nexport default DebugInspectionPage;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugInspectionWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DebugPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[409,412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[409,412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Bug, Database, RefreshCw } from \"lucide-react\";\n\ninterface DebugPanelProps {\n  inspectionId: string;\n  checklistItemsCount: number;\n  completedCount: number;\n  totalCount: number;\n  progressPercentage: number;\n  onRunDatabaseTests: () => Promise<void>;\n  onRefetch: () => void;\n  isRefetching: boolean;\n  debugInfo: any;\n}\n\nexport const DebugPanel = ({\n  inspectionId,\n  checklistItemsCount,\n  completedCount,\n  totalCount,\n  progressPercentage,\n  onRunDatabaseTests,\n  onRefetch,\n  isRefetching,\n  debugInfo\n}: DebugPanelProps) => {\n  const [showDebugPanel, setShowDebugPanel] = useState(true);\n\n  if (!showDebugPanel) {\n    return null;\n  }\n\n  return (\n    <div className=\"bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4\">\n      <div className=\"flex items-center justify-between mb-2\">\n        <div className=\"flex items-center\">\n          <Bug className=\"w-5 h-5 text-yellow-600 mr-2\" />\n          <span className=\"text-yellow-800 font-medium\">Debug Mode Active</span>\n        </div>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={() => setShowDebugPanel(false)}\n        >\n          Hide Debug\n        </Button>\n      </div>\n      \n      <div className=\"space-y-2\">\n        <div className=\"text-sm text-yellow-700\">\n          <strong>Inspection ID:</strong> {inspectionId}\n        </div>\n        <div className=\"text-sm text-yellow-700\">\n          <strong>Items Loaded:</strong> {checklistItemsCount}\n        </div>\n        <div className=\"text-sm text-yellow-700\">\n          <strong>Progress:</strong> {completedCount}/{totalCount} ({progressPercentage}%)\n        </div>\n        \n        <div className=\"flex gap-2 mt-3\">\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={onRunDatabaseTests}\n            className=\"text-yellow-700 border-yellow-300\"\n          >\n            <Database className=\"w-4 h-4 mr-1\" />\n            Test Database\n          </Button>\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={onRefetch}\n            disabled={isRefetching}\n            className=\"text-yellow-700 border-yellow-300\"\n          >\n            <RefreshCw className={`w-4 h-4 mr-1 ${isRefetching ? 'animate-spin' : ''}`} />\n            Reload Data\n          </Button>\n        </div>\n\n        {debugInfo && (\n          <div className=\"mt-3 p-3 bg-white rounded border border-yellow-200\">\n            <div className=\"text-xs text-gray-600 font-mono whitespace-pre-wrap\">\n              {JSON.stringify(debugInfo, null, 2)}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DomainAwarePWA.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":154,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":154,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5283,5286],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5283,5286],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { isInspectorDomain, isAdminDomain } from '@/lib/config/app-type';\nimport { env } from '@/lib/config/environment';\n\n// Domain-aware PWA registration component\nexport const DomainAwarePWA: React.FC = () => {\n  useEffect(() => {\n    // Only register PWA service worker on inspector domain\n    if (isInspectorDomain() && 'serviceWorker' in navigator) {\n      registerPWA();\n    }\n  }, []);\n\n  const registerPWA = async () => {\n    try {\n      // Check if we should register PWA\n      const shouldRegister = isInspectorDomain() && env.features.pwa;\n      \n      if (!shouldRegister) {\n        console.log('PWA registration skipped - not inspector domain or PWA disabled');\n        return;\n      }\n\n      // Register the service worker\n      const registration = await navigator.serviceWorker.register('/sw.js', {\n        scope: '/',\n      });\n\n      console.log('PWA Service Worker registered successfully:', registration);\n\n      // Listen for updates\n      registration.addEventListener('updatefound', () => {\n        const newWorker = registration.installing;\n        if (newWorker) {\n          newWorker.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              // New version available\n              console.log('New PWA version available. Refresh to update.');\n              // You could show a notification here\n            }\n          });\n        }\n      });\n\n      // Handle service worker messages\n      navigator.serviceWorker.addEventListener('message', (event) => {\n        if (event.data && event.data.type === 'SKIP_WAITING') {\n          // Update available, reload the page\n          window.location.reload();\n        }\n      });\n\n    } catch (error) {\n      console.error('PWA Service Worker registration failed:', error);\n    }\n  };\n\n  // Add meta tags for PWA on inspector domain\n  useEffect(() => {\n    if (isInspectorDomain()) {\n      // Add PWA meta tags\n      const metaTags = [\n        { name: 'apple-mobile-web-app-capable', content: 'yes' },\n        { name: 'apple-mobile-web-app-status-bar-style', content: 'default' },\n        { name: 'apple-mobile-web-app-title', content: 'STR Inspector' },\n        { name: 'application-name', content: 'STR Inspector' },\n        { name: 'msapplication-TileColor', content: '#8b5cf6' },\n        { name: 'theme-color', content: '#8b5cf6' },\n        { name: 'mobile-web-app-capable', content: 'yes' },\n      ];\n\n      metaTags.forEach(({ name, content }) => {\n        let meta = document.querySelector(`meta[name=\"${name}\"]`);\n        if (!meta) {\n          meta = document.createElement('meta');\n          meta.setAttribute('name', name);\n          document.head.appendChild(meta);\n        }\n        meta.setAttribute('content', content);\n      });\n\n      // Add PWA icons\n      const iconSizes = [\n        { size: '180x180', name: 'apple-touch-icon' },\n        { size: '32x32', name: 'icon' },\n        { size: '16x16', name: 'icon' },\n        { size: '192x192', name: 'icon' },\n        { size: '512x512', name: 'icon' },\n      ];\n\n      iconSizes.forEach(({ size, name }) => {\n        let link = document.querySelector(`link[rel=\"${name}\"][sizes=\"${size}\"]`);\n        if (!link) {\n          link = document.createElement('link');\n          link.setAttribute('rel', name);\n          link.setAttribute('sizes', size);\n          document.head.appendChild(link);\n        }\n        link.setAttribute('href', `/pwa-${size}.png`);\n      });\n\n      // Add manifest link\n      let manifestLink = document.querySelector('link[rel=\"manifest\"]');\n      if (!manifestLink) {\n        manifestLink = document.createElement('link');\n        manifestLink.setAttribute('rel', 'manifest');\n        manifestLink.setAttribute('href', '/manifest.json');\n        document.head.appendChild(manifestLink);\n      }\n    }\n  }, []);\n\n  // Add analytics script for admin domain\n  useEffect(() => {\n    if (isAdminDomain() && env.features.analytics) {\n      // Add Google Analytics or other analytics scripts\n      if (env.monitoring.gaTrackingId) {\n        addAnalyticsScript();\n      }\n    }\n  }, []);\n\n  const addAnalyticsScript = () => {\n    const gaTrackingId = env.monitoring.gaTrackingId;\n    if (!gaTrackingId) return;\n\n    // Check if script already exists\n    if (document.querySelector(`script[src*=\"${gaTrackingId}\"]`)) {\n      return;\n    }\n\n    // Add Google Analytics script\n    const script1 = document.createElement('script');\n    script1.async = true;\n    script1.src = `https://www.googletagmanager.com/gtag/js?id=${gaTrackingId}`;\n    document.head.appendChild(script1);\n\n    const script2 = document.createElement('script');\n    script2.innerHTML = `\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n      gtag('config', '${gaTrackingId}');\n    `;\n    document.head.appendChild(script2);\n\n    console.log('Analytics script added for admin domain');\n  };\n\n  return null; // This component doesn't render anything\n};\n\n// Hook to get PWA installation status\nexport const usePWAInstallation = () => {\n  const [canInstall, setCanInstall] = React.useState(false);\n  const [deferredPrompt, setDeferredPrompt] = React.useState<any>(null);\n\n  useEffect(() => {\n    // Only enable PWA installation on inspector domain\n    if (!isInspectorDomain()) return;\n\n    const handleBeforeInstallPrompt = (e: Event) => {\n      e.preventDefault();\n      setDeferredPrompt(e);\n      setCanInstall(true);\n    };\n\n    const handleAppInstalled = () => {\n      setDeferredPrompt(null);\n      setCanInstall(false);\n      console.log('PWA installed successfully');\n    };\n\n    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\n    window.addEventListener('appinstalled', handleAppInstalled);\n\n    return () => {\n      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\n      window.removeEventListener('appinstalled', handleAppInstalled);\n    };\n  }, []);\n\n  const promptInstall = async () => {\n    if (!deferredPrompt) return false;\n\n    deferredPrompt.prompt();\n    const { outcome } = await deferredPrompt.userChoice;\n    \n    if (outcome === 'accepted') {\n      setDeferredPrompt(null);\n      setCanInstall(false);\n      return true;\n    }\n    \n    return false;\n  };\n\n  return {\n    canInstall,\n    promptInstall,\n    isInspectorDomain: isInspectorDomain(),\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/DualUploadInterface.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/EmptyPropertiesState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/EnhancedBreadcrumb.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[474,477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[474,477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { ChevronRight, Home, Building2, ClipboardList, CheckCircle } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n} from '@/components/ui/breadcrumb';\n\ninterface BreadcrumbConfig {\n  path: string;\n  label: string;\n  icon: React.ComponentType<any>;\n  isClickable?: boolean;\n}\n\nexport const EnhancedBreadcrumb = () => {\n  const location = useLocation();\n  const navigate = useNavigate();\n\n  const getBreadcrumbConfig = (): BreadcrumbConfig[] => {\n    const pathSegments = location.pathname.split('/').filter(Boolean);\n    const configs: BreadcrumbConfig[] = [\n      { path: '/', label: 'Home', icon: Home, isClickable: true }\n    ];\n\n    if (pathSegments.includes('properties')) {\n      configs.push({\n        path: '/properties',\n        label: 'Properties',\n        icon: Building2,\n        isClickable: true\n      });\n    }\n\n    if (pathSegments.includes('add-property')) {\n      configs.push({\n        path: '/add-property',\n        label: 'Add Property',\n        icon: Building2,\n        isClickable: false\n      });\n    }\n\n    if (pathSegments.includes('inspection')) {\n      const inspectionId = pathSegments[pathSegments.indexOf('inspection') + 1];\n      configs.push({\n        path: `/inspection/${inspectionId}`,\n        label: 'Inspection',\n        icon: ClipboardList,\n        isClickable: false\n      });\n\n      if (pathSegments.includes('complete')) {\n        configs.push({\n          path: `/inspection/${inspectionId}/complete`,\n          label: 'Complete',\n          icon: CheckCircle,\n          isClickable: false\n        });\n      }\n    }\n\n    return configs;\n  };\n\n  const breadcrumbConfigs = getBreadcrumbConfig();\n  const currentPath = location.pathname;\n\n  return (\n    <div className=\"bg-white border-b border-gray-200 px-4 py-2\">\n      <Breadcrumb>\n        <BreadcrumbList className=\"text-sm\">\n          {breadcrumbConfigs.map((config, index) => {\n            const isLast = index === breadcrumbConfigs.length - 1;\n            const Icon = config.icon;\n\n            return (\n              <React.Fragment key={config.path}>\n                <BreadcrumbItem className=\"flex items-center gap-1\">\n                  {config.isClickable && !isLast ? (\n                    <BreadcrumbLink asChild>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={() => navigate(config.path)}\n                        className=\"flex items-center gap-1 h-auto p-1 text-gray-600 hover:text-blue-600\"\n                      >\n                        <Icon className=\"w-3 h-3\" />\n                        <span>{config.label}</span>\n                      </Button>\n                    </BreadcrumbLink>\n                  ) : (\n                    <BreadcrumbPage className=\"flex items-center gap-1 text-gray-900 font-medium\">\n                      <Icon className=\"w-3 h-3\" />\n                      <span>{config.label}</span>\n                    </BreadcrumbPage>\n                  )}\n                </BreadcrumbItem>\n                {!isLast && (\n                  <BreadcrumbSeparator>\n                    <ChevronRight className=\"w-3 h-3\" />\n                  </BreadcrumbSeparator>\n                )}\n              </React.Fragment>\n            );\n          })}\n        </BreadcrumbList>\n      </Breadcrumb>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/EnhancedErrorRecovery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/EnhancedProgressIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ErrorBoundaryWithRecovery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/FormErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionCompleteButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionContent.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'safeChecklistItems' conditional could make the dependencies of useMemo Hook (at line 92) change on every render. To fix this, wrap the initialization of 'safeChecklistItems' in its own useMemo() Hook.","line":39,"column":9,"nodeType":"VariableDeclarator","endLine":39,"endColumn":81},{"ruleId":"prefer-const","severity":2,"message":"'items' is never reassigned. Use 'const' instead.","line":43,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":43,"endColumn":14,"fix":{"range":[1660,2443],"text":"const items = safeChecklistItems.filter(item => {\n      if (!item || !item.id) return false; // Safety check\n      \n      // Filter by completion status\n      const matchesCompletedFilter = showCompleted || (!item.status || item.status === null);\n      \n      // Filter by category\n      const matchesCategoryFilter = !selectedCategory || item.category === selectedCategory;\n      \n      // Filter by search query\n      const matchesSearch = !searchQuery.trim() || \n        item.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        item.description?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        item.category?.toLowerCase().includes(searchQuery.toLowerCase());\n      \n      return matchesCompletedFilter && matchesCategoryFilter && matchesSearch;\n    });"}},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":73,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":73,"endColumn":107,"suggestions":[{"messageId":"addBrackets","fix":{"range":[2805,3081],"text":"{ const statusOrder = { 'completed': 3, 'failed': 2, 'not_applicable': 1, null: 0, undefined: 0 };\n          comparison = (statusOrder[a.status as keyof typeof statusOrder] || 0) - \n                      (statusOrder[b.status as keyof typeof statusOrder] || 0);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":78,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":78,"endColumn":70,"suggestions":[{"messageId":"addBrackets","fix":{"range":[3117,3368],"text":"{ const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };\n          comparison = (priorityOrder[a.priority as keyof typeof priorityOrder] || 0) - \n                      (priorityOrder[b.priority as keyof typeof priorityOrder] || 0);\n          break; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"\nimport { useState, useMemo } from \"react\";\nimport { MobileOptimizedLayout } from \"@/components/MobileOptimizedLayout\";\nimport { InspectionProgressTracker } from \"@/components/InspectionProgressTracker\";\nimport { InspectionFilters, type SortOption, type SortDirection } from \"@/components/InspectionFilters\";\nimport { InspectionList } from \"@/components/InspectionList\";\nimport { InspectionCompleteButton } from \"@/components/InspectionCompleteButton\";\nimport { ChecklistItemType } from \"@/types/inspection\";\nimport { debugLogger } from \"@/utils/debugLogger\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { InfoIcon } from \"lucide-react\";\n\ninterface InspectionContentProps {\n  inspectionId: string;\n  checklistItems: ChecklistItemType[];\n  onRefetch: () => void;\n  isRefetching?: boolean;\n}\n\nexport const InspectionContent = ({ \n  inspectionId, \n  checklistItems, \n  onRefetch, \n  isRefetching = false \n}: InspectionContentProps) => {\n  const [showCompleted, setShowCompleted] = useState(false);\n  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [sortBy, setSortBy] = useState<SortOption>(\"order\");\n  const [sortDirection, setSortDirection] = useState<SortDirection>(\"asc\");\n\n  debugLogger.info('InspectionContent', 'Rendering with data', {\n    inspectionId,\n    itemCount: checklistItems.length,\n    isRefetching\n  });\n\n  // Defensive programming - handle null/undefined data\n  const safeChecklistItems = Array.isArray(checklistItems) ? checklistItems : [];\n\n  // Sort and filter items\n  const filteredAndSortedItems = useMemo(() => {\n    let items = safeChecklistItems.filter(item => {\n      if (!item || !item.id) return false; // Safety check\n      \n      // Filter by completion status\n      const matchesCompletedFilter = showCompleted || (!item.status || item.status === null);\n      \n      // Filter by category\n      const matchesCategoryFilter = !selectedCategory || item.category === selectedCategory;\n      \n      // Filter by search query\n      const matchesSearch = !searchQuery.trim() || \n        item.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        item.description?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        item.category?.toLowerCase().includes(searchQuery.toLowerCase());\n      \n      return matchesCompletedFilter && matchesCategoryFilter && matchesSearch;\n    });\n\n    // Sort items\n    items.sort((a, b) => {\n      let comparison = 0;\n      \n      switch (sortBy) {\n        case 'title':\n          comparison = (a.title || '').localeCompare(b.title || '');\n          break;\n        case 'category':\n          comparison = (a.category || '').localeCompare(b.category || '');\n          break;\n        case 'status':\n          const statusOrder = { 'completed': 3, 'failed': 2, 'not_applicable': 1, null: 0, undefined: 0 };\n          comparison = (statusOrder[a.status as keyof typeof statusOrder] || 0) - \n                      (statusOrder[b.status as keyof typeof statusOrder] || 0);\n          break;\n        case 'priority':\n          const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };\n          comparison = (priorityOrder[a.priority as keyof typeof priorityOrder] || 0) - \n                      (priorityOrder[b.priority as keyof typeof priorityOrder] || 0);\n          break;\n        case 'order':\n        default:\n          comparison = (a.order || 0) - (b.order || 0);\n          break;\n      }\n      \n      return sortDirection === 'desc' ? -comparison : comparison;\n    });\n\n    return items;\n  }, [safeChecklistItems, showCompleted, selectedCategory, searchQuery, sortBy, sortDirection]);\n\n  const filteredItems = filteredAndSortedItems;\n\n  const completedCount = safeChecklistItems.filter(item => \n    item && (item.status === 'completed' || item.status === 'failed' || item.status === 'not_applicable')\n  ).length;\n  const totalCount = safeChecklistItems.length;\n  const passedCount = safeChecklistItems.filter(item => item && item.status === 'completed').length;\n  const failedCount = safeChecklistItems.filter(item => item && item.status === 'failed').length;\n  const isAllCompleted = completedCount === totalCount && totalCount > 0;\n\n  debugLogger.info('InspectionContent', 'Render stats', {\n    totalItems: totalCount,\n    completedItems: completedCount,\n    filteredItems: filteredItems.length,\n    isAllCompleted\n  });\n\n  return (\n    <MobileOptimizedLayout\n      title=\"Inspection Checklist\"\n      subtitle={totalCount > 0 ? `${completedCount}/${totalCount} items completed` : \"Loading checklist...\"}\n      showBackButton\n      backTo=\"/properties\"\n    >\n      <div className=\"px-3 sm:px-4 py-4 space-y-4 max-w-4xl mx-auto\">\n        {/* Loading state during refetch */}\n        {isRefetching && (\n          <div className=\"text-center py-4\">\n            <div className=\"w-6 h-6 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-2\" />\n            <p className=\"text-sm text-gray-600\">Refreshing checklist...</p>\n          </div>\n        )}\n\n        {/* Empty state with helpful message */}\n        {totalCount === 0 && !isRefetching && (\n          <Alert className=\"bg-blue-50 border-blue-200\">\n            <InfoIcon className=\"h-4 w-4 text-blue-600\" />\n            <AlertDescription className=\"text-blue-800\">\n              This inspection doesn't have any checklist items yet. Checklist items are usually generated automatically when a property is added. \n              You can add items manually using the \"Add Item\" button below.\n            </AlertDescription>\n          </Alert>\n        )}\n\n        {/* Progress Tracker - only show if we have items */}\n        {totalCount > 0 && (\n          <InspectionProgressTracker checklistItems={safeChecklistItems} showDetailed />\n        )}\n\n        {/* Filters - only show if we have items */}\n        {totalCount > 0 && (\n          <InspectionFilters\n            checklistItems={safeChecklistItems}\n            selectedCategory={selectedCategory}\n            onCategoryChange={setSelectedCategory}\n            showCompleted={showCompleted}\n            onToggleCompleted={() => setShowCompleted(!showCompleted)}\n            onRefresh={onRefetch}\n            isRefetching={isRefetching}\n            searchQuery={searchQuery}\n            onSearchChange={setSearchQuery}\n            sortBy={sortBy}\n            sortDirection={sortDirection}\n            onSortChange={(newSortBy: SortOption, newDirection: SortDirection) => {\n              setSortBy(newSortBy);\n              setSortDirection(newDirection);\n            }}\n          />\n        )}\n\n        {/* Checklist Items or Empty State */}\n        <InspectionList\n          items={filteredItems}\n          showCompleted={showCompleted}\n          selectedCategory={selectedCategory}\n          onComplete={onRefetch}\n          onCategoryChange={setSelectedCategory}\n          inspectionId={inspectionId}\n        />\n\n        {/* Complete Button - only show if we have completed items */}\n        {totalCount > 0 && (\n          <InspectionCompleteButton\n            inspectionId={inspectionId}\n            isAllCompleted={isAllCompleted}\n            passedCount={passedCount}\n            failedCount={failedCount}\n          />\n        )}\n      </div>\n    </MobileOptimizedLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionErrorState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionInvalidState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionLoadingState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectionProgressTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/InspectorPresenceIndicator.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[533,536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[533,536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2278,2281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2278,2281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3398,3401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3398,3401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef } from \"react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"@/components/ui/tooltip\";\nimport { Users, Eye, Wrench, AlertCircle } from \"lucide-react\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useChannelManager } from \"@/hooks/useChannelManager\";\nimport type { Tables } from \"@/integrations/supabase/types\";\n\ntype InspectorPresence = Tables<'inspector_presence'> & {\n  metadata: Record<string, any>;\n};\n\ninterface InspectorPresenceIndicatorProps {\n  inspectionId: string;\n  currentItemId?: string;\n}\n\nexport const InspectorPresenceIndicator = ({ \n  inspectionId, \n  currentItemId \n}: InspectorPresenceIndicatorProps) => {\n  const [presenceData, setPresenceData] = useState<InspectorPresence[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { createChannel, subscribeChannel, cleanupChannel } = useChannelManager();\n  const isMountedRef = useRef(true);\n  const retryTimeoutRef = useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    if (!inspectionId) {\n      setIsLoading(false);\n      return;\n    }\n\n    isMountedRef.current = true;\n\n    const fetchPresence = async () => {\n      if (!isMountedRef.current) return;\n      \n      try {\n        setError(null);\n        \n        const { data, error } = await supabase\n          .from('inspector_presence')\n          .select('*')\n          .eq('inspection_id', inspectionId)\n          .neq('status', 'offline')\n          .gte('last_seen', new Date(Date.now() - 5 * 60 * 1000).toISOString());\n\n        if (error) {\n          console.error('Error fetching presence:', error);\n          setError(error.message);\n          \n          // Retry after 5 seconds if there's an error\n          if (isMountedRef.current) {\n            retryTimeoutRef.current = setTimeout(() => {\n              if (isMountedRef.current) fetchPresence();\n            }, 5000);\n          }\n          return;\n        }\n        \n        // Transform the data to ensure metadata is properly typed\n        const transformedData: InspectorPresence[] = (data || []).map(item => ({\n          ...item,\n          metadata: (item.metadata as Record<string, any>) || {}\n        }));\n        \n        if (isMountedRef.current) {\n          setPresenceData(transformedData);\n          setIsLoading(false);\n        }\n      } catch (fetchError) {\n        console.error('Error fetching presence:', fetchError);\n        if (isMountedRef.current) {\n          setError('Failed to load presence data');\n          setIsLoading(false);\n          \n          // Retry after 5 seconds\n          retryTimeoutRef.current = setTimeout(() => {\n            if (isMountedRef.current) fetchPresence();\n          }, 5000);\n        }\n      }\n    };\n\n    const setupRealtimeSubscription = async () => {\n      try {\n        // Create unique channel name\n        const channelName = `presence-indicator-${inspectionId}`;\n        console.log('Setting up presence channel:', channelName);\n        \n        const channel = createChannel(channelName, {\n          presenceChanges: {\n            filter: {\n              event: '*',\n              schema: 'public',\n              table: 'inspector_presence',\n              filter: `inspection_id=eq.${inspectionId}`\n            },\n            callback: (payload: any) => {\n              console.log('Presence update received:', payload);\n              if (isMountedRef.current) {\n                fetchPresence();\n              }\n            }\n          }\n        });\n\n        // Subscribe to the channel with async handling\n        await subscribeChannel(channelName, (status: string) => {\n          console.log('Presence subscription status:', status);\n          if (status === 'SUBSCRIBED' && isMountedRef.current) {\n            fetchPresence();\n          } else if (status === 'CHANNEL_ERROR') {\n            console.error('Channel subscription error');\n          }\n        });\n\n      } catch (subscriptionError) {\n        console.error('Error setting up presence subscription:', subscriptionError);\n        // Fall back to periodic polling if realtime fails\n        if (isMountedRef.current) {\n          const pollInterval = setInterval(() => {\n            if (isMountedRef.current) fetchPresence();\n          }, 30000);\n          \n          return () => {\n            clearInterval(pollInterval);\n          };\n        }\n      }\n    };\n\n    // Initial fetch\n    fetchPresence();\n    \n    // Setup realtime subscription\n    setupRealtimeSubscription();\n\n    return () => {\n      isMountedRef.current = false;\n      \n      if (retryTimeoutRef.current) clearTimeout(retryTimeoutRef.current);\n      \n      // Clean up channel\n      const channelName = `presence-indicator-${inspectionId}`;\n      cleanupChannel(channelName);\n    };\n  }, [inspectionId, createChannel, subscribeChannel, cleanupChannel]);\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'viewing':\n        return <Eye className=\"w-3 h-3\" />;\n      case 'working':\n        return <Wrench className=\"w-3 h-3\" />;\n      default:\n        return <Users className=\"w-3 h-3\" />;\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'online':\n        return 'bg-green-500';\n      case 'viewing':\n        return 'bg-blue-500';\n      case 'working':\n        return 'bg-orange-500';\n      default:\n        return 'bg-gray-500';\n    }\n  };\n\n  // Show error state\n  if (error && !isLoading) {\n    return (\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger>\n            <Badge variant=\"outline\" className=\"flex items-center gap-1 text-red-600 border-red-200\">\n              <AlertCircle className=\"w-3 h-3\" />\n              Connection issue\n            </Badge>\n          </TooltipTrigger>\n          <TooltipContent>\n            <p>Unable to load presence data: {error}</p>\n          </TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    );\n  }\n\n  // Show loading state\n  if (isLoading) {\n    return (\n      <Badge variant=\"outline\" className=\"flex items-center gap-1 animate-pulse\">\n        <Users className=\"w-3 h-3\" />\n        Loading...\n      </Badge>\n    );\n  }\n\n  const activeInspectorsOnItem = presenceData.filter(\n    p => p.current_item_id === currentItemId && currentItemId\n  );\n\n  const totalActiveInspectors = presenceData.length;\n\n  if (totalActiveInspectors === 0) return null;\n\n  return (\n    <TooltipProvider>\n      <div className=\"flex items-center gap-2\">\n        <Tooltip>\n          <TooltipTrigger>\n            <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n              <Users className=\"w-3 h-3\" />\n              {totalActiveInspectors} active\n            </Badge>\n          </TooltipTrigger>\n          <TooltipContent>\n            <p>{totalActiveInspectors} inspector(s) currently working on this inspection</p>\n          </TooltipContent>\n        </Tooltip>\n\n        {activeInspectorsOnItem.length > 0 && (\n          <Tooltip>\n            <TooltipTrigger>\n              <Badge className={`flex items-center gap-1 ${getStatusColor(activeInspectorsOnItem[0].status)}`}>\n                {getStatusIcon(activeInspectorsOnItem[0].status)}\n                {activeInspectorsOnItem.length}\n              </Badge>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>{activeInspectorsOnItem.length} inspector(s) working on this item</p>\n            </TooltipContent>\n          </Tooltip>\n        )}\n      </div>\n    </TooltipProvider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/LoadingStateManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/Logo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaLightbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MediaUploader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileAuthLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileErrorRecovery.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'canRetry', 'handleRetry', and 'retryCount'. Either include them or remove the dependency array.","line":39,"column":6,"nodeType":"ArrayExpression","endLine":39,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [canRetry, handleRetry, isOnline, retryCount]","fix":{"range":[1204,1214],"text":"[canRetry, handleRetry, isOnline, retryCount]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useState, useEffect } from 'react';\nimport { AlertTriangle, RefreshCw, Home, Wifi, WifiOff } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { useNetworkStatus } from '@/hooks/useNetworkStatus';\n\ninterface MobileErrorRecoveryProps {\n  error: Error | string;\n  onRetry: () => void;\n  onNavigateHome: () => void;\n  context?: string;\n  showOfflineMode?: boolean;\n}\n\nexport const MobileErrorRecovery: React.FC<MobileErrorRecoveryProps> = ({\n  error,\n  onRetry,\n  onNavigateHome,\n  context = 'operation',\n  showOfflineMode = true\n}) => {\n  const [retryCount, setRetryCount] = useState(0);\n  const isOnline = useNetworkStatus();\n  const maxRetries = 3;\n\n  const errorMessage = error instanceof Error ? error.message : error;\n  const canRetry = retryCount < maxRetries;\n\n  // Auto-retry on network reconnection\n  useEffect(() => {\n    if (isOnline && retryCount > 0 && canRetry) {\n      console.log('ðŸ“± Network reconnected, auto-retrying...');\n      setTimeout(() => {\n        handleRetry();\n      }, 1000);\n    }\n  }, [isOnline]);\n\n  const handleRetry = () => {\n    setRetryCount(prev => prev + 1);\n    onRetry();\n  };\n\n  const isNetworkError = errorMessage.toLowerCase().includes('network') || \n                        errorMessage.toLowerCase().includes('fetch') ||\n                        !isOnline;\n\n  return (\n    <div className=\"fixed inset-0 bg-gray-50 flex items-center justify-center p-4 z-50\">\n      <Card className=\"max-w-sm w-full\">\n        <CardHeader className=\"text-center pb-4\">\n          <div className=\"mx-auto w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mb-3\">\n            <AlertTriangle className=\"w-6 h-6 text-red-600\" />\n          </div>\n          \n          <CardTitle className=\"text-lg text-gray-900\">\n            {context} Failed\n          </CardTitle>\n          \n          {/* Network Status */}\n          <div className={`flex items-center justify-center gap-2 px-3 py-1 rounded-full text-xs ${\n            isOnline ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'\n          }`}>\n            {isOnline ? <Wifi className=\"w-3 h-3\" /> : <WifiOff className=\"w-3 h-3\" />}\n            {isOnline ? 'Online' : 'Offline'}\n          </div>\n        </CardHeader>\n        \n        <CardContent className=\"space-y-4\">\n          {/* Error Message */}\n          <Alert className=\"bg-red-50 border-red-200\">\n            <AlertDescription className=\"text-red-700 text-sm\">\n              {errorMessage}\n            </AlertDescription>\n          </Alert>\n\n          {/* Retry Status */}\n          {maxRetries > 1 && (\n            <div className=\"flex items-center justify-between text-xs text-gray-600\">\n              <span>Attempt {retryCount + 1} of {maxRetries + 1}</span>\n              <div className=\"flex gap-1\">\n                {Array.from({ length: maxRetries + 1 }, (_, i) => (\n                  <div\n                    key={i}\n                    className={`w-2 h-2 rounded-full ${\n                      i <= retryCount \n                        ? i === retryCount && !canRetry\n                          ? 'bg-red-400'\n                          : 'bg-blue-400'\n                        : 'bg-gray-200'\n                    }`}\n                  />\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Mobile Tips */}\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-3\">\n            <h4 className=\"text-sm font-medium text-blue-800 mb-2\">ðŸ’¡ Quick fixes:</h4>\n            <ul className=\"text-xs text-blue-700 space-y-1\">\n              {isNetworkError ? (\n                <>\n                  <li>â€¢ Check your mobile data or WiFi</li>\n                  <li>â€¢ Move to an area with better signal</li>\n                  <li>â€¢ Try switching between WiFi and mobile data</li>\n                </>\n              ) : (\n                <>\n                  <li>â€¢ Close and reopen the app</li>\n                  <li>â€¢ Clear browser cache</li>\n                  <li>â€¢ Try again in a few moments</li>\n                </>\n              )}\n            </ul>\n          </div>\n          \n          {/* Action Buttons */}\n          <div className=\"space-y-3\">\n            {canRetry && (\n              <Button\n                onClick={handleRetry}\n                className=\"w-full\"\n                disabled={!isOnline && isNetworkError}\n              >\n                <RefreshCw className=\"w-4 h-4 mr-2\" />\n                {!isOnline && isNetworkError ? 'Waiting for connection...' : `Try Again (${maxRetries - retryCount} left)`}\n              </Button>\n            )}\n            \n            <Button\n              onClick={onNavigateHome}\n              variant=\"outline\"\n              className=\"w-full\"\n            >\n              <Home className=\"w-4 h-4 mr-2\" />\n              Return to Properties\n            </Button>\n          </div>\n\n          {/* Offline Mode Info */}\n          {showOfflineMode && !isOnline && (\n            <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\n              <p className=\"text-xs text-yellow-700\">\n                ðŸ“± Some features work offline. Photos can be saved locally and will sync when reconnected.\n              </p>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileFastAuthProvider.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":11,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":11,"endColumn":21},{"ruleId":"no-async-promise-executor","severity":2,"message":"Promise executor functions should not be async.","line":60,"column":43,"nodeType":"Identifier","messageId":"async","endLine":60,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useContext, useEffect, useState, useRef, useCallback } from 'react';\nimport { User, Session } from '@supabase/supabase-js';\nimport { supabase } from '@/integrations/supabase/client';\nimport { AuthContext, AuthContextType } from '@/contexts/MobileAuthContext';\nimport { MobileAuthLoading } from '@/components/MobileAuthLoading';\nimport { useMobileAuthHooks } from '@/hooks/useMobileAuthHooks';\nimport { getCachedRole } from '@/utils/mobileCacheUtils';\nimport { useToast } from '@/hooks/use-toast';\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const MobileFastAuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [session, setSession] = useState<Session | null>(null);\n  const [userRole, setUserRole] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  const initializationRef = useRef<Promise<void> | null>(null);\n  const { toast } = useToast();\n  const { fetchUserRole, clearSession, signIn, signUp, signOut } = useMobileAuthHooks();\n\n  const loadUserRole = useCallback(async () => {\n    if (!user?.id) return;\n    \n    console.log('ðŸ“± Loading mobile user role...');\n    try {\n      const role = await fetchUserRole(user.id, false);\n      setUserRole(role);\n    } catch (error) {\n      console.error('ðŸ“± Failed to load mobile role:', error);\n      setUserRole('inspector');\n    }\n  }, [user?.id, fetchUserRole]);\n\n  const handleClearSession = useCallback(() => {\n    clearSession(user?.id);\n    setUser(null);\n    setSession(null);\n    setUserRole(null);\n    setError('Session cleared - please sign in again');\n  }, [user?.id, clearSession]);\n\n  // Mobile-optimized initialization\n  const initializeAuth = useCallback(async (): Promise<void> => {\n    if (initializationRef.current) {\n      return initializationRef.current;\n    }\n\n    console.log('ðŸ“± Mobile auth initialization...');\n    setError(null);\n\n    const initPromise = new Promise<void>(async (resolve) => {\n      try {\n        // Mobile-friendly timeout (2 seconds)\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error('Mobile auth timeout')), 2000);\n        });\n\n        const sessionPromise = supabase.auth.getSession();\n        \n        const { data: { session } } = await Promise.race([sessionPromise, timeoutPromise]);\n        \n        setSession(session);\n        setUser(session?.user ?? null);\n        \n        if (session?.user) {\n          console.log('ðŸ“± Mobile user found, setting role...');\n          const cachedRole = getCachedRole(session.user.id);\n          if (cachedRole) {\n            setUserRole(cachedRole);\n          } else {\n            setUserRole('inspector');\n            // Background role fetch for mobile\n            fetchUserRole(session.user.id, false).then(role => {\n              setUserRole(role);\n            }).catch(() => {\n              console.warn('ðŸ“± Background mobile role fetch failed');\n            });\n          }\n        } else {\n          setUserRole(null);\n          console.log('ðŸ“± No mobile session found');\n        }\n        \n        setLoading(false);\n        setError(null);\n        console.log('ðŸ“± Mobile auth initialization complete');\n        resolve();\n        \n      } catch (error) {\n        console.error('ðŸ“± Mobile auth initialization error:', error);\n        setUser(null);\n        setSession(null);\n        setUserRole(null);\n        setError('Mobile authentication failed');\n        setLoading(false);\n        resolve();\n      }\n    });\n\n    initializationRef.current = initPromise;\n    return initPromise;\n  }, [fetchUserRole]);\n\n  const forceRefresh = useCallback(async () => {\n    console.log('ðŸ“± Mobile force refresh...');\n    setLoading(true);\n    setError(null);\n    initializationRef.current = null;\n    \n    try {\n      await initializeAuth();\n      toast({\n        title: \"Mobile Session Refreshed\",\n        description: \"Your mobile session has been refreshed.\",\n      });\n    } catch (error) {\n      console.error('ðŸ“± Mobile refresh failed:', error);\n      toast({\n        title: \"Mobile Refresh Failed\",\n        description: \"Please try signing in again.\",\n        variant: \"destructive\",\n      });\n    }\n  }, [initializeAuth, toast]);\n\n  const handleSignIn = useCallback(async (email: string, password: string) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await signIn(email, password);\n      return result;\n    } finally {\n      setLoading(false);\n    }\n  }, [signIn]);\n\n  const handleSignUp = useCallback(async (email: string, password: string) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await signUp(email, password);\n      return result;\n    } finally {\n      setLoading(false);\n    }\n  }, [signUp]);\n\n  const handleSignOut = useCallback(async () => {\n    setLoading(true);\n    setUserRole(null);\n    setSession(null);\n    setUser(null);\n    setError(null);\n    \n    try {\n      await signOut(user?.id);\n    } finally {\n      setLoading(false);\n    }\n  }, [signOut, user?.id]);\n\n  // Mobile-optimized auth state listener\n  useEffect(() => {\n    let isMounted = true;\n    \n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (!isMounted) return;\n        \n        console.log('ðŸ“± Mobile auth state changed:', event, session?.user?.email);\n        \n        setSession(session);\n        setUser(session?.user ?? null);\n        \n        if (session?.user) {\n          const cachedRole = getCachedRole(session.user.id);\n          if (cachedRole) {\n            setUserRole(cachedRole);\n          } else {\n            setUserRole('inspector');\n            \n            // Background mobile role fetch\n            fetchUserRole(session.user.id, false).then(role => {\n              if (isMounted) {\n                setUserRole(role);\n              }\n            }).catch(error => {\n              console.error('ðŸ“± Background mobile role fetch failed:', error);\n            });\n          }\n        } else {\n          if (isMounted) {\n            setUserRole(null);\n          }\n        }\n        \n        if (isMounted) {\n          setLoading(false);\n          setError(null);\n        }\n      }\n    );\n\n    initializeAuth().catch((error) => {\n      if (isMounted) {\n        console.error('ðŸ“± Failed to initialize mobile auth:', error);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n      initializationRef.current = null;\n    };\n  }, [initializeAuth, fetchUserRole]);\n\n  const value: AuthContextType = {\n    user,\n    userRole,\n    loading,\n    error,\n    signIn: handleSignIn,\n    signUp: handleSignUp,\n    signOut: handleSignOut,\n    forceRefresh,\n    clearSession: handleClearSession,\n    loadUserRole,\n  };\n\n  // Mobile-optimized loading screen\n  if (loading) {\n    return <MobileAuthLoading onRefresh={() => {\n      handleClearSession();\n      forceRefresh();\n    }} />;\n  }\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileInspectionCard.tsx","messages":[{"ruleId":"no-extra-boolean-cast","severity":2,"message":"Redundant double negation.","line":125,"column":78,"nodeType":"UnaryExpression","messageId":"unexpectedNegation","endLine":125,"endColumn":86,"fix":{"range":[4032,4040],"text":"onEdit"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"\nimport React from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { MapPin, Clock, Users, CheckCircle2, Edit } from \"lucide-react\";\nimport { useFastAuth } from \"@/hooks/useFastAuth\";\n\ninterface PropertyStatus {\n  status: string;\n  color: string;\n  textLabel: string;\n  badgeColor: string;\n}\n\ninterface MobileInspectionCardProps {\n  property: {\n    property_id: string;\n    property_name: string;\n    property_address: string;\n    property_vrbo_url?: string | null;\n    property_airbnb_url?: string | null;\n    inspection_count?: number;\n    completed_inspection_count?: number;\n    active_inspection_count?: number;\n  };\n  propertyStatus: PropertyStatus;\n  isSelected: boolean;\n  onSelect: (propertyId: string) => void;\n  onStartInspection: (propertyId: string) => void;\n  onEdit?: (propertyId: string) => void;\n  isLoading?: boolean;\n}\n\nexport const MobileInspectionCard: React.FC<MobileInspectionCardProps> = ({\n  property,\n  propertyStatus,\n  isSelected,\n  onSelect,\n  onStartInspection,\n  onEdit,\n  isLoading = false\n}) => {\n  const { userRole, user } = useFastAuth();\n  \n  // Debug logging to help troubleshoot\n  console.log('ðŸ” MobileInspectionCard Debug:', {\n    userRole,\n    hasUser: !!user,\n    userEmail: user?.email,\n    hasOnEdit: !!onEdit,\n    isAdmin: userRole === 'admin'\n  });\n  \n  const isAdmin = userRole === 'admin';\n\n  const getButtonText = () => {\n    if (propertyStatus.status === 'in-progress') {\n      return 'Join Inspection';\n    }\n    return 'Start Inspection';\n  };\n\n  const handleCardTap = () => {\n    onSelect(property.property_id);\n  };\n\n  const handleInspectionStart = (e: React.MouseEvent) => {\n    e.stopPropagation(); // Prevent card selection when clicking button\n    onStartInspection(property.property_id);\n  };\n\n  const handleEdit = (e: React.MouseEvent) => {\n    e.stopPropagation(); // Prevent card selection when clicking edit\n    console.log('ðŸ”§ Edit button clicked for property:', property.property_id);\n    if (onEdit) {\n      onEdit(property.property_id);\n    }\n  };\n\n  return (\n    <Card \n      className={`mobile-optimized-card cursor-pointer transition-all duration-200 ${\n        isSelected \n          ? 'ring-2 ring-blue-500 bg-blue-50 border-blue-200' \n          : 'hover:shadow-md border-gray-200'\n      }`}\n      onClick={handleCardTap}\n    >\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-start justify-between\">\n          <div className=\"flex-1 min-w-0\">\n            <CardTitle className=\"text-lg font-semibold text-gray-900 truncate\">\n              {property.property_name}\n            </CardTitle>\n            <div className=\"flex items-center mt-1 text-gray-600\">\n              <MapPin className=\"w-4 h-4 mr-1 flex-shrink-0\" />\n              <span className=\"text-sm truncate\">{property.property_address}</span>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2 ml-2 flex-shrink-0\">\n            <Badge className={`${propertyStatus.badgeColor}`}>\n              {propertyStatus.textLabel}\n            </Badge>\n            {/* Force show edit button for debugging - remove this condition check temporarily */}\n            {onEdit && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleEdit}\n                className=\"h-8 w-8 p-0 bg-blue-50 hover:bg-blue-100\"\n                title={`Edit ${property.property_name} (Admin: ${isAdmin})`}\n              >\n                <Edit className=\"h-4 w-4 text-blue-600\" />\n              </Button>\n            )}\n          </div>\n        </div>\n      </CardHeader>\n\n      <CardContent className=\"pt-0 space-y-3\">\n        {/* Debug info for troubleshooting */}\n        {user?.email?.includes('@rentresponsibly.org') && (\n          <div className=\"text-xs text-gray-500 bg-gray-50 p-2 rounded\">\n            Debug: Role={userRole}, Admin={isAdmin ? 'Yes' : 'No'}, HasEdit={!!onEdit ? 'Yes' : 'No'}\n          </div>\n        )}\n        \n        {/* Inspection Stats */}\n        <div className=\"flex items-center justify-between text-sm text-gray-600\">\n          <div className=\"flex items-center\">\n            <Clock className=\"w-4 h-4 mr-1\" />\n            <span>\n              {property.inspection_count || 0} total inspections\n            </span>\n          </div>\n          {(property.completed_inspection_count || 0) > 0 && (\n            <div className=\"flex items-center\">\n              <CheckCircle2 className=\"w-4 h-4 mr-1 text-green-600\" />\n              <span className=\"text-green-600\">\n                {property.completed_inspection_count} completed\n              </span>\n            </div>\n          )}\n        </div>\n\n        {/* Action Button */}\n        <Button\n          onClick={handleInspectionStart}\n          disabled={isLoading}\n          className={`w-full mobile-touch-target ${\n            propertyStatus.status === 'in-progress'\n              ? 'bg-yellow-600 hover:bg-yellow-700'\n              : 'bg-blue-600 hover:bg-blue-700'\n          }`}\n          size=\"lg\"\n        >\n          {isLoading ? (\n            <div className=\"flex items-center\">\n              <div className=\"w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin mr-2\" />\n              Processing...\n            </div>\n          ) : (\n            <>\n              <Users className=\"w-4 h-4 mr-2\" />\n              {getButtonText()}\n            </>\n          )}\n        </Button>\n\n        {/* Quick Links */}\n        {(property.property_vrbo_url || property.property_airbnb_url) && (\n          <div className=\"flex gap-2 pt-2 border-t border-gray-100\">\n            {property.property_vrbo_url && (\n              <a\n                href={property.property_vrbo_url}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"text-xs text-blue-600 hover:text-blue-800 underline\"\n                onClick={(e) => e.stopPropagation()}\n              >\n                View on Vrbo\n              </a>\n            )}\n            {property.property_airbnb_url && (\n              <a\n                href={property.property_airbnb_url}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"text-xs text-blue-600 hover:text-blue-800 underline\"\n                onClick={(e) => e.stopPropagation()}\n              >\n                View on Airbnb\n              </a>\n            )}\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileNavigationOptimizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileOptimizedLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileOptimizedPropertyList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobilePropertyList.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[932,935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[932,935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { memo } from \"react\";\nimport { OptimizedPropertyCard } from \"@/components/OptimizedPropertyCard\";\nimport { EmptyPropertiesState } from \"@/components/EmptyPropertiesState\";\nimport { LoadingSpinner } from \"@/components/LoadingSpinner\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Button } from \"@/components/ui/button\";\nimport { RefreshCw } from \"lucide-react\";\n\ninterface MobilePropertyData {\n  property_id: string;\n  property_name: string;\n  property_address: string;\n  property_vrbo_url: string | null;\n  property_airbnb_url: string | null;\n  property_status: string;\n  property_created_at: string;\n  inspection_count: number;\n  completed_inspection_count: number;\n  active_inspection_count: number;\n  latest_inspection_id: string | null;\n  latest_inspection_completed: boolean | null;\n}\n\ninterface MobilePropertyListProps {\n  properties: MobilePropertyData[];\n  isLoading: boolean;\n  error: any;\n  onRefresh: () => void;\n  isFetching: boolean;\n  onEdit: (propertyId: string) => void;\n  onDelete: (propertyId: string, propertyName: string) => void;\n  onStartInspection: (propertyId: string) => void;\n  selectedProperty?: string | null;\n  onPropertySelect?: (propertyId: string) => void;\n  getPropertyStatus?: (propertyId: string) => {\n    status: string;\n    color: string;\n    text: string;\n    activeInspectionId?: string | null;\n  };\n}\n\nexport const MobilePropertyList = memo(({\n  properties,\n  isLoading,\n  error,\n  onRefresh,\n  isFetching,\n  onEdit,\n  onDelete,\n  onStartInspection,\n  selectedProperty,\n  onPropertySelect,\n  getPropertyStatus\n}: MobilePropertyListProps) => {\n  console.log('ðŸ“± Mobile Property List rendering:', {\n    propertiesCount: properties?.length || 0,\n    isLoading,\n    error: !!error,\n    isFetching,\n    selectedProperty,\n    hasSelection: !!onPropertySelect\n  });\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center py-12\">\n        <LoadingSpinner message=\"Loading mobile properties...\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert className=\"mx-4 my-4 border-red-200 bg-red-50\">\n        <AlertDescription className=\"text-red-800\">\n          Failed to load properties on mobile. Please try again.\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            onClick={onRefresh}\n            className=\"ml-2\"\n          >\n            <RefreshCw className=\"w-4 h-4 mr-1\" />\n            Retry\n          </Button>\n        </AlertDescription>\n      </Alert>\n    );\n  }\n\n  if (!properties || properties.length === 0) {\n    return <EmptyPropertiesState />;\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Property Grid */}\n      <div className=\"grid gap-4 px-4\">\n        {properties.map((property) => {\n          const isSelected = selectedProperty === property.property_id;\n          const status = getPropertyStatus ? getPropertyStatus(property.property_id) : undefined;\n\n          return (\n            <OptimizedPropertyCard\n              key={property.property_id}\n              property={property}\n              isSelected={isSelected}\n              onSelect={onPropertySelect ? () => onPropertySelect(property.property_id) : undefined}\n              status={status}\n              onEdit={onEdit}\n              onDelete={(id: string) => onDelete(id, property.property_name)}\n              onStartInspection={onStartInspection}\n            />\n          );\n        })}\n      </div>\n\n      {/* Mobile Refresh */}\n      <div className=\"px-4 pb-4\">\n        <Button\n          variant=\"outline\"\n          onClick={onRefresh}\n          disabled={isFetching}\n          className=\"w-full\"\n        >\n          <RefreshCw className={`w-4 h-4 mr-2 ${isFetching ? 'animate-spin' : ''}`} />\n          {isFetching ? 'Refreshing mobile data...' : 'Refresh Properties'}\n        </Button>\n      </div>\n    </div>\n  );\n});\n\nMobilePropertyList.displayName = 'MobilePropertyList';\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/MobileStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NavigationErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NetworkStatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NetworkStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NotesHistoryList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NotesInputForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/NotesPromptDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OfflineIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OptimizedChecklistItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OptimizedChecklistItemCore.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OptimizedPropertyCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OptimizedPropertyList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/OptimizedPropertyListWithCache.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PhotoCaptureGuide.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":70,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":70,"endColumn":81,"suggestions":[{"messageId":"addBrackets","fix":{"range":[2761,3573],"text":"{ const IconComponent = categoryObj ? getCategoryIcon(categoryObj) : Info;\n        return {\n          tips: [\n            \"Document the current condition clearly\",\n            \"Show any wear, damage, or maintenance needs\",\n            \"Include before/after if repairs are made\",\n            \"Capture serial numbers or model information if relevant\"\n          ],\n          examples: [\n            \"Clear, well-lit photos showing the item in context\",\n            \"Multiple angles if the item is complex\",\n            \"Close-ups of important details or features\"\n          ],\n          icon: <IconComponent className=\"w-5 h-5 text-gray-500\" />,\n          color: categoryObj ? getCategoryColor(categoryObj).replace('text-', 'border-').replace('bg-', 'bg-') + \" bg-opacity-50\" : \"border-gray-200 bg-gray-50\"\n        }; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Camera, CheckCircle, AlertTriangle, Info } from \"lucide-react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { useCategories } from \"@/hooks/useCategories\";\nimport { getCategoryColor, getCategoryIcon } from \"@/utils/categoryUtils\";\n\ninterface PhotoCaptureGuideProps {\n  category: string; // Changed from hardcoded union to string\n  label: string;\n}\n\nexport const PhotoCaptureGuide = ({ category, label }: PhotoCaptureGuideProps) => {\n  const { data: categories = [] } = useCategories();\n  \n  // Find the category object for this item\n  const categoryObj = categories.find(cat => cat.name === category);\n  \n  const getGuidelines = () => {\n    switch (category) {\n      case 'safety':\n        return {\n          tips: [\n            \"Ensure the safety feature is clearly visible and unobstructed\",\n            \"Capture the entire device/feature in the frame\",\n            \"Check that expiration dates are readable if applicable\",\n            \"Include surrounding context to show proper placement\"\n          ],\n          examples: [\n            \"Fire extinguisher with gauge and inspection tag visible\",\n            \"Smoke detector showing green light/status\",\n            \"Exit signs that are illuminated and unblocked\"\n          ],\n          icon: <AlertTriangle className=\"w-5 h-5 text-red-500\" />,\n          color: \"border-red-200 bg-red-50\"\n        };\n      case 'amenity':\n        return {\n          tips: [\n            \"Show the amenity in its intended use state\",\n            \"Capture multiple angles if the amenity is large\",\n            \"Include any control panels or interfaces\",\n            \"Verify cleanliness and working condition\"\n          ],\n          examples: [\n            \"Hot tub with clear water and functioning jets\",\n            \"Game room showing all equipment and space\",\n            \"Kitchen appliances that appear clean and operational\"\n          ],\n          icon: <Camera className=\"w-5 h-5 text-blue-500\" />,\n          color: \"border-blue-200 bg-blue-50\"\n        };\n      case 'cleanliness':\n        return {\n          tips: [\n            \"Focus on areas that guests will notice first\",\n            \"Capture overall room condition, not just details\",\n            \"Include corners, surfaces, and high-touch areas\",\n            \"Document any cleaning supplies or maintenance needs\"\n          ],\n          examples: [\n            \"Bathroom showing clean fixtures and surfaces\",\n            \"Kitchen with clean counters and appliances\",\n            \"Living areas with fresh linens and tidy appearance\"\n          ],\n          icon: <CheckCircle className=\"w-5 h-5 text-green-500\" />,\n          color: \"border-green-200 bg-green-50\"\n        };\n      default:\n        // Generic guidelines for any other category\n        const IconComponent = categoryObj ? getCategoryIcon(categoryObj) : Info;\n        return {\n          tips: [\n            \"Document the current condition clearly\",\n            \"Show any wear, damage, or maintenance needs\",\n            \"Include before/after if repairs are made\",\n            \"Capture serial numbers or model information if relevant\"\n          ],\n          examples: [\n            \"Clear, well-lit photos showing the item in context\",\n            \"Multiple angles if the item is complex\",\n            \"Close-ups of important details or features\"\n          ],\n          icon: <IconComponent className=\"w-5 h-5 text-gray-500\" />,\n          color: categoryObj ? getCategoryColor(categoryObj).replace('text-', 'border-').replace('bg-', 'bg-') + \" bg-opacity-50\" : \"border-gray-200 bg-gray-50\"\n        };\n    }\n  };\n\n  const guidelines = getGuidelines();\n\n  return (\n    <div className={`rounded-lg border-2 p-4 mb-4 ${guidelines.color}`}>\n      <div className=\"flex items-center gap-2 mb-3\">\n        {guidelines.icon}\n        <h4 className=\"font-semibold text-gray-900\">Photo Guidelines</h4>\n        <Badge variant=\"outline\" className=\"text-xs\">\n          {category.toUpperCase()}\n        </Badge>\n      </div>\n      \n      <div className=\"space-y-3\">\n        <div>\n          <p className=\"text-sm font-medium text-gray-700 mb-2\">ðŸ“‹ Best Practices:</p>\n          <ul className=\"text-sm text-gray-600 space-y-1\">\n            {guidelines.tips.map((tip, index) => (\n              <li key={index} className=\"flex items-start gap-2\">\n                <span className=\"text-blue-500 mt-1\">â€¢</span>\n                <span>{tip}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n        \n        <div>\n          <p className=\"text-sm font-medium text-gray-700 mb-2\">ðŸ’¡ Examples:</p>\n          <ul className=\"text-sm text-gray-600 space-y-1\">\n            {guidelines.examples.map((example, index) => (\n              <li key={index} className=\"flex items-start gap-2\">\n                <span className=\"text-green-500 mt-1\">âœ“</span>\n                <span>{example}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyActionsDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyDeleteDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyFormAlerts.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[185,188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[185,188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { WifiOff, AlertCircle } from \"lucide-react\";\n\ninterface PropertyFormAlertsProps {\n  isOnline: boolean;\n  user: any;\n}\n\nexport const PropertyFormAlerts = ({ isOnline, user }: PropertyFormAlertsProps) => {\n  return (\n    <>\n      {/* Network status alert */}\n      {!isOnline && (\n        <Alert className=\"mb-4 border-red-200 bg-red-50\">\n          <WifiOff className=\"h-4 w-4 text-red-600\" />\n          <AlertDescription className=\"text-red-800\">\n            You're currently offline. Please check your internet connection before submitting.\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Authentication status alert */}\n      {!user && (\n        <Alert className=\"mb-4 border-yellow-200 bg-yellow-50\">\n          <AlertCircle className=\"h-4 w-4 text-yellow-600\" />\n          <AlertDescription className=\"text-yellow-800\">\n            You need to be logged in to add or edit properties.\n          </AlertDescription>\n        </Alert>\n      )}\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyFormFields.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[750,753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[750,753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[880,883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[880,883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Loader2, ExternalLink, CheckCircle, AlertTriangle } from \"lucide-react\";\nimport { VRBOScraper } from \"@/lib/scrapers/vrbo-scraper\";\nimport { dynamicChecklistGenerator } from \"@/lib/ai/dynamic-checklist-generator\";\n\ninterface FormData {\n  name: string;\n  address: string;\n  vrbo_url: string;\n  airbnb_url: string;\n}\n\ninterface PropertyFormFieldsProps {\n  formData: FormData;\n  formErrors: Record<string, string>;\n  onInputChange: (field: string, value: string) => void;\n  onVRBODataScraped?: (data: any) => void;\n}\n\ninterface VRBOScrapingState {\n  isLoading: boolean;\n  isSuccess: boolean;\n  error: string | null;\n  scrapedData: any | null;\n}\n\nexport const PropertyFormFields = ({ formData, formErrors, onInputChange, onVRBODataScraped }: PropertyFormFieldsProps) => {\n  const [vrboState, setVRBOState] = useState<VRBOScrapingState>({\n    isLoading: false,\n    isSuccess: false,\n    error: null,\n    scrapedData: null\n  });\n  // Ensure formData has all required fields with defaults\n  const safeFormData = {\n    name: formData?.name || \"\",\n    address: formData?.address || \"\",\n    vrbo_url: formData?.vrbo_url || \"\",\n    airbnb_url: formData?.airbnb_url || \"\"\n  };\n\n  const safeFormErrors = formErrors || {};\n\n  // Check if at least one URL is provided\n  const hasVrbo = safeFormData.vrbo_url.trim();\n  const hasAirbnb = safeFormData.airbnb_url.trim();\n  const hasAtLeastOneUrl = hasVrbo || hasAirbnb;\n\n  // VRBO URL validation\n  const isValidVRBOUrl = (url: string): boolean => {\n    if (!url.trim()) return false;\n    const vrboPatterns = [\n      /^https?:\\/\\/(www\\.)?vrbo\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?homeaway\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?vacationrentals\\.com\\/\\d+/\n    ];\n    return vrboPatterns.some(pattern => pattern.test(url));\n  };\n\n  // Handle VRBO data scraping\n  const handleScrapeVRBO = async () => {\n    if (!safeFormData.vrbo_url || !isValidVRBOUrl(safeFormData.vrbo_url)) {\n      setVRBOState(prev => ({ ...prev, error: \"Please enter a valid VRBO URL\" }));\n      return;\n    }\n\n    setVRBOState({\n      isLoading: true,\n      isSuccess: false,\n      error: null,\n      scrapedData: null\n    });\n\n    try {\n      const scraper = new VRBOScraper();\n      const result = await scraper.scrapePropertyDetails(safeFormData.vrbo_url);\n\n      if (result.success && result.data) {\n        // Auto-fill form fields from scraped data\n        const scrapedData = result.data;\n        \n        // Only update empty fields to avoid overwriting user input\n        if (!safeFormData.name && scrapedData.title) {\n          onInputChange('name', scrapedData.title);\n        }\n        \n        if (!safeFormData.address && scrapedData.location) {\n          const address = `${scrapedData.location.city}, ${scrapedData.location.state}`;\n          onInputChange('address', address);\n        }\n\n        setVRBOState({\n          isLoading: false,\n          isSuccess: true,\n          error: null,\n          scrapedData: scrapedData\n        });\n\n        // Notify parent component\n        if (onVRBODataScraped) {\n          onVRBODataScraped(scrapedData);\n        }\n\n      } else {\n        const errorMessage = result.errors?.[0]?.message || \"Failed to scrape VRBO data\";\n        setVRBOState({\n          isLoading: false,\n          isSuccess: false,\n          error: errorMessage,\n          scrapedData: null\n        });\n      }\n    } catch (error) {\n      console.error('VRBO scraping error:', error);\n      setVRBOState({\n        isLoading: false,\n        isSuccess: false,\n        error: \"Unable to connect to VRBO. Please try again later.\",\n        scrapedData: null\n      });\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"name\">Property Name *</Label>\n        <Input\n          id=\"name\"\n          value={safeFormData.name}\n          onChange={(e) => onInputChange('name', e.target.value)}\n          placeholder=\"e.g., Cozy Mountain Cabin\"\n          required\n          className={safeFormErrors.name ? \"border-red-500\" : \"\"}\n        />\n        {safeFormErrors.name && (\n          <p className=\"text-sm text-red-600\">{safeFormErrors.name}</p>\n        )}\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"address\">Address *</Label>\n        <Input\n          id=\"address\"\n          value={safeFormData.address}\n          onChange={(e) => onInputChange('address', e.target.value)}\n          placeholder=\"e.g., 123 Main St, Mountain View, CA 94041\"\n          required\n          className={safeFormErrors.address ? \"border-red-500\" : \"\"}\n        />\n        {safeFormErrors.address && (\n          <p className=\"text-sm text-red-600\">{safeFormErrors.address}</p>\n        )}\n      </div>\n\n      {/* URL Section with Helper Text */}\n      <div className=\"space-y-4\">\n        <div className=\"space-y-1\">\n          <h3 className=\"text-sm font-medium text-gray-900\">\n            Listing URLs * \n            <span className=\"text-xs font-normal text-gray-500 ml-1\">\n              (at least one required)\n            </span>\n          </h3>\n          <p className=\"text-xs text-gray-600\">\n            Provide at least one listing URL from Vrbo or Airbnb\n          </p>\n        </div>\n\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"vrbo_url\">Vrbo Listing URL</Label>\n          <div className=\"flex gap-2\">\n            <Input\n              id=\"vrbo_url\"\n              type=\"url\"\n              value={safeFormData.vrbo_url}\n              onChange={(e) => {\n                onInputChange('vrbo_url', e.target.value);\n                // Clear VRBO state when URL changes\n                if (vrboState.isSuccess || vrboState.error) {\n                  setVRBOState(prev => ({ ...prev, isSuccess: false, error: null }));\n                }\n              }}\n              placeholder=\"https://www.vrbo.com/...\"\n              className={safeFormErrors.vrbo_url ? \"border-red-500\" : \"\"}\n            />\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={handleScrapeVRBO}\n              disabled={vrboState.isLoading || !safeFormData.vrbo_url || !isValidVRBOUrl(safeFormData.vrbo_url)}\n              className=\"shrink-0\"\n            >\n              {vrboState.isLoading ? (\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n              ) : (\n                <ExternalLink className=\"h-4 w-4\" />\n              )}\n              {vrboState.isLoading ? \"Importing...\" : \"Import\"}\n            </Button>\n          </div>\n          \n          {/* VRBO Scraping Status */}\n          {vrboState.isSuccess && (\n            <Alert className=\"bg-green-50 border-green-200\">\n              <CheckCircle className=\"h-4 w-4 text-green-600\" />\n              <AlertDescription className=\"text-green-800\">\n                Successfully imported property data from VRBO! \n                {vrboState.scrapedData && (\n                  <span className=\"block text-sm mt-1\">\n                    Found {vrboState.scrapedData.specifications?.bedrooms || 0} bedrooms, \n                    {vrboState.scrapedData.specifications?.bathrooms || 0} bathrooms, \n                    and {vrboState.scrapedData.amenities?.length || 0} amenities.\n                  </span>\n                )}\n              </AlertDescription>\n            </Alert>\n          )}\n          \n          {vrboState.error && (\n            <Alert className=\"bg-red-50 border-red-200\">\n              <AlertTriangle className=\"h-4 w-4 text-red-600\" />\n              <AlertDescription className=\"text-red-800\">\n                {vrboState.error}\n              </AlertDescription>\n            </Alert>\n          )}\n          \n          {safeFormErrors.vrbo_url && (\n            <p className=\"text-sm text-red-600\">{safeFormErrors.vrbo_url}</p>\n          )}\n        </div>\n\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"airbnb_url\">Airbnb Listing URL</Label>\n          <Input\n            id=\"airbnb_url\"\n            type=\"url\"\n            value={safeFormData.airbnb_url}\n            onChange={(e) => onInputChange('airbnb_url', e.target.value)}\n            placeholder=\"https://www.airbnb.com/...\"\n            className={safeFormErrors.airbnb_url ? \"border-red-500\" : \"\"}\n          />\n          {safeFormErrors.airbnb_url && (\n            <p className=\"text-sm text-red-600\">{safeFormErrors.airbnb_url}</p>\n          )}\n        </div>\n\n        {/* Show general URL requirement error */}\n        {safeFormErrors.listing_urls && (\n          <p className=\"text-sm text-red-600\">{safeFormErrors.listing_urls}</p>\n        )}\n\n        {/* Status indicator */}\n        {!hasAtLeastOneUrl && (safeFormData.vrbo_url || safeFormData.airbnb_url) && (\n          <p className=\"text-xs text-orange-600\">\n            âš ï¸ At least one valid listing URL is required\n          </p>\n        )}\n        {hasAtLeastOneUrl && (\n          <p className=\"text-xs text-green-600\">\n            âœ“ Listing URL requirement satisfied\n          </p>\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertyList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertySelectionContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertySelectionError.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[146,149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[146,149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { AlertTriangle } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface PropertySelectionErrorProps {\n  error: any;\n  onRetry: () => void;\n}\n\nexport const PropertySelectionError = ({ error, onRetry }: PropertySelectionErrorProps) => {\n  console.error('ðŸ’¥ PropertySelection error:', error);\n  \n  return (\n    <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n      <div className=\"text-center bg-white p-8 rounded-lg shadow-md max-w-md\">\n        <AlertTriangle className=\"w-12 h-12 text-red-500 mx-auto mb-4\" />\n        <h2 className=\"text-xl font-semibold text-gray-900 mb-2\">\n          Error Loading Data\n        </h2>\n        <p className=\"text-gray-600 mb-4\">\n          {error?.message || 'Failed to load properties and inspections.'}\n        </p>\n        <Button onClick={onRetry} className=\"w-full\">\n          Try Again\n        </Button>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/PropertySelectionLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/QuickActions.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[385,388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[385,388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Plus, Search, RefreshCw, Settings, Zap } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\n\ninterface QuickAction {\n  id: string;\n  label: string;\n  icon: React.ComponentType<any>;\n  action: () => void;\n  shortcut?: string;\n  variant?: 'default' | 'secondary' | 'outline';\n  badge?: string;\n}\n\ninterface QuickActionsProps {\n  context?: 'home' | 'properties' | 'inspection';\n  pendingInspections?: number;\n}\n\nexport const QuickActions = ({ \n  context = 'home', \n  pendingInspections = 0 \n}: QuickActionsProps) => {\n  const navigate = useNavigate();\n\n  const getQuickActions = (): QuickAction[] => {\n    const baseActions: QuickAction[] = [\n      {\n        id: 'add-property',\n        label: 'Add Property',\n        icon: Plus,\n        action: () => navigate('/add-property'),\n        shortcut: 'Ctrl+N',\n        variant: 'default'\n      },\n      {\n        id: 'refresh',\n        label: 'Refresh',\n        icon: RefreshCw,\n        action: () => window.location.reload(),\n        shortcut: 'F5',\n        variant: 'outline'\n      }\n    ];\n\n    if (context === 'home' || context === 'properties') {\n      baseActions.unshift({\n        id: 'view-properties',\n        label: 'Properties',\n        icon: Search,\n        action: () => navigate('/properties'),\n        variant: 'secondary',\n        badge: pendingInspections > 0 ? `${pendingInspections}` : undefined\n      });\n    }\n\n    return baseActions;\n  };\n\n  const actions = getQuickActions();\n\n  // Keyboard shortcuts\n  React.useEffect(() => {\n    const handleKeyboard = (e: KeyboardEvent) => {\n      if (e.ctrlKey && e.key === 'n') {\n        e.preventDefault();\n        navigate('/add-property');\n      }\n      if (e.key === 'F5') {\n        e.preventDefault();\n        window.location.reload();\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyboard);\n    return () => window.removeEventListener('keydown', handleKeyboard);\n  }, [navigate]);\n\n  return (\n    <Card className=\"shadow-sm\">\n      <CardContent className=\"p-4\">\n        <div className=\"flex items-center gap-2 mb-3\">\n          <Zap className=\"w-4 h-4 text-blue-600\" />\n          <h3 className=\"font-medium text-gray-900\">Quick Actions</h3>\n        </div>\n        \n        <div className=\"grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2\">\n          {actions.map((action) => {\n            const Icon = action.icon;\n            return (\n              <Button\n                key={action.id}\n                variant={action.variant || 'outline'}\n                size=\"sm\"\n                onClick={action.action}\n                className=\"flex flex-col items-center gap-1 h-auto py-3 relative\"\n              >\n                <Icon className=\"w-4 h-4\" />\n                <span className=\"text-xs\">{action.label}</span>\n                {action.badge && (\n                  <Badge \n                    variant=\"destructive\" \n                    className=\"absolute -top-1 -right-1 text-xs min-w-[1.25rem] h-5 flex items-center justify-center\"\n                  >\n                    {action.badge}\n                  </Badge>\n                )}\n                {action.shortcut && (\n                  <span className=\"text-xs text-gray-500 mt-1\">\n                    {action.shortcut}\n                  </span>\n                )}\n              </Button>\n            );\n          })}\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/SearchAndFilter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/SimplePropertyActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/SimplePropertyForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1273,1276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1273,1276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2753,2756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2753,2756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport React, { useState, useEffect } from \"react\";\nimport { PropertyFormFields } from \"@/components/PropertyFormFields\";\nimport { PropertyFormAlerts } from \"@/components/PropertyFormAlerts\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { useSimplePropertySubmission } from \"@/hooks/useSimplePropertySubmission\";\nimport { useMobileAuth } from \"@/hooks/useMobileAuth\";\nimport { useNetworkStatus } from \"@/hooks/useNetworkStatus\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { Loader2 } from \"lucide-react\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const SimplePropertyForm = () => {\n  const { user, isAuthenticated, loading: authLoading } = useMobileAuth();\n  const isOnline = useNetworkStatus();\n  const { isLoading, submitProperty, isEditing } = useSimplePropertySubmission();\n  \n  const [formData, setFormData] = useState<PropertyFormData>({\n    name: '',\n    address: '',\n    vrbo_url: '',\n    airbnb_url: ''\n  });\n  \n  const [formErrors, setFormErrors] = useState<Record<string, string>>({});\n  const [isLoadingProperty, setIsLoadingProperty] = useState(false);\n  const [scrapedVRBOData, setScrapedVRBOData] = useState<any>(null);\n\n  // Load property data for editing\n  useEffect(() => {\n    const loadPropertyForEdit = async () => {\n      if (!isEditing) return;\n      \n      const urlParams = new URLSearchParams(window.location.search);\n      const editId = urlParams.get('edit');\n      \n      if (!editId) return;\n\n      console.log('ðŸ“ Loading property for edit:', editId);\n      setIsLoadingProperty(true);\n\n      try {\n        const { data, error } = await supabase\n          .from('properties')\n          .select('*')\n          .eq('id', editId)\n          .single();\n\n        if (error) {\n          console.error('âŒ Error loading property:', error);\n          return;\n        }\n\n        if (data) {\n          console.log('âœ… Property loaded for edit:', data);\n          setFormData({\n            name: data.name || '',\n            address: data.address || '',\n            vrbo_url: data.vrbo_url || '',\n            airbnb_url: data.airbnb_url || ''\n          });\n        }\n      } catch (error) {\n        console.error('ðŸ’¥ Unexpected error loading property:', error);\n      } finally {\n        setIsLoadingProperty(false);\n      }\n    };\n\n    loadPropertyForEdit();\n  }, [isEditing]);\n\n  const handleInputChange = (field: string, value: string) => {\n    setFormData(prev => ({ ...prev, [field]: value }));\n    // Clear field error when user starts typing\n    if (formErrors[field]) {\n      setFormErrors(prev => ({ ...prev, [field]: '' }));\n    }\n  };\n\n  const handleVRBODataScraped = (data: any) => {\n    console.log('ðŸ“Š VRBO data scraped:', data);\n    setScrapedVRBOData(data);\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    console.log('ðŸ“ Form submitted with data:', formData);\n    console.log('ðŸ“Š Scraped VRBO data:', scrapedVRBOData);\n    \n    // Clear previous errors\n    setFormErrors({});\n    \n    // Include scraped VRBO data in submission\n    const submissionData = {\n      ...formData,\n      scraped_vrbo_data: scrapedVRBOData\n    };\n    \n    const success = await submitProperty(submissionData);\n    if (!success) {\n      console.log('âŒ Submission failed');\n    }\n  };\n\n  if (authLoading || isLoadingProperty) {\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <Loader2 className=\"h-8 w-8 animate-spin mx-auto mb-4 text-blue-600\" />\n          <p className=\"text-gray-600\">\n            {authLoading ? \"Loading...\" : \"Loading property...\"}\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  const submitButtonText = isLoading \n    ? (isEditing ? \"Updating...\" : \"Adding...\")\n    : (isEditing ? \"Update Property\" : \"Add Property\");\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 p-4\">\n      <div className=\"max-w-2xl mx-auto\">\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"text-xl font-semibold text-gray-900\">\n              {isEditing ? \"Edit Property\" : \"Add New Property\"}\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <PropertyFormAlerts isOnline={isOnline} user={user} />\n            \n            <form onSubmit={handleSubmit} className=\"space-y-6\">\n              <PropertyFormFields\n                formData={formData}\n                formErrors={formErrors}\n                onInputChange={handleInputChange}\n                onVRBODataScraped={handleVRBODataScraped}\n              />\n              \n              {/* Show scraped data preview */}\n              {scrapedVRBOData && (\n                <div className=\"mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg\">\n                  <h3 className=\"text-sm font-medium text-blue-900 mb-2\">\n                    ðŸ“Š Imported Property Details\n                  </h3>\n                  <div className=\"text-xs text-blue-800 space-y-1\">\n                    <div>â€¢ {scrapedVRBOData.specifications?.bedrooms || 0} bedrooms, {scrapedVRBOData.specifications?.bathrooms || 0} bathrooms</div>\n                    <div>â€¢ Max guests: {scrapedVRBOData.specifications?.maxGuests || 'N/A'}</div>\n                    <div>â€¢ {scrapedVRBOData.amenities?.length || 0} amenities detected</div>\n                    <div>â€¢ Ready for AI checklist generation</div>\n                  </div>\n                </div>\n              )}\n              \n              <div className=\"flex gap-3 pt-4\">\n                <Button\n                  type=\"submit\"\n                  disabled={isLoading || !isAuthenticated || !isOnline}\n                  className=\"flex-1 bg-blue-600 hover:bg-blue-700\"\n                >\n                  {isLoading && <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />}\n                  {submitButtonText}\n                </Button>\n              </div>\n            </form>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/SimplifiedInspectionPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/StartInspectionButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/UploadInterface.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/UploadSuccessState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/UploadedEvidence.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2975,2978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2975,2978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useRef } from \"react\";\nimport { Image as ImageIcon } from \"lucide-react\";\nimport { MediaUpload } from \"@/types/inspection\";\nimport { MediaLightbox } from \"@/components/MediaLightbox\";\nimport { MediaItem } from \"@/components/MediaItem\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useChannelManager } from \"@/hooks/useChannelManager\";\n\ninterface MediaUploadWithAttribution extends MediaUpload {\n  user_id?: string;\n  uploaded_by_name?: string;\n}\n\ninterface UploadedEvidenceProps {\n  checklistItemId: string;\n}\n\nexport const UploadedEvidence = ({ checklistItemId }: UploadedEvidenceProps) => {\n  const [selectedMedia, setSelectedMedia] = useState<MediaUploadWithAttribution | null>(null);\n  const [mediaItems, setMediaItems] = useState<MediaUploadWithAttribution[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const { createChannel, subscribeChannel, cleanupChannel } = useChannelManager();\n  const isMountedRef = useRef(true);\n\n  // Load media items with user attribution\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    const loadMediaItems = async () => {\n      if (!isMountedRef.current) return;\n      \n      try {\n        const { data, error } = await supabase\n          .from('media')\n          .select('*')\n          .eq('checklist_item_id', checklistItemId)\n          .order('created_at', { ascending: false });\n\n        if (error) throw error;\n\n        // Transform and properly type the data\n        const transformedData: MediaUploadWithAttribution[] = (data || []).map(item => ({\n          id: item.id,\n          checklist_item_id: item.checklist_item_id,\n          type: (item.type === 'photo' || item.type === 'video') ? item.type : 'photo',\n          url: item.url || '',\n          user_id: item.user_id || undefined,\n          uploaded_by_name: item.uploaded_by_name || undefined,\n          created_at: item.created_at || new Date().toISOString()\n        }));\n\n        if (isMountedRef.current) {\n          setMediaItems(transformedData);\n          setIsLoading(false);\n        }\n      } catch (error) {\n        console.error('Failed to load media items:', error);\n        if (isMountedRef.current) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    loadMediaItems();\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, [checklistItemId]);\n\n  // Real-time subscription for media updates\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    const setupSubscription = async () => {\n      try {\n        // Create unique channel name\n        const channelName = `media-${checklistItemId}`;\n        console.log('Setting up media channel:', channelName);\n\n        const channel = createChannel(channelName, {\n          mediaChanges: {\n            filter: {\n              event: '*',\n              schema: 'public',\n              table: 'media',\n              filter: `checklist_item_id=eq.${checklistItemId}`\n            },\n            callback: (payload: any) => {\n              console.log('Media update received:', payload);\n              \n              if (!isMountedRef.current) return;\n              \n              if (payload.eventType === 'INSERT') {\n                const newItem: MediaUploadWithAttribution = {\n                  id: payload.new.id,\n                  checklist_item_id: payload.new.checklist_item_id,\n                  type: (payload.new.type === 'photo' || payload.new.type === 'video') ? payload.new.type : 'photo',\n                  url: payload.new.url || '',\n                  user_id: payload.new.user_id || undefined,\n                  uploaded_by_name: payload.new.uploaded_by_name || undefined,\n                  created_at: payload.new.created_at || new Date().toISOString()\n                };\n                setMediaItems(prev => [newItem, ...prev]);\n              } else if (payload.eventType === 'DELETE') {\n                setMediaItems(prev => prev.filter(item => item.id !== payload.old.id));\n              } else if (payload.eventType === 'UPDATE') {\n                const updatedItem: MediaUploadWithAttribution = {\n                  id: payload.new.id,\n                  checklist_item_id: payload.new.checklist_item_id,\n                  type: (payload.new.type === 'photo' || payload.new.type === 'video') ? payload.new.type : 'photo',\n                  url: payload.new.url || '',\n                  user_id: payload.new.user_id || undefined,\n                  uploaded_by_name: payload.new.uploaded_by_name || undefined,\n                  created_at: payload.new.created_at || new Date().toISOString()\n                };\n                setMediaItems(prev => prev.map(item => \n                  item.id === payload.new.id ? updatedItem : item\n                ));\n              }\n            }\n          }\n        });\n\n        // Subscribe to the channel with async handling\n        await subscribeChannel(channelName, (status: string) => {\n          console.log('Media subscription status:', status);\n          if (status === 'CHANNEL_ERROR') {\n            console.error('Media channel subscription error');\n          }\n        });\n\n      } catch (error) {\n        console.error('Error setting up media subscription:', error);\n      }\n    };\n\n    setupSubscription();\n\n    return () => {\n      isMountedRef.current = false;\n      \n      // Clean up channel\n      const channelName = `media-${checklistItemId}`;\n      cleanupChannel(channelName);\n    };\n  }, [checklistItemId, createChannel, subscribeChannel, cleanupChannel]);\n\n  const handleDownload = async (media: MediaUploadWithAttribution) => {\n    try {\n      const response = await fetch(media.url);\n      const blob = await response.blob();\n      const url = window.URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `evidence-${media.id}.${media.type === 'photo' ? 'jpg' : 'mp4'}`;\n      document.body.appendChild(a);\n      a.click();\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    } catch (error) {\n      console.error('Download failed:', error);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"bg-gray-50 rounded-lg p-4\">\n        <div className=\"animate-pulse\">\n          <div className=\"h-4 bg-gray-200 rounded mb-2 w-24\"></div>\n          <div className=\"h-20 bg-gray-200 rounded\"></div>\n        </div>\n      </div>\n    );\n  }\n\n  if (mediaItems.length === 0) {\n    return null;\n  }\n\n  return (\n    <>\n      <div className=\"space-y-3\">\n        <div className=\"flex items-center justify-between\">\n          <h4 className=\"text-sm font-medium text-gray-700 flex items-center gap-2\">\n            <ImageIcon className=\"w-4 h-4\" />\n            Uploaded Evidence ({mediaItems.length})\n          </h4>\n          {mediaItems.length > 0 && (\n            <div className=\"text-xs text-green-600 bg-green-50 px-2 py-1 rounded-full\">\n              âœ“ Complete\n            </div>\n          )}\n        </div>\n        \n        <div className=\"grid grid-cols-1 gap-3\">\n          {mediaItems.map((media) => (\n            <MediaItem\n              key={media.id}\n              media={media}\n              onMediaClick={setSelectedMedia}\n              onDownload={handleDownload}\n            />\n          ))}\n        </div>\n      </div>\n\n      {selectedMedia && (\n        <MediaLightbox\n          media={selectedMedia}\n          isOpen={!!selectedMedia}\n          onClose={() => setSelectedMedia(null)}\n        />\n      )}\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/admin/AIPerformanceDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6165,6168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6165,6168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Performance Dashboard Component for STR Certified\n// Real-time monitoring of AI metrics, costs, and optimization suggestions\n\nimport React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Progress } from '@/components/ui/progress';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { DateRangePicker } from '@/components/ui/date-range-picker';\nimport {\n  AreaChart,\n  Area,\n  BarChart,\n  Bar,\n  LineChart,\n  Line,\n  PieChart,\n  Pie,\n  Cell,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ResponsiveContainer\n} from 'recharts';\nimport {\n  Activity,\n  AlertTriangle,\n  ArrowDown,\n  ArrowUp,\n  Brain,\n  CheckCircle,\n  Clock,\n  DollarSign,\n  Download,\n  RefreshCw,\n  TrendingDown,\n  TrendingUp,\n  Zap,\n  AlertCircle,\n  BarChart3,\n  Cpu,\n  Database,\n  Gauge,\n  Info,\n  Target,\n  Timer,\n  Wallet\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { createAIMetricsCollector } from '@/lib/monitoring/ai-metrics';\nimport { useQuery } from '@tanstack/react-query';\n\ninterface AIPerformanceDashboardProps {\n  className?: string;\n}\n\nexport const AIPerformanceDashboard: React.FC<AIPerformanceDashboardProps> = ({\n  className\n}) => {\n  // State\n  const [timeRange, setTimeRange] = useState<'1h' | '24h' | '7d' | '30d'>('24h');\n  const [autoRefresh, setAutoRefresh] = useState(true);\n  const [selectedModel, setSelectedModel] = useState<'all' | string>('all');\n\n  // Initialize metrics collector\n  const metricsCollector = React.useMemo(() => createAIMetricsCollector(), []);\n\n  // Fetch real-time metrics\n  const { data: metrics, isLoading, refetch } = useQuery({\n    queryKey: ['ai-performance-metrics', timeRange],\n    queryFn: async () => {\n      return metricsCollector.getRealTimeMetrics();\n    },\n    refetchInterval: autoRefresh ? 30000 : false, // Refresh every 30 seconds\n    staleTime: 15000 // Consider stale after 15 seconds\n  });\n\n  // Fetch performance report\n  const { data: report } = useQuery({\n    queryKey: ['ai-performance-report', timeRange],\n    queryFn: async () => {\n      const end = new Date();\n      const start = new Date();\n      \n      switch (timeRange) {\n        case '1h':\n          start.setHours(start.getHours() - 1);\n          break;\n        case '24h':\n          start.setDate(start.getDate() - 1);\n          break;\n        case '7d':\n          start.setDate(start.getDate() - 7);\n          break;\n        case '30d':\n          start.setDate(start.getDate() - 30);\n          break;\n      }\n\n      return metricsCollector.generatePerformanceReport(start, end);\n    },\n    refetchInterval: autoRefresh ? 60000 : false // Refresh every minute\n  });\n\n  // Mock data for charts (in production, would come from metrics)\n  const accuracyTrendData = [\n    { time: '00:00', accuracy: 82 },\n    { time: '04:00', accuracy: 84 },\n    { time: '08:00', accuracy: 86 },\n    { time: '12:00', accuracy: 85 },\n    { time: '16:00', accuracy: 87 },\n    { time: '20:00', accuracy: 88 },\n    { time: 'Now', accuracy: 89 }\n  ];\n\n  const responseTimeData = [\n    { operation: 'Image Analysis', avg: 1250, p95: 2100, p99: 3500 },\n    { operation: 'Text Generation', avg: 800, p95: 1400, p99: 2200 },\n    { operation: 'Object Detection', avg: 1800, p95: 3200, p99: 4800 },\n    { operation: 'Classification', avg: 450, p95: 780, p99: 1200 }\n  ];\n\n  const costBreakdownData = [\n    { name: 'GPT-4 Vision', value: 45, cost: '$450' },\n    { name: 'GPT-3.5 Turbo', value: 25, cost: '$250' },\n    { name: 'Embeddings', value: 15, cost: '$150' },\n    { name: 'Other', value: 15, cost: '$150' }\n  ];\n\n  const COLORS = ['#8b5cf6', '#3b82f6', '#10b981', '#f59e0b'];\n\n  // Handle export\n  const handleExport = async () => {\n    if (!report) return;\n\n    const data = {\n      metrics,\n      report,\n      exported: new Date().toISOString()\n    };\n\n    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `ai-performance-${Date.now()}.json`;\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  // Calculate metrics change\n  const calculateChange = (current: number, previous: number): number => {\n    return ((current - previous) / previous) * 100;\n  };\n\n  // Get status color\n  const getStatusColor = (status: string): string => {\n    switch (status) {\n      case 'healthy':\n      case 'operational':\n        return 'text-green-600 bg-green-50';\n      case 'degraded':\n      case 'warning':\n        return 'text-yellow-600 bg-yellow-50';\n      case 'down':\n      case 'critical':\n        return 'text-red-600 bg-red-50';\n      default:\n        return 'text-gray-600 bg-gray-50';\n    }\n  };\n\n  // Get trend icon\n  const getTrendIcon = (trend: 'improving' | 'declining' | 'stable') => {\n    switch (trend) {\n      case 'improving':\n        return <TrendingUp className=\"h-4 w-4 text-green-600\" />;\n      case 'declining':\n        return <TrendingDown className=\"h-4 w-4 text-red-600\" />;\n      case 'stable':\n        return <Activity className=\"h-4 w-4 text-gray-600\" />;\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-96\">\n        <RefreshCw className=\"h-8 w-8 animate-spin text-primary\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn('space-y-6', className)}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h2 className=\"text-3xl font-bold tracking-tight\">AI Performance Dashboard</h2>\n          <p className=\"text-muted-foreground\">\n            Monitor AI system performance, accuracy, and costs in real-time\n          </p>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <Select value={timeRange} onValueChange={(value: any) => setTimeRange(value)}>\n            <SelectTrigger className=\"w-[120px]\">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"1h\">Last Hour</SelectItem>\n              <SelectItem value=\"24h\">Last 24 Hours</SelectItem>\n              <SelectItem value=\"7d\">Last 7 Days</SelectItem>\n              <SelectItem value=\"30d\">Last 30 Days</SelectItem>\n            </SelectContent>\n          </Select>\n          <Button\n            variant={autoRefresh ? 'default' : 'outline'}\n            size=\"sm\"\n            onClick={() => setAutoRefresh(!autoRefresh)}\n          >\n            <RefreshCw className={cn('h-4 w-4 mr-2', autoRefresh && 'animate-spin')} />\n            {autoRefresh ? 'Auto' : 'Manual'}\n          </Button>\n          <Button variant=\"outline\" size=\"sm\" onClick={() => refetch()}>\n            <RefreshCw className=\"h-4 w-4\" />\n          </Button>\n          <Button variant=\"outline\" size=\"sm\" onClick={handleExport}>\n            <Download className=\"h-4 w-4 mr-2\" />\n            Export\n          </Button>\n        </div>\n      </div>\n\n      {/* Key Metrics Overview */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4\">\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Overall Accuracy</CardTitle>\n            <Target className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              {metrics?.accuracy.current ? `${(metrics.accuracy.current * 100).toFixed(1)}%` : 'N/A'}\n            </div>\n            <div className=\"flex items-center text-xs text-muted-foreground\">\n              {metrics?.accuracy.trend && getTrendIcon(metrics.accuracy.trend)}\n              <span className=\"ml-1\">\n                {metrics?.accuracy.trend === 'improving' ? '+2.3%' : \n                 metrics?.accuracy.trend === 'declining' ? '-1.5%' : '0%'} from last period\n              </span>\n            </div>\n            <Progress value={metrics?.accuracy.current ? metrics.accuracy.current * 100 : 0} className=\"mt-2\" />\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Avg Response Time</CardTitle>\n            <Timer className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              {metrics?.performance.avgResponseTime ? `${metrics.performance.avgResponseTime.toFixed(0)}ms` : 'N/A'}\n            </div>\n            <div className=\"flex items-center text-xs text-muted-foreground\">\n              <span>P95: {metrics?.performance.p95ResponseTime?.toFixed(0) || 'N/A'}ms</span>\n            </div>\n            <Progress \n              value={metrics?.performance.avgResponseTime ? \n                Math.min(100, (metrics.performance.avgResponseTime / 3000) * 100) : 0\n              } \n              className=\"mt-2\" \n            />\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Current Cost Rate</CardTitle>\n            <DollarSign className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"text-2xl font-bold\">\n              ${metrics?.usage.costPerHour?.toFixed(2) || '0.00'}/hr\n            </div>\n            <div className=\"text-xs text-muted-foreground\">\n              Projected monthly: ${((metrics?.usage.costPerHour || 0) * 24 * 30).toFixed(0)}\n            </div>\n            <Progress \n              value={metrics?.usage.costPerHour ? \n                Math.min(100, (metrics.usage.costPerHour / 10) * 100) : 0\n              } \n              className=\"mt-2\" \n            />\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">System Health</CardTitle>\n            <Activity className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"flex items-center space-x-2\">\n              <Badge className={cn('text-xs', getStatusColor(metrics?.health.status || 'unknown'))}>\n                {metrics?.health.status || 'Unknown'}\n              </Badge>\n              <span className=\"text-2xl font-bold\">\n                {metrics?.performance.errorRate ? \n                  `${(100 - metrics.performance.errorRate * 100).toFixed(1)}%` : 'N/A'\n                }\n              </span>\n            </div>\n            <div className=\"text-xs text-muted-foreground mt-1\">\n              Uptime | {metrics?.alerts.length || 0} active alerts\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Alerts Section */}\n      {metrics?.alerts && metrics.alerts.length > 0 && (\n        <Alert variant=\"destructive\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertTitle>Active Alerts</AlertTitle>\n          <AlertDescription>\n            <div className=\"mt-2 space-y-1\">\n              {metrics.alerts.slice(0, 3).map((alert, index) => (\n                <div key={index} className=\"flex items-center justify-between\">\n                  <span className=\"text-sm\">{alert.type.replace(/_/g, ' ')}</span>\n                  <Badge variant=\"outline\" className=\"text-xs\">\n                    {alert.severity}\n                  </Badge>\n                </div>\n              ))}\n              {metrics.alerts.length > 3 && (\n                <p className=\"text-xs mt-1\">And {metrics.alerts.length - 3} more...</p>\n              )}\n            </div>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Main Content Tabs */}\n      <Tabs defaultValue=\"accuracy\" className=\"space-y-4\">\n        <TabsList className=\"grid w-full grid-cols-5\">\n          <TabsTrigger value=\"accuracy\">Accuracy</TabsTrigger>\n          <TabsTrigger value=\"performance\">Performance</TabsTrigger>\n          <TabsTrigger value=\"costs\">Costs</TabsTrigger>\n          <TabsTrigger value=\"optimization\">Optimization</TabsTrigger>\n          <TabsTrigger value=\"health\">System Health</TabsTrigger>\n        </TabsList>\n\n        {/* Accuracy Tab */}\n        <TabsContent value=\"accuracy\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Accuracy Trends</CardTitle>\n              <CardDescription>\n                AI prediction accuracy over time\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <ResponsiveContainer width=\"100%\" height={300}>\n                <LineChart data={accuracyTrendData}>\n                  <CartesianGrid strokeDasharray=\"3 3\" />\n                  <XAxis dataKey=\"time\" />\n                  <YAxis domain={[70, 100]} />\n                  <Tooltip />\n                  <Legend />\n                  <Line \n                    type=\"monotone\" \n                    dataKey=\"accuracy\" \n                    stroke=\"#8b5cf6\" \n                    strokeWidth={2}\n                    dot={{ fill: '#8b5cf6', strokeWidth: 2 }} \n                  />\n                </LineChart>\n              </ResponsiveContainer>\n            </CardContent>\n          </Card>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Accuracy by Category</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {Object.entries(metrics?.accuracy.byCategory || {}).map(([category, accuracy]) => (\n                    <div key={category} className=\"space-y-2\">\n                      <div className=\"flex items-center justify-between\">\n                        <span className=\"text-sm font-medium\">\n                          {category.replace(/_/g, ' ')}\n                        </span>\n                        <span className=\"text-sm text-muted-foreground\">\n                          {(accuracy * 100).toFixed(1)}%\n                        </span>\n                      </div>\n                      <Progress value={accuracy * 100} />\n                    </div>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Benchmarks</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {report?.benchmarks.map((benchmark) => (\n                    <div key={benchmark.name} className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center space-x-2\">\n                        <div className={cn(\n                          'h-2 w-2 rounded-full',\n                          benchmark.status === 'pass' ? 'bg-green-600' : 'bg-red-600'\n                        )} />\n                        <span className=\"text-sm font-medium\">{benchmark.name}</span>\n                      </div>\n                      <div className=\"text-right\">\n                        <p className=\"text-sm font-mono\">\n                          {benchmark.displayValue}{benchmark.unit}\n                        </p>\n                        <p className=\"text-xs text-muted-foreground\">\n                          Target: {benchmark.target}{benchmark.unit}\n                        </p>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n\n        {/* Performance Tab */}\n        <TabsContent value=\"performance\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Response Times by Operation</CardTitle>\n              <CardDescription>\n                Average, P95, and P99 response times\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <ResponsiveContainer width=\"100%\" height={300}>\n                <BarChart data={responseTimeData}>\n                  <CartesianGrid strokeDasharray=\"3 3\" />\n                  <XAxis dataKey=\"operation\" />\n                  <YAxis />\n                  <Tooltip />\n                  <Legend />\n                  <Bar dataKey=\"avg\" fill=\"#8b5cf6\" name=\"Average\" />\n                  <Bar dataKey=\"p95\" fill=\"#3b82f6\" name=\"P95\" />\n                  <Bar dataKey=\"p99\" fill=\"#ef4444\" name=\"P99\" />\n                </BarChart>\n              </ResponsiveContainer>\n            </CardContent>\n          </Card>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Request Rate</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-3xl font-bold\">\n                  {metrics?.usage.requestsPerMinute || 0}\n                </div>\n                <p className=\"text-xs text-muted-foreground\">requests/minute</p>\n                <div className=\"mt-4 space-y-2\">\n                  <div className=\"flex justify-between text-sm\">\n                    <span>Token Rate</span>\n                    <span className=\"font-mono\">{metrics?.usage.tokensPerMinute || 0}/min</span>\n                  </div>\n                  <div className=\"flex justify-between text-sm\">\n                    <span>Error Rate</span>\n                    <span className=\"font-mono\">\n                      {((metrics?.performance.errorRate || 0) * 100).toFixed(2)}%\n                    </span>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Slow Operations</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-2\">\n                  {metrics?.performance.slowOperations.slice(0, 5).map((op, index) => (\n                    <div key={index} className=\"flex items-center justify-between\">\n                      <span className=\"text-sm truncate\">{op}</span>\n                      <Badge variant=\"outline\" className=\"text-xs\">Slow</Badge>\n                    </div>\n                  )) || <p className=\"text-sm text-muted-foreground\">No slow operations</p>}\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Cache Performance</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  <div>\n                    <div className=\"flex justify-between text-sm\">\n                      <span>Hit Rate</span>\n                      <span className=\"font-mono\">78.5%</span>\n                    </div>\n                    <Progress value={78.5} className=\"mt-1\" />\n                  </div>\n                  <div>\n                    <div className=\"flex justify-between text-sm\">\n                      <span>Saved API Calls</span>\n                      <span className=\"font-mono\">1,234</span>\n                    </div>\n                    <p className=\"text-xs text-muted-foreground mt-1\">\n                      Estimated savings: $45.67\n                    </p>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n\n        {/* Costs Tab */}\n        <TabsContent value=\"costs\" className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Cost Breakdown by Model</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <ResponsiveContainer width=\"100%\" height={300}>\n                  <PieChart>\n                    <Pie\n                      data={costBreakdownData}\n                      cx=\"50%\"\n                      cy=\"50%\"\n                      labelLine={false}\n                      label={({ name, value, cost }) => `${name}: ${cost}`}\n                      outerRadius={80}\n                      fill=\"#8884d8\"\n                      dataKey=\"value\"\n                    >\n                      {costBreakdownData.map((entry, index) => (\n                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />\n                      ))}\n                    </Pie>\n                    <Tooltip />\n                  </PieChart>\n                </ResponsiveContainer>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>Cost Trends</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  <div className=\"grid grid-cols-2 gap-4\">\n                    <div>\n                      <p className=\"text-sm text-muted-foreground\">Today</p>\n                      <p className=\"text-2xl font-bold\">$127.45</p>\n                      <p className=\"text-xs text-green-600\">-12% from yesterday</p>\n                    </div>\n                    <div>\n                      <p className=\"text-sm text-muted-foreground\">This Month</p>\n                      <p className=\"text-2xl font-bold\">$2,845.67</p>\n                      <p className=\"text-xs text-red-600\">+8% from last month</p>\n                    </div>\n                  </div>\n                  <div className=\"pt-4 border-t\">\n                    <h4 className=\"text-sm font-medium mb-2\">Projected Costs</h4>\n                    <div className=\"space-y-2\">\n                      <div className=\"flex justify-between text-sm\">\n                        <span>End of Month</span>\n                        <span className=\"font-mono\">$3,127.89</span>\n                      </div>\n                      <div className=\"flex justify-between text-sm\">\n                        <span>Next Month (est.)</span>\n                        <span className=\"font-mono\">$3,456.78</span>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n\n          <Card>\n            <CardHeader>\n              <CardTitle>Cost Optimization Opportunities</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-4\">\n                <Alert>\n                  <Wallet className=\"h-4 w-4\" />\n                  <AlertTitle>Potential Savings: $456/month</AlertTitle>\n                  <AlertDescription>\n                    Based on current usage patterns and optimization opportunities\n                  </AlertDescription>\n                </Alert>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-start space-x-3\">\n                    <div className=\"h-8 w-8 rounded-full bg-primary/10 flex items-center justify-center flex-shrink-0\">\n                      <Database className=\"h-4 w-4 text-primary\" />\n                    </div>\n                    <div className=\"flex-1\">\n                      <h4 className=\"text-sm font-medium\">Enable Aggressive Caching</h4>\n                      <p className=\"text-xs text-muted-foreground\">\n                        Could save ~$234/month by caching repeated image analyses\n                      </p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <div className=\"h-8 w-8 rounded-full bg-primary/10 flex items-center justify-center flex-shrink-0\">\n                      <Zap className=\"h-4 w-4 text-primary\" />\n                    </div>\n                    <div className=\"flex-1\">\n                      <h4 className=\"text-sm font-medium\">Use GPT-3.5 for Simple Tasks</h4>\n                      <p className=\"text-xs text-muted-foreground\">\n                        Could save ~$156/month by routing simple classifications to cheaper models\n                      </p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <div className=\"h-8 w-8 rounded-full bg-primary/10 flex items-center justify-center flex-shrink-0\">\n                      <Cpu className=\"h-4 w-4 text-primary\" />\n                    </div>\n                    <div className=\"flex-1\">\n                      <h4 className=\"text-sm font-medium\">Batch Similar Requests</h4>\n                      <p className=\"text-xs text-muted-foreground\">\n                        Could save ~$66/month by batching similar analysis requests\n                      </p>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Optimization Tab */}\n        <TabsContent value=\"optimization\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Optimization Recommendations</CardTitle>\n              <CardDescription>\n                AI-powered suggestions to improve performance and reduce costs\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-4\">\n                {report?.recommendations.map((rec, index) => (\n                  <div key={index} className=\"border rounded-lg p-4\">\n                    <div className=\"flex items-start justify-between mb-2\">\n                      <h4 className=\"font-medium\">{rec.title}</h4>\n                      <Badge variant={\n                        rec.priority === 'high' ? 'destructive' :\n                        rec.priority === 'medium' ? 'default' : 'secondary'\n                      }>\n                        {rec.priority}\n                      </Badge>\n                    </div>\n                    <p className=\"text-sm text-muted-foreground mb-3\">\n                      {rec.description}\n                    </p>\n                    <div className=\"space-y-1\">\n                      {rec.actions.map((action, i) => (\n                        <div key={i} className=\"flex items-center text-sm\">\n                          <ChevronRight className=\"h-3 w-3 mr-1 text-muted-foreground\" />\n                          <span>{action}</span>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Mobile Performance</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Image Compression</span>\n                    <Badge variant=\"outline\">Enabled</Badge>\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Progressive Loading</span>\n                    <Badge variant=\"outline\">Enabled</Badge>\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Offline Mode</span>\n                    <Badge variant=\"outline\">Partial</Badge>\n                  </div>\n                  <div className=\"pt-4 border-t\">\n                    <p className=\"text-sm font-medium mb-2\">Mobile Metrics</p>\n                    <div className=\"space-y-2 text-sm text-muted-foreground\">\n                      <div className=\"flex justify-between\">\n                        <span>Avg Load Time</span>\n                        <span className=\"font-mono\">2.3s</span>\n                      </div>\n                      <div className=\"flex justify-between\">\n                        <span>Data Usage</span>\n                        <span className=\"font-mono\">1.2MB/session</span>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle>API Rate Limits</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {Object.entries(metrics?.health.endpoints || {}).map(([endpoint, status]) => (\n                    <div key={endpoint} className=\"space-y-2\">\n                      <div className=\"flex items-center justify-between\">\n                        <span className=\"text-sm font-medium capitalize\">{endpoint}</span>\n                        <Badge className={cn('text-xs', getStatusColor(status.status))}>\n                          {status.status}\n                        </Badge>\n                      </div>\n                      <Progress value={75} className=\"h-2\" />\n                      <p className=\"text-xs text-muted-foreground\">\n                        750/1000 requests remaining\n                      </p>\n                    </div>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n        </TabsContent>\n\n        {/* System Health Tab */}\n        <TabsContent value=\"health\" className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-4\">\n            {Object.entries(metrics?.health.endpoints || {}).map(([endpoint, status]) => (\n              <Card key={endpoint}>\n                <CardHeader>\n                  <CardTitle className=\"capitalize\">{endpoint} API</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"space-y-3\">\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-sm\">Status</span>\n                      <Badge className={cn('text-xs', getStatusColor(status.status))}>\n                        {status.status}\n                      </Badge>\n                    </div>\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-sm\">Latency</span>\n                      <span className=\"text-sm font-mono\">{status.latency.toFixed(0)}ms</span>\n                    </div>\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-sm\">Last Check</span>\n                      <span className=\"text-xs text-muted-foreground\">\n                        {new Date(status.lastChecked).toLocaleTimeString()}\n                      </span>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n            ))}\n          </div>\n\n          <Card>\n            <CardHeader>\n              <CardTitle>System Diagnostics</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4\">\n                <div className=\"space-y-1\">\n                  <p className=\"text-sm text-muted-foreground\">Queue Size</p>\n                  <p className=\"text-2xl font-bold\">23</p>\n                  <p className=\"text-xs text-green-600\">Normal</p>\n                </div>\n                <div className=\"space-y-1\">\n                  <p className=\"text-sm text-muted-foreground\">Cache Size</p>\n                  <p className=\"text-2xl font-bold\">1.2GB</p>\n                  <p className=\"text-xs text-yellow-600\">78% full</p>\n                </div>\n                <div className=\"space-y-1\">\n                  <p className=\"text-sm text-muted-foreground\">Memory Usage</p>\n                  <p className=\"text-2xl font-bold\">456MB</p>\n                  <p className=\"text-xs text-green-600\">Healthy</p>\n                </div>\n                <div className=\"space-y-1\">\n                  <p className=\"text-sm text-muted-foreground\">Active Workers</p>\n                  <p className=\"text-2xl font-bold\">8/10</p>\n                  <p className=\"text-xs text-green-600\">Available</p>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n};\n\n// ChevronRight icon component (since it wasn't imported)\nconst ChevronRight: React.FC<{ className?: string }> = ({ className }) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"24\"\n    height=\"24\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    stroke=\"currentColor\"\n    strokeWidth=\"2\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    className={className}\n  >\n    <polyline points=\"9 18 15 12 9 6\" />\n  </svg>\n);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/admin/AdminRoutes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ai/AIAnalysisDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ai/AIAnalysisPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ai/ChecklistGenerator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/FeedbackCollectionForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1743,1746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1743,1746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7295,7298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7295,7298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10363,10366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10363,10366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":491,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":491,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19236,19239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19236,19239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Feedback Collection Form Component for STR Certified\n// Allows auditors to provide feedback on AI predictions\n\nimport React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Label } from '@/components/ui/label';\nimport { Textarea } from '@/components/ui/textarea';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Slider } from '@/components/ui/slider';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Separator } from '@/components/ui/separator';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport {\n  MessageSquare,\n  AlertTriangle,\n  CheckCircle,\n  XCircle,\n  Info,\n  Brain,\n  Target,\n  TrendingUp,\n  Send,\n  Save,\n  Trash2,\n  Plus,\n  Edit3,\n  Image as ImageIcon,\n  Video,\n  FileText,\n  ChevronRight,\n  ChevronDown,\n  HelpCircle,\n  Sparkles,\n  ThumbsUp,\n  ThumbsDown\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport type {\n  FeedbackFormData,\n  FeedbackItem,\n  FeedbackCategory,\n  AuditorFeedback\n} from '@/types/learning';\nimport { createFeedbackProcessor } from '@/lib/ai/feedback-processor';\nimport { useMutation } from '@tanstack/react-query';\n\ninterface FeedbackCollectionFormProps {\n  inspectionId: string;\n  auditorId: string;\n  aiPredictions: Array<{\n    id: string;\n    category: FeedbackCategory;\n    value: any;\n    confidence: number;\n    context?: {\n      roomType?: string;\n      photoId?: string;\n      videoTimestamp?: number;\n      checklistItemId?: string;\n    };\n  }>;\n  onSubmit?: (feedback: AuditorFeedback[]) => void;\n  onSaveDraft?: (draft: FeedbackFormData) => void;\n  initialDraft?: FeedbackFormData;\n  className?: string;\n}\n\nexport const FeedbackCollectionForm: React.FC<FeedbackCollectionFormProps> = ({\n  inspectionId,\n  auditorId,\n  aiPredictions,\n  onSubmit,\n  onSaveDraft,\n  initialDraft,\n  className\n}) => {\n  // State\n  const [feedbackItems, setFeedbackItems] = useState<FeedbackItem[]>([]);\n  const [overallRating, setOverallRating] = useState(3);\n  const [comments, setComments] = useState('');\n  const [suggestedImprovements, setSuggestedImprovements] = useState<string[]>([]);\n  const [newImprovement, setNewImprovement] = useState('');\n  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());\n  const [filterCategory, setFilterCategory] = useState<FeedbackCategory | 'all'>('all');\n  const [showOnlyErrors, setShowOnlyErrors] = useState(false);\n\n  // Initialize feedback processor\n  const feedbackProcessor = React.useMemo(() => createFeedbackProcessor(), []);\n\n  // Initialize feedback items from AI predictions\n  useEffect(() => {\n    const items: FeedbackItem[] = aiPredictions.map(prediction => ({\n      id: prediction.id,\n      type: prediction.category,\n      aiValue: prediction.value,\n      correctValue: prediction.value, // Initially same as AI\n      confidenceRating: prediction.confidence,\n      severity: 'minor',\n      explanation: '',\n      evidence: {\n        photoIds: prediction.context?.photoId ? [prediction.context.photoId] : undefined,\n        videoTimestamp: prediction.context?.videoTimestamp,\n        checklistItemId: prediction.context?.checklistItemId\n      }\n    }));\n\n    // Apply initial draft if provided\n    if (initialDraft) {\n      const draftMap = new Map(initialDraft.feedbackItems.map(item => [item.id, item]));\n      items.forEach(item => {\n        const draft = draftMap.get(item.id);\n        if (draft) {\n          Object.assign(item, draft);\n        }\n      });\n      setOverallRating(initialDraft.overallRating);\n      setComments(initialDraft.comments || '');\n      setSuggestedImprovements(initialDraft.suggestedImprovements || []);\n    }\n\n    setFeedbackItems(items);\n  }, [aiPredictions, initialDraft]);\n\n  // Submit mutation\n  const submitMutation = useMutation({\n    mutationFn: async () => {\n      const formData: FeedbackFormData = {\n        inspectionId,\n        feedbackItems: feedbackItems.filter(item => \n          JSON.stringify(item.aiValue) !== JSON.stringify(item.correctValue) ||\n          item.explanation\n        ),\n        overallRating,\n        comments,\n        suggestedImprovements\n      };\n\n      const feedback = await feedbackProcessor.collectFeedback(\n        formData,\n        auditorId,\n        inspectionId\n      );\n\n      return feedback;\n    },\n    onSuccess: (feedback) => {\n      onSubmit?.(feedback);\n    }\n  });\n\n  // Filter items\n  const filteredItems = feedbackItems.filter(item => {\n    if (filterCategory !== 'all' && item.type !== filterCategory) return false;\n    if (showOnlyErrors && JSON.stringify(item.aiValue) === JSON.stringify(item.correctValue)) return false;\n    return true;\n  });\n\n  // Statistics\n  const stats = {\n    total: feedbackItems.length,\n    corrections: feedbackItems.filter(item => \n      JSON.stringify(item.aiValue) !== JSON.stringify(item.correctValue)\n    ).length,\n    reviewed: feedbackItems.filter(item => item.explanation).length,\n    highSeverity: feedbackItems.filter(item => item.severity === 'major').length\n  };\n\n  // Handle item update\n  const updateFeedbackItem = (id: string, updates: Partial<FeedbackItem>) => {\n    setFeedbackItems(prev => prev.map(item =>\n      item.id === id ? { ...item, ...updates } : item\n    ));\n  };\n\n  // Handle save draft\n  const handleSaveDraft = () => {\n    const draft: FeedbackFormData = {\n      inspectionId,\n      feedbackItems,\n      overallRating,\n      comments,\n      suggestedImprovements\n    };\n    onSaveDraft?.(draft);\n  };\n\n  // Toggle item expansion\n  const toggleExpanded = (id: string) => {\n    setExpandedItems(prev => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  };\n\n  // Add improvement suggestion\n  const addImprovement = () => {\n    if (newImprovement.trim()) {\n      setSuggestedImprovements(prev => [...prev, newImprovement.trim()]);\n      setNewImprovement('');\n    }\n  };\n\n  // Remove improvement suggestion\n  const removeImprovement = (index: number) => {\n    setSuggestedImprovements(prev => prev.filter((_, i) => i !== index));\n  };\n\n  // Get category color\n  const getCategoryColor = (category: FeedbackCategory) => {\n    const colors: Record<FeedbackCategory, string> = {\n      photo_quality: 'bg-blue-100 text-blue-800',\n      object_detection: 'bg-purple-100 text-purple-800',\n      room_classification: 'bg-green-100 text-green-800',\n      damage_assessment: 'bg-red-100 text-red-800',\n      completeness_check: 'bg-yellow-100 text-yellow-800',\n      safety_compliance: 'bg-orange-100 text-orange-800',\n      amenity_verification: 'bg-indigo-100 text-indigo-800',\n      measurement_accuracy: 'bg-pink-100 text-pink-800',\n      condition_rating: 'bg-gray-100 text-gray-800'\n    };\n    return colors[category] || 'bg-gray-100 text-gray-800';\n  };\n\n  // Render value based on type\n  const renderValue = (value: any) => {\n    if (value === null || value === undefined) return 'N/A';\n    if (typeof value === 'boolean') return value ? 'Yes' : 'No';\n    if (typeof value === 'number') return value.toFixed(2);\n    if (typeof value === 'string') return value;\n    if (Array.isArray(value)) return `${value.length} items`;\n    if (typeof value === 'object') return JSON.stringify(value, null, 2);\n    return String(value);\n  };\n\n  return (\n    <div className={cn('space-y-6', className)}>\n      {/* Header */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <CardTitle className=\"flex items-center space-x-2\">\n                <Brain className=\"h-5 w-5 text-purple-600\" />\n                <span>AI Learning Feedback</span>\n              </CardTitle>\n              <CardDescription>\n                Help improve our AI by reviewing and correcting its predictions\n              </CardDescription>\n            </div>\n            <div className=\"flex items-center space-x-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={handleSaveDraft}\n              >\n                <Save className=\"h-4 w-4 mr-2\" />\n                Save Draft\n              </Button>\n              <Button\n                size=\"sm\"\n                onClick={() => submitMutation.mutate()}\n                disabled={submitMutation.isPending}\n              >\n                <Send className=\"h-4 w-4 mr-2\" />\n                Submit Feedback\n              </Button>\n            </div>\n          </div>\n        </CardHeader>\n      </Card>\n\n      {/* Statistics */}\n      <div className=\"grid grid-cols-4 gap-4\">\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"text-2xl font-bold\">{stats.total}</div>\n            <p className=\"text-xs text-muted-foreground\">Total Predictions</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"text-2xl font-bold text-red-600\">{stats.corrections}</div>\n            <p className=\"text-xs text-muted-foreground\">Corrections</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"text-2xl font-bold text-green-600\">{stats.reviewed}</div>\n            <p className=\"text-xs text-muted-foreground\">Reviewed</p>\n          </CardContent>\n        </Card>\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"text-2xl font-bold text-orange-600\">{stats.highSeverity}</div>\n            <p className=\"text-xs text-muted-foreground\">High Severity</p>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Main Content */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <CardTitle>Review AI Predictions</CardTitle>\n            <div className=\"flex items-center space-x-4\">\n              <Select\n                value={filterCategory}\n                onValueChange={(value: any) => setFilterCategory(value)}\n              >\n                <SelectTrigger className=\"w-[200px]\">\n                  <SelectValue placeholder=\"Filter by category\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All Categories</SelectItem>\n                  <SelectItem value=\"photo_quality\">Photo Quality</SelectItem>\n                  <SelectItem value=\"object_detection\">Object Detection</SelectItem>\n                  <SelectItem value=\"room_classification\">Room Classification</SelectItem>\n                  <SelectItem value=\"damage_assessment\">Damage Assessment</SelectItem>\n                  <SelectItem value=\"completeness_check\">Completeness Check</SelectItem>\n                  <SelectItem value=\"safety_compliance\">Safety Compliance</SelectItem>\n                  <SelectItem value=\"amenity_verification\">Amenity Verification</SelectItem>\n                  <SelectItem value=\"measurement_accuracy\">Measurement Accuracy</SelectItem>\n                  <SelectItem value=\"condition_rating\">Condition Rating</SelectItem>\n                </SelectContent>\n              </Select>\n              <div className=\"flex items-center space-x-2\">\n                <Checkbox\n                  id=\"showErrors\"\n                  checked={showOnlyErrors}\n                  onCheckedChange={(checked) => setShowOnlyErrors(!!checked)}\n                />\n                <Label htmlFor=\"showErrors\" className=\"text-sm cursor-pointer\">\n                  Show only errors\n                </Label>\n              </div>\n            </div>\n          </div>\n        </CardHeader>\n        <CardContent>\n          <ScrollArea className=\"h-[600px]\">\n            <div className=\"space-y-4\">\n              {filteredItems.map((item) => {\n                const isExpanded = expandedItems.has(item.id);\n                const hasError = JSON.stringify(item.aiValue) !== JSON.stringify(item.correctValue);\n                \n                return (\n                  <div\n                    key={item.id}\n                    className={cn(\n                      'border rounded-lg p-4 transition-all',\n                      hasError ? 'border-red-200 bg-red-50' : 'border-gray-200',\n                      isExpanded && 'ring-2 ring-primary ring-offset-2'\n                    )}\n                  >\n                    {/* Item Header */}\n                    <div className=\"flex items-start justify-between\">\n                      <div className=\"flex items-start space-x-3 flex-1\">\n                        <button\n                          onClick={() => toggleExpanded(item.id)}\n                          className=\"mt-1\"\n                        >\n                          {isExpanded ? (\n                            <ChevronDown className=\"h-4 w-4\" />\n                          ) : (\n                            <ChevronRight className=\"h-4 w-4\" />\n                          )}\n                        </button>\n                        <div className=\"flex-1\">\n                          <div className=\"flex items-center space-x-2\">\n                            <Badge className={cn('text-xs', getCategoryColor(item.type))}>\n                              {item.type.replace(/_/g, ' ')}\n                            </Badge>\n                            {hasError && (\n                              <Badge variant=\"destructive\" className=\"text-xs\">\n                                Correction\n                              </Badge>\n                            )}\n                            <Badge variant=\"outline\" className=\"text-xs\">\n                              {item.confidenceRating}% confidence\n                            </Badge>\n                          </div>\n                          <div className=\"mt-2 grid grid-cols-2 gap-4\">\n                            <div>\n                              <p className=\"text-xs text-muted-foreground\">AI Prediction</p>\n                              <p className=\"text-sm font-mono\">{renderValue(item.aiValue)}</p>\n                            </div>\n                            <div>\n                              <p className=\"text-xs text-muted-foreground\">Correct Value</p>\n                              <p className={cn(\n                                'text-sm font-mono',\n                                hasError && 'text-red-600 font-semibold'\n                              )}>\n                                {renderValue(item.correctValue)}\n                              </p>\n                            </div>\n                          </div>\n                        </div>\n                      </div>\n                      <div className=\"flex items-center space-x-2\">\n                        {item.explanation && (\n                          <Badge variant=\"secondary\" className=\"text-xs\">\n                            <MessageSquare className=\"h-3 w-3 mr-1\" />\n                            Explained\n                          </Badge>\n                        )}\n                        {hasError ? (\n                          <XCircle className=\"h-5 w-5 text-red-600\" />\n                        ) : (\n                          <CheckCircle className=\"h-5 w-5 text-green-600\" />\n                        )}\n                      </div>\n                    </div>\n\n                    {/* Expanded Content */}\n                    {isExpanded && (\n                      <div className=\"mt-4 space-y-4\">\n                        <Separator />\n                        \n                        {/* Correct Value Input */}\n                        <div>\n                          <Label>Correct Value</Label>\n                          <div className=\"mt-1\">\n                            {typeof item.aiValue === 'boolean' ? (\n                              <RadioGroup\n                                value={String(item.correctValue)}\n                                onValueChange={(value) => \n                                  updateFeedbackItem(item.id, { correctValue: value === 'true' })\n                                }\n                              >\n                                <div className=\"flex items-center space-x-4\">\n                                  <div className=\"flex items-center space-x-2\">\n                                    <RadioGroupItem value=\"true\" id={`${item.id}_true`} />\n                                    <Label htmlFor={`${item.id}_true`}>Yes</Label>\n                                  </div>\n                                  <div className=\"flex items-center space-x-2\">\n                                    <RadioGroupItem value=\"false\" id={`${item.id}_false`} />\n                                    <Label htmlFor={`${item.id}_false`}>No</Label>\n                                  </div>\n                                </div>\n                              </RadioGroup>\n                            ) : typeof item.aiValue === 'number' ? (\n                              <div className=\"flex items-center space-x-2\">\n                                <Slider\n                                  value={[item.correctValue]}\n                                  onValueChange={([value]) => \n                                    updateFeedbackItem(item.id, { correctValue: value })\n                                  }\n                                  max={100}\n                                  step={1}\n                                  className=\"flex-1\"\n                                />\n                                <span className=\"w-12 text-sm font-mono\">{item.correctValue}</span>\n                              </div>\n                            ) : (\n                              <Textarea\n                                value={\n                                  typeof item.correctValue === 'string' \n                                    ? item.correctValue \n                                    : JSON.stringify(item.correctValue, null, 2)\n                                }\n                                onChange={(e) => {\n                                  try {\n                                    const value = JSON.parse(e.target.value);\n                                    updateFeedbackItem(item.id, { correctValue: value });\n                                  } catch {\n                                    updateFeedbackItem(item.id, { correctValue: e.target.value });\n                                  }\n                                }}\n                                className=\"font-mono text-sm\"\n                                rows={3}\n                              />\n                            )}\n                          </div>\n                        </div>\n\n                        {/* Severity */}\n                        <div>\n                          <Label>Severity</Label>\n                          <RadioGroup\n                            value={item.severity}\n                            onValueChange={(value: any) => \n                              updateFeedbackItem(item.id, { severity: value })\n                            }\n                            className=\"flex items-center space-x-4 mt-1\"\n                          >\n                            <div className=\"flex items-center space-x-2\">\n                              <RadioGroupItem value=\"minor\" id={`${item.id}_minor`} />\n                              <Label htmlFor={`${item.id}_minor`} className=\"cursor-pointer\">\n                                Minor\n                              </Label>\n                            </div>\n                            <div className=\"flex items-center space-x-2\">\n                              <RadioGroupItem value=\"moderate\" id={`${item.id}_moderate`} />\n                              <Label htmlFor={`${item.id}_moderate`} className=\"cursor-pointer\">\n                                Moderate\n                              </Label>\n                            </div>\n                            <div className=\"flex items-center space-x-2\">\n                              <RadioGroupItem value=\"major\" id={`${item.id}_major`} />\n                              <Label htmlFor={`${item.id}_major`} className=\"cursor-pointer\">\n                                Major\n                              </Label>\n                            </div>\n                          </RadioGroup>\n                        </div>\n\n                        {/* Confidence Rating */}\n                        <div>\n                          <Label>Your Confidence Level</Label>\n                          <div className=\"flex items-center space-x-2 mt-1\">\n                            <Slider\n                              value={[item.confidenceRating]}\n                              onValueChange={([value]) => \n                                updateFeedbackItem(item.id, { confidenceRating: value })\n                              }\n                              max={100}\n                              step={5}\n                              className=\"flex-1\"\n                            />\n                            <span className=\"w-12 text-sm font-mono\">{item.confidenceRating}%</span>\n                          </div>\n                        </div>\n\n                        {/* Explanation */}\n                        <div>\n                          <Label>Explanation (Optional)</Label>\n                          <Textarea\n                            placeholder=\"Explain why this correction is needed...\"\n                            value={item.explanation || ''}\n                            onChange={(e) => \n                              updateFeedbackItem(item.id, { explanation: e.target.value })\n                            }\n                            className=\"mt-1\"\n                            rows={3}\n                          />\n                        </div>\n\n                        {/* Evidence */}\n                        {item.evidence && (\n                          <div>\n                            <Label>Related Evidence</Label>\n                            <div className=\"flex items-center space-x-4 mt-1 text-sm text-muted-foreground\">\n                              {item.evidence.photoIds && (\n                                <div className=\"flex items-center space-x-1\">\n                                  <ImageIcon className=\"h-4 w-4\" />\n                                  <span>{item.evidence.photoIds.length} photos</span>\n                                </div>\n                              )}\n                              {item.evidence.videoTimestamp !== undefined && (\n                                <div className=\"flex items-center space-x-1\">\n                                  <Video className=\"h-4 w-4\" />\n                                  <span>Video at {formatTime(item.evidence.videoTimestamp)}</span>\n                                </div>\n                              )}\n                              {item.evidence.checklistItemId && (\n                                <div className=\"flex items-center space-x-1\">\n                                  <FileText className=\"h-4 w-4\" />\n                                  <span>Checklist item</span>\n                                </div>\n                              )}\n                            </div>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n          </ScrollArea>\n        </CardContent>\n      </Card>\n\n      {/* Overall Feedback */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Overall Feedback</CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          {/* Overall Rating */}\n          <div>\n            <Label>Overall AI Performance Rating</Label>\n            <div className=\"flex items-center space-x-4 mt-2\">\n              {[1, 2, 3, 4, 5].map((rating) => (\n                <button\n                  key={rating}\n                  onClick={() => setOverallRating(rating)}\n                  className={cn(\n                    'p-2 rounded-lg transition-all',\n                    overallRating >= rating\n                      ? 'bg-primary text-primary-foreground'\n                      : 'bg-gray-100 text-gray-400 hover:bg-gray-200'\n                  )}\n                >\n                  <Target className=\"h-6 w-6\" />\n                </button>\n              ))}\n              <span className=\"text-sm text-muted-foreground\">\n                {overallRating === 1 && 'Poor'}\n                {overallRating === 2 && 'Fair'}\n                {overallRating === 3 && 'Good'}\n                {overallRating === 4 && 'Very Good'}\n                {overallRating === 5 && 'Excellent'}\n              </span>\n            </div>\n          </div>\n\n          {/* Comments */}\n          <div>\n            <Label>Additional Comments</Label>\n            <Textarea\n              placeholder=\"Any additional feedback about the AI's performance...\"\n              value={comments}\n              onChange={(e) => setComments(e.target.value)}\n              className=\"mt-1\"\n              rows={4}\n            />\n          </div>\n\n          {/* Suggested Improvements */}\n          <div>\n            <Label>Suggested Improvements</Label>\n            <div className=\"space-y-2 mt-1\">\n              {suggestedImprovements.map((improvement, index) => (\n                <div key={index} className=\"flex items-center justify-between p-2 bg-gray-50 rounded\">\n                  <span className=\"text-sm\">{improvement}</span>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={() => removeImprovement(index)}\n                  >\n                    <Trash2 className=\"h-4 w-4\" />\n                  </Button>\n                </div>\n              ))}\n              <div className=\"flex items-center space-x-2\">\n                <input\n                  type=\"text\"\n                  placeholder=\"Add a suggestion...\"\n                  value={newImprovement}\n                  onChange={(e) => setNewImprovement(e.target.value)}\n                  onKeyPress={(e) => e.key === 'Enter' && addImprovement()}\n                  className=\"flex-1 px-3 py-2 border rounded-md text-sm\"\n                />\n                <Button size=\"sm\" onClick={addImprovement}>\n                  <Plus className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Submit Status */}\n      {submitMutation.isPending && (\n        <Alert>\n          <Sparkles className=\"h-4 w-4 animate-spin\" />\n          <AlertDescription>\n            Submitting your feedback to improve our AI...\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {submitMutation.isSuccess && (\n        <Alert className=\"border-green-200 bg-green-50\">\n          <CheckCircle className=\"h-4 w-4 text-green-600\" />\n          <AlertDescription className=\"text-green-800\">\n            Thank you! Your feedback has been submitted and will help improve our AI.\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {submitMutation.isError && (\n        <Alert variant=\"destructive\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription>\n            Failed to submit feedback. Please try again.\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};\n\n// Helper function\nfunction formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/MetricsChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/VideoAnnotationTools.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":383,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12036,12039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12036,12039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Annotation Tools Component for STR Certified Auditor Interface\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Textarea } from '@/components/ui/textarea';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport {\n  MessageSquare,\n  Edit3,\n  Square,\n  Circle,\n  Type,\n  Check,\n  X,\n  AlertTriangle,\n  Flag,\n  Save,\n  Trash2,\n  ChevronDown,\n  Clock,\n  User,\n  Palette,\n  MousePointer,\n  Move,\n  ZoomIn,\n  Undo,\n  Redo,\n  Download,\n  Upload\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\nexport interface VideoAnnotation {\n  id: string;\n  timestamp: number;\n  type: 'comment' | 'drawing' | 'flag';\n  status?: 'pass' | 'fail' | 'needs_review';\n  content: string;\n  drawing?: DrawingData;\n  author: string;\n  createdAt: Date;\n  position?: { x: number; y: number };\n  color?: string;\n}\n\nexport interface DrawingData {\n  tool: 'pen' | 'rectangle' | 'circle' | 'arrow' | 'text';\n  points: { x: number; y: number }[];\n  color: string;\n  strokeWidth: number;\n  text?: string;\n}\n\ninterface VideoAnnotationToolsProps {\n  currentTime: number;\n  videoElement?: HTMLVideoElement | null;\n  annotations: VideoAnnotation[];\n  onAddAnnotation: (annotation: Omit<VideoAnnotation, 'id' | 'createdAt'>) => void;\n  onUpdateAnnotation: (id: string, annotation: Partial<VideoAnnotation>) => void;\n  onDeleteAnnotation: (id: string) => void;\n  currentUser: string;\n  className?: string;\n}\n\nexport const VideoAnnotationTools: React.FC<VideoAnnotationToolsProps> = ({\n  currentTime,\n  videoElement,\n  annotations,\n  onAddAnnotation,\n  onUpdateAnnotation,\n  onDeleteAnnotation,\n  currentUser,\n  className\n}) => {\n  // State\n  const [activeTab, setActiveTab] = useState<'comment' | 'drawing' | 'flag'>('comment');\n  const [commentText, setCommentText] = useState('');\n  const [flagStatus, setFlagStatus] = useState<'pass' | 'fail' | 'needs_review'>('needs_review');\n  const [drawingTool, setDrawingTool] = useState<DrawingData['tool']>('pen');\n  const [drawingColor, setDrawingColor] = useState('#ff0000');\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [showAnnotations, setShowAnnotations] = useState(true);\n  const [selectedAnnotation, setSelectedAnnotation] = useState<string | null>(null);\n\n  // Refs\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const drawingRef = useRef<DrawingData | null>(null);\n\n  // Get annotations for current time (within 2 seconds)\n  const currentAnnotations = annotations.filter(\n    ann => Math.abs(ann.timestamp - currentTime) < 2\n  );\n\n  // Format time\n  const formatTime = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  // Handle comment submission\n  const handleAddComment = () => {\n    if (!commentText.trim()) return;\n\n    onAddAnnotation({\n      timestamp: currentTime,\n      type: 'comment',\n      content: commentText,\n      author: currentUser\n    });\n\n    setCommentText('');\n  };\n\n  // Handle flag submission\n  const handleAddFlag = () => {\n    onAddAnnotation({\n      timestamp: currentTime,\n      type: 'flag',\n      status: flagStatus,\n      content: `Flagged as ${flagStatus.replace('_', ' ')}`,\n      author: currentUser\n    });\n  };\n\n  // Initialize canvas for drawing\n  useEffect(() => {\n    if (activeTab === 'drawing' && canvasRef.current && videoElement) {\n      const canvas = canvasRef.current;\n      const rect = videoElement.getBoundingClientRect();\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n      \n      // Clear canvas\n      const ctx = canvas.getContext('2d');\n      if (ctx) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      }\n    }\n  }, [activeTab, videoElement]);\n\n  // Handle drawing\n  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasRef.current) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    setIsDrawing(true);\n    drawingRef.current = {\n      tool: drawingTool,\n      points: [{ x, y }],\n      color: drawingColor,\n      strokeWidth: 3\n    };\n  };\n\n  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDrawing || !canvasRef.current || !drawingRef.current) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    drawingRef.current.points.push({ x, y });\n\n    // Draw on canvas\n    const ctx = canvasRef.current.getContext('2d');\n    if (ctx) {\n      ctx.strokeStyle = drawingColor;\n      ctx.lineWidth = 3;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n\n      const points = drawingRef.current.points;\n      if (points.length > 1) {\n        const lastPoint = points[points.length - 2];\n        const currentPoint = points[points.length - 1];\n        \n        ctx.beginPath();\n        ctx.moveTo(lastPoint.x, lastPoint.y);\n        ctx.lineTo(currentPoint.x, currentPoint.y);\n        ctx.stroke();\n      }\n    }\n  };\n\n  const stopDrawing = () => {\n    if (!isDrawing || !drawingRef.current) return;\n\n    setIsDrawing(false);\n\n    // Save drawing annotation\n    onAddAnnotation({\n      timestamp: currentTime,\n      type: 'drawing',\n      content: `Drawing annotation with ${drawingTool}`,\n      drawing: drawingRef.current,\n      author: currentUser\n    });\n\n    // Clear canvas\n    if (canvasRef.current) {\n      const ctx = canvasRef.current.getContext('2d');\n      if (ctx) {\n        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      }\n    }\n\n    drawingRef.current = null;\n  };\n\n  // Status badge color\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'pass':\n        return 'bg-green-500';\n      case 'fail':\n        return 'bg-red-500';\n      case 'needs_review':\n        return 'bg-yellow-500';\n      default:\n        return 'bg-gray-500';\n    }\n  };\n\n  return (\n    <div className={cn('space-y-4', className)}>\n      {/* Annotation Tools Card */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <CardTitle className=\"text-lg\">Annotation Tools</CardTitle>\n            <Badge variant=\"secondary\">\n              {formatTime(currentTime)}\n            </Badge>\n          </div>\n        </CardHeader>\n        <CardContent>\n          {/* Tool Tabs */}\n          <div className=\"flex space-x-2 mb-4\">\n            <Button\n              variant={activeTab === 'comment' ? 'default' : 'outline'}\n              size=\"sm\"\n              onClick={() => setActiveTab('comment')}\n            >\n              <MessageSquare className=\"h-4 w-4 mr-1\" />\n              Comment\n            </Button>\n            <Button\n              variant={activeTab === 'drawing' ? 'default' : 'outline'}\n              size=\"sm\"\n              onClick={() => setActiveTab('drawing')}\n            >\n              <Edit3 className=\"h-4 w-4 mr-1\" />\n              Draw\n            </Button>\n            <Button\n              variant={activeTab === 'flag' ? 'default' : 'outline'}\n              size=\"sm\"\n              onClick={() => setActiveTab('flag')}\n            >\n              <Flag className=\"h-4 w-4 mr-1\" />\n              Flag\n            </Button>\n          </div>\n\n          {/* Comment Tab */}\n          {activeTab === 'comment' && (\n            <div className=\"space-y-3\">\n              <Textarea\n                placeholder=\"Add a comment about this moment...\"\n                value={commentText}\n                onChange={(e) => setCommentText(e.target.value)}\n                className=\"min-h-[80px]\"\n              />\n              <Button \n                onClick={handleAddComment}\n                disabled={!commentText.trim()}\n                className=\"w-full\"\n              >\n                <MessageSquare className=\"h-4 w-4 mr-2\" />\n                Add Comment\n              </Button>\n            </div>\n          )}\n\n          {/* Drawing Tab */}\n          {activeTab === 'drawing' && (\n            <div className=\"space-y-3\">\n              {/* Drawing Tools */}\n              <div className=\"flex items-center space-x-2\">\n                <Button\n                  variant={drawingTool === 'pen' ? 'default' : 'outline'}\n                  size=\"icon\"\n                  onClick={() => setDrawingTool('pen')}\n                >\n                  <Edit3 className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant={drawingTool === 'rectangle' ? 'default' : 'outline'}\n                  size=\"icon\"\n                  onClick={() => setDrawingTool('rectangle')}\n                >\n                  <Square className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant={drawingTool === 'circle' ? 'default' : 'outline'}\n                  size=\"icon\"\n                  onClick={() => setDrawingTool('circle')}\n                >\n                  <Circle className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant={drawingTool === 'text' ? 'default' : 'outline'}\n                  size=\"icon\"\n                  onClick={() => setDrawingTool('text')}\n                >\n                  <Type className=\"h-4 w-4\" />\n                </Button>\n                \n                <div className=\"flex-1\" />\n                \n                {/* Color Picker */}\n                <Popover>\n                  <PopoverTrigger asChild>\n                    <Button variant=\"outline\" size=\"icon\">\n                      <div\n                        className=\"w-4 h-4 rounded\"\n                        style={{ backgroundColor: drawingColor }}\n                      />\n                    </Button>\n                  </PopoverTrigger>\n                  <PopoverContent className=\"w-48\">\n                    <div className=\"grid grid-cols-4 gap-2\">\n                      {['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#000000', '#ffffff'].map(color => (\n                        <button\n                          key={color}\n                          className={cn(\n                            'w-8 h-8 rounded border-2',\n                            drawingColor === color ? 'border-primary' : 'border-transparent'\n                          )}\n                          style={{ backgroundColor: color }}\n                          onClick={() => setDrawingColor(color)}\n                        />\n                      ))}\n                    </div>\n                  </PopoverContent>\n                </Popover>\n              </div>\n\n              {/* Drawing Canvas */}\n              {videoElement && (\n                <div className=\"relative bg-gray-100 rounded-lg overflow-hidden\">\n                  <canvas\n                    ref={canvasRef}\n                    className=\"absolute inset-0 cursor-crosshair\"\n                    onMouseDown={startDrawing}\n                    onMouseMove={draw}\n                    onMouseUp={stopDrawing}\n                    onMouseLeave={stopDrawing}\n                  />\n                  <Alert className=\"m-2\">\n                    <AlertDescription>\n                      Draw on the video to highlight areas. Your drawing will be saved at the current timestamp.\n                    </AlertDescription>\n                  </Alert>\n                </div>\n              )}\n            </div>\n          )}\n\n          {/* Flag Tab */}\n          {activeTab === 'flag' && (\n            <div className=\"space-y-3\">\n              <RadioGroup value={flagStatus} onValueChange={(value: any) => setFlagStatus(value)}>\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"pass\" id=\"pass\" />\n                  <Label htmlFor=\"pass\" className=\"flex items-center cursor-pointer\">\n                    <Check className=\"h-4 w-4 mr-1 text-green-600\" />\n                    Pass\n                  </Label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"fail\" id=\"fail\" />\n                  <Label htmlFor=\"fail\" className=\"flex items-center cursor-pointer\">\n                    <X className=\"h-4 w-4 mr-1 text-red-600\" />\n                    Fail\n                  </Label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"needs_review\" id=\"needs_review\" />\n                  <Label htmlFor=\"needs_review\" className=\"flex items-center cursor-pointer\">\n                    <AlertTriangle className=\"h-4 w-4 mr-1 text-yellow-600\" />\n                    Needs Review\n                  </Label>\n                </div>\n              </RadioGroup>\n              <Button onClick={handleAddFlag} className=\"w-full\">\n                <Flag className=\"h-4 w-4 mr-2\" />\n                Add Flag\n              </Button>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Current Annotations */}\n      {currentAnnotations.length > 0 && (\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"text-lg\">Annotations at {formatTime(currentTime)}</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <ScrollArea className=\"h-48\">\n              <div className=\"space-y-2\">\n                {currentAnnotations.map((annotation) => (\n                  <AnnotationItem\n                    key={annotation.id}\n                    annotation={annotation}\n                    isSelected={selectedAnnotation === annotation.id}\n                    onSelect={() => setSelectedAnnotation(annotation.id)}\n                    onDelete={() => onDeleteAnnotation(annotation.id)}\n                  />\n                ))}\n              </div>\n            </ScrollArea>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* All Annotations List */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <CardTitle className=\"text-lg\">All Annotations</CardTitle>\n            <Badge variant=\"secondary\">\n              {annotations.length} total\n            </Badge>\n          </div>\n        </CardHeader>\n        <CardContent>\n          <ScrollArea className=\"h-64\">\n            <div className=\"space-y-2\">\n              {annotations.map((annotation) => (\n                <AnnotationItem\n                  key={annotation.id}\n                  annotation={annotation}\n                  isSelected={selectedAnnotation === annotation.id}\n                  onSelect={() => setSelectedAnnotation(annotation.id)}\n                  onDelete={() => onDeleteAnnotation(annotation.id)}\n                  showTimestamp\n                />\n              ))}\n            </div>\n          </ScrollArea>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n\n// Annotation item component\nconst AnnotationItem: React.FC<{\n  annotation: VideoAnnotation;\n  isSelected: boolean;\n  onSelect: () => void;\n  onDelete: () => void;\n  showTimestamp?: boolean;\n}> = ({ annotation, isSelected, onSelect, onDelete, showTimestamp }) => {\n  const getIcon = () => {\n    switch (annotation.type) {\n      case 'comment':\n        return <MessageSquare className=\"h-4 w-4\" />;\n      case 'drawing':\n        return <Edit3 className=\"h-4 w-4\" />;\n      case 'flag':\n        return <Flag className=\"h-4 w-4\" />;\n    }\n  };\n\n  const getStatusBadge = () => {\n    if (annotation.status) {\n      const colors = {\n        pass: 'bg-green-500',\n        fail: 'bg-red-500',\n        needs_review: 'bg-yellow-500'\n      };\n      \n      return (\n        <Badge className={cn('text-xs', colors[annotation.status])}>\n          {annotation.status.replace('_', ' ')}\n        </Badge>\n      );\n    }\n    return null;\n  };\n\n  return (\n    <div\n      className={cn(\n        'p-3 rounded-lg border cursor-pointer transition-colors',\n        isSelected ? 'border-primary bg-primary/5' : 'border-border hover:bg-muted/50'\n      )}\n      onClick={onSelect}\n    >\n      <div className=\"flex items-start justify-between\">\n        <div className=\"flex items-start space-x-2\">\n          <div className=\"mt-0.5\">{getIcon()}</div>\n          <div className=\"flex-1\">\n            <div className=\"flex items-center space-x-2\">\n              <span className=\"text-sm font-medium\">{annotation.author}</span>\n              {getStatusBadge()}\n              {showTimestamp && (\n                <span className=\"text-xs text-muted-foreground\">\n                  at {formatTime(annotation.timestamp)}\n                </span>\n              )}\n            </div>\n            <p className=\"text-sm text-muted-foreground mt-1\">\n              {annotation.content}\n            </p>\n          </div>\n        </div>\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={(e) => {\n            e.stopPropagation();\n            onDelete();\n          }}\n          className=\"h-6 w-6\"\n        >\n          <Trash2 className=\"h-3 w-3\" />\n        </Button>\n      </div>\n    </div>\n  );\n};\n\n// Helper function\nfunction formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/VideoComparisonPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10071,10074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10071,10074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15140,15143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15140,15143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Comparison Panel Component for STR Certified Auditor Interface\n\nimport React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Separator } from '@/components/ui/separator';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport { Textarea } from '@/components/ui/textarea';\nimport {\n  Check,\n  X,\n  AlertTriangle,\n  Eye,\n  EyeOff,\n  ChevronRight,\n  ZoomIn,\n  RotateCw,\n  Flag,\n  ThumbsUp,\n  ThumbsDown,\n  MessageSquare,\n  Sparkles,\n  Image as ImageIcon,\n  Video,\n  Info,\n  ArrowRight,\n  CheckCircle,\n  XCircle\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport type { VideoTimestamp, VideoAnalysisResult, DiscrepancyReport } from '@/types/video';\nimport type { PhotoData } from '@/types/property';\n\ninterface AIFinding {\n  id: string;\n  timestamp: number;\n  type: 'match' | 'discrepancy' | 'missing' | 'extra';\n  category: string;\n  description: string;\n  confidence: number;\n  videoEvidence?: string; // Frame URL\n  listingEvidence?: string; // Photo URL\n  severity: 'low' | 'medium' | 'high';\n  auditorStatus?: 'pending' | 'confirmed' | 'rejected';\n  auditorNotes?: string;\n}\n\ninterface VideoComparisonPanelProps {\n  videoAnalysis: VideoAnalysisResult;\n  listingPhotos: PhotoData[];\n  currentTime: number;\n  onJumpToTime?: (time: number) => void;\n  onFindingUpdate?: (findingId: string, status: 'confirmed' | 'rejected', notes?: string) => void;\n  className?: string;\n}\n\nexport const VideoComparisonPanel: React.FC<VideoComparisonPanelProps> = ({\n  videoAnalysis,\n  listingPhotos,\n  currentTime,\n  onJumpToTime,\n  onFindingUpdate,\n  className\n}) => {\n  // State\n  const [selectedFinding, setSelectedFinding] = useState<AIFinding | null>(null);\n  const [showOnlyUnreviewed, setShowOnlyUnreviewed] = useState(false);\n  const [filterSeverity, setFilterSeverity] = useState<'all' | 'low' | 'medium' | 'high'>('all');\n  const [auditorNotes, setAuditorNotes] = useState('');\n  const [comparisonMode, setComparisonMode] = useState<'side-by-side' | 'overlay'>('side-by-side');\n\n  // Generate AI findings from video analysis\n  const aiFindings: AIFinding[] = React.useMemo(() => {\n    const findings: AIFinding[] = [];\n\n    // Convert discrepancies to findings\n    videoAnalysis.issues.forEach((issue, index) => {\n      issue.affectedTimestamps.forEach((timestamp) => {\n        findings.push({\n          id: `issue_${index}_${timestamp}`,\n          timestamp,\n          type: 'discrepancy',\n          category: issue.type,\n          description: issue.description,\n          confidence: 85 + Math.random() * 10,\n          severity: issue.severity,\n          auditorStatus: 'pending'\n        });\n      });\n    });\n\n    // Add room-based findings\n    videoAnalysis.roomSequence.forEach((room) => {\n      // Check if room exists in listing\n      const listingHasRoom = listingPhotos.some(photo => \n        photo.roomType?.toLowerCase() === room.roomType.toLowerCase()\n      );\n\n      if (!listingHasRoom && room.coverage !== 'minimal') {\n        findings.push({\n          id: `extra_room_${room.roomId}`,\n          timestamp: room.startTime,\n          type: 'extra',\n          category: 'room_not_in_listing',\n          description: `${room.roomType} found in video but not shown in listing photos`,\n          confidence: 75,\n          severity: 'medium',\n          auditorStatus: 'pending'\n        });\n      }\n    });\n\n    // Check for missing rooms\n    const coveredRooms = videoAnalysis.roomSequence.map(r => r.roomType.toLowerCase());\n    const listingRooms = [...new Set(listingPhotos.map(p => p.roomType?.toLowerCase()).filter(Boolean))];\n    \n    listingRooms.forEach((roomType) => {\n      if (!coveredRooms.includes(roomType!)) {\n        findings.push({\n          id: `missing_room_${roomType}`,\n          timestamp: 0,\n          type: 'missing',\n          category: 'room_not_covered',\n          description: `${roomType} shown in listing but not found in video`,\n          confidence: 90,\n          severity: 'high',\n          auditorStatus: 'pending'\n        });\n      }\n    });\n\n    // Add feature-based findings\n    videoAnalysis.featureDetection.forEach((feature) => {\n      if (!feature.detected) {\n        findings.push({\n          id: `missing_feature_${feature.feature}`,\n          timestamp: 0,\n          type: 'missing',\n          category: 'amenity_missing',\n          description: `${feature.feature} not detected in video`,\n          confidence: feature.confidence,\n          severity: 'medium',\n          auditorStatus: 'pending'\n        });\n      }\n    });\n\n    return findings.sort((a, b) => a.timestamp - b.timestamp);\n  }, [videoAnalysis, listingPhotos]);\n\n  // Filter findings\n  const filteredFindings = aiFindings.filter(finding => {\n    if (showOnlyUnreviewed && finding.auditorStatus !== 'pending') return false;\n    if (filterSeverity !== 'all' && finding.severity !== filterSeverity) return false;\n    return true;\n  });\n\n  // Get findings at current time\n  const currentFindings = filteredFindings.filter(\n    f => Math.abs(f.timestamp - currentTime) < 5\n  );\n\n  // Statistics\n  const stats = {\n    total: aiFindings.length,\n    confirmed: aiFindings.filter(f => f.auditorStatus === 'confirmed').length,\n    rejected: aiFindings.filter(f => f.auditorStatus === 'rejected').length,\n    pending: aiFindings.filter(f => f.auditorStatus === 'pending').length,\n    high: aiFindings.filter(f => f.severity === 'high').length,\n    medium: aiFindings.filter(f => f.severity === 'medium').length,\n    low: aiFindings.filter(f => f.severity === 'low').length\n  };\n\n  // Handle finding review\n  const handleFindingReview = (status: 'confirmed' | 'rejected') => {\n    if (!selectedFinding) return;\n\n    onFindingUpdate?.(selectedFinding.id, status, auditorNotes);\n    \n    // Update local state\n    selectedFinding.auditorStatus = status;\n    selectedFinding.auditorNotes = auditorNotes;\n    \n    // Clear form\n    setAuditorNotes('');\n    \n    // Move to next unreviewed finding\n    const nextUnreviewed = filteredFindings.find(\n      f => f.auditorStatus === 'pending' && f.id !== selectedFinding.id\n    );\n    if (nextUnreviewed) {\n      setSelectedFinding(nextUnreviewed);\n    }\n  };\n\n  // Get severity color\n  const getSeverityColor = (severity: string) => {\n    switch (severity) {\n      case 'high': return 'text-red-600 bg-red-50';\n      case 'medium': return 'text-yellow-600 bg-yellow-50';\n      case 'low': return 'text-blue-600 bg-blue-50';\n      default: return 'text-gray-600 bg-gray-50';\n    }\n  };\n\n  // Get finding icon\n  const getFindingIcon = (type: string) => {\n    switch (type) {\n      case 'match': return <CheckCircle className=\"h-4 w-4 text-green-600\" />;\n      case 'discrepancy': return <AlertTriangle className=\"h-4 w-4 text-yellow-600\" />;\n      case 'missing': return <XCircle className=\"h-4 w-4 text-red-600\" />;\n      case 'extra': return <Info className=\"h-4 w-4 text-blue-600\" />;\n      default: return <Flag className=\"h-4 w-4\" />;\n    }\n  };\n\n  return (\n    <div className={cn('space-y-4', className)}>\n      {/* Overview Card */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <CardTitle className=\"flex items-center space-x-2\">\n              <Sparkles className=\"h-5 w-5 text-purple-600\" />\n              <span>AI Comparison Analysis</span>\n            </CardTitle>\n            <Badge variant=\"secondary\">\n              {videoAnalysis.aiConfidence.toFixed(0)}% Confidence\n            </Badge>\n          </div>\n        </CardHeader>\n        <CardContent>\n          {/* Statistics */}\n          <div className=\"grid grid-cols-3 gap-4 mb-4\">\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold\">{stats.total}</div>\n              <div className=\"text-xs text-muted-foreground\">Total Findings</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-green-600\">{stats.confirmed}</div>\n              <div className=\"text-xs text-muted-foreground\">Confirmed</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-red-600\">{stats.rejected}</div>\n              <div className=\"text-xs text-muted-foreground\">Rejected</div>\n            </div>\n          </div>\n\n          <Separator className=\"my-4\" />\n\n          {/* Severity Breakdown */}\n          <div className=\"flex items-center justify-between text-sm\">\n            <div className=\"flex items-center space-x-4\">\n              <span className=\"text-muted-foreground\">Severity:</span>\n              <Badge variant=\"destructive\">{stats.high} High</Badge>\n              <Badge variant=\"secondary\" className=\"bg-yellow-100\">{stats.medium} Medium</Badge>\n              <Badge variant=\"secondary\">{stats.low} Low</Badge>\n            </div>\n            <div className=\"text-muted-foreground\">\n              {stats.pending} pending review\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Findings List */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <CardTitle>Comparison Findings</CardTitle>\n            <div className=\"flex items-center space-x-2\">\n              <Button\n                variant={showOnlyUnreviewed ? 'default' : 'outline'}\n                size=\"sm\"\n                onClick={() => setShowOnlyUnreviewed(!showOnlyUnreviewed)}\n              >\n                <Eye className=\"h-4 w-4 mr-1\" />\n                Unreviewed Only\n              </Button>\n              <RadioGroup\n                value={filterSeverity}\n                onValueChange={(value: any) => setFilterSeverity(value)}\n                className=\"flex items-center space-x-2\"\n              >\n                <div className=\"flex items-center space-x-1\">\n                  <RadioGroupItem value=\"all\" id=\"all\" className=\"h-3 w-3\" />\n                  <Label htmlFor=\"all\" className=\"text-xs cursor-pointer\">All</Label>\n                </div>\n                <div className=\"flex items-center space-x-1\">\n                  <RadioGroupItem value=\"high\" id=\"high\" className=\"h-3 w-3\" />\n                  <Label htmlFor=\"high\" className=\"text-xs cursor-pointer\">High</Label>\n                </div>\n                <div className=\"flex items-center space-x-1\">\n                  <RadioGroupItem value=\"medium\" id=\"medium\" className=\"h-3 w-3\" />\n                  <Label htmlFor=\"medium\" className=\"text-xs cursor-pointer\">Medium</Label>\n                </div>\n                <div className=\"flex items-center space-x-1\">\n                  <RadioGroupItem value=\"low\" id=\"low\" className=\"h-3 w-3\" />\n                  <Label htmlFor=\"low\" className=\"text-xs cursor-pointer\">Low</Label>\n                </div>\n              </RadioGroup>\n            </div>\n          </div>\n        </CardHeader>\n        <CardContent>\n          <ScrollArea className=\"h-96\">\n            <div className=\"space-y-2\">\n              {filteredFindings.map((finding) => {\n                const isSelected = selectedFinding?.id === finding.id;\n                const isAtCurrentTime = Math.abs(finding.timestamp - currentTime) < 5;\n                \n                return (\n                  <div\n                    key={finding.id}\n                    className={cn(\n                      'p-3 rounded-lg border cursor-pointer transition-all',\n                      isSelected ? 'border-primary bg-primary/5' : 'border-border hover:bg-muted/50',\n                      isAtCurrentTime && 'ring-2 ring-primary ring-offset-2'\n                    )}\n                    onClick={() => setSelectedFinding(finding)}\n                  >\n                    <div className=\"flex items-start justify-between\">\n                      <div className=\"flex items-start space-x-2\">\n                        {getFindingIcon(finding.type)}\n                        <div className=\"flex-1\">\n                          <div className=\"flex items-center space-x-2\">\n                            <span className=\"font-medium text-sm\">\n                              {finding.category.replace(/_/g, ' ')}\n                            </span>\n                            <Badge className={cn('text-xs', getSeverityColor(finding.severity))}>\n                              {finding.severity}\n                            </Badge>\n                            {finding.auditorStatus !== 'pending' && (\n                              <Badge\n                                variant={finding.auditorStatus === 'confirmed' ? 'default' : 'secondary'}\n                                className=\"text-xs\"\n                              >\n                                {finding.auditorStatus === 'confirmed' ? (\n                                  <Check className=\"h-3 w-3 mr-1\" />\n                                ) : (\n                                  <X className=\"h-3 w-3 mr-1\" />\n                                )}\n                                {finding.auditorStatus}\n                              </Badge>\n                            )}\n                          </div>\n                          <p className=\"text-sm text-muted-foreground mt-1\">\n                            {finding.description}\n                          </p>\n                          <div className=\"flex items-center space-x-3 mt-1 text-xs text-muted-foreground\">\n                            <span>At {formatTime(finding.timestamp)}</span>\n                            <span>â€¢</span>\n                            <span>{finding.confidence.toFixed(0)}% confidence</span>\n                          </div>\n                        </div>\n                      </div>\n                      {finding.timestamp > 0 && (\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            onJumpToTime?.(finding.timestamp);\n                          }}\n                        >\n                          <ArrowRight className=\"h-4 w-4\" />\n                        </Button>\n                      )}\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </ScrollArea>\n        </CardContent>\n      </Card>\n\n      {/* Selected Finding Detail */}\n      {selectedFinding && (\n        <Card>\n          <CardHeader>\n            <CardTitle>Finding Review</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            {/* Evidence Comparison */}\n            <div>\n              <h4 className=\"text-sm font-medium mb-2\">Evidence Comparison</h4>\n              <Tabs value={comparisonMode} onValueChange={(v: any) => setComparisonMode(v)}>\n                <TabsList className=\"grid w-full grid-cols-2\">\n                  <TabsTrigger value=\"side-by-side\">Side by Side</TabsTrigger>\n                  <TabsTrigger value=\"overlay\">Overlay</TabsTrigger>\n                </TabsList>\n                <TabsContent value=\"side-by-side\" className=\"mt-4\">\n                  <div className=\"grid grid-cols-2 gap-4\">\n                    <div>\n                      <p className=\"text-sm font-medium mb-2\">Video Frame</p>\n                      <div className=\"aspect-video bg-gray-100 rounded-lg overflow-hidden\">\n                        {selectedFinding.videoEvidence ? (\n                          <img\n                            src={selectedFinding.videoEvidence}\n                            alt=\"Video evidence\"\n                            className=\"w-full h-full object-cover\"\n                          />\n                        ) : (\n                          <div className=\"flex items-center justify-center h-full text-muted-foreground\">\n                            <Video className=\"h-8 w-8\" />\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                    <div>\n                      <p className=\"text-sm font-medium mb-2\">Listing Photo</p>\n                      <div className=\"aspect-video bg-gray-100 rounded-lg overflow-hidden\">\n                        {selectedFinding.listingEvidence ? (\n                          <img\n                            src={selectedFinding.listingEvidence}\n                            alt=\"Listing evidence\"\n                            className=\"w-full h-full object-cover\"\n                          />\n                        ) : (\n                          <div className=\"flex items-center justify-center h-full text-muted-foreground\">\n                            <ImageIcon className=\"h-8 w-8\" />\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                </TabsContent>\n                <TabsContent value=\"overlay\" className=\"mt-4\">\n                  <div className=\"relative aspect-video bg-gray-100 rounded-lg overflow-hidden\">\n                    {selectedFinding.listingEvidence && (\n                      <img\n                        src={selectedFinding.listingEvidence}\n                        alt=\"Listing evidence\"\n                        className=\"absolute inset-0 w-full h-full object-cover opacity-50\"\n                      />\n                    )}\n                    {selectedFinding.videoEvidence && (\n                      <img\n                        src={selectedFinding.videoEvidence}\n                        alt=\"Video evidence\"\n                        className=\"absolute inset-0 w-full h-full object-cover opacity-50 mix-blend-difference\"\n                      />\n                    )}\n                  </div>\n                </TabsContent>\n              </Tabs>\n            </div>\n\n            {/* AI Analysis */}\n            <Alert>\n              <Sparkles className=\"h-4 w-4\" />\n              <AlertTitle>AI Analysis</AlertTitle>\n              <AlertDescription>\n                <p className=\"mt-2\">{selectedFinding.description}</p>\n                <div className=\"flex items-center space-x-4 mt-2 text-sm\">\n                  <span>Type: {selectedFinding.type}</span>\n                  <span>Category: {selectedFinding.category.replace(/_/g, ' ')}</span>\n                  <span>Confidence: {selectedFinding.confidence.toFixed(0)}%</span>\n                </div>\n              </AlertDescription>\n            </Alert>\n\n            {/* Auditor Review */}\n            <div className=\"space-y-3\">\n              <Label>Auditor Notes</Label>\n              <Textarea\n                placeholder=\"Add notes about this finding...\"\n                value={auditorNotes}\n                onChange={(e) => setAuditorNotes(e.target.value)}\n                className=\"min-h-[80px]\"\n              />\n              \n              <div className=\"flex items-center space-x-2\">\n                <Button\n                  onClick={() => handleFindingReview('confirmed')}\n                  disabled={selectedFinding.auditorStatus !== 'pending'}\n                  className=\"flex-1\"\n                  variant=\"default\"\n                >\n                  <ThumbsUp className=\"h-4 w-4 mr-2\" />\n                  Confirm Finding\n                </Button>\n                <Button\n                  onClick={() => handleFindingReview('rejected')}\n                  disabled={selectedFinding.auditorStatus !== 'pending'}\n                  className=\"flex-1\"\n                  variant=\"destructive\"\n                >\n                  <ThumbsDown className=\"h-4 w-4 mr-2\" />\n                  Reject Finding\n                </Button>\n              </div>\n\n              {selectedFinding.auditorStatus !== 'pending' && selectedFinding.auditorNotes && (\n                <Alert>\n                  <MessageSquare className=\"h-4 w-4\" />\n                  <AlertDescription>\n                    <p className=\"font-medium\">Previous Notes:</p>\n                    <p className=\"mt-1\">{selectedFinding.auditorNotes}</p>\n                  </AlertDescription>\n                </Alert>\n              )}\n            </div>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Current Time Findings */}\n      {currentFindings.length > 0 && (\n        <Alert>\n          <Info className=\"h-4 w-4\" />\n          <AlertTitle>Findings at Current Time</AlertTitle>\n          <AlertDescription>\n            <p className=\"mt-1\">\n              {currentFindings.length} finding{currentFindings.length > 1 ? 's' : ''} detected at {formatTime(currentTime)}\n            </p>\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};\n\n// Helper function\nfunction formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/VideoReviewPlayer.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1169,1172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1169,1172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'addBookmark', 'handleVolumeChange', 'seek', 'toggleFullscreen', 'toggleMute', and 'togglePlayPause'. Either include them or remove the dependency array.","line":230,"column":6,"nodeType":"ArrayExpression","endLine":230,"endColumn":56,"suggestions":[{"desc":"Update the dependencies array to be: [currentTime, volume, isPlaying, nearestTimestamp, togglePlayPause, seek, handleVolumeChange, toggleMute, toggleFullscreen, addBookmark]","fix":{"range":[6125,6175],"text":"[currentTime, volume, isPlaying, nearestTimestamp, togglePlayPause, seek, handleVolumeChange, toggleMute, toggleFullscreen, addBookmark]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Review Player Component for STR Certified Auditor Interface\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Slider } from '@/components/ui/slider';\nimport { Badge } from '@/components/ui/badge';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport {\n  Play,\n  Pause,\n  SkipBack,\n  SkipForward,\n  Volume2,\n  VolumeX,\n  Maximize2,\n  Minimize2,\n  Settings,\n  Bookmark,\n  Flag,\n  ChevronLeft,\n  ChevronRight,\n  Info,\n  Clock,\n  MapPin,\n  Camera,\n  Home,\n  Zap\n} from 'lucide-react';\nimport { VideoTimeline } from './VideoTimeline';\nimport { useVideoReview } from '@/hooks/useVideoReview';\nimport { cn } from '@/lib/utils';\nimport type { VideoRecording, VideoTimestamp, SceneType } from '@/types/video';\n\ninterface VideoReviewPlayerProps {\n  video: VideoRecording;\n  onTimestampClick?: (timestamp: VideoTimestamp) => void;\n  onAnnotation?: (timestamp: number, annotation: any) => void;\n  showSceneInfo?: boolean;\n  className?: string;\n}\n\nexport const VideoReviewPlayer: React.FC<VideoReviewPlayerProps> = ({\n  video,\n  onTimestampClick,\n  onAnnotation,\n  showSceneInfo = true,\n  className\n}) => {\n  // Refs\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // State\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  const [showControls, setShowControls] = useState(true);\n  const [volume, setVolume] = useState(1);\n  const [isMuted, setIsMuted] = useState(false);\n  const [playbackRate, setPlaybackRate] = useState(1);\n  const [showSettings, setShowSettings] = useState(false);\n  const controlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Custom hook for video management\n  const {\n    isPlaying,\n    currentTime,\n    duration,\n    buffered,\n    currentScene,\n    nearestTimestamp,\n    play,\n    pause,\n    seek,\n    jumpToTimestamp,\n    jumpToNextScene,\n    jumpToPreviousScene,\n    addBookmark,\n    removeBookmark,\n    bookmarks,\n    isBookmarked\n  } = useVideoReview(video, videoRef);\n\n  // Format time display\n  const formatTime = (seconds: number): string => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  // Get scene icon\n  const getSceneIcon = (sceneType: SceneType) => {\n    switch (sceneType) {\n      case 'room_entry':\n        return <Home className=\"h-4 w-4\" />;\n      case 'room_overview':\n        return <Camera className=\"h-4 w-4\" />;\n      case 'detail_shot':\n        return <ZoomIn className=\"h-4 w-4\" />;\n      case 'amenity_focus':\n        return <Zap className=\"h-4 w-4\" />;\n      case 'issue_documentation':\n        return <Flag className=\"h-4 w-4\" />;\n      default:\n        return <MapPin className=\"h-4 w-4\" />;\n    }\n  };\n\n  // Get scene color\n  const getSceneColor = (sceneType: SceneType) => {\n    switch (sceneType) {\n      case 'room_entry':\n        return 'bg-blue-500';\n      case 'room_overview':\n        return 'bg-green-500';\n      case 'detail_shot':\n        return 'bg-purple-500';\n      case 'amenity_focus':\n        return 'bg-yellow-500';\n      case 'issue_documentation':\n        return 'bg-red-500';\n      default:\n        return 'bg-gray-500';\n    }\n  };\n\n  // Handle play/pause toggle\n  const togglePlayPause = () => {\n    if (isPlaying) {\n      pause();\n    } else {\n      play();\n    }\n  };\n\n  // Handle volume change\n  const handleVolumeChange = (value: number[]) => {\n    const newVolume = value[0];\n    setVolume(newVolume);\n    if (videoRef.current) {\n      videoRef.current.volume = newVolume;\n    }\n    if (newVolume > 0 && isMuted) {\n      setIsMuted(false);\n    }\n  };\n\n  // Toggle mute\n  const toggleMute = () => {\n    if (videoRef.current) {\n      videoRef.current.muted = !isMuted;\n      setIsMuted(!isMuted);\n    }\n  };\n\n  // Handle playback rate change\n  const handlePlaybackRateChange = (rate: string) => {\n    const newRate = parseFloat(rate);\n    setPlaybackRate(newRate);\n    if (videoRef.current) {\n      videoRef.current.playbackRate = newRate;\n    }\n  };\n\n  // Toggle fullscreen\n  const toggleFullscreen = async () => {\n    if (!containerRef.current) return;\n\n    if (!isFullscreen) {\n      if (containerRef.current.requestFullscreen) {\n        await containerRef.current.requestFullscreen();\n      }\n    } else {\n      if (document.exitFullscreen) {\n        await document.exitFullscreen();\n      }\n    }\n    setIsFullscreen(!isFullscreen);\n  };\n\n  // Handle keyboard shortcuts\n  useEffect(() => {\n    const handleKeyPress = (e: KeyboardEvent) => {\n      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {\n        return;\n      }\n\n      switch (e.key) {\n        case ' ':\n          e.preventDefault();\n          togglePlayPause();\n          break;\n        case 'ArrowLeft':\n          e.preventDefault();\n          seek(currentTime - 10);\n          break;\n        case 'ArrowRight':\n          e.preventDefault();\n          seek(currentTime + 10);\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          handleVolumeChange([Math.min(1, volume + 0.1)]);\n          break;\n        case 'ArrowDown':\n          e.preventDefault();\n          handleVolumeChange([Math.max(0, volume - 0.1)]);\n          break;\n        case 'm':\n          toggleMute();\n          break;\n        case 'f':\n          toggleFullscreen();\n          break;\n        case 'b':\n          if (nearestTimestamp) {\n            addBookmark(currentTime, nearestTimestamp.description);\n          }\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [currentTime, volume, isPlaying, nearestTimestamp]);\n\n  // Auto-hide controls\n  useEffect(() => {\n    const handleMouseMove = () => {\n      setShowControls(true);\n      \n      if (controlsTimeoutRef.current) {\n        clearTimeout(controlsTimeoutRef.current);\n      }\n      \n      controlsTimeoutRef.current = setTimeout(() => {\n        if (isPlaying) {\n          setShowControls(false);\n        }\n      }, 3000);\n    };\n\n    const container = containerRef.current;\n    if (container) {\n      container.addEventListener('mousemove', handleMouseMove);\n      return () => container.removeEventListener('mousemove', handleMouseMove);\n    }\n  }, [isPlaying]);\n\n  // Handle timeline click\n  const handleTimelineClick = (timestamp: VideoTimestamp) => {\n    jumpToTimestamp(timestamp);\n    onTimestampClick?.(timestamp);\n  };\n\n  // Handle bookmark toggle\n  const handleBookmarkToggle = () => {\n    if (isBookmarked(currentTime)) {\n      const bookmark = bookmarks.find(b => Math.abs(b.time - currentTime) < 1);\n      if (bookmark) {\n        removeBookmark(bookmark.id);\n      }\n    } else {\n      const description = nearestTimestamp?.description || `Bookmark at ${formatTime(currentTime)}`;\n      addBookmark(currentTime, description);\n    }\n  };\n\n  return (\n    <Card className={cn('w-full overflow-hidden', className)}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center space-x-2\">\n            <span>Video Review</span>\n            <Badge variant=\"secondary\">\n              {video.duration}s â€¢ {video.resolution.width}x{video.resolution.height}\n            </Badge>\n          </CardTitle>\n          {showSceneInfo && currentScene && (\n            <div className=\"flex items-center space-x-2\">\n              <div className={cn('p-1 rounded', getSceneColor(currentScene.sceneType), 'bg-opacity-20')}>\n                {getSceneIcon(currentScene.sceneType)}\n              </div>\n              <div className=\"text-sm\">\n                <p className=\"font-medium\">{currentScene.roomDetected || 'Unknown Room'}</p>\n                <p className=\"text-xs text-muted-foreground\">{currentScene.description}</p>\n              </div>\n            </div>\n          )}\n        </div>\n      </CardHeader>\n\n      <CardContent className=\"p-0\">\n        <div\n          ref={containerRef}\n          className={cn(\n            'relative bg-black',\n            isFullscreen && 'fixed inset-0 z-50'\n          )}\n        >\n          {/* Video Element */}\n          <video\n            ref={videoRef}\n            src={URL.createObjectURL(video.file)}\n            className=\"w-full h-full\"\n            onClick={togglePlayPause}\n          />\n\n          {/* Video Controls Overlay */}\n          <div\n            className={cn(\n              'absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/80 to-transparent transition-opacity duration-300',\n              showControls ? 'opacity-100' : 'opacity-0 pointer-events-none'\n            )}\n          >\n            {/* Timeline */}\n            <div className=\"px-4 pb-2\">\n              <VideoTimeline\n                duration={duration}\n                currentTime={currentTime}\n                timestamps={video.timestamps}\n                bookmarks={bookmarks}\n                buffered={buffered}\n                onSeek={seek}\n                onTimestampClick={handleTimelineClick}\n                className=\"mb-4\"\n              />\n            </div>\n\n            {/* Control Buttons */}\n            <div className=\"px-4 pb-4\">\n              <div className=\"flex items-center justify-between\">\n                {/* Left Controls */}\n                <div className=\"flex items-center space-x-2\">\n                  {/* Play/Pause */}\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={togglePlayPause}\n                    className=\"text-white hover:bg-white/20\"\n                  >\n                    {isPlaying ? (\n                      <Pause className=\"h-5 w-5\" />\n                    ) : (\n                      <Play className=\"h-5 w-5\" />\n                    )}\n                  </Button>\n\n                  {/* Previous/Next Scene */}\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={jumpToPreviousScene}\n                    className=\"text-white hover:bg-white/20\"\n                  >\n                    <SkipBack className=\"h-4 w-4\" />\n                  </Button>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={jumpToNextScene}\n                    className=\"text-white hover:bg-white/20\"\n                  >\n                    <SkipForward className=\"h-4 w-4\" />\n                  </Button>\n\n                  {/* Volume */}\n                  <div className=\"flex items-center space-x-2\">\n                    <Button\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      onClick={toggleMute}\n                      className=\"text-white hover:bg-white/20\"\n                    >\n                      {isMuted || volume === 0 ? (\n                        <VolumeX className=\"h-4 w-4\" />\n                      ) : (\n                        <Volume2 className=\"h-4 w-4\" />\n                      )}\n                    </Button>\n                    <div className=\"w-24\">\n                      <Slider\n                        value={[isMuted ? 0 : volume]}\n                        onValueChange={handleVolumeChange}\n                        min={0}\n                        max={1}\n                        step={0.1}\n                        className=\"cursor-pointer\"\n                      />\n                    </div>\n                  </div>\n\n                  {/* Time Display */}\n                  <div className=\"text-white text-sm font-mono ml-4\">\n                    {formatTime(currentTime)} / {formatTime(duration)}\n                  </div>\n                </div>\n\n                {/* Right Controls */}\n                <div className=\"flex items-center space-x-2\">\n                  {/* Bookmark */}\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={handleBookmarkToggle}\n                    className={cn(\n                      'text-white hover:bg-white/20',\n                      isBookmarked(currentTime) && 'text-yellow-400'\n                    )}\n                  >\n                    <Bookmark className=\"h-4 w-4\" />\n                  </Button>\n\n                  {/* Settings */}\n                  <Popover open={showSettings} onOpenChange={setShowSettings}>\n                    <PopoverTrigger asChild>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        className=\"text-white hover:bg-white/20\"\n                      >\n                        <Settings className=\"h-4 w-4\" />\n                      </Button>\n                    </PopoverTrigger>\n                    <PopoverContent className=\"w-48\" align=\"end\">\n                      <div className=\"space-y-2\">\n                        <div>\n                          <label className=\"text-sm font-medium\">Playback Speed</label>\n                          <Select\n                            value={playbackRate.toString()}\n                            onValueChange={handlePlaybackRateChange}\n                          >\n                            <SelectTrigger className=\"w-full mt-1\">\n                              <SelectValue />\n                            </SelectTrigger>\n                            <SelectContent>\n                              <SelectItem value=\"0.5\">0.5x</SelectItem>\n                              <SelectItem value=\"0.75\">0.75x</SelectItem>\n                              <SelectItem value=\"1\">1x (Normal)</SelectItem>\n                              <SelectItem value=\"1.25\">1.25x</SelectItem>\n                              <SelectItem value=\"1.5\">1.5x</SelectItem>\n                              <SelectItem value=\"2\">2x</SelectItem>\n                            </SelectContent>\n                          </Select>\n                        </div>\n                      </div>\n                    </PopoverContent>\n                  </Popover>\n\n                  {/* Fullscreen */}\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={toggleFullscreen}\n                    className=\"text-white hover:bg-white/20\"\n                  >\n                    {isFullscreen ? (\n                      <Minimize2 className=\"h-4 w-4\" />\n                    ) : (\n                      <Maximize2 className=\"h-4 w-4\" />\n                    )}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Current Scene Info Overlay */}\n          {showSceneInfo && currentScene && !isFullscreen && (\n            <div className=\"absolute top-4 left-4 right-4\">\n              <Card className=\"bg-black/70 backdrop-blur-sm text-white\">\n                <CardContent className=\"p-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"flex items-center space-x-3\">\n                      <div className={cn('p-2 rounded', getSceneColor(currentScene.sceneType))}>\n                        {getSceneIcon(currentScene.sceneType)}\n                      </div>\n                      <div>\n                        <p className=\"font-medium\">\n                          {currentScene.roomDetected || 'Scene'} - {currentScene.sceneType.replace(/_/g, ' ')}\n                        </p>\n                        <p className=\"text-sm opacity-80\">{currentScene.description}</p>\n                      </div>\n                    </div>\n                    <Badge variant=\"secondary\" className=\"bg-white/20\">\n                      {currentScene.confidence}% confidence\n                    </Badge>\n                  </div>\n                  {currentScene.features.length > 0 && (\n                    <div className=\"mt-2 flex flex-wrap gap-1\">\n                      {currentScene.features.map((feature, index) => (\n                        <Badge key={index} variant=\"outline\" className=\"text-xs border-white/20 text-white\">\n                          {feature}\n                        </Badge>\n                      ))}\n                    </div>\n                  )}\n                </CardContent>\n              </Card>\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\n// Quick navigation component\nexport const VideoQuickNav: React.FC<{\n  timestamps: VideoTimestamp[];\n  currentTime: number;\n  onJump: (timestamp: VideoTimestamp) => void;\n  className?: string;\n}> = ({ timestamps, currentTime, onJump, className }) => {\n  // Group timestamps by room\n  const roomGroups = timestamps.reduce((acc, ts) => {\n    const room = ts.roomDetected || 'Other';\n    if (!acc[room]) acc[room] = [];\n    acc[room].push(ts);\n    return acc;\n  }, {} as Record<string, VideoTimestamp[]>);\n\n  return (\n    <div className={cn('space-y-2', className)}>\n      <h3 className=\"text-sm font-medium text-muted-foreground\">Quick Navigation</h3>\n      {Object.entries(roomGroups).map(([room, roomTimestamps]) => (\n        <div key={room} className=\"space-y-1\">\n          <p className=\"text-sm font-medium\">{room}</p>\n          <div className=\"flex flex-wrap gap-1\">\n            {roomTimestamps.map((ts) => {\n              const isActive = Math.abs(ts.time - currentTime) < 5;\n              return (\n                <Button\n                  key={ts.id}\n                  variant={isActive ? 'default' : 'outline'}\n                  size=\"sm\"\n                  onClick={() => onJump(ts)}\n                  className=\"text-xs\"\n                >\n                  <Clock className=\"h-3 w-3 mr-1\" />\n                  {formatTime(ts.time)}\n                </Button>\n              );\n            })}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n\n// Helper function\nfunction formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/audit/VideoTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/error/ErrorFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/mobile/OfflineSync.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[896,899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[896,899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2569,2572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2569,2572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2796,2799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2796,2799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Progress } from '@/components/ui/progress';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { \n  Upload, \n  Download, \n  Wifi, \n  WifiOff, \n  CheckCircle, \n  AlertTriangle,\n  RefreshCw,\n  HardDrive,\n  Clock,\n  X\n} from 'lucide-react';\nimport { syncService } from '@/services/syncService';\nimport { offlineStorageService } from '@/services/offlineStorageService';\nimport { logger } from '@/utils/logger';\n\n// Types from InspectorWorkflow\ninterface InspectionStep {\n  id: string;\n  title: string;\n  description: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'error';\n  required: boolean;\n  data?: any;\n}\n\ninterface OfflineSyncProps {\n  inspectionData: InspectionStep[];\n  propertyId?: string;\n  onSyncComplete: () => void;\n  progress?: number;\n}\n\ninterface SyncItem {\n  id: string;\n  type: 'checklist' | 'photo' | 'video' | 'metadata';\n  name: string;\n  size: number;\n  status: 'pending' | 'syncing' | 'completed' | 'error';\n  progress: number;\n  error?: string;\n}\n\nexport function OfflineSync({ \n  inspectionData, \n  propertyId, \n  onSyncComplete,\n  progress: externalProgress = 0\n}: OfflineSyncProps) {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [syncItems, setSyncItems] = useState<SyncItem[]>([]);\n  const [overallProgress, setOverallProgress] = useState(0);\n  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'completed' | 'error'>('idle');\n  const [currentSyncItem, setCurrentSyncItem] = useState<string | null>(null);\n  const [totalSize, setTotalSize] = useState(0);\n  const [uploadedSize, setUploadedSize] = useState(0);\n  const [estimatedTimeRemaining, setEstimatedTimeRemaining] = useState(0);\n  const [syncSpeed, setSyncSpeed] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  const [realSyncProgress, setRealSyncProgress] = useState({ current: 0, total: 0, status: 'idle' });\n  const [pendingItems, setPendingItems] = useState(0);\n\n  // Monitor online status and sync service\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Setup sync service listeners\n    const syncProgressListener = (progress: any) => {\n      setRealSyncProgress(progress);\n      setOverallProgress(progress.total > 0 ? (progress.current / progress.total) * 100 : 0);\n      setSyncStatus(progress.status);\n    };\n\n    const syncStatusListener = (status: any) => {\n      setIsOnline(status.isOnline);\n      setPendingItems(status.totalSyncItems);\n    };\n\n    syncService.addSyncListener(syncProgressListener);\n    syncService.addStatusListener(syncStatusListener);\n\n    // Get initial sync status\n    syncService.getSyncStatus().then(status => {\n      setPendingItems(status.totalSyncItems);\n    });\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n      syncService.removeSyncListener(syncProgressListener);\n      syncService.removeStatusListener(syncStatusListener);\n    };\n  }, []);\n\n  // Generate sync items from inspection data\n  useEffect(() => {\n    if (inspectionData.length > 0) {\n      const items: SyncItem[] = [];\n      let totalSizeCalc = 0;\n\n      // Add checklist data\n      items.push({\n        id: 'checklist_data',\n        type: 'checklist',\n        name: 'Checklist Data',\n        size: 50 * 1024, // 50KB\n        status: 'pending',\n        progress: 0\n      });\n      totalSizeCalc += 50 * 1024;\n\n      // Add photos from completed steps\n      inspectionData.forEach((step, index) => {\n        if (step.status === 'completed' && step.data) {\n          items.push({\n            id: `photo_${step.id}`,\n            type: 'photo',\n            name: `Photo - ${step.title}`,\n            size: 2 * 1024 * 1024, // 2MB per photo\n            status: 'pending',\n            progress: 0\n          });\n          totalSizeCalc += 2 * 1024 * 1024;\n        }\n      });\n\n      // Add video if available\n      const videoStep = inspectionData.find(step => step.id === 'video_walkthrough');\n      if (videoStep && videoStep.status === 'completed') {\n        items.push({\n          id: 'video_walkthrough',\n          type: 'video',\n          name: 'Property Video Walkthrough',\n          size: 100 * 1024 * 1024, // 100MB\n          status: 'pending',\n          progress: 0\n        });\n        totalSizeCalc += 100 * 1024 * 1024;\n      }\n\n      // Add metadata\n      items.push({\n        id: 'metadata',\n        type: 'metadata',\n        name: 'Inspection Metadata',\n        size: 10 * 1024, // 10KB\n        status: 'pending',\n        progress: 0\n      });\n      totalSizeCalc += 10 * 1024;\n\n      setSyncItems(items);\n      setTotalSize(totalSizeCalc);\n    }\n  }, [inspectionData]);\n\n  // Format file size\n  const formatFileSize = (bytes: number): string => {\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  };\n\n  // Format time\n  const formatTime = (seconds: number): string => {\n    if (seconds < 60) return `${Math.round(seconds)}s`;\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = Math.round(seconds % 60);\n    return `${minutes}m ${remainingSeconds}s`;\n  };\n\n  // Format sync speed\n  const formatSpeed = (bytesPerSecond: number): string => {\n    if (bytesPerSecond < 1024) return `${bytesPerSecond.toFixed(0)} B/s`;\n    if (bytesPerSecond < 1024 * 1024) return `${(bytesPerSecond / 1024).toFixed(1)} KB/s`;\n    return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`;\n  };\n\n  // Simulate sync process\n  const simulateSyncItem = useCallback(async (item: SyncItem): Promise<void> => {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      let bytesUploaded = 0;\n      \n      const interval = setInterval(() => {\n        const elapsed = Date.now() - startTime;\n        const increment = Math.min(item.size / 20, item.size - bytesUploaded); // Upload in 20 chunks\n        bytesUploaded += increment;\n        \n        const progress = (bytesUploaded / item.size) * 100;\n        \n        // Update item progress\n        setSyncItems(prev => prev.map(i => \n          i.id === item.id ? { ...i, progress, status: 'syncing' } : i\n        ));\n        \n        // Update overall progress\n        setUploadedSize(prev => prev + increment);\n        \n        // Calculate speed\n        const speed = bytesUploaded / (elapsed / 1000);\n        setSyncSpeed(speed);\n        \n        // Calculate time remaining\n        const remainingBytes = totalSize - uploadedSize - bytesUploaded;\n        const timeRemaining = remainingBytes / speed;\n        setEstimatedTimeRemaining(timeRemaining);\n        \n        // Complete this item\n        if (bytesUploaded >= item.size) {\n          clearInterval(interval);\n          setSyncItems(prev => prev.map(i => \n            i.id === item.id ? { ...i, progress: 100, status: 'completed' } : i\n          ));\n          \n          // Simulate potential errors (5% chance)\n          if (Math.random() < 0.05) {\n            setSyncItems(prev => prev.map(i => \n              i.id === item.id ? { ...i, status: 'error', error: 'Upload failed' } : i\n            ));\n            reject(new Error('Upload failed'));\n          } else {\n            resolve();\n          }\n        }\n      }, 100);\n    });\n  }, [totalSize, uploadedSize]);\n\n  // Start sync process using real sync service\n  const startSync = useCallback(async () => {\n    if (!isOnline) {\n      setError('No internet connection. Please check your connection and try again.');\n      return;\n    }\n\n    setSyncStatus('syncing');\n    setError(null);\n    setOverallProgress(0);\n    setUploadedSize(0);\n\n    try {\n      logger.info('Starting sync from OfflineSync component', {}, 'OFFLINE_SYNC');\n      \n      // Use real sync service\n      const syncResult = await syncService.forceSyncNow();\n      \n      if (syncResult) {\n        setSyncStatus('completed');\n        setCurrentSyncItem(null);\n        onSyncComplete();\n        \n        logger.info('Sync completed successfully', {}, 'OFFLINE_SYNC');\n      } else {\n        throw new Error('Sync failed');\n      }\n      \n    } catch (err) {\n      setSyncStatus('error');\n      const errorMessage = err instanceof Error ? err.message : 'Sync failed';\n      setError(errorMessage);\n      logger.error('Sync failed', err, 'OFFLINE_SYNC');\n    }\n  }, [isOnline, onSyncComplete]);\n\n  // Retry failed items using real sync service\n  const retryFailedItems = useCallback(async () => {\n    setSyncStatus('syncing');\n    setError(null);\n    \n    try {\n      logger.info('Retrying failed sync items', {}, 'OFFLINE_SYNC');\n      \n      // Clear failed items and retry\n      await syncService.retryFailedSyncItems();\n      \n      // Force sync again\n      const syncResult = await syncService.forceSyncNow();\n      \n      if (syncResult) {\n        setSyncStatus('completed');\n        setCurrentSyncItem(null);\n        onSyncComplete();\n      } else {\n        throw new Error('Retry failed');\n      }\n      \n    } catch (err) {\n      setSyncStatus('error');\n      const errorMessage = err instanceof Error ? err.message : 'Retry failed';\n      setError(errorMessage);\n      logger.error('Retry failed', err, 'OFFLINE_SYNC');\n    }\n  }, [onSyncComplete]);\n\n  const getStatusIcon = (status: string) => {\n    switch (status) {\n      case 'completed': return <CheckCircle className=\"h-4 w-4 text-green-500\" />;\n      case 'error': return <AlertTriangle className=\"h-4 w-4 text-red-500\" />;\n      case 'syncing': return <RefreshCw className=\"h-4 w-4 animate-spin text-blue-500\" />;\n      default: return <Clock className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  const getTypeIcon = (type: string) => {\n    switch (type) {\n      case 'photo': return 'ðŸ“¸';\n      case 'video': return 'ðŸŽ¥';\n      case 'checklist': return 'ðŸ“‹';\n      case 'metadata': return 'ðŸ“„';\n      default: return 'ðŸ“';\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Connection Status */}\n      <Card className={`border-2 ${isOnline ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}`}>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            {isOnline ? <Wifi className=\"h-5 w-5 text-green-600\" /> : <WifiOff className=\"h-5 w-5 text-red-600\" />}\n            {isOnline ? 'Online' : 'Offline'}\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm text-gray-600\">\n                {isOnline ? \n                  'Ready to sync inspection data to cloud storage' : \n                  'No internet connection. Data will sync when connection is restored.'\n                }\n              </p>\n              {pendingItems > 0 && (\n                <p className=\"text-sm font-medium mt-1\">\n                  {pendingItems} items ready to sync\n                </p>\n              )}\n            </div>\n            \n            {syncStatus === 'idle' && isOnline && (\n              <Button \n                onClick={startSync} \n                disabled={pendingItems === 0}\n                className=\"h-12 px-6 text-base touch-manipulation\"\n              >\n                <Upload className=\"h-5 w-5 mr-2\" />\n                Start Sync\n              </Button>\n            )}\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Sync Progress */}\n      {syncStatus === 'syncing' && (\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center gap-2\">\n              <RefreshCw className=\"h-5 w-5 animate-spin text-blue-500\" />\n              Syncing Data\n            </CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            {/* Overall Progress */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between text-sm\">\n                <span>Overall Progress</span>\n                <span>{Math.round(overallProgress)}%</span>\n              </div>\n              <Progress value={overallProgress} className=\"h-2\" />\n            </div>\n\n            {/* Sync Stats */}\n            <div className=\"grid grid-cols-2 gap-4 text-sm\">\n              <div>\n                <span className=\"text-gray-600\">Progress:</span>\n                <span className=\"font-medium ml-2\">{realSyncProgress.current} / {realSyncProgress.total}</span>\n              </div>\n              <div>\n                <span className=\"text-gray-600\">Status:</span>\n                <span className=\"font-medium ml-2\">{realSyncProgress.status}</span>\n              </div>\n              <div>\n                <span className=\"text-gray-600\">Pending:</span>\n                <span className=\"font-medium ml-2\">{pendingItems} items</span>\n              </div>\n              <div>\n                <span className=\"text-gray-600\">Connection:</span>\n                <span className=\"font-medium ml-2\">{isOnline ? 'Online' : 'Offline'}</span>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Sync Items */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Sync Items</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-3\">\n            {syncItems.map((item) => (\n              <div\n                key={item.id}\n                className={`p-3 rounded-lg border ${\n                  currentSyncItem === item.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'\n                }`}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-3\">\n                    <span className=\"text-lg\">{getTypeIcon(item.type)}</span>\n                    <div>\n                      <h4 className=\"font-medium\">{item.name}</h4>\n                      <p className=\"text-sm text-gray-600\">{formatFileSize(item.size)}</p>\n                    </div>\n                  </div>\n                  \n                  <div className=\"flex items-center gap-2\">\n                    {item.status === 'syncing' && (\n                      <span className=\"text-sm text-blue-600\">{Math.round(item.progress)}%</span>\n                    )}\n                    {getStatusIcon(item.status)}\n                  </div>\n                </div>\n                \n                {item.status === 'syncing' && (\n                  <div className=\"mt-2\">\n                    <Progress value={item.progress} className=\"h-1\" />\n                  </div>\n                )}\n                \n                {item.status === 'error' && item.error && (\n                  <div className=\"mt-2\">\n                    <Alert variant=\"destructive\" className=\"py-2\">\n                      <AlertTriangle className=\"h-3 w-3\" />\n                      <AlertDescription className=\"text-xs\">\n                        {item.error}\n                      </AlertDescription>\n                    </Alert>\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Error State */}\n      {error && (\n        <Alert variant=\"destructive\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertTitle>Sync Error</AlertTitle>\n          <AlertDescription className=\"mt-2\">\n            {error}\n            <div className=\"flex gap-2 mt-2\">\n              <Button \n                variant=\"outline\" \n                size=\"sm\" \n                onClick={retryFailedItems}\n                className=\"h-10 px-4 text-base touch-manipulation\"\n              >\n                <RefreshCw className=\"h-4 w-4 mr-2\" />\n                Retry Failed Items\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Completion State */}\n      {syncStatus === 'completed' && (\n        <Card className=\"border-green-200 bg-green-50\">\n          <CardContent className=\"text-center py-8\">\n            <CheckCircle className=\"h-12 w-12 mx-auto text-green-500 mb-4\" />\n            <h3 className=\"text-lg font-medium text-green-800 mb-2\">\n              Sync Complete!\n            </h3>\n            <p className=\"text-green-700\">\n              All inspection data has been successfully uploaded to the cloud.\n            </p>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Offline Tips */}\n      {!isOnline && (\n        <Alert>\n          <WifiOff className=\"h-4 w-4\" />\n          <AlertTitle>Working Offline</AlertTitle>\n          <AlertDescription>\n            Your inspection data is saved locally and will automatically sync when you're back online.\n            You can continue working on other inspections in the meantime.\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};\n\nexport default OfflineSync;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/mobile/OfflineSyncManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1431,1434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1431,1434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1596,1599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1596,1599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1677,1680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1677,1680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1699,1702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1699,1702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadSyncQueue', 'startAutoSync', and 'startSync'. Either include them or remove the dependency array.","line":142,"column":6,"nodeType":"ArrayExpression","endLine":142,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [autoSync, loadSyncQueue, startAutoSync, startSync]","fix":{"range":[3813,3823],"text":"[autoSync, loadSyncQueue, startAutoSync, startSync]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":268,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":268,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7432,7435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7432,7435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":701,"column":130,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":701,"endColumn":133,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22750,22753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22750,22753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Offline Sync Manager Component for STR Certified\n// Handles offline data storage, sync, and conflict resolution\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { Label } from '@/components/ui/label';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Separator } from '@/components/ui/separator';\nimport {\n  Cloud,\n  CloudOff,\n  Download,\n  Upload,\n  RefreshCw,\n  Wifi,\n  WifiOff,\n  Check,\n  X,\n  AlertTriangle,\n  Database,\n  HardDrive,\n  Smartphone,\n  Clock,\n  ArrowUpDown,\n  FileWarning,\n  CheckCircle,\n  Info,\n  Loader2,\n  Zap,\n  Shield\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useQuery, useMutation } from '@tanstack/react-query';\n\ninterface OfflineSyncManagerProps {\n  className?: string;\n}\n\ninterface SyncItem {\n  id: string;\n  type: 'inspection' | 'photo' | 'video' | 'checklist' | 'report';\n  action: 'create' | 'update' | 'delete';\n  data: any;\n  size: number;\n  timestamp: Date;\n  retries: number;\n  status: 'pending' | 'syncing' | 'completed' | 'failed' | 'conflict';\n  error?: string;\n  conflictData?: any;\n}\n\ninterface SyncConflict {\n  id: string;\n  item: SyncItem;\n  localVersion: any;\n  remoteVersion: any;\n  detectedAt: Date;\n  resolution?: 'local' | 'remote' | 'merge';\n}\n\ninterface SyncStatus {\n  isOnline: boolean;\n  isSyncing: boolean;\n  pendingItems: number;\n  failedItems: number;\n  conflicts: number;\n  lastSync: Date | null;\n  dataUsage: {\n    uploaded: number;\n    downloaded: number;\n  };\n}\n\nexport const OfflineSyncManager: React.FC<OfflineSyncManagerProps> = ({\n  className\n}) => {\n  // State\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    isOnline: navigator.onLine,\n    isSyncing: false,\n    pendingItems: 0,\n    failedItems: 0,\n    conflicts: 0,\n    lastSync: null,\n    dataUsage: {\n      uploaded: 0,\n      downloaded: 0\n    }\n  });\n  const [syncQueue, setSyncQueue] = useState<SyncItem[]>([]);\n  const [conflicts, setConflicts] = useState<SyncConflict[]>([]);\n  const [selectedConflict, setSelectedConflict] = useState<SyncConflict | null>(null);\n  const [syncProgress, setSyncProgress] = useState(0);\n  const [autoSync, setAutoSync] = useState(true);\n  const [showDetails, setShowDetails] = useState(false);\n\n  // Refs\n  const syncWorker = useRef<Worker | null>(null);\n  const syncInterval = useRef<NodeJS.Timeout | null>(null);\n\n  // Initialize sync worker\n  useEffect(() => {\n    // In production, would use actual Web Worker\n    // syncWorker.current = new Worker('/workers/sync-worker.js');\n\n    // Monitor online status\n    const handleOnline = () => {\n      setSyncStatus(prev => ({ ...prev, isOnline: true }));\n      if (autoSync) {\n        startSync();\n      }\n    };\n\n    const handleOffline = () => {\n      setSyncStatus(prev => ({ ...prev, isOnline: false }));\n    };\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Load saved sync queue\n    loadSyncQueue();\n\n    // Start auto-sync if online\n    if (navigator.onLine && autoSync) {\n      startAutoSync();\n    }\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n      if (syncInterval.current) {\n        clearInterval(syncInterval.current);\n      }\n    };\n  }, [autoSync]);\n\n  // Load sync queue from storage\n  const loadSyncQueue = async () => {\n    try {\n      const stored = localStorage.getItem('syncQueue');\n      if (stored) {\n        const queue = JSON.parse(stored);\n        setSyncQueue(queue);\n        updateSyncStatus(queue);\n      }\n    } catch (error) {\n      console.error('Failed to load sync queue:', error);\n    }\n  };\n\n  // Save sync queue to storage\n  const saveSyncQueue = useCallback((queue: SyncItem[]) => {\n    try {\n      localStorage.setItem('syncQueue', JSON.stringify(queue));\n      setSyncQueue(queue);\n      updateSyncStatus(queue);\n    } catch (error) {\n      console.error('Failed to save sync queue:', error);\n    }\n  }, []);\n\n  // Update sync status based on queue\n  const updateSyncStatus = (queue: SyncItem[]) => {\n    const pending = queue.filter(item => item.status === 'pending').length;\n    const failed = queue.filter(item => item.status === 'failed').length;\n    const conflictCount = queue.filter(item => item.status === 'conflict').length;\n\n    setSyncStatus(prev => ({\n      ...prev,\n      pendingItems: pending,\n      failedItems: failed,\n      conflicts: conflictCount\n    }));\n  };\n\n  // Start auto-sync\n  const startAutoSync = () => {\n    if (syncInterval.current) {\n      clearInterval(syncInterval.current);\n    }\n\n    syncInterval.current = setInterval(() => {\n      if (navigator.onLine && !syncStatus.isSyncing) {\n        startSync();\n      }\n    }, 30000); // Every 30 seconds\n  };\n\n  // Start manual sync\n  const startSync = async () => {\n    if (!navigator.onLine || syncStatus.isSyncing) return;\n\n    setSyncStatus(prev => ({ ...prev, isSyncing: true }));\n    setSyncProgress(0);\n\n    try {\n      const queue = [...syncQueue];\n      const totalItems = queue.filter(item => \n        item.status === 'pending' || item.status === 'failed'\n      ).length;\n\n      let processed = 0;\n\n      for (const item of queue) {\n        if (item.status === 'pending' || item.status === 'failed') {\n          const result = await syncItem(item);\n          \n          if (result.success) {\n            item.status = 'completed';\n            setSyncStatus(prev => ({\n              ...prev,\n              dataUsage: {\n                uploaded: prev.dataUsage.uploaded + (item.size || 0),\n                downloaded: prev.dataUsage.downloaded\n              }\n            }));\n          } else if (result.conflict) {\n            item.status = 'conflict';\n            const conflict: SyncConflict = {\n              id: `conflict_${Date.now()}`,\n              item,\n              localVersion: item.data,\n              remoteVersion: result.remoteData,\n              detectedAt: new Date()\n            };\n            setConflicts(prev => [...prev, conflict]);\n          } else {\n            item.status = 'failed';\n            item.error = result.error;\n            item.retries++;\n          }\n\n          processed++;\n          setSyncProgress((processed / totalItems) * 100);\n        }\n      }\n\n      // Clean up completed items\n      const updatedQueue = queue.filter(item => \n        item.status !== 'completed' || \n        (Date.now() - item.timestamp.getTime()) < 24 * 60 * 60 * 1000 // Keep for 24h\n      );\n\n      saveSyncQueue(updatedQueue);\n      setSyncStatus(prev => ({\n        ...prev,\n        isSyncing: false,\n        lastSync: new Date()\n      }));\n\n    } catch (error) {\n      console.error('Sync failed:', error);\n      setSyncStatus(prev => ({ ...prev, isSyncing: false }));\n    }\n  };\n\n  // Sync individual item\n  const syncItem = async (item: SyncItem): Promise<{\n    success: boolean;\n    conflict?: boolean;\n    remoteData?: any;\n    error?: string;\n  }> => {\n    // Simulate API call\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        // Mock sync logic\n        const random = Math.random();\n        if (random > 0.9) {\n          // Simulate conflict\n          resolve({\n            success: false,\n            conflict: true,\n            remoteData: { ...item.data, updated: 'remote' }\n          });\n        } else if (random > 0.8) {\n          // Simulate failure\n          resolve({\n            success: false,\n            error: 'Network timeout'\n          });\n        } else {\n          // Success\n          resolve({ success: true });\n        }\n      }, 500 + Math.random() * 1000);\n    });\n  };\n\n  // Add item to sync queue\n  const addToSyncQueue = (item: Omit<SyncItem, 'id' | 'timestamp' | 'retries' | 'status'>) => {\n    const newItem: SyncItem = {\n      ...item,\n      id: `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date(),\n      retries: 0,\n      status: 'pending'\n    };\n\n    const updatedQueue = [...syncQueue, newItem];\n    saveSyncQueue(updatedQueue);\n\n    // Auto-sync if online\n    if (navigator.onLine && autoSync) {\n      setTimeout(() => startSync(), 1000);\n    }\n  };\n\n  // Resolve conflict\n  const resolveConflict = async (conflictId: string, resolution: 'local' | 'remote' | 'merge') => {\n    const conflict = conflicts.find(c => c.id === conflictId);\n    if (!conflict) return;\n\n    conflict.resolution = resolution;\n\n    // Apply resolution\n    let resolvedData;\n    switch (resolution) {\n      case 'local':\n        resolvedData = conflict.localVersion;\n        break;\n      case 'remote':\n        resolvedData = conflict.remoteVersion;\n        break;\n      case 'merge':\n        // Simple merge - in production would be more sophisticated\n        resolvedData = { ...conflict.remoteVersion, ...conflict.localVersion };\n        break;\n    }\n\n    // Update sync item\n    const queueIndex = syncQueue.findIndex(item => item.id === conflict.item.id);\n    if (queueIndex !== -1) {\n      syncQueue[queueIndex].data = resolvedData;\n      syncQueue[queueIndex].status = 'pending';\n      saveSyncQueue(syncQueue);\n    }\n\n    // Remove conflict\n    setConflicts(prev => prev.filter(c => c.id !== conflictId));\n    setSelectedConflict(null);\n\n    // Retry sync\n    if (navigator.onLine) {\n      startSync();\n    }\n  };\n\n  // Clear sync queue\n  const clearSyncQueue = () => {\n    if (confirm('Are you sure you want to clear all pending sync items? This action cannot be undone.')) {\n      setSyncQueue([]);\n      localStorage.removeItem('syncQueue');\n      updateSyncStatus([]);\n    }\n  };\n\n  // Get storage info\n  const getStorageInfo = async (): Promise<{\n    used: number;\n    quota: number;\n    percentage: number;\n  }> => {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      const used = estimate.usage || 0;\n      const quota = estimate.quota || 0;\n      return {\n        used,\n        quota,\n        percentage: quota > 0 ? (used / quota) * 100 : 0\n      };\n    }\n    return { used: 0, quota: 0, percentage: 0 };\n  };\n\n  // Format bytes\n  const formatBytes = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  // Format time ago\n  const formatTimeAgo = (date: Date | null): string => {\n    if (!date) return 'Never';\n    const seconds = Math.floor((Date.now() - date.getTime()) / 1000);\n    if (seconds < 60) return 'Just now';\n    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;\n    if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;\n    return `${Math.floor(seconds / 86400)}d ago`;\n  };\n\n  // Get status color\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'completed': return 'text-green-600 bg-green-50';\n      case 'syncing': return 'text-blue-600 bg-blue-50';\n      case 'failed': return 'text-red-600 bg-red-50';\n      case 'conflict': return 'text-orange-600 bg-orange-50';\n      default: return 'text-gray-600 bg-gray-50';\n    }\n  };\n\n  // Get type icon\n  const getTypeIcon = (type: string) => {\n    switch (type) {\n      case 'inspection': return <FileWarning className=\"h-4 w-4\" />;\n      case 'photo': return <Database className=\"h-4 w-4\" />;\n      case 'video': return <HardDrive className=\"h-4 w-4\" />;\n      case 'checklist': return <CheckCircle className=\"h-4 w-4\" />;\n      case 'report': return <Info className=\"h-4 w-4\" />;\n      default: return <Database className=\"h-4 w-4\" />;\n    }\n  };\n\n  return (\n    <div className={cn('space-y-4', className)}>\n      {/* Main Status Card */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-2\">\n              <CardTitle>Offline Sync Manager</CardTitle>\n              <Badge variant={syncStatus.isOnline ? 'default' : 'secondary'}>\n                {syncStatus.isOnline ? (\n                  <>\n                    <Wifi className=\"h-3 w-3 mr-1\" />\n                    Online\n                  </>\n                ) : (\n                  <>\n                    <WifiOff className=\"h-3 w-3 mr-1\" />\n                    Offline\n                  </>\n                )}\n              </Badge>\n            </div>\n            <div className=\"flex items-center space-x-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setShowDetails(!showDetails)}\n              >\n                {showDetails ? 'Hide' : 'Show'} Details\n              </Button>\n              <Button\n                size=\"sm\"\n                onClick={() => startSync()}\n                disabled={!syncStatus.isOnline || syncStatus.isSyncing}\n              >\n                {syncStatus.isSyncing ? (\n                  <>\n                    <Loader2 className=\"h-4 w-4 mr-2 animate-spin\" />\n                    Syncing...\n                  </>\n                ) : (\n                  <>\n                    <RefreshCw className=\"h-4 w-4 mr-2\" />\n                    Sync Now\n                  </>\n                )}\n              </Button>\n            </div>\n          </div>\n        </CardHeader>\n        <CardContent>\n          {/* Sync Progress */}\n          {syncStatus.isSyncing && (\n            <div className=\"mb-4\">\n              <div className=\"flex items-center justify-between text-sm mb-1\">\n                <span>Syncing...</span>\n                <span>{Math.round(syncProgress)}%</span>\n              </div>\n              <Progress value={syncProgress} className=\"h-2\" />\n            </div>\n          )}\n\n          {/* Status Overview */}\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold\">{syncStatus.pendingItems}</div>\n              <p className=\"text-xs text-muted-foreground\">Pending</p>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-red-600\">{syncStatus.failedItems}</div>\n              <p className=\"text-xs text-muted-foreground\">Failed</p>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-orange-600\">{syncStatus.conflicts}</div>\n              <p className=\"text-xs text-muted-foreground\">Conflicts</p>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-sm font-medium\">\n                {formatTimeAgo(syncStatus.lastSync)}\n              </div>\n              <p className=\"text-xs text-muted-foreground\">Last Sync</p>\n            </div>\n          </div>\n\n          {/* Data Usage */}\n          <div className=\"mt-4 pt-4 border-t\">\n            <div className=\"flex items-center justify-between text-sm\">\n              <div className=\"flex items-center space-x-2\">\n                <Upload className=\"h-4 w-4 text-muted-foreground\" />\n                <span>Uploaded: {formatBytes(syncStatus.dataUsage.uploaded)}</span>\n              </div>\n              <div className=\"flex items-center space-x-2\">\n                <Download className=\"h-4 w-4 text-muted-foreground\" />\n                <span>Downloaded: {formatBytes(syncStatus.dataUsage.downloaded)}</span>\n              </div>\n            </div>\n          </div>\n\n          {/* Auto-sync Toggle */}\n          <div className=\"mt-4 flex items-center justify-between\">\n            <div className=\"flex items-center space-x-2\">\n              <Zap className=\"h-4 w-4 text-muted-foreground\" />\n              <span className=\"text-sm font-medium\">Auto-sync when online</span>\n            </div>\n            <Button\n              variant={autoSync ? 'default' : 'outline'}\n              size=\"sm\"\n              onClick={() => setAutoSync(!autoSync)}\n            >\n              {autoSync ? 'Enabled' : 'Disabled'}\n            </Button>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Alerts */}\n      {syncStatus.conflicts > 0 && (\n        <Alert>\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertTitle>Sync Conflicts Detected</AlertTitle>\n          <AlertDescription>\n            {syncStatus.conflicts} items have conflicts that need resolution.\n            <Button\n              variant=\"link\"\n              size=\"sm\"\n              className=\"ml-2\"\n              onClick={() => setShowDetails(true)}\n            >\n              View Conflicts\n            </Button>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {!syncStatus.isOnline && (\n        <Alert>\n          <WifiOff className=\"h-4 w-4\" />\n          <AlertTitle>Working Offline</AlertTitle>\n          <AlertDescription>\n            Your changes are being saved locally and will sync when you're back online.\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Detailed View */}\n      {showDetails && (\n        <Card>\n          <CardHeader>\n            <CardTitle>Sync Queue Details</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <ScrollArea className=\"h-96\">\n              <div className=\"space-y-2\">\n                {syncQueue.length === 0 ? (\n                  <p className=\"text-center text-muted-foreground py-8\">\n                    No items in sync queue\n                  </p>\n                ) : (\n                  syncQueue.map((item) => (\n                    <div\n                      key={item.id}\n                      className=\"flex items-center justify-between p-3 border rounded-lg\"\n                    >\n                      <div className=\"flex items-center space-x-3\">\n                        {getTypeIcon(item.type)}\n                        <div>\n                          <p className=\"text-sm font-medium\">\n                            {item.type.charAt(0).toUpperCase() + item.type.slice(1)} - {item.action}\n                          </p>\n                          <p className=\"text-xs text-muted-foreground\">\n                            {formatBytes(item.size)} â€¢ {formatTimeAgo(item.timestamp)}\n                          </p>\n                        </div>\n                      </div>\n                      <div className=\"flex items-center space-x-2\">\n                        <Badge className={cn('text-xs', getStatusColor(item.status))}>\n                          {item.status}\n                        </Badge>\n                        {item.status === 'conflict' && (\n                          <Button\n                            variant=\"outline\"\n                            size=\"sm\"\n                            onClick={() => {\n                              const conflict = conflicts.find(c => c.item.id === item.id);\n                              if (conflict) setSelectedConflict(conflict);\n                            }}\n                          >\n                            Resolve\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                  ))\n                )}\n              </div>\n            </ScrollArea>\n\n            {syncQueue.length > 0 && (\n              <div className=\"mt-4 pt-4 border-t\">\n                <Button\n                  variant=\"destructive\"\n                  size=\"sm\"\n                  onClick={clearSyncQueue}\n                >\n                  Clear Sync Queue\n                </Button>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Storage Info */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Local Storage</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <StorageInfo />\n        </CardContent>\n      </Card>\n\n      {/* Conflict Resolution Dialog */}\n      {selectedConflict && (\n        <Dialog open={!!selectedConflict} onOpenChange={() => setSelectedConflict(null)}>\n          <DialogContent className=\"max-w-2xl\">\n            <DialogHeader>\n              <DialogTitle>Resolve Sync Conflict</DialogTitle>\n              <DialogDescription>\n                Choose which version to keep or merge the changes.\n              </DialogDescription>\n            </DialogHeader>\n            \n            <div className=\"space-y-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <h4 className=\"text-sm font-medium mb-2\">Local Version</h4>\n                  <div className=\"p-3 border rounded-lg bg-gray-50\">\n                    <pre className=\"text-xs overflow-auto\">\n                      {JSON.stringify(selectedConflict.localVersion, null, 2)}\n                    </pre>\n                  </div>\n                </div>\n                <div>\n                  <h4 className=\"text-sm font-medium mb-2\">Remote Version</h4>\n                  <div className=\"p-3 border rounded-lg bg-gray-50\">\n                    <pre className=\"text-xs overflow-auto\">\n                      {JSON.stringify(selectedConflict.remoteVersion, null, 2)}\n                    </pre>\n                  </div>\n                </div>\n              </div>\n\n              <RadioGroup defaultValue=\"local\" className=\"space-y-2\">\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"local\" id=\"local\" />\n                  <Label htmlFor=\"local\">Keep local version</Label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"remote\" id=\"remote\" />\n                  <Label htmlFor=\"remote\">Keep remote version</Label>\n                </div>\n                <div className=\"flex items-center space-x-2\">\n                  <RadioGroupItem value=\"merge\" id=\"merge\" />\n                  <Label htmlFor=\"merge\">Merge both versions</Label>\n                </div>\n              </RadioGroup>\n            </div>\n\n            <DialogFooter>\n              <Button variant=\"outline\" onClick={() => setSelectedConflict(null)}>\n                Cancel\n              </Button>\n              <Button\n                onClick={() => {\n                  const resolution = (document.querySelector('input[name=\"radio-group\"]:checked') as HTMLInputElement)?.value as any;\n                  resolveConflict(selectedConflict.id, resolution || 'local');\n                }}\n              >\n                Resolve Conflict\n              </Button>\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      )}\n    </div>\n  );\n};\n\n// Storage Info Component\nconst StorageInfo: React.FC = () => {\n  const [storage, setStorage] = useState<{\n    used: number;\n    quota: number;\n    percentage: number;\n  }>({ used: 0, quota: 0, percentage: 0 });\n\n  useEffect(() => {\n    const checkStorage = async () => {\n      if ('storage' in navigator && 'estimate' in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        setStorage({\n          used: estimate.usage || 0,\n          quota: estimate.quota || 0,\n          percentage: estimate.quota ? ((estimate.usage || 0) / estimate.quota) * 100 : 0\n        });\n      }\n    };\n\n    checkStorage();\n    const interval = setInterval(checkStorage, 10000); // Update every 10 seconds\n\n    return () => clearInterval(interval);\n  }, []);\n\n  const formatBytes = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center space-x-2\">\n          <HardDrive className=\"h-4 w-4 text-muted-foreground\" />\n          <span className=\"text-sm\">Storage Usage</span>\n        </div>\n        <span className=\"text-sm font-medium\">\n          {formatBytes(storage.used)} / {formatBytes(storage.quota)}\n        </span>\n      </div>\n      <Progress value={storage.percentage} className=\"h-2\" />\n      <div className=\"grid grid-cols-3 gap-4 text-sm\">\n        <div>\n          <p className=\"text-muted-foreground\">Used</p>\n          <p className=\"font-medium\">{formatBytes(storage.used)}</p>\n        </div>\n        <div>\n          <p className=\"text-muted-foreground\">Available</p>\n          <p className=\"font-medium\">{formatBytes(storage.quota - storage.used)}</p>\n        </div>\n        <div>\n          <p className=\"text-muted-foreground\">Percentage</p>\n          <p className=\"font-medium\">{storage.percentage.toFixed(1)}%</p>\n        </div>\n      </div>\n      {storage.percentage > 80 && (\n        <Alert>\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription>\n            Storage is {storage.percentage.toFixed(0)}% full. Consider clearing old data.\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/mobile/PhotoCaptureInterface.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'captureTimeoutRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'captureTimeoutRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":224,"column":40,"nodeType":"Identifier","endLine":224,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Mobile-Optimized Photo Capture Interface for STR Certified\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport {\n  Camera,\n  CameraOff,\n  Check,\n  RefreshCw,\n  X,\n  ZoomIn,\n  FlipHorizontal,\n  Maximize2,\n  Eye,\n  EyeOff,\n  Settings,\n  Download,\n  ChevronUp,\n  ChevronDown,\n  Loader2\n} from 'lucide-react';\nimport { useCamera } from '@/hooks/useCamera';\nimport { usePhotoGuidance } from '@/hooks/usePhotoGuidance';\nimport { usePhotoComparison } from '@/hooks/usePhotoComparison';\nimport { PhotoQualityIndicator } from './PhotoQualityIndicator';\nimport { ReferencePhotoOverlay } from '@/components/photo/ReferencePhotoOverlay';\nimport { PhotoGuidanceOverlay } from '@/components/photo/PhotoGuidanceOverlay';\nimport { cn } from '@/lib/utils';\nimport type { PhotoGuidance, ChecklistItem } from '@/types/photo';\n\ninterface PhotoCaptureInterfaceProps {\n  checklistItem: ChecklistItem;\n  referencePhotoUrl?: string;\n  onPhotoCapture: (photo: File, metadata: PhotoCaptureMetadata) => void;\n  onCancel?: () => void;\n  className?: string;\n}\n\nexport interface PhotoCaptureMetadata {\n  checklistItemId: string;\n  roomName: string;\n  captureTime: Date;\n  deviceInfo: {\n    userAgent: string;\n    screenResolution: string;\n    cameraCapabilities: MediaTrackCapabilities | null;\n  };\n  qualityScore: number;\n  guidanceFollowed: boolean;\n}\n\nexport const PhotoCaptureInterface: React.FC<PhotoCaptureInterfaceProps> = ({\n  checklistItem,\n  referencePhotoUrl,\n  onPhotoCapture,\n  onCancel,\n  className\n}) => {\n  // State management\n  const [capturedPhoto, setCapturedPhoto] = useState<string | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [showReference, setShowReference] = useState(true);\n  const [referenceOpacity, setReferenceOpacity] = useState(30);\n  const [showGuidance, setShowGuidance] = useState(true);\n  const [expandedView, setExpandedView] = useState(false);\n  const [currentQuality, setCurrentQuality] = useState<PhotoGuidance | null>(null);\n\n  // Refs\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const captureTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Custom hooks\n  const {\n    stream,\n    isReady,\n    error: cameraError,\n    hasPermission,\n    isLoading: cameraLoading,\n    requestPermission,\n    switchCamera,\n    getCurrentCamera,\n    getCameraCapabilities,\n    stopCamera\n  } = useCamera({\n    videoRef,\n    facingMode: 'environment',\n    resolution: { width: 1920, height: 1080 }\n  });\n\n  const {\n    currentStep,\n    guidance,\n    isComplete,\n    nextStep,\n    previousStep,\n    resetGuidance,\n    getProgress\n  } = usePhotoGuidance({\n    checklistItem,\n    referencePhoto: referencePhotoUrl\n  });\n\n  const {\n    checkPhotoQuality,\n    qualityGuidance,\n    isCheckingQuality,\n    startRealTimeFeedback,\n    stopRealTimeFeedback,\n    realTimeGuidance\n  } = usePhotoComparison({\n    enableHistory: false\n  });\n\n  // Start real-time feedback when camera is ready\n  useEffect(() => {\n    if (stream && isReady && showGuidance) {\n      startRealTimeFeedback(stream);\n      return () => {\n        stopRealTimeFeedback();\n      };\n    }\n  }, [stream, isReady, showGuidance, startRealTimeFeedback, stopRealTimeFeedback]);\n\n  // Update current quality from real-time guidance\n  useEffect(() => {\n    if (realTimeGuidance) {\n      setCurrentQuality(realTimeGuidance);\n    }\n  }, [realTimeGuidance]);\n\n  // Handle photo capture\n  const handleCapture = async () => {\n    if (!videoRef.current || !canvasRef.current || !currentQuality) return;\n\n    setIsProcessing(true);\n\n    try {\n      // Set canvas dimensions to match video\n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n\n      // Draw video frame to canvas\n      const ctx = canvas.getContext('2d');\n      if (!ctx) throw new Error('Failed to get canvas context');\n      \n      ctx.drawImage(video, 0, 0);\n\n      // Convert to blob\n      const blob = await new Promise<Blob>((resolve, reject) => {\n        canvas.toBlob(\n          (blob) => {\n            if (blob) resolve(blob);\n            else reject(new Error('Failed to create blob'));\n          },\n          'image/jpeg',\n          0.95\n        );\n      });\n\n      // Create File object\n      const file = new File([blob], `inspection_${Date.now()}.jpg`, {\n        type: 'image/jpeg'\n      });\n\n      // Get device capabilities\n      const capabilities = getCameraCapabilities();\n\n      // Create metadata\n      const metadata: PhotoCaptureMetadata = {\n        checklistItemId: checklistItem.id,\n        roomName: checklistItem.roomName || 'Unknown Room',\n        captureTime: new Date(),\n        deviceInfo: {\n          userAgent: navigator.userAgent,\n          screenResolution: `${window.screen.width}x${window.screen.height}`,\n          cameraCapabilities: capabilities\n        },\n        qualityScore: currentQuality.qualityScore,\n        guidanceFollowed: guidance.stepsCompleted >= guidance.totalSteps * 0.8\n      };\n\n      // Set captured photo for preview\n      setCapturedPhoto(URL.createObjectURL(blob));\n\n      // Delay to show preview\n      setTimeout(() => {\n        onPhotoCapture(file, metadata);\n      }, 1500);\n\n    } catch (error) {\n      console.error('Capture error:', error);\n      setIsProcessing(false);\n    }\n  };\n\n  // Handle retake\n  const handleRetake = () => {\n    if (capturedPhoto) {\n      URL.revokeObjectURL(capturedPhoto);\n    }\n    setCapturedPhoto(null);\n    setIsProcessing(false);\n    resetGuidance();\n  };\n\n  // Handle permission request\n  const handlePermissionRequest = async () => {\n    await requestPermission();\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (capturedPhoto) {\n        URL.revokeObjectURL(capturedPhoto);\n      }\n      if (captureTimeoutRef.current) {\n        clearTimeout(captureTimeoutRef.current);\n      }\n      stopCamera();\n    };\n  }, [capturedPhoto, stopCamera]);\n\n  // Render permission screen\n  if (!hasPermission) {\n    return (\n      <div className={cn(\n        'fixed inset-0 bg-background flex flex-col items-center justify-center p-4',\n        className\n      )}>\n        <Card className=\"w-full max-w-md p-6 space-y-4\">\n          <div className=\"text-center space-y-2\">\n            <CameraOff className=\"h-12 w-12 text-muted-foreground mx-auto\" />\n            <h2 className=\"text-xl font-semibold\">Camera Permission Required</h2>\n            <p className=\"text-sm text-muted-foreground\">\n              STR Certified needs camera access to capture inspection photos\n            </p>\n          </div>\n          \n          <Button\n            onClick={handlePermissionRequest}\n            className=\"w-full\"\n            size=\"lg\"\n          >\n            <Camera className=\"h-5 w-5 mr-2\" />\n            Grant Camera Access\n          </Button>\n          \n          {cameraError && (\n            <Alert variant=\"destructive\">\n              <AlertDescription>{cameraError}</AlertDescription>\n            </Alert>\n          )}\n          \n          {onCancel && (\n            <Button\n              variant=\"outline\"\n              onClick={onCancel}\n              className=\"w-full\"\n            >\n              Cancel\n            </Button>\n          )}\n        </Card>\n      </div>\n    );\n  }\n\n  // Render loading screen\n  if (cameraLoading || !isReady) {\n    return (\n      <div className={cn(\n        'fixed inset-0 bg-background flex items-center justify-center',\n        className\n      )}>\n        <div className=\"text-center space-y-4\">\n          <Loader2 className=\"h-8 w-8 animate-spin text-primary mx-auto\" />\n          <p className=\"text-muted-foreground\">Initializing camera...</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Main capture interface\n  return (\n    <div className={cn(\n      'fixed inset-0 bg-black flex flex-col',\n      expandedView && 'z-50',\n      className\n    )}>\n      {/* Header */}\n      <div className=\"relative z-20 bg-gradient-to-b from-black/70 to-transparent p-4\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={onCancel}\n              className=\"text-white hover:bg-white/20\"\n            >\n              <X className=\"h-5 w-5\" />\n            </Button>\n            <div className=\"text-white\">\n              <h3 className=\"font-medium\">{checklistItem.title}</h3>\n              <p className=\"text-xs opacity-80\">{checklistItem.roomName}</p>\n            </div>\n          </div>\n          \n          <div className=\"flex items-center space-x-2\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => setExpandedView(!expandedView)}\n              className=\"text-white hover:bg-white/20\"\n            >\n              <Maximize2 className=\"h-5 w-5\" />\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={switchCamera}\n              className=\"text-white hover:bg-white/20\"\n            >\n              <FlipHorizontal className=\"h-5 w-5\" />\n            </Button>\n          </div>\n        </div>\n\n        {/* Guidance Progress */}\n        {showGuidance && (\n          <div className=\"mt-4 space-y-2\">\n            <div className=\"flex items-center justify-between text-white text-xs\">\n              <span>Step {currentStep + 1} of {guidance.totalSteps}</span>\n              <span>{Math.round(getProgress())}% Complete</span>\n            </div>\n            <Progress value={getProgress()} className=\"h-1 bg-white/20\" />\n          </div>\n        )}\n      </div>\n\n      {/* Camera View */}\n      <div className=\"relative flex-1 overflow-hidden\">\n        {/* Video Preview */}\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          muted\n          className=\"absolute inset-0 w-full h-full object-cover\"\n        />\n\n        {/* Reference Photo Overlay */}\n        {referencePhotoUrl && showReference && (\n          <ReferencePhotoOverlay\n            photoUrl={referencePhotoUrl}\n            opacity={referenceOpacity}\n            onOpacityChange={setReferenceOpacity}\n            onClose={() => setShowReference(false)}\n          />\n        )}\n\n        {/* Quality Indicator */}\n        {currentQuality && (\n          <div className=\"absolute top-4 right-4 z-10\">\n            <PhotoQualityIndicator\n              quality={currentQuality}\n              compact={!expandedView}\n            />\n          </div>\n        )}\n\n        {/* Guidance Overlay */}\n        {showGuidance && currentQuality && (\n          <PhotoGuidanceOverlay\n            guidance={currentQuality}\n            referencePhotoUrl={referencePhotoUrl}\n            onCapture={handleCapture}\n            onRetake={handleRetake}\n            isCapturing={isProcessing}\n            showReferencePhoto={false}\n            className=\"absolute inset-0\"\n          />\n        )}\n\n        {/* Captured Photo Preview */}\n        {capturedPhoto && (\n          <div className=\"absolute inset-0 bg-black/90 flex items-center justify-center z-30\">\n            <div className=\"relative max-w-full max-h-full\">\n              <img\n                src={capturedPhoto}\n                alt=\"Captured photo\"\n                className=\"max-w-full max-h-full object-contain\"\n              />\n              <div className=\"absolute inset-0 flex items-center justify-center\">\n                <div className=\"bg-green-500 text-white p-4 rounded-full animate-pulse\">\n                  <Check className=\"h-8 w-8\" />\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n\n        {/* Canvas for capture (hidden) */}\n        <canvas ref={canvasRef} className=\"hidden\" />\n      </div>\n\n      {/* Bottom Controls */}\n      <div className=\"relative z-20 bg-gradient-to-t from-black/70 to-transparent p-4\">\n        {/* Quick Settings */}\n        <div className=\"flex items-center justify-center space-x-4 mb-4\">\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setShowReference(!showReference)}\n            className=\"text-white hover:bg-white/20\"\n            disabled={!referencePhotoUrl}\n          >\n            {showReference ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n            <span className=\"ml-1 text-xs\">Reference</span>\n          </Button>\n          \n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setShowGuidance(!showGuidance)}\n            className=\"text-white hover:bg-white/20\"\n          >\n            <Settings className=\"h-4 w-4\" />\n            <span className=\"ml-1 text-xs\">Guidance</span>\n          </Button>\n        </div>\n\n        {/* Capture Controls */}\n        <div className=\"flex items-center justify-center space-x-4\">\n          {/* Previous Step */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            onClick={previousStep}\n            disabled={currentStep === 0 || isProcessing}\n            className=\"text-white hover:bg-white/20\"\n          >\n            <ChevronDown className=\"h-5 w-5\" />\n          </Button>\n\n          {/* Capture Button */}\n          <Button\n            size=\"lg\"\n            onClick={handleCapture}\n            disabled={isProcessing || !currentQuality?.isAcceptable}\n            className={cn(\n              'h-16 w-16 rounded-full shadow-xl transition-all',\n              currentQuality?.isAcceptable\n                ? 'bg-white hover:bg-gray-100'\n                : 'bg-red-500 hover:bg-red-600'\n            )}\n          >\n            {isProcessing ? (\n              <Loader2 className=\"h-6 w-6 animate-spin text-black\" />\n            ) : (\n              <Camera className=\"h-6 w-6 text-black\" />\n            )}\n          </Button>\n\n          {/* Next Step */}\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            onClick={nextStep}\n            disabled={currentStep >= guidance.totalSteps - 1 || isProcessing}\n            className=\"text-white hover:bg-white/20\"\n          >\n            <ChevronUp className=\"h-5 w-5\" />\n          </Button>\n        </div>\n\n        {/* Current Guidance Text */}\n        {guidance.currentGuidance && (\n          <div className=\"mt-4 text-center\">\n            <p className=\"text-white text-sm\">\n              {guidance.currentGuidance}\n            </p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\n// Simplified Mobile Capture for Quick Photos\nexport const QuickPhotoCapture: React.FC<{\n  onCapture: (photo: File) => void;\n  onCancel: () => void;\n}> = ({ onCapture, onCancel }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  const { stream, isReady, hasPermission, requestPermission } = useCamera({\n    videoRef,\n    facingMode: 'environment'\n  });\n\n  const handleQuickCapture = async () => {\n    if (!videoRef.current || !canvasRef.current) return;\n\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    ctx.drawImage(video, 0, 0);\n\n    canvas.toBlob((blob) => {\n      if (blob) {\n        const file = new File([blob], `quick_${Date.now()}.jpg`, {\n          type: 'image/jpeg'\n        });\n        onCapture(file);\n      }\n    }, 'image/jpeg', 0.9);\n  };\n\n  if (!hasPermission) {\n    return (\n      <div className=\"fixed inset-0 bg-black flex items-center justify-center p-4\">\n        <Button onClick={requestPermission} size=\"lg\" variant=\"outline\">\n          <Camera className=\"h-5 w-5 mr-2\" />\n          Enable Camera\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"fixed inset-0 bg-black\">\n      <video\n        ref={videoRef}\n        autoPlay\n        playsInline\n        muted\n        className=\"w-full h-full object-cover\"\n      />\n      <canvas ref={canvasRef} className=\"hidden\" />\n      \n      <div className=\"absolute bottom-0 inset-x-0 p-6 flex items-center justify-center space-x-4\">\n        <Button\n          variant=\"outline\"\n          size=\"lg\"\n          onClick={onCancel}\n          className=\"bg-white/10 backdrop-blur text-white border-white/20\"\n        >\n          Cancel\n        </Button>\n        <Button\n          size=\"lg\"\n          onClick={handleQuickCapture}\n          disabled={!isReady}\n          className=\"h-16 w-16 rounded-full bg-white shadow-xl\"\n        >\n          <Camera className=\"h-6 w-6 text-black\" />\n        </Button>\n      </div>\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/mobile/PhotoQualityIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/photo/PhotoComparisonView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/photo/PhotoGuidance.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1505,1508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1505,1508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'inspectionId' and 'onPhotoStored'. Either include them or remove the dependency array. If 'onPhotoStored' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":353,"column":6,"nodeType":"ArrayExpression","endLine":353,"endColumn":106,"suggestions":[{"desc":"Update the dependencies array to be: [currentItem, isReady, takePhoto, currentItemIndex, totalItems, onPhotoStored, inspectionId, onPhotoCapture, onAllPhotosComplete]","fix":{"range":[12583,12683],"text":"[currentItem, isReady, takePhoto, currentItemIndex, totalItems, onPhotoStored, inspectionId, onPhotoCapture, onAllPhotosComplete]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useCallback, useEffect } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport { \n  Camera, \n  RotateCcw, \n  CheckCircle, \n  X, \n  AlertTriangle,\n  Zap,\n  Eye,\n  Target,\n  Lightbulb,\n  RefreshCw\n} from 'lucide-react';\nimport { useCamera } from '@/hooks/useCamera';\nimport type { DynamicChecklistItem } from '@/lib/ai/dynamic-checklist-generator';\nimport { STRCertifiedAIService } from '@/lib/ai/openai-service';\nimport { createPhotoQualityChecker } from '@/lib/ai/photo-quality-checker';\nimport { checklistService } from '@/services/checklistService';\nimport { mediaCompressionService } from '@/services/mediaCompressionService';\nimport { logger } from '@/utils/logger';\n\n// Checklist interface for workflow compatibility  \ninterface ChecklistData {\n  items: DynamicChecklistItem[];\n  estimatedTime: number;\n  totalItems: number;\n}\n\ninterface PhotoResult {\n  photo: File;\n  analysis: {\n    score: number;\n    issues: string[];\n    suggestions: string[];\n  };\n}\n\ninterface PhotoGuidanceProps {\n  checklist: ChecklistData;\n  onPhotoCapture: (roomType: string) => Promise<PhotoResult>;\n  onAllPhotosComplete: () => void;\n  onPhotoStored?: (itemId: string, photoFile: File, analysis: any) => void;\n  inspectionId?: string;\n}\n\nexport function PhotoGuidance({ \n  checklist, \n  onPhotoCapture, \n  onAllPhotosComplete,\n  onPhotoStored,\n  inspectionId\n}: PhotoGuidanceProps) {\n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  const [currentItemIndex, setCurrentItemIndex] = useState(0);\n  const [capturedPhotos, setCapturedPhotos] = useState<Record<string, PhotoResult>>({});\n  const [isCapturing, setIsCapturing] = useState(false);\n  const [captureProgress, setCaptureProgress] = useState(0);\n  \n  const {\n    isReady,\n    error: cameraError,\n    hasPermission,\n    isLoading: cameraLoading,\n    availableDevices,\n    requestPermission,\n    startCamera,\n    stopCamera,\n    switchCamera,\n    takePhoto\n  } = useCamera({\n    videoRef,\n    facingMode: 'environment',\n    resolution: { width: 1920, height: 1080 },\n    autoStart: true\n  });\n\n  const currentItem = checklist?.items[currentItemIndex];\n  const totalItems = checklist?.items.length || 0;\n  const completedPhotos = Object.keys(capturedPhotos).length;\n\n  // Photo capture handler\n  const handlePhotoCapture = useCallback(async () => {\n    if (!currentItem || !isReady) return;\n    \n    setIsCapturing(true);\n    setCaptureProgress(0);\n    \n    try {\n      // Simulate progress updates\n      const progressInterval = setInterval(() => {\n        setCaptureProgress(prev => Math.min(prev + 10, 90));\n      }, 150);\n\n      // Take photo using camera hook\n      const photoBlob = await takePhoto();\n      if (!photoBlob) {\n        throw new Error('Failed to capture photo');\n      }\n\n      // Convert blob to file\n      const originalPhotoFile = new File([photoBlob], `${currentItem.id}_${Date.now()}.jpg`, {\n        type: 'image/jpeg',\n        lastModified: Date.now(),\n      });\n\n      // Compress photo for mobile optimization\n      let photoFile = originalPhotoFile;\n      try {\n        setCaptureProgress(20);\n        \n        // Check if compression is needed\n        if (mediaCompressionService.shouldCompressFile(originalPhotoFile)) {\n          const compressionResult = await mediaCompressionService.compressPhoto(originalPhotoFile, {\n            quality: 0.8,\n            maxWidth: 1920,\n            maxHeight: 1080,\n            outputFormat: 'jpeg',\n            stripMetadata: true\n          });\n          \n          photoFile = compressionResult.compressedFile;\n          \n          logger.info('Photo compressed successfully', {\n            originalSize: compressionResult.originalSize,\n            compressedSize: compressionResult.compressedSize,\n            compressionRatio: compressionResult.compressionRatio,\n            timeTaken: compressionResult.timeTaken,\n            savedBytes: compressionResult.originalSize - compressionResult.compressedSize\n          }, 'PHOTO_GUIDANCE');\n        }\n      } catch (compressionError) {\n        logger.warn('Photo compression failed, using original', compressionError, 'PHOTO_GUIDANCE');\n        photoFile = originalPhotoFile;\n      }\n\n      // Real AI analysis using OpenAI service\n      const aiService = new STRCertifiedAIService();\n      const qualityChecker = createPhotoQualityChecker();\n      \n      try {\n        // First check photo quality\n        const qualityGuidance = await qualityChecker.analyzePhotoWithGuidance(photoFile);\n        \n        if (!qualityGuidance.isAcceptable) {\n          clearInterval(progressInterval);\n          setCaptureProgress(100);\n          \n          // Return quality issues to user\n          const qualityResult = {\n            photo: photoFile,\n            analysis: {\n              score: qualityGuidance.qualityScore,\n              issues: qualityGuidance.messages.map(m => m.message),\n              suggestions: qualityGuidance.messages.filter(m => m.action).map(m => m.action || '')\n            }\n          };\n          \n          setCapturedPhotos(prev => ({\n            ...prev,\n            [currentItem.id]: qualityResult\n          }));\n          \n          // Store photo even if quality is poor for improvement\n          if (onPhotoStored) {\n            onPhotoStored(currentItem.id, photoFile, qualityResult.analysis);\n          }\n          \n          // Update checklist item with quality issues\n          if (inspectionId) {\n            try {\n              await checklistService.completeChecklistItem(\n                currentItem.id,\n                {\n                  id: currentItem.id,\n                  aiScore: qualityResult.analysis.score,\n                  aiConfidence: qualityGuidance.qualityScore / 100,\n                  aiReasoning: qualityGuidance.messages.map(m => m.message).join('; '),\n                  suggestions: qualityGuidance.messages.filter(m => m.action).map(m => m.action || ''),\n                  issues: qualityGuidance.messages.map(m => m.message),\n                  passed: false, // Failed quality check\n                  requiresReview: true // Always require review for quality issues\n                },\n                [photoFile], // photos array\n                undefined, // no videos\n                'Photo quality issues detected - retake recommended', // notes\n                false // no user override\n              );\n              \n              logger.info('Checklist item completed with quality issues', {\n                itemId: currentItem.id,\n                qualityScore: qualityGuidance.qualityScore,\n                issues: qualityGuidance.messages.length\n              }, 'PHOTO_GUIDANCE');\n            } catch (error) {\n              logger.error('Failed to complete checklist item with quality issues', error, 'PHOTO_GUIDANCE');\n              // Don't block the workflow - continue with photo capture\n            }\n          }\n          \n          return;\n        }\n        \n        // If quality is acceptable, proceed with AI analysis\n        const aiResult = await aiService.analyzeInspectionPhoto(\n          photoFile,\n          currentItem.gptPrompt || currentItem.description,\n          {\n            includeQualityMetrics: true,\n            includeImprovementSuggestions: true,\n            roomType: currentItem.roomType || currentItem.category\n          }\n        );\n        \n        clearInterval(progressInterval);\n        setCaptureProgress(100);\n        \n        // Create result with real AI analysis\n        const analysisResult = {\n          photo: photoFile,\n          analysis: {\n            score: Math.round(aiResult.confidence * 100),\n            issues: aiResult.issues || [],\n            suggestions: aiResult.suggestions || ['Analysis completed successfully']\n          }\n        };\n        \n        setCapturedPhotos(prev => ({\n          ...prev,\n          [currentItem.id]: analysisResult\n        }));\n        \n        // Store photo data in parent component for database sync\n        if (onPhotoStored) {\n          onPhotoStored(currentItem.id, photoFile, analysisResult.analysis);\n        }\n        \n        // Update checklist item status using the service\n        if (inspectionId) {\n          try {\n            await checklistService.completeChecklistItem(\n              currentItem.id,\n              {\n                id: currentItem.id,\n                aiScore: analysisResult.analysis.score,\n                aiConfidence: aiResult.confidence,\n                aiReasoning: aiResult.reasoning || 'Photo analysis completed',\n                suggestions: aiResult.suggestions || [],\n                issues: aiResult.issues || [],\n                passed: analysisResult.analysis.score > 80,\n                requiresReview: analysisResult.analysis.score < 60\n              },\n              [photoFile], // photos array\n              undefined, // no videos\n              undefined, // no notes\n              false // no user override\n            );\n            \n            logger.info('Checklist item completed successfully', {\n              itemId: currentItem.id,\n              score: analysisResult.analysis.score,\n              confidence: aiResult.confidence\n            }, 'PHOTO_GUIDANCE');\n          } catch (error) {\n            logger.error('Failed to complete checklist item', error, 'PHOTO_GUIDANCE');\n            // Don't block the workflow - continue with photo capture\n          }\n        }\n        \n        // Also call the parent handler for workflow integration\n        await onPhotoCapture(currentItem.roomType || currentItem.category);\n        \n      } catch (error) {\n        console.error('AI analysis failed:', error);\n        clearInterval(progressInterval);\n        setCaptureProgress(100);\n        \n        // Fallback to basic analysis\n        const fallbackResult = {\n          photo: photoFile,\n          analysis: {\n            score: 70,\n            issues: ['AI analysis unavailable'],\n            suggestions: ['Photo captured, manual review recommended']\n          }\n        };\n        \n        setCapturedPhotos(prev => ({\n          ...prev,\n          [currentItem.id]: fallbackResult\n        }));\n        \n        // Store photo data in parent component for database sync\n        if (onPhotoStored) {\n          onPhotoStored(currentItem.id, photoFile, fallbackResult.analysis);\n        }\n        \n        // Update checklist item status with fallback analysis\n        if (inspectionId) {\n          try {\n            await checklistService.completeChecklistItem(\n              currentItem.id,\n              {\n                id: currentItem.id,\n                aiScore: fallbackResult.analysis.score,\n                aiConfidence: 0.5, // Low confidence for fallback\n                aiReasoning: 'AI analysis unavailable, manual review recommended',\n                suggestions: fallbackResult.analysis.suggestions,\n                issues: fallbackResult.analysis.issues,\n                passed: false, // Conservative approach when AI fails\n                requiresReview: true // Always require review when AI fails\n              },\n              [photoFile], // photos array\n              undefined, // no videos\n              'AI analysis failed - manual review required', // notes\n              false // no user override\n            );\n            \n            logger.info('Checklist item completed with fallback analysis', {\n              itemId: currentItem.id,\n              score: fallbackResult.analysis.score\n            }, 'PHOTO_GUIDANCE');\n          } catch (error) {\n            logger.error('Failed to complete checklist item with fallback', error, 'PHOTO_GUIDANCE');\n            // Don't block the workflow - continue with photo capture\n          }\n        }\n        \n        // Still call parent handler\n        await onPhotoCapture(currentItem.roomType || currentItem.category);\n      }\n      \n      // Result is already stored in the AI analysis section above\n\n      // Move to next item or complete\n      if (currentItemIndex < totalItems - 1) {\n        setCurrentItemIndex(prev => prev + 1);\n      } else {\n        // All photos captured\n        onAllPhotosComplete();\n      }\n      \n    } catch (error) {\n      console.error('Photo capture failed:', error);\n    } finally {\n      setIsCapturing(false);\n      setCaptureProgress(0);\n    }\n  }, [currentItem, isReady, takePhoto, onPhotoCapture, currentItemIndex, totalItems, onAllPhotosComplete]);\n\n  const handleRetake = useCallback(() => {\n    if (currentItem) {\n      const newCapturedPhotos = { ...capturedPhotos };\n      delete newCapturedPhotos[currentItem.id];\n      setCapturedPhotos(newCapturedPhotos);\n    }\n  }, [currentItem, capturedPhotos]);\n\n  const handleSkipItem = useCallback(() => {\n    if (currentItemIndex < totalItems - 1) {\n      setCurrentItemIndex(prev => prev + 1);\n    } else {\n      onAllPhotosComplete();\n    }\n  }, [currentItemIndex, totalItems, onAllPhotosComplete]);\n\n  const handlePreviousItem = useCallback(() => {\n    if (currentItemIndex > 0) {\n      setCurrentItemIndex(prev => prev - 1);\n    }\n  }, [currentItemIndex]);\n\n  const getCategoryIcon = (category: string) => {\n    const icons: Record<string, React.ReactNode> = {\n      safety: <AlertTriangle className=\"h-4 w-4\" />,\n      bedrooms: <Eye className=\"h-4 w-4\" />,\n      bathrooms: <Eye className=\"h-4 w-4\" />,\n      kitchen: <Eye className=\"h-4 w-4\" />,\n      general: <Target className=\"h-4 w-4\" />\n    };\n    \n    return icons[category] || <Camera className=\"h-4 w-4\" />;\n  };\n\n  const getPhotoGuidelines = (item: DynamicChecklistItem): string[] => {\n    const baseGuidelines = [\n      'Ensure good lighting and clear visibility',\n      'Hold the camera steady to avoid blur',\n      'Capture the entire subject in frame',\n      'Avoid shadows and reflections when possible'\n    ];\n\n    const categoryGuidelines: Record<string, string[]> = {\n      safety: [\n        'Focus on safety equipment and hazards',\n        'Show condition and accessibility clearly',\n        'Include any warning labels or signs'\n      ],\n      kitchen: [\n        'Show appliances and their condition',\n        'Capture cleanliness of surfaces',\n        'Include storage and organization'\n      ],\n      bathrooms: [\n        'Test and show water pressure',\n        'Check for leaks or damage',\n        'Show cleanliness and supplies'\n      ],\n      bedrooms: [\n        'Show bed quality and linens',\n        'Capture overall room condition',\n        'Include lighting and furniture'\n      ]\n    };\n\n    return [...baseGuidelines, ...(categoryGuidelines[item.category] || [])];\n  };\n\n  // Camera permission handling\n  if (!hasPermission && !cameraLoading) {\n    return (\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Camera className=\"h-5 w-5\" />\n            Camera Permission Required\n          </CardTitle>\n          <CardDescription>\n            We need access to your camera to capture inspection photos\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <Alert>\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertTitle>Camera Access Needed</AlertTitle>\n            <AlertDescription>\n              To continue with the photo documentation step, please allow camera access when prompted.\n            </AlertDescription>\n          </Alert>\n          <Button onClick={requestPermission} className=\"w-full\">\n            <Camera className=\"h-4 w-4 mr-2\" />\n            Enable Camera\n          </Button>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (cameraError) {\n    return (\n      <Alert variant=\"destructive\">\n        <AlertTriangle className=\"h-4 w-4\" />\n        <AlertTitle>Camera Error</AlertTitle>\n        <AlertDescription className=\"mt-2\">\n          {cameraError}\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            className=\"mt-2 ml-2\" \n            onClick={() => window.location.reload()}\n          >\n            <RefreshCw className=\"h-4 w-4 mr-2\" />\n            Retry\n          </Button>\n        </AlertDescription>\n      </Alert>\n    );\n  }\n\n  if (!currentItem) {\n    return (\n      <Card>\n        <CardContent className=\"text-center py-12\">\n          <CheckCircle className=\"h-12 w-12 mx-auto text-green-500 mb-4\" />\n          <h3 className=\"text-lg font-medium text-gray-900 dark:text-gray-100 mb-2\">\n            All Photos Captured!\n          </h3>\n          <p className=\"text-gray-600 dark:text-gray-400\">\n            You've completed the photo documentation step.\n          </p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  const isCurrentItemCompleted = capturedPhotos[currentItem.id];\n  const currentPhotoResult = capturedPhotos[currentItem.id];\n\n  return (\n    <div className=\"space-y-4 pb-6\">\n      {/* Progress Header */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Camera className=\"h-5 w-5\" />\n            Photo Documentation\n          </CardTitle>\n          <CardDescription>\n            Capture photos for each checklist item ({completedPhotos}/{totalItems} completed)\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between text-sm\">\n              <span>Progress</span>\n              <span>{Math.round((completedPhotos / totalItems) * 100)}%</span>\n            </div>\n            <Progress value={(completedPhotos / totalItems) * 100} className=\"h-2\" />\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Current Item - Mobile Optimized */}\n      <Card className=\"border-blue-200 bg-blue-50 dark:bg-blue-900/20\">\n        <CardHeader className=\"pb-3\">\n          <CardTitle className=\"flex items-start gap-3 text-lg\">\n            <div className=\"mt-1\">\n              {getCategoryIcon(currentItem.category)}\n            </div>\n            <div className=\"flex-1 min-w-0\">\n              <div className=\"flex items-start justify-between gap-2\">\n                <h3 className=\"font-semibold leading-tight\">{currentItem.title}</h3>\n                {isCurrentItemCompleted && (\n                  <Badge className=\"bg-green-100 text-green-800 shrink-0\">\n                    Completed\n                  </Badge>\n                )}\n              </div>\n            </div>\n          </CardTitle>\n          <CardDescription className=\"text-base mt-2\">\n            {currentItem.description}\n          </CardDescription>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex flex-wrap items-center gap-2\">\n            <Badge variant=\"outline\" className=\"text-sm py-1\">{currentItem.category}</Badge>\n            <Badge className={`text-sm py-1 ${\n              currentItem.priority === 'critical' ? 'bg-red-100 text-red-800' :\n              currentItem.priority === 'high' ? 'bg-orange-100 text-orange-800' :\n              'bg-blue-100 text-blue-800'\n            }`}>\n              {currentItem.priority}\n            </Badge>\n            {currentItem.required && (\n              <Badge variant=\"destructive\" className=\"text-sm py-1\">Required</Badge>\n            )}\n          </div>\n\n          {/* Photo Guidelines - Mobile Optimized */}\n          <div className=\"space-y-3\">\n            <h4 className=\"font-medium flex items-center gap-2 text-base\">\n              <Lightbulb className=\"h-5 w-5\" />\n              Photo Guidelines\n            </h4>\n            <ul className=\"text-base text-gray-600 dark:text-gray-400 space-y-2\">\n              {getPhotoGuidelines(currentItem).map((guideline, index) => (\n                <li key={index} className=\"flex items-start gap-3 leading-relaxed\">\n                  <span className=\"text-blue-500 mt-1 text-lg\">â€¢</span>\n                  <span className=\"flex-1\">{guideline}</span>\n                </li>\n              ))}\n            </ul>\n          </div>\n\n          {/* Current Photo Result */}\n          {currentPhotoResult && (\n            <div className=\"p-3 bg-green-50 dark:bg-green-900/20 rounded-lg\">\n              <div className=\"flex items-center gap-2 mb-2\">\n                <CheckCircle className=\"h-4 w-4 text-green-500\" />\n                <span className=\"font-medium text-green-800 dark:text-green-200\">\n                  Photo Captured\n                </span>\n                <Badge className=\"bg-green-100 text-green-800 ml-auto\">\n                  Score: {currentPhotoResult.analysis.score}%\n                </Badge>\n              </div>\n              {currentPhotoResult.analysis.suggestions.length > 0 && (\n                <div className=\"text-sm text-green-700 dark:text-green-300\">\n                  <p className=\"font-medium\">Suggestions:</p>\n                  <ul className=\"list-disc list-inside\">\n                    {currentPhotoResult.analysis.suggestions.map((suggestion, index) => (\n                      <li key={index}>{suggestion}</li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Camera Interface */}\n      <Card>\n        <CardHeader>\n          <CardTitle>Camera</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-4\">\n            {/* Video Preview - Mobile Optimized */}\n            <div className=\"relative bg-black rounded-lg overflow-hidden aspect-video min-h-[300px] sm:min-h-[400px]\">\n              {cameraLoading ? (\n                <div className=\"absolute inset-0 flex items-center justify-center\">\n                  <div className=\"text-white\">Loading camera...</div>\n                </div>\n              ) : (\n                <video\n                  ref={videoRef}\n                  className=\"w-full h-full object-cover\"\n                  autoPlay\n                  playsInline\n                  muted\n                />\n              )}\n              \n              {/* Capture Progress Overlay */}\n              {isCapturing && (\n                <div className=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center\">\n                  <div className=\"text-center text-white\">\n                    <div className=\"mb-2\">\n                      {captureProgress < 20 ? 'Capturing photo...' :\n                       captureProgress < 40 ? 'Compressing image...' :\n                       captureProgress < 60 ? 'Checking quality...' :\n                       captureProgress < 90 ? 'Analyzing with AI...' :\n                       'Finalizing...'}\n                    </div>\n                    <Progress value={captureProgress} className=\"w-48 h-2\" />\n                    <div className=\"text-xs mt-2 opacity-75\">{Math.round(captureProgress)}%</div>\n                  </div>\n                </div>\n              )}\n            </div>\n\n            {/* Camera Controls - Mobile Optimized */}\n            <div className=\"space-y-3\">\n              {/* Primary Action - Large Touch Target */}\n              <div className=\"flex justify-center\">\n                {isCurrentItemCompleted ? (\n                  <Button\n                    variant=\"outline\"\n                    onClick={handleRetake}\n                    disabled={isCapturing}\n                    className=\"h-16 px-8 text-lg font-medium min-w-[200px] touch-manipulation\"\n                  >\n                    <Camera className=\"h-6 w-6 mr-3\" />\n                    Retake Photo\n                  </Button>\n                ) : (\n                  <Button\n                    onClick={handlePhotoCapture}\n                    disabled={!isReady || isCapturing}\n                    className=\"h-16 px-8 text-lg font-medium min-w-[200px] bg-blue-600 hover:bg-blue-700 touch-manipulation\"\n                  >\n                    <Camera className=\"h-6 w-6 mr-3\" />\n                    {isCapturing ? 'Processing...' : 'Capture Photo'}\n                  </Button>\n                )}\n              </div>\n              \n              {/* Secondary Actions - Mobile Grid */}\n              <div className=\"grid grid-cols-2 gap-3\">\n                <Button\n                  variant=\"outline\"\n                  onClick={handlePreviousItem}\n                  disabled={currentItemIndex === 0}\n                  className=\"h-12 text-base touch-manipulation\"\n                >\n                  Previous\n                </Button>\n                \n                <Button\n                  variant=\"outline\"\n                  onClick={handleSkipItem}\n                  disabled={isCapturing}\n                  className=\"h-12 text-base touch-manipulation\"\n                >\n                  Next\n                </Button>\n              </div>\n              \n              {/* Utility Controls */}\n              <div className=\"flex justify-center gap-3\">\n                {availableDevices.length > 1 && (\n                  <Button\n                    variant=\"outline\"\n                    onClick={switchCamera}\n                    disabled={isCapturing}\n                    className=\"h-12 px-6 touch-manipulation\"\n                  >\n                    <RotateCcw className=\"h-5 w-5 mr-2\" />\n                    Switch Camera\n                  </Button>\n                )}\n                \n                {!currentItem.required && (\n                  <Button\n                    variant=\"outline\"\n                    onClick={handleSkipItem}\n                    disabled={isCapturing}\n                    className=\"h-12 px-6 touch-manipulation\"\n                  >\n                    Skip Item\n                  </Button>\n                )}\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Photo Summary - Mobile Optimized */}\n      {completedPhotos > 0 && (\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center gap-2 text-lg\">\n              <CheckCircle className=\"h-5 w-5 text-green-500\" />\n              Captured Photos ({completedPhotos})\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-3\">\n              {Object.entries(capturedPhotos).map(([itemId, result]) => {\n                const item = checklist.items.find(i => i.id === itemId);\n                if (!item) return null;\n                \n                return (\n                  <div key={itemId} className=\"flex items-center justify-between p-4 border rounded-lg min-h-[60px] touch-manipulation\">\n                    <div className=\"flex-1 min-w-0 mr-3\">\n                      <h5 className=\"font-medium text-base leading-tight\">{item.title}</h5>\n                      <p className=\"text-sm text-gray-600 mt-1\">{item.category}</p>\n                    </div>\n                    <Badge className=\"bg-green-100 text-green-800 text-sm py-1 px-2 shrink-0\">\n                      {result.analysis.score}%\n                    </Badge>\n                  </div>\n                );\n              })}\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n};\n\nexport default PhotoGuidance;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/photo/PhotoGuidanceOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/photo/ReferencePhotoOverlay.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleDragMove'. Either include it or remove the dependency array.","line":170,"column":6,"nodeType":"ArrayExpression","endLine":170,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [handleDragMove, isDragging]","fix":{"range":[4989,5001],"text":"[handleDragMove, isDragging]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleResizeMove'. Either include it or remove the dependency array.","line":186,"column":6,"nodeType":"ArrayExpression","endLine":186,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [handleResizeMove, isResizing]","fix":{"range":[5617,5629],"text":"[handleResizeMove, isResizing]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Reference Photo Overlay Component for STR Certified\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Card } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Slider } from '@/components/ui/slider';\nimport {\n  X,\n  Move,\n  Maximize2,\n  Minimize2,\n  RotateCw,\n  FlipHorizontal,\n  FlipVertical,\n  Eye,\n  EyeOff,\n  Layers,\n  Lock,\n  Unlock,\n  Download,\n  RefreshCw\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\ninterface ReferencePhotoOverlayProps {\n  photoUrl: string;\n  opacity?: number;\n  initialPosition?: { x: number; y: number };\n  initialSize?: { width: number; height: number };\n  onOpacityChange?: (opacity: number) => void;\n  onClose?: () => void;\n  allowResize?: boolean;\n  allowRotate?: boolean;\n  allowFlip?: boolean;\n  locked?: boolean;\n  className?: string;\n}\n\nexport const ReferencePhotoOverlay: React.FC<ReferencePhotoOverlayProps> = ({\n  photoUrl,\n  opacity = 30,\n  initialPosition = { x: 20, y: 20 },\n  initialSize = { width: 200, height: 150 },\n  onOpacityChange,\n  onClose,\n  allowResize = true,\n  allowRotate = true,\n  allowFlip = true,\n  locked = false,\n  className\n}) => {\n  // State\n  const [position, setPosition] = useState(initialPosition);\n  const [size, setSize] = useState(initialSize);\n  const [rotation, setRotation] = useState(0);\n  const [flipH, setFlipH] = useState(false);\n  const [flipV, setFlipV] = useState(false);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isResizing, setIsResizing] = useState(false);\n  const [isMinimized, setIsMinimized] = useState(false);\n  const [isLocked, setIsLocked] = useState(locked);\n  const [currentOpacity, setCurrentOpacity] = useState(opacity);\n\n  // Refs\n  const overlayRef = useRef<HTMLDivElement>(null);\n  const dragStartRef = useRef({ x: 0, y: 0 });\n  const positionStartRef = useRef({ x: 0, y: 0 });\n  const resizeStartRef = useRef({ width: 0, height: 0, x: 0, y: 0 });\n\n  // Handle opacity changes\n  useEffect(() => {\n    setCurrentOpacity(opacity);\n  }, [opacity]);\n\n  // Handle drag start\n  const handleDragStart = (e: React.MouseEvent | React.TouchEvent) => {\n    if (isLocked || isMinimized) return;\n    \n    e.preventDefault();\n    setIsDragging(true);\n    \n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    dragStartRef.current = { x: clientX, y: clientY };\n    positionStartRef.current = { ...position };\n  };\n\n  // Handle drag move\n  const handleDragMove = (e: MouseEvent | TouchEvent) => {\n    if (!isDragging) return;\n    \n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    const deltaX = clientX - dragStartRef.current.x;\n    const deltaY = clientY - dragStartRef.current.y;\n    \n    setPosition({\n      x: positionStartRef.current.x + deltaX,\n      y: positionStartRef.current.y + deltaY\n    });\n  };\n\n  // Handle drag end\n  const handleDragEnd = () => {\n    setIsDragging(false);\n  };\n\n  // Handle resize start\n  const handleResizeStart = (e: React.MouseEvent | React.TouchEvent) => {\n    if (isLocked || !allowResize) return;\n    \n    e.preventDefault();\n    e.stopPropagation();\n    setIsResizing(true);\n    \n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    resizeStartRef.current = {\n      width: size.width,\n      height: size.height,\n      x: clientX,\n      y: clientY\n    };\n  };\n\n  // Handle resize move\n  const handleResizeMove = (e: MouseEvent | TouchEvent) => {\n    if (!isResizing) return;\n    \n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    const deltaX = clientX - resizeStartRef.current.x;\n    const deltaY = clientY - resizeStartRef.current.y;\n    \n    // Maintain aspect ratio\n    const aspectRatio = resizeStartRef.current.width / resizeStartRef.current.height;\n    const newWidth = Math.max(100, resizeStartRef.current.width + deltaX);\n    const newHeight = newWidth / aspectRatio;\n    \n    setSize({\n      width: newWidth,\n      height: newHeight\n    });\n  };\n\n  // Handle resize end\n  const handleResizeEnd = () => {\n    setIsResizing(false);\n  };\n\n  // Set up global event listeners\n  useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('mousemove', handleDragMove);\n      document.addEventListener('mouseup', handleDragEnd);\n      document.addEventListener('touchmove', handleDragMove);\n      document.addEventListener('touchend', handleDragEnd);\n      \n      return () => {\n        document.removeEventListener('mousemove', handleDragMove);\n        document.removeEventListener('mouseup', handleDragEnd);\n        document.removeEventListener('touchmove', handleDragMove);\n        document.removeEventListener('touchend', handleDragEnd);\n      };\n    }\n  }, [isDragging]);\n\n  useEffect(() => {\n    if (isResizing) {\n      document.addEventListener('mousemove', handleResizeMove);\n      document.addEventListener('mouseup', handleResizeEnd);\n      document.addEventListener('touchmove', handleResizeMove);\n      document.addEventListener('touchend', handleResizeEnd);\n      \n      return () => {\n        document.removeEventListener('mousemove', handleResizeMove);\n        document.removeEventListener('mouseup', handleResizeEnd);\n        document.removeEventListener('touchmove', handleResizeMove);\n        document.removeEventListener('touchend', handleResizeEnd);\n      };\n    }\n  }, [isResizing]);\n\n  // Handle rotation\n  const handleRotate = () => {\n    if (isLocked) return;\n    setRotation((prev) => (prev + 90) % 360);\n  };\n\n  // Handle flip\n  const handleFlipH = () => {\n    if (isLocked) return;\n    setFlipH(!flipH);\n  };\n\n  const handleFlipV = () => {\n    if (isLocked) return;\n    setFlipV(!flipV);\n  };\n\n  // Handle opacity change\n  const handleOpacityChange = (value: number[]) => {\n    const newOpacity = value[0];\n    setCurrentOpacity(newOpacity);\n    onOpacityChange?.(newOpacity);\n  };\n\n  // Calculate transform\n  const transform = `\n    rotate(${rotation}deg)\n    scaleX(${flipH ? -1 : 1})\n    scaleY(${flipV ? -1 : 1})\n  `;\n\n  if (isMinimized) {\n    return (\n      <div\n        className=\"fixed top-4 left-4 z-40\"\n        style={{ left: position.x, top: position.y }}\n      >\n        <Button\n          variant=\"secondary\"\n          size=\"sm\"\n          onClick={() => setIsMinimized(false)}\n          className=\"shadow-lg\"\n        >\n          <Layers className=\"h-4 w-4 mr-1\" />\n          Reference\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={overlayRef}\n      className={cn(\n        'absolute z-30 select-none',\n        isDragging && 'cursor-move',\n        className\n      )}\n      style={{\n        left: position.x,\n        top: position.y,\n        width: size.width,\n        height: size.height\n      }}\n    >\n      <Card className=\"relative w-full h-full overflow-hidden shadow-xl bg-black/20 backdrop-blur-sm\">\n        {/* Header Controls */}\n        <div className=\"absolute top-0 left-0 right-0 bg-black/50 backdrop-blur-sm p-2 z-10\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-1\">\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-6 w-6 text-white hover:bg-white/20\"\n                onClick={() => setIsLocked(!isLocked)}\n              >\n                {isLocked ? <Lock className=\"h-3 w-3\" /> : <Unlock className=\"h-3 w-3\" />}\n              </Button>\n              \n              {allowRotate && (\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-6 w-6 text-white hover:bg-white/20\"\n                  onClick={handleRotate}\n                  disabled={isLocked}\n                >\n                  <RotateCw className=\"h-3 w-3\" />\n                </Button>\n              )}\n              \n              {allowFlip && (\n                <>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    className=\"h-6 w-6 text-white hover:bg-white/20\"\n                    onClick={handleFlipH}\n                    disabled={isLocked}\n                  >\n                    <FlipHorizontal className=\"h-3 w-3\" />\n                  </Button>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    className=\"h-6 w-6 text-white hover:bg-white/20\"\n                    onClick={handleFlipV}\n                    disabled={isLocked}\n                  >\n                    <FlipVertical className=\"h-3 w-3\" />\n                  </Button>\n                </>\n              )}\n            </div>\n            \n            <div className=\"flex items-center space-x-1\">\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-6 w-6 text-white hover:bg-white/20\"\n                onClick={() => setIsMinimized(true)}\n              >\n                <Minimize2 className=\"h-3 w-3\" />\n              </Button>\n              {onClose && (\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-6 w-6 text-white hover:bg-white/20\"\n                  onClick={onClose}\n                >\n                  <X className=\"h-3 w-3\" />\n                </Button>\n              )}\n            </div>\n          </div>\n        </div>\n\n        {/* Photo Container */}\n        <div\n          className=\"relative w-full h-full cursor-move\"\n          onMouseDown={handleDragStart}\n          onTouchStart={handleDragStart}\n        >\n          <img\n            src={photoUrl}\n            alt=\"Reference\"\n            className=\"w-full h-full object-cover\"\n            style={{\n              opacity: currentOpacity / 100,\n              transform,\n              transformOrigin: 'center'\n            }}\n            draggable={false}\n          />\n          \n          {/* Resize Handle */}\n          {allowResize && !isLocked && (\n            <div\n              className=\"absolute bottom-0 right-0 w-4 h-4 bg-white/50 cursor-se-resize\"\n              onMouseDown={handleResizeStart}\n              onTouchStart={handleResizeStart}\n            />\n          )}\n        </div>\n\n        {/* Opacity Control */}\n        <div className=\"absolute bottom-0 left-0 right-0 bg-black/50 backdrop-blur-sm p-2\">\n          <div className=\"flex items-center space-x-2\">\n            <EyeOff className=\"h-3 w-3 text-white/60\" />\n            <Slider\n              value={[currentOpacity]}\n              onValueChange={handleOpacityChange}\n              min={0}\n              max={100}\n              step={5}\n              className=\"flex-1\"\n              disabled={isLocked}\n            />\n            <Eye className=\"h-3 w-3 text-white\" />\n            <span className=\"text-xs text-white min-w-[3ch]\">{currentOpacity}%</span>\n          </div>\n        </div>\n      </Card>\n    </div>\n  );\n};\n\n// Simplified static reference photo\nexport const StaticReferencePhoto: React.FC<{\n  photoUrl: string;\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  size?: 'small' | 'medium' | 'large';\n  onToggle?: () => void;\n}> = ({\n  photoUrl,\n  position = 'top-left',\n  size = 'small',\n  onToggle\n}) => {\n  const sizeClasses = {\n    small: 'w-24 h-18',\n    medium: 'w-32 h-24',\n    large: 'w-48 h-36'\n  };\n\n  const positionClasses = {\n    'top-left': 'top-4 left-4',\n    'top-right': 'top-4 right-4',\n    'bottom-left': 'bottom-4 left-4',\n    'bottom-right': 'bottom-4 right-4'\n  };\n\n  return (\n    <div className={cn(\n      'fixed z-20',\n      positionClasses[position]\n    )}>\n      <Card className={cn(\n        'overflow-hidden shadow-xl cursor-pointer',\n        sizeClasses[size]\n      )}\n      onClick={onToggle}\n      >\n        <img\n          src={photoUrl}\n          alt=\"Reference\"\n          className=\"w-full h-full object-cover\"\n        />\n        <div className=\"absolute inset-0 bg-gradient-to-t from-black/50 to-transparent\" />\n        <div className=\"absolute bottom-0 left-0 right-0 p-2\">\n          <p className=\"text-xs text-white font-medium\">Reference</p>\n        </div>\n      </Card>\n    </div>\n  );\n};\n\n// Mobile-optimized reference toggle\nexport const MobileReferenceToggle: React.FC<{\n  photoUrl: string;\n  isVisible: boolean;\n  onToggle: () => void;\n}> = ({ photoUrl, isVisible, onToggle }) => {\n  return (\n    <>\n      {/* Toggle Button */}\n      <Button\n        variant=\"secondary\"\n        size=\"sm\"\n        onClick={onToggle}\n        className=\"fixed top-4 right-4 z-30 shadow-lg\"\n      >\n        {isVisible ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n      </Button>\n\n      {/* Reference Photo */}\n      {isVisible && (\n        <div className=\"fixed inset-0 pointer-events-none z-20\">\n          <img\n            src={photoUrl}\n            alt=\"Reference\"\n            className=\"w-full h-full object-cover opacity-30\"\n          />\n        </div>\n      )}\n    </>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/scrapers/PropertyDataDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":465,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17676,17679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17676,17679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":485,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18327,18330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18327,18330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":506,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":506,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18935,18938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18935,18938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Property Data Display Component for STR Certified Scrapers\n\nimport React, { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Progress } from '@/components/ui/progress';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Separator } from '@/components/ui/separator';\nimport {\n  CheckCircle,\n  XCircle,\n  AlertTriangle,\n  RefreshCw,\n  Home,\n  MapPin,\n  Users,\n  Star,\n  Wifi,\n  Car,\n  Utensils,\n  Waves,\n  Flame,\n  Snowflake,\n  Shield,\n  Camera,\n  Grid3X3,\n  Image,\n  Filter,\n  Eye,\n  Calendar,\n  DollarSign\n} from 'lucide-react';\nimport type {\n  VRBOPropertyData,\n  PropertyAmenity,\n  PropertyRoom,\n  PhotoData,\n  PhotoDeduplicationResult,\n  AmenityCategory,\n  ScrapingState\n} from '@/lib/scrapers/types';\nimport { cn } from '@/lib/utils';\n\ninterface PropertyDataDisplayProps {\n  propertyData: VRBOPropertyData;\n  photos?: PhotoData[];\n  deduplicatedPhotos?: PhotoDeduplicationResult;\n  scrapingState?: ScrapingState;\n  className?: string;\n  onRefreshData?: () => void;\n  showPhotos?: boolean;\n  showDetailedBreakdown?: boolean;\n}\n\nexport const PropertyDataDisplay: React.FC<PropertyDataDisplayProps> = ({\n  propertyData,\n  photos = [],\n  deduplicatedPhotos,\n  scrapingState,\n  className,\n  onRefreshData,\n  showPhotos = true,\n  showDetailedBreakdown = true\n}) => {\n  const [selectedPhotoCategory, setSelectedPhotoCategory] = useState<string>('all');\n\n  const getAmenityIcon = (category: AmenityCategory) => {\n    const iconMap = {\n      kitchen: Utensils,\n      bathroom: Waves,\n      bedroom: Home,\n      entertainment: Grid3X3,\n      outdoor: MapPin,\n      safety: Shield,\n      accessibility: Users,\n      connectivity: Wifi,\n      climate: Snowflake,\n      parking: Car,\n      laundry: RefreshCw,\n      general: Home\n    };\n    \n    return iconMap[category] || Home;\n  };\n\n  const getCompletionPercentage = () => {\n    const requiredFields = ['title', 'description', 'amenities', 'photos', 'rooms'];\n    const completedFields = requiredFields.filter(field => {\n      const value = propertyData[field as keyof VRBOPropertyData];\n      if (Array.isArray(value)) return value.length > 0;\n      if (typeof value === 'string') return value.trim().length > 0;\n      return !!value;\n    });\n    \n    return Math.round((completedFields.length / requiredFields.length) * 100);\n  };\n\n  const filteredPhotos = selectedPhotoCategory === 'all' \n    ? photos \n    : photos.filter(photo => photo.category === selectedPhotoCategory);\n\n  const photoCategories = Array.from(new Set(photos.map(photo => photo.category)));\n\n  return (\n    <div className={cn('w-full space-y-6', className)}>\n      {/* Header with Status */}\n      <Card>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div className=\"space-y-1\">\n              <CardTitle className=\"flex items-center space-x-2\">\n                <Home className=\"h-5 w-5 text-blue-600\" />\n                <span>Property Data</span>\n              </CardTitle>\n              <CardDescription>\n                Scraped from VRBO â€¢ Last updated {propertyData.lastUpdated.toLocaleString()}\n              </CardDescription>\n            </div>\n            {onRefreshData && (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={onRefreshData}\n                disabled={scrapingState?.status === 'scraping'}\n                className=\"flex items-center space-x-1\"\n              >\n                <RefreshCw className={cn(\n                  \"h-4 w-4\", \n                  scrapingState?.status === 'scraping' && \"animate-spin\"\n                )} />\n                <span>Refresh</span>\n              </Button>\n            )}\n          </div>\n          \n          {/* Data Completeness */}\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between text-sm\">\n              <span>Data Completeness</span>\n              <span className=\"font-medium\">{getCompletionPercentage()}%</span>\n            </div>\n            <Progress value={getCompletionPercentage()} className=\"h-2\" />\n          </div>\n        </CardHeader>\n      </Card>\n\n      {/* Scraping Progress */}\n      {scrapingState?.status === 'scraping' && (\n        <Alert>\n          <RefreshCw className=\"h-4 w-4 animate-spin\" />\n          <AlertTitle>Scraping in Progress</AlertTitle>\n          <AlertDescription>\n            {scrapingState.currentStep} ({scrapingState.progress}%)\n            <Progress value={scrapingState.progress} className=\"mt-2 h-1\" />\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Main Content Tabs */}\n      <Tabs defaultValue=\"overview\" className=\"space-y-4\">\n        <TabsList className=\"grid w-full grid-cols-5\">\n          <TabsTrigger value=\"overview\">Overview</TabsTrigger>\n          <TabsTrigger value=\"amenities\">Amenities</TabsTrigger>\n          <TabsTrigger value=\"rooms\">Rooms</TabsTrigger>\n          {showPhotos && <TabsTrigger value=\"photos\">Photos</TabsTrigger>}\n          <TabsTrigger value=\"details\">Details</TabsTrigger>\n        </TabsList>\n\n        {/* Overview Tab */}\n        <TabsContent value=\"overview\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-xl\">{propertyData.title}</CardTitle>\n              <div className=\"flex items-center space-x-4 text-sm text-muted-foreground\">\n                <div className=\"flex items-center space-x-1\">\n                  <MapPin className=\"h-4 w-4\" />\n                  <span>{propertyData.location.city}, {propertyData.location.state}</span>\n                </div>\n                <div className=\"flex items-center space-x-1\">\n                  <Users className=\"h-4 w-4\" />\n                  <span>Up to {propertyData.specifications.maxGuests} guests</span>\n                </div>\n                {propertyData.reviews && (\n                  <div className=\"flex items-center space-x-1\">\n                    <Star className=\"h-4 w-4 fill-yellow-400 text-yellow-400\" />\n                    <span>{propertyData.reviews.averageRating} ({propertyData.reviews.totalReviews} reviews)</span>\n                  </div>\n                )}\n              </div>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <p className=\"text-muted-foreground leading-relaxed\">\n                {propertyData.description}\n              </p>\n              \n              <Separator />\n              \n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n                <div className=\"text-center p-3 bg-blue-50 rounded-lg\">\n                  <div className=\"text-2xl font-bold text-blue-600\">\n                    {propertyData.specifications.bedrooms}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Bedrooms</div>\n                </div>\n                <div className=\"text-center p-3 bg-green-50 rounded-lg\">\n                  <div className=\"text-2xl font-bold text-green-600\">\n                    {propertyData.specifications.bathrooms}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Bathrooms</div>\n                </div>\n                <div className=\"text-center p-3 bg-purple-50 rounded-lg\">\n                  <div className=\"text-2xl font-bold text-purple-600\">\n                    {propertyData.amenities.length}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Amenities</div>\n                </div>\n                <div className=\"text-center p-3 bg-orange-50 rounded-lg\">\n                  <div className=\"text-2xl font-bold text-orange-600\">\n                    {photos.length}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Photos</div>\n                </div>\n              </div>\n\n              {propertyData.pricing && (\n                <div className=\"p-4 bg-gray-50 rounded-lg\">\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"flex items-center space-x-2\">\n                      <DollarSign className=\"h-5 w-5 text-green-600\" />\n                      <span className=\"font-medium\">Pricing</span>\n                    </div>\n                    <div className=\"text-right\">\n                      <div className=\"text-lg font-bold\">\n                        ${propertyData.pricing.basePrice}/{propertyData.pricing.currency}\n                      </div>\n                      <div className=\"text-sm text-muted-foreground\">per night</div>\n                    </div>\n                  </div>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Amenities Tab */}\n        <TabsContent value=\"amenities\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle>Property Amenities</CardTitle>\n              <CardDescription>\n                {propertyData.amenities.length} amenities found\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <AmenitiesGrid amenities={propertyData.amenities} />\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Rooms Tab */}\n        <TabsContent value=\"rooms\" className=\"space-y-4\">\n          <div className=\"grid gap-4\">\n            {propertyData.rooms.map((room, index) => (\n              <RoomCard key={index} room={room} />\n            ))}\n          </div>\n        </TabsContent>\n\n        {/* Photos Tab */}\n        {showPhotos && (\n          <TabsContent value=\"photos\" className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle>Property Photos</CardTitle>\n                    <CardDescription>\n                      {photos.length} photos found\n                      {deduplicatedPhotos && (\n                        <span className=\"ml-2\">\n                          â€¢ {deduplicatedPhotos.duplicatesRemoved} duplicates removed\n                        </span>\n                      )}\n                    </CardDescription>\n                  </div>\n                  <div className=\"flex items-center space-x-2\">\n                    <Filter className=\"h-4 w-4\" />\n                    <select\n                      value={selectedPhotoCategory}\n                      onChange={(e) => setSelectedPhotoCategory(e.target.value)}\n                      className=\"text-sm border rounded px-2 py-1\"\n                    >\n                      <option value=\"all\">All Photos</option>\n                      {photoCategories.map(category => (\n                        <option key={category} value={category}>\n                          {category.replace('_', ' ').toUpperCase()}\n                        </option>\n                      ))}\n                    </select>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <PhotoGallery photos={filteredPhotos} />\n              </CardContent>\n            </Card>\n          </TabsContent>\n        )}\n\n        {/* Details Tab */}\n        <TabsContent value=\"details\" className=\"space-y-4\">\n          {showDetailedBreakdown && (\n            <div className=\"grid gap-4\">\n              <PropertySpecifications specifications={propertyData.specifications} />\n              <PropertyLocation location={propertyData.location} />\n              {propertyData.host && <HostInformation host={propertyData.host} />}\n              <VRBOSpecificDetails data={propertyData} />\n            </div>\n          )}\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n};\n\n// Sub-components\n\nconst AmenitiesGrid: React.FC<{ amenities: PropertyAmenity[] }> = ({ amenities }) => {\n  const groupedAmenities = amenities.reduce((acc, amenity) => {\n    if (!acc[amenity.category]) {\n      acc[amenity.category] = [];\n    }\n    acc[amenity.category].push(amenity);\n    return acc;\n  }, {} as Record<string, PropertyAmenity[]>);\n\n  return (\n    <div className=\"space-y-6\">\n      {Object.entries(groupedAmenities).map(([category, categoryAmenities]) => {\n        const IconComponent = getAmenityIcon(category as AmenityCategory);\n        \n        return (\n          <div key={category} className=\"space-y-3\">\n            <h4 className=\"font-medium flex items-center space-x-2 capitalize\">\n              <IconComponent className=\"h-4 w-4\" />\n              <span>{category.replace('_', ' ')}</span>\n            </h4>\n            <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3\">\n              {categoryAmenities.map((amenity, index) => (\n                <div\n                  key={index}\n                  className={cn(\n                    'flex items-center space-x-2 p-3 rounded-lg border',\n                    amenity.verified \n                      ? 'bg-green-50 border-green-200' \n                      : 'bg-gray-50 border-gray-200'\n                  )}\n                >\n                  {amenity.verified ? (\n                    <CheckCircle className=\"h-4 w-4 text-green-600\" />\n                  ) : (\n                    <AlertTriangle className=\"h-4 w-4 text-yellow-600\" />\n                  )}\n                  <span className=\"text-sm font-medium\">{amenity.name}</span>\n                  {amenity.icon && <span className=\"text-lg\">{amenity.icon}</span>}\n                </div>\n              ))}\n            </div>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nconst RoomCard: React.FC<{ room: PropertyRoom }> = ({ room }) => {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"capitalize flex items-center space-x-2\">\n          <Home className=\"h-5 w-5\" />\n          <span>{room.type.replace('_', ' ')}</span>\n          <Badge variant=\"secondary\">{room.count}</Badge>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        {room.description && (\n          <p className=\"text-muted-foreground\">{room.description}</p>\n        )}\n        \n        {room.amenities.length > 0 && (\n          <div className=\"space-y-2\">\n            <h5 className=\"font-medium\">Features:</h5>\n            <div className=\"flex flex-wrap gap-2\">\n              {room.amenities.map((amenity, index) => (\n                <Badge key={index} variant=\"outline\">{amenity}</Badge>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {room.photos.length > 0 && (\n          <div className=\"space-y-2\">\n            <h5 className=\"font-medium flex items-center space-x-2\">\n              <Camera className=\"h-4 w-4\" />\n              <span>Photos ({room.photos.length})</span>\n            </h5>\n            <div className=\"grid grid-cols-4 gap-2\">\n              {room.photos.slice(0, 4).map((photo, index) => (\n                <div key={index} className=\"aspect-square bg-gray-200 rounded-lg overflow-hidden\">\n                  <img \n                    src={photo} \n                    alt={`${room.type} ${index + 1}`}\n                    className=\"w-full h-full object-cover\"\n                    onError={(e) => {\n                      e.currentTarget.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBmaWxsPSIjRjNGNEY2Ii8+CjxwYXRoIGQ9Ik0xMiA5VjEzTTEyIDE3SDE2TTE2IDlIOEw2IDExVjE5SDIwVjExTDE4IDlaIiBzdHJva2U9IiM2QjcyODAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=';\n                    }}\n                  />\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nconst PhotoGallery: React.FC<{ photos: PhotoData[] }> = ({ photos }) => {\n  if (photos.length === 0) {\n    return (\n      <div className=\"text-center py-8 text-muted-foreground\">\n        <Image className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n        <p>No photos to display</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4\">\n      {photos.map((photo, index) => (\n        <div key={index} className=\"group relative aspect-square bg-gray-200 rounded-lg overflow-hidden\">\n          <img\n            src={photo.url}\n            alt={photo.alt || `Property photo ${index + 1}`}\n            className=\"w-full h-full object-cover transition-transform group-hover:scale-105\"\n            onError={(e) => {\n              e.currentTarget.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiBmaWxsPSIjRjNGNEY2Ii8+CjxwYXRoIGQ9Ik0xMiA5VjEzTTEyIDE3SDE2TTE2IDlIOEw2IDExVjE5SDIwVjExTDE4IDlaIiBzdHJva2U9IiM2QjcyODAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=';\n            }}\n          />\n          <div className=\"absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-opacity\" />\n          <div className=\"absolute bottom-2 left-2 right-2\">\n            <Badge variant=\"secondary\" className=\"text-xs\">\n              {photo.category.replace('_', ' ')}\n            </Badge>\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nconst PropertySpecifications: React.FC<{ specifications: any }> = ({ specifications }) => (\n  <Card>\n    <CardHeader>\n      <CardTitle>Property Specifications</CardTitle>\n    </CardHeader>\n    <CardContent>\n      <div className=\"grid grid-cols-2 md:grid-cols-3 gap-4\">\n        {Object.entries(specifications).map(([key, value]) => (\n          <div key={key} className=\"space-y-1\">\n            <div className=\"text-sm text-muted-foreground capitalize\">\n              {key.replace(/([A-Z])/g, ' $1').trim()}\n            </div>\n            <div className=\"font-medium\">{String(value)}</div>\n          </div>\n        ))}\n      </div>\n    </CardContent>\n  </Card>\n);\n\nconst PropertyLocation: React.FC<{ location: any }> = ({ location }) => (\n  <Card>\n    <CardHeader>\n      <CardTitle>Location</CardTitle>\n    </CardHeader>\n    <CardContent>\n      <div className=\"space-y-2\">\n        <div className=\"flex items-center space-x-2\">\n          <MapPin className=\"h-4 w-4\" />\n          <span>{location.city}, {location.state}, {location.country}</span>\n        </div>\n        {location.neighborhood && (\n          <div className=\"text-sm text-muted-foreground\">\n            Neighborhood: {location.neighborhood}\n          </div>\n        )}\n      </div>\n    </CardContent>\n  </Card>\n);\n\nconst HostInformation: React.FC<{ host: any }> = ({ host }) => (\n  <Card>\n    <CardHeader>\n      <CardTitle>Host Information</CardTitle>\n    </CardHeader>\n    <CardContent>\n      <div className=\"space-y-2\">\n        <div className=\"font-medium\">{host.name}</div>\n        {host.responseRate && (\n          <div className=\"text-sm\">Response rate: {host.responseRate}%</div>\n        )}\n        {host.responseTime && (\n          <div className=\"text-sm\">Response time: {host.responseTime}</div>\n        )}\n      </div>\n    </CardContent>\n  </Card>\n);\n\nconst VRBOSpecificDetails: React.FC<{ data: VRBOPropertyData }> = ({ data }) => (\n  <Card>\n    <CardHeader>\n      <CardTitle>VRBO Details</CardTitle>\n    </CardHeader>\n    <CardContent className=\"space-y-4\">\n      <div className=\"grid grid-cols-2 gap-4\">\n        <div>\n          <div className=\"text-sm text-muted-foreground\">Property ID</div>\n          <div className=\"font-medium\">{data.vrboId}</div>\n        </div>\n        <div>\n          <div className=\"text-sm text-muted-foreground\">Instant Book</div>\n          <div className=\"font-medium\">{data.instantBook ? 'Yes' : 'No'}</div>\n        </div>\n      </div>\n      \n      {data.houseRules && data.houseRules.length > 0 && (\n        <div>\n          <div className=\"text-sm text-muted-foreground mb-2\">House Rules</div>\n          <ul className=\"text-sm space-y-1\">\n            {data.houseRules.map((rule, index) => (\n              <li key={index} className=\"flex items-center space-x-2\">\n                <div className=\"w-1 h-1 bg-current rounded-full\" />\n                <span>{rule}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </CardContent>\n  </Card>\n);\n\n// Helper function to get amenity icon\nconst getAmenityIcon = (category: AmenityCategory) => {\n  const iconMap = {\n    kitchen: Utensils,\n    bathroom: Waves,\n    bedroom: Home,\n    entertainment: Grid3X3,\n    outdoor: MapPin,\n    safety: Shield,\n    accessibility: Users,\n    connectivity: Wifi,\n    climate: Snowflake,\n    parking: Car,\n    laundry: RefreshCw,\n    general: Home\n  };\n  \n  return iconMap[category] || Home;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/scrapers/PropertySelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/aspect-ratio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/badge.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":37,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":37,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":56,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":56,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/command.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":24,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":24,"endColumn":29,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[701,752],"text":"type CommandDialogProps = DialogProps"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\ninterface CommandDialogProps extends DialogProps {}\n\nconst CommandDialog = ({ children, ...props }: CommandDialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/context-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/form.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":168,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":168,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  ControllerProps,\n  FieldPath,\n  FieldValues,\n  FormProvider,\n  useFormContext,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message) : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/hover-card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/input-otp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/navigation-menu.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":119,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":119,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/sidebar.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":760,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":760,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { VariantProps, cva } from \"class-variance-authority\"\nimport { PanelLeft } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Sheet, SheetContent } from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar:state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContext = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContext | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean\n    open?: boolean\n    onOpenChange?: (open: boolean) => void\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const isMobile = useIsMobile()\n    const [openMobile, setOpenMobile] = React.useState(false)\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen)\n    const open = openProp ?? _open\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        const openState = typeof value === \"function\" ? value(open) : value\n        if (setOpenProp) {\n          setOpenProp(openState)\n        } else {\n          _setOpen(openState)\n        }\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n      },\n      [setOpenProp, open]\n    )\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open)\n    }, [isMobile, setOpen, setOpenMobile])\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault()\n          toggleSidebar()\n        }\n      }\n\n      window.addEventListener(\"keydown\", handleKeyDown)\n      return () => window.removeEventListener(\"keydown\", handleKeyDown)\n    }, [toggleSidebar])\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\"\n\n    const contextValue = React.useMemo<SidebarContext>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n    )\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar\",\n              className\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    )\n  }\n)\nSidebarProvider.displayName = \"SidebarProvider\"\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\"\n    variant?: \"sidebar\" | \"floating\" | \"inset\"\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      )\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      )\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden md:block text-sidebar-foreground\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\"\n          )}\n        />\n        <div\n          className={cn(\n            \"duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    )\n  }\n)\nSidebar.displayName = \"Sidebar\"\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n})\nSidebarTrigger.displayName = \"SidebarTrigger\"\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarRail.displayName = \"SidebarRail\"\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex min-h-svh flex-1 flex-col bg-background\",\n        \"peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInset.displayName = \"SidebarInset\"\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInput.displayName = \"SidebarInput\"\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarHeader.displayName = \"SidebarHeader\"\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarFooter.displayName = \"SidebarFooter\"\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  )\n})\nSidebarSeparator.displayName = \"SidebarSeparator\"\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarContent.displayName = \"SidebarContent\"\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarGroup.displayName = \"SidebarGroup\"\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\"\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupAction.displayName = \"SidebarGroupAction\"\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n))\nSidebarGroupContent.displayName = \"SidebarGroupContent\"\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n))\nSidebarMenu.displayName = \"SidebarMenu\"\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n))\nSidebarMenuItem.displayName = \"SidebarMenuItem\"\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    isActive?: boolean\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const Comp = asChild ? Slot : \"button\"\n    const { isMobile, state } = useSidebar()\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    )\n\n    if (!tooltip) {\n      return button\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      }\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    )\n  }\n)\nSidebarMenuButton.displayName = \"SidebarMenuButton\"\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    showOnHover?: boolean\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuAction.displayName = \"SidebarMenuAction\"\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\"\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"rounded-md h-8 flex gap-2 px-2 items-center\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 flex-1 max-w-[--skeleton-width]\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n})\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\"\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuSub.displayName = \"SidebarMenuSub\"\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />)\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\"\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean\n    size?: \"sm\" | \"md\"\n    isActive?: boolean\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\"\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/sonner.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":29,"column":19,"nodeType":"Identifier","messageId":"namedExport","endLine":29,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useTheme } from \"next-themes\"\nimport { Toaster as Sonner, toast } from \"sonner\"\n\ntype ToasterProps = React.ComponentProps<typeof Sonner>\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      toastOptions={{\n        classNames: {\n          toast:\n            \"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\",\n          description: \"group-[.toast]:text-muted-foreground\",\n          actionButton:\n            \"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\",\n          cancelButton:\n            \"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\",\n        },\n      }}\n      {...props}\n    />\n  )\n}\n\nexport { Toaster, toast }\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/textarea.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":5,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":5,"endColumn":31,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[73,159],"text":"type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  ({ className, ...props }, ref) => {\n    return (\n      <textarea\n        className={cn(\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/toggle.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":43,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":43,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3\",\n        sm: \"h-9 px-2.5\",\n        lg: \"h-11 px-5\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/ui/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/video/VideoPlayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/video/VideoRecorder.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleStopRecording'. Either include it or remove the dependency array.","line":90,"column":6,"nodeType":"ArrayExpression","endLine":90,"endColumn":50,"suggestions":[{"desc":"Update the dependencies array to be: [handleStopRecording, internalIsRecording, isPaused, maxDuration]","fix":{"range":[2377,2421],"text":"[handleStopRecording, internalIsRecording, isPaused, maxDuration]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useCallback, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Progress } from '@/components/ui/progress';\nimport {\n  Video,\n  Circle,\n  Square,\n  Pause,\n  Play,\n  RotateCcw,\n  AlertTriangle,\n  Info,\n  Camera,\n  Mic,\n  MicOff,\n  Settings,\n  RefreshCw\n} from 'lucide-react';\nimport { useCamera } from '@/hooks/useCamera';\n\ninterface VideoRecorderProps {\n  propertyId?: string;\n  isRecording: boolean;\n  onStartRecording: () => void;\n  onStopRecording: () => void;\n  maxDuration?: number; // seconds\n  className?: string;\n}\n\nexport function VideoRecorder({\n  propertyId,\n  isRecording: externalIsRecording,\n  onStartRecording,\n  onStopRecording,\n  maxDuration = 600, // 10 minutes default\n  className\n}: VideoRecorderProps) {\n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const chunksRef = useRef<Blob[]>([]);\n  \n  const [internalIsRecording, setInternalIsRecording] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [duration, setDuration] = useState(0);\n  const [recordedVideo, setRecordedVideo] = useState<Blob | null>(null);\n  const [audioEnabled, setAudioEnabled] = useState(true);\n  const [showSettings, setShowSettings] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const {\n    isReady,\n    error: cameraError,\n    hasPermission,\n    isLoading: cameraLoading,\n    stream,\n    requestPermission,\n    startCamera,\n    stopCamera,\n    switchCamera,\n    availableDevices\n  } = useCamera({\n    videoRef,\n    facingMode: 'environment',\n    resolution: { width: 1920, height: 1080 },\n    autoStart: true\n  });\n\n  // Timer for recording duration\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    \n    if (internalIsRecording && !isPaused) {\n      interval = setInterval(() => {\n        setDuration(prev => {\n          if (prev >= maxDuration) {\n            handleStopRecording();\n            return prev;\n          }\n          return prev + 1;\n        });\n      }, 1000);\n    }\n    \n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [internalIsRecording, isPaused, maxDuration]);\n\n  // Setup MediaRecorder when stream is available\n  useEffect(() => {\n    if (stream && isReady) {\n      try {\n        const mediaRecorder = new MediaRecorder(stream, {\n          mimeType: 'video/webm;codecs=vp9' \n        });\n        \n        mediaRecorder.ondataavailable = (event) => {\n          if (event.data.size > 0) {\n            chunksRef.current.push(event.data);\n          }\n        };\n        \n        mediaRecorder.onstop = () => {\n          const blob = new Blob(chunksRef.current, { type: 'video/webm' });\n          setRecordedVideo(blob);\n          chunksRef.current = [];\n          setInternalIsRecording(false);\n          setIsPaused(false);\n          onStopRecording();\n        };\n        \n        mediaRecorderRef.current = mediaRecorder;\n      } catch (err) {\n        console.error('Failed to create MediaRecorder:', err);\n        setError('Video recording not supported on this device');\n      }\n    }\n  }, [stream, isReady, onStopRecording]);\n\n  const handleStartRecording = useCallback(async () => {\n    if (!mediaRecorderRef.current || !stream) {\n      setError('Camera not ready for recording');\n      return;\n    }\n    \n    try {\n      setError(null);\n      chunksRef.current = [];\n      setDuration(0);\n      setRecordedVideo(null);\n      \n      mediaRecorderRef.current.start(1000); // Record in 1-second chunks\n      setInternalIsRecording(true);\n      setIsPaused(false);\n      \n      onStartRecording();\n    } catch (err) {\n      setError('Failed to start recording');\n      console.error('Recording start error:', err);\n    }\n  }, [stream, onStartRecording]);\n\n  const handleStopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && internalIsRecording) {\n      mediaRecorderRef.current.stop();\n    }\n  }, [internalIsRecording]);\n\n  const handlePauseRecording = useCallback(() => {\n    if (mediaRecorderRef.current && internalIsRecording) {\n      mediaRecorderRef.current.pause();\n      setIsPaused(true);\n    }\n  }, [internalIsRecording]);\n\n  const handleResumeRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isPaused) {\n      mediaRecorderRef.current.resume();\n      setIsPaused(false);\n    }\n  }, [isPaused]);\n\n  // Format duration\n  const formatDuration = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  // Camera permission handling\n  if (!hasPermission && !cameraLoading) {\n    return (\n      <Card className={className}>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Camera className=\"h-5 w-5\" />\n            Camera Permission Required\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <Alert>\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertTitle>Camera Access Needed</AlertTitle>\n            <AlertDescription>\n              We need access to your camera to record the property walkthrough.\n            </AlertDescription>\n          </Alert>\n          <Button onClick={requestPermission} className=\"w-full\">\n            <Camera className=\"h-4 w-4 mr-2\" />\n            Enable Camera\n          </Button>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (cameraError || error) {\n    return (\n      <Alert variant=\"destructive\">\n        <AlertTriangle className=\"h-4 w-4\" />\n        <AlertTitle>Camera Error</AlertTitle>\n        <AlertDescription className=\"mt-2\">\n          {error || cameraError}\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            className=\"mt-2 ml-2\" \n            onClick={() => window.location.reload()}\n          >\n            <RefreshCw className=\"h-4 w-4 mr-2\" />\n            Retry\n          </Button>\n        </AlertDescription>\n      </Alert>\n    );\n  }\n\n  const isCurrentlyRecording = internalIsRecording || externalIsRecording;\n\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <Video className=\"h-5 w-5\" />\n          Video Walkthrough\n          {isCurrentlyRecording && (\n            <Badge className=\"bg-red-100 text-red-800 animate-pulse\">\n              Recording\n            </Badge>\n          )}\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4 pb-6\">\n        {/* Video Preview - Mobile Optimized */}\n        <div className=\"relative bg-black rounded-lg overflow-hidden aspect-video min-h-[300px] sm:min-h-[400px]\">\n          {cameraLoading ? (\n            <div className=\"absolute inset-0 flex items-center justify-center\">\n              <div className=\"text-white text-lg\">Loading camera...</div>\n            </div>\n          ) : (\n            <video\n              ref={videoRef}\n              className=\"w-full h-full object-cover\"\n              autoPlay\n              playsInline\n              muted\n            />\n          )}\n          \n          {/* Recording Indicator - Mobile Optimized */}\n          {isCurrentlyRecording && (\n            <div className=\"absolute top-4 left-4 bg-red-600 text-white px-4 py-2 rounded-full flex items-center gap-2 text-lg font-medium\">\n              <Circle className=\"h-4 w-4 fill-current animate-pulse\" />\n              <span className=\"font-mono\">{formatDuration(duration)}</span>\n            </div>\n          )}\n\n          {/* Settings Button - Mobile Optimized */}\n          <Button\n            variant=\"secondary\"\n            size=\"icon\"\n            className=\"absolute bottom-4 right-4 h-12 w-12 touch-manipulation\"\n            onClick={() => setShowSettings(!showSettings)}\n            disabled={isCurrentlyRecording}\n          >\n            <Settings className=\"h-6 w-6\" />\n          </Button>\n        </div>\n\n        {/* Settings Panel - Mobile Optimized */}\n        {showSettings && !isCurrentlyRecording && (\n          <Card className=\"p-4 bg-gray-50 dark:bg-gray-800\">\n            <div className=\"space-y-4\">\n              <div className=\"flex items-center justify-between py-2\">\n                <div className=\"flex items-center gap-3\">\n                  {audioEnabled ? <Mic className=\"h-5 w-5\" /> : <MicOff className=\"h-5 w-5\" />}\n                  <span className=\"text-base font-medium\">Audio Recording</span>\n                </div>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => setAudioEnabled(!audioEnabled)}\n                  className=\"h-10 px-4 text-base touch-manipulation\"\n                >\n                  {audioEnabled ? 'Enabled' : 'Disabled'}\n                </Button>\n              </div>\n              \n              {availableDevices.length > 1 && (\n                <div className=\"flex items-center justify-between py-2\">\n                  <div className=\"flex items-center gap-3\">\n                    <Camera className=\"h-5 w-5\" />\n                    <span className=\"text-base font-medium\">Switch Camera</span>\n                  </div>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={switchCamera}\n                    className=\"h-10 px-4 text-base touch-manipulation\"\n                  >\n                    <RotateCcw className=\"h-4 w-4 mr-2\" />\n                    Switch\n                  </Button>\n                </div>\n              )}\n            </div>\n          </Card>\n        )}\n\n        {/* Progress Bar - Mobile Optimized */}\n        {isCurrentlyRecording && (\n          <div className=\"space-y-3\">\n            <div className=\"flex items-center justify-between text-lg font-medium\">\n              <span>{formatDuration(duration)}</span>\n              <span className=\"text-gray-600\">{formatDuration(maxDuration)}</span>\n            </div>\n            <Progress\n              value={(duration / maxDuration) * 100}\n              className=\"h-3\"\n            />\n          </div>\n        )}\n\n        {/* Recording Controls - Mobile Optimized */}\n        <div className=\"space-y-4\">\n          {!isCurrentlyRecording && (\n            <div className=\"flex justify-center\">\n              <Button\n                size=\"lg\"\n                onClick={handleStartRecording}\n                disabled={!isReady}\n                className=\"h-16 px-8 text-lg min-w-[200px] touch-manipulation\"\n              >\n                <Circle className=\"h-6 w-6 mr-3\" />\n                Start Recording\n              </Button>\n            </div>\n          )}\n\n          {isCurrentlyRecording && !isPaused && (\n            <div className=\"flex flex-col sm:flex-row justify-center gap-3\">\n              <Button\n                variant=\"secondary\"\n                size=\"lg\"\n                onClick={handlePauseRecording}\n                className=\"h-14 px-6 text-lg min-w-[120px] touch-manipulation\"\n              >\n                <Pause className=\"h-5 w-5 mr-2\" />\n                Pause\n              </Button>\n              <Button\n                variant=\"destructive\"\n                size=\"lg\"\n                onClick={handleStopRecording}\n                className=\"h-14 px-6 text-lg min-w-[120px] touch-manipulation\"\n              >\n                <Square className=\"h-5 w-5 mr-2\" />\n                Stop\n              </Button>\n            </div>\n          )}\n\n          {isPaused && (\n            <div className=\"flex flex-col sm:flex-row justify-center gap-3\">\n              <Button\n                size=\"lg\"\n                onClick={handleResumeRecording}\n                className=\"h-14 px-6 text-lg min-w-[120px] touch-manipulation\"\n              >\n                <Play className=\"h-5 w-5 mr-2\" />\n                Resume\n              </Button>\n              <Button\n                variant=\"destructive\"\n                size=\"lg\"\n                onClick={handleStopRecording}\n                className=\"h-14 px-6 text-lg min-w-[120px] touch-manipulation\"\n              >\n                <Square className=\"h-5 w-5 mr-2\" />\n                Stop\n              </Button>\n            </div>\n          )}\n        </div>\n\n        {/* Recording Tips - Mobile Optimized */}\n        {!isCurrentlyRecording && (\n          <Alert>\n            <Info className=\"h-5 w-5\" />\n            <AlertDescription>\n              <p className=\"font-medium mb-3 text-base\">Recording Tips:</p>\n              <ul className=\"text-base space-y-2 list-disc list-inside text-gray-600 dark:text-gray-400 leading-relaxed\">\n                <li>Walk slowly and steadily through each room</li>\n                <li>Focus on key features and any issues you find</li>\n                <li>Narrate what you're showing if audio is enabled</li>\n                <li>Ensure good lighting in all areas</li>\n                <li>Keep the camera steady to avoid shaky footage</li>\n              </ul>\n            </AlertDescription>\n          </Alert>\n        )}\n\n        {/* Completed Video - Mobile Optimized */}\n        {recordedVideo && !isCurrentlyRecording && (\n          <Card className=\"border-green-200 bg-green-50 dark:bg-green-900/20\">\n            <CardContent className=\"p-4\">\n              <div className=\"flex items-center gap-3 text-green-800 dark:text-green-200\">\n                <Video className=\"h-5 w-5 shrink-0\" />\n                <div className=\"flex-1 min-w-0\">\n                  <span className=\"font-medium text-base\">Video Recorded Successfully</span>\n                  <p className=\"text-sm text-green-700 dark:text-green-300 mt-1\">\n                    Your property walkthrough video has been recorded and is ready for upload.\n                  </p>\n                </div>\n                <Badge className=\"bg-green-100 text-green-800 shrink-0 text-sm py-1\">\n                  {formatDuration(duration)}\n                </Badge>\n              </div>\n            </CardContent>\n          </Card>\n        )}\n      </CardContent>\n    </Card>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/components/video/VideoUploadProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/contexts/AuthContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[278,281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[278,281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[350,353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[350,353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { createContext } from 'react';\nimport { User } from '@supabase/supabase-js';\n\nexport interface AuthContextType {\n  user: User | null;\n  userRole: string | null;\n  loading: boolean;\n  error: string | null;\n  signIn: (email: string, password: string) => Promise<{ error: any }>;\n  signUp: (email: string, password: string) => Promise<{ error: any }>;\n  signOut: () => Promise<void>;\n  forceRefresh: () => Promise<void>;\n  clearSession: () => void;\n  loadUserRole: () => Promise<void>;\n}\n\nexport const AuthContext = createContext<AuthContextType | undefined>(undefined);\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/contexts/MobileAuthContext.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[278,281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[278,281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[350,353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[350,353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { createContext } from 'react';\nimport { User } from '@supabase/supabase-js';\n\nexport interface AuthContextType {\n  user: User | null;\n  userRole: string | null;\n  loading: boolean;\n  error: string | null;\n  signIn: (email: string, password: string) => Promise<{ error: any }>;\n  signUp: (email: string, password: string) => Promise<{ error: any }>;\n  signOut: () => Promise<void>;\n  forceRefresh: () => Promise<void>;\n  clearSession: () => void;\n  loadUserRole: () => Promise<void>;\n}\n\nexport const AuthContext = createContext<AuthContextType | undefined>(undefined);\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/use-mobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAIAnalysis.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1491,1494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1491,1494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1525,1528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1525,1528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1618,1621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1618,1621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5525,5528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5525,5528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7069,7072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7069,7072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// React Hook for AI Analysis in STR Certified\n\nimport { useState, useCallback, useRef } from 'react';\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport { STRCertifiedAIService, createAIService } from '@/lib/ai/openai-service';\nimport type {\n  AIAnalysisResult,\n  PhotoComparisonResult,\n  DynamicChecklistItem,\n  PropertyData,\n  AIAnalysisState,\n  AIError,\n  AIAnalysisOptions\n} from '@/lib/ai/types';\n\ninterface UseAIAnalysisConfig {\n  apiKey?: string;\n  maxRetries?: number;\n  retryDelay?: number;\n  enableAutoRetry?: boolean;\n}\n\ninterface UseAIAnalysisReturn {\n  // States\n  analysisState: AIAnalysisState;\n  \n  // Photo Analysis\n  analyzePhoto: (file: File, context: string, options?: AIAnalysisOptions) => Promise<AIAnalysisResult>;\n  photoAnalysis: {\n    isLoading: boolean;\n    error: AIError | null;\n    data: AIAnalysisResult | null;\n    retry: () => void;\n  };\n  \n  // Photo Comparison\n  comparePhotos: (inspectorPhoto: File, listingPhotos: string[], context: string) => Promise<PhotoComparisonResult>;\n  photoComparison: {\n    isLoading: boolean;\n    error: AIError | null;\n    data: PhotoComparisonResult | null;\n    retry: () => void;\n  };\n  \n  // Checklist Generation\n  generateChecklist: (propertyData: PropertyData) => Promise<DynamicChecklistItem[]>;\n  checklistGeneration: {\n    isLoading: boolean;\n    error: AIError | null;\n    data: DynamicChecklistItem[] | null;\n    retry: () => void;\n  };\n  \n  // Validation\n  validateInspection: (checklistItems: any[], photos: File[]) => Promise<any>;\n  inspectionValidation: {\n    isLoading: boolean;\n    error: AIError | null;\n    data: any;\n    retry: () => void;\n  };\n  \n  // Utility\n  resetAnalysis: () => void;\n  isAnalyzing: boolean;\n}\n\nexport const useAIAnalysis = (config: UseAIAnalysisConfig = {}): UseAIAnalysisReturn => {\n  const {\n    apiKey = process.env.VITE_OPENAI_API_KEY || '',\n    maxRetries = 3,\n    retryDelay = 1000,\n    enableAutoRetry = true\n  } = config;\n\n  // State management\n  const [analysisState, setAnalysisState] = useState<AIAnalysisState>({\n    status: 'idle'\n  });\n\n  // Service instance ref\n  const aiServiceRef = useRef<STRCertifiedAIService | null>(null);\n\n  // Initialize AI service\n  const getAIService = useCallback(() => {\n    if (!aiServiceRef.current && apiKey) {\n      aiServiceRef.current = createAIService({ apiKey });\n    }\n    if (!aiServiceRef.current) {\n      throw new Error('OpenAI API key is required for AI analysis');\n    }\n    return aiServiceRef.current;\n  }, [apiKey]);\n\n  // Photo Analysis Mutation\n  const photoAnalysisMutation = useMutation({\n    mutationFn: async ({ \n      file, \n      context, \n      options \n    }: { \n      file: File; \n      context: string; \n      options?: AIAnalysisOptions;\n    }) => {\n      const service = getAIService();\n      setAnalysisState({ status: 'analyzing', progress: 0 });\n      \n      try {\n        const result = await service.analyzeInspectionPhoto(file, context, options);\n        setAnalysisState({ status: 'completed', result, progress: 100 });\n        return result;\n      } catch (error) {\n        const aiError = error as AIError;\n        setAnalysisState({ status: 'error', error: aiError });\n        throw aiError;\n      }\n    },\n    retry: (failureCount, error) => {\n      const aiError = error as AIError;\n      return enableAutoRetry && aiError.retryable && failureCount < maxRetries;\n    },\n    retryDelay: (attemptIndex) => Math.min(retryDelay * Math.pow(2, attemptIndex), 10000),\n  });\n\n  // Photo Comparison Mutation\n  const photoComparisonMutation = useMutation({\n    mutationFn: async ({\n      inspectorPhoto,\n      listingPhotos,\n      context\n    }: {\n      inspectorPhoto: File;\n      listingPhotos: string[];\n      context: string;\n    }) => {\n      const service = getAIService();\n      setAnalysisState({ status: 'analyzing', progress: 0 });\n      \n      try {\n        const result = await service.comparePhotoToListing(inspectorPhoto, listingPhotos, context);\n        setAnalysisState({ status: 'completed', progress: 100 });\n        return result;\n      } catch (error) {\n        const aiError = error as AIError;\n        setAnalysisState({ status: 'error', error: aiError });\n        throw aiError;\n      }\n    },\n    retry: (failureCount, error) => {\n      const aiError = error as AIError;\n      return enableAutoRetry && aiError.retryable && failureCount < maxRetries;\n    },\n    retryDelay: (attemptIndex) => Math.min(retryDelay * Math.pow(2, attemptIndex), 10000),\n  });\n\n  // Checklist Generation Mutation\n  const checklistGenerationMutation = useMutation({\n    mutationFn: async (propertyData: PropertyData) => {\n      const service = getAIService();\n      setAnalysisState({ status: 'analyzing', progress: 0 });\n      \n      try {\n        const result = await service.generateDynamicChecklist(propertyData);\n        setAnalysisState({ status: 'completed', progress: 100 });\n        return result;\n      } catch (error) {\n        const aiError = error as AIError;\n        setAnalysisState({ status: 'error', error: aiError });\n        throw aiError;\n      }\n    },\n    retry: (failureCount, error) => {\n      const aiError = error as AIError;\n      return enableAutoRetry && aiError.retryable && failureCount < maxRetries;\n    },\n    retryDelay: (attemptIndex) => Math.min(retryDelay * Math.pow(2, attemptIndex), 10000),\n  });\n\n  // Inspection Validation Mutation\n  const inspectionValidationMutation = useMutation({\n    mutationFn: async ({\n      checklistItems,\n      photos\n    }: {\n      checklistItems: any[];\n      photos: File[];\n    }) => {\n      const service = getAIService();\n      setAnalysisState({ status: 'analyzing', progress: 0 });\n      \n      try {\n        const result = await service.validateInspectionCompleteness(checklistItems, photos);\n        setAnalysisState({ status: 'completed', progress: 100 });\n        return result;\n      } catch (error) {\n        const aiError = error as AIError;\n        setAnalysisState({ status: 'error', error: aiError });\n        throw aiError;\n      }\n    },\n    retry: (failureCount, error) => {\n      const aiError = error as AIError;\n      return enableAutoRetry && aiError.retryable && failureCount < maxRetries;\n    },\n    retryDelay: (attemptIndex) => Math.min(retryDelay * Math.pow(2, attemptIndex), 10000),\n  });\n\n  // Helper functions\n  const analyzePhoto = useCallback(\n    async (file: File, context: string, options?: AIAnalysisOptions) => {\n      return photoAnalysisMutation.mutateAsync({ file, context, options });\n    },\n    [photoAnalysisMutation]\n  );\n\n  const comparePhotos = useCallback(\n    async (inspectorPhoto: File, listingPhotos: string[], context: string) => {\n      return photoComparisonMutation.mutateAsync({ inspectorPhoto, listingPhotos, context });\n    },\n    [photoComparisonMutation]\n  );\n\n  const generateChecklist = useCallback(\n    async (propertyData: PropertyData) => {\n      return checklistGenerationMutation.mutateAsync(propertyData);\n    },\n    [checklistGenerationMutation]\n  );\n\n  const validateInspection = useCallback(\n    async (checklistItems: any[], photos: File[]) => {\n      return inspectionValidationMutation.mutateAsync({ checklistItems, photos });\n    },\n    [inspectionValidationMutation]\n  );\n\n  const resetAnalysis = useCallback(() => {\n    setAnalysisState({ status: 'idle' });\n    photoAnalysisMutation.reset();\n    photoComparisonMutation.reset();\n    checklistGenerationMutation.reset();\n    inspectionValidationMutation.reset();\n  }, [\n    photoAnalysisMutation,\n    photoComparisonMutation,\n    checklistGenerationMutation,\n    inspectionValidationMutation\n  ]);\n\n  // Computed values\n  const isAnalyzing = \n    photoAnalysisMutation.isPending ||\n    photoComparisonMutation.isPending ||\n    checklistGenerationMutation.isPending ||\n    inspectionValidationMutation.isPending;\n\n  return {\n    analysisState,\n    \n    analyzePhoto,\n    photoAnalysis: {\n      isLoading: photoAnalysisMutation.isPending,\n      error: photoAnalysisMutation.error as AIError | null,\n      data: photoAnalysisMutation.data || null,\n      retry: () => photoAnalysisMutation.reset(),\n    },\n    \n    comparePhotos,\n    photoComparison: {\n      isLoading: photoComparisonMutation.isPending,\n      error: photoComparisonMutation.error as AIError | null,\n      data: photoComparisonMutation.data || null,\n      retry: () => photoComparisonMutation.reset(),\n    },\n    \n    generateChecklist,\n    checklistGeneration: {\n      isLoading: checklistGenerationMutation.isPending,\n      error: checklistGenerationMutation.error as AIError | null,\n      data: checklistGenerationMutation.data || null,\n      retry: () => checklistGenerationMutation.reset(),\n    },\n    \n    validateInspection,\n    inspectionValidation: {\n      isLoading: inspectionValidationMutation.isPending,\n      error: inspectionValidationMutation.error as AIError | null,\n      data: inspectionValidationMutation.data || null,\n      retry: () => inspectionValidationMutation.reset(),\n    },\n    \n    resetAnalysis,\n    isAnalyzing,\n  };\n};\n\n// Specialized hooks for specific use cases\n\nexport const usePhotoAnalysis = (config?: UseAIAnalysisConfig) => {\n  const { analyzePhoto, photoAnalysis, resetAnalysis } = useAIAnalysis(config);\n  \n  return {\n    analyzePhoto,\n    ...photoAnalysis,\n    reset: resetAnalysis,\n  };\n};\n\nexport const usePhotoComparison = (config?: UseAIAnalysisConfig) => {\n  const { comparePhotos, photoComparison, resetAnalysis } = useAIAnalysis(config);\n  \n  return {\n    comparePhotos,\n    ...photoComparison,\n    reset: resetAnalysis,\n  };\n};\n\nexport const useChecklistGeneration = (config?: UseAIAnalysisConfig) => {\n  const { generateChecklist, checklistGeneration, resetAnalysis } = useAIAnalysis(config);\n  \n  return {\n    generateChecklist,\n    ...checklistGeneration,\n    reset: resetAnalysis,\n  };\n};\n\nexport const useInspectionValidation = (config?: UseAIAnalysisConfig) => {\n  const { validateInspection, inspectionValidation, resetAnalysis } = useAIAnalysis(config);\n  \n  return {\n    validateInspection,\n    ...inspectionValidation,\n    reset: resetAnalysis,\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAuthInitialization.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[219,222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[219,222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[251,254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[251,254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-async-promise-executor","severity":2,"message":"Promise executor functions should not be async.","line":34,"column":43,"nodeType":"Identifier","messageId":"async","endLine":34,"endColumn":48}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { getCachedRole } from '@/utils/mobileCacheUtils';\n\ninterface UseAuthInitializationProps {\n  setSession: (session: any) => void;\n  setUser: (user: any) => void;\n  setUserRole: (role: string | null) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  fetchUserRole: (userId: string, useCache?: boolean) => Promise<string>;\n  initializationRef: React.MutableRefObject<Promise<void> | null>;\n}\n\nexport const useAuthInitialization = ({\n  setSession,\n  setUser,\n  setUserRole,\n  setLoading,\n  setError,\n  fetchUserRole,\n  initializationRef\n}: UseAuthInitializationProps) => {\n  \n  const initializeAuth = useCallback(async (): Promise<void> => {\n    if (initializationRef.current) {\n      return initializationRef.current;\n    }\n\n    console.log('ðŸ“± Mobile auth initialization...');\n    setError(null);\n\n    const initPromise = new Promise<void>(async (resolve) => {\n      try {\n        // Mobile-friendly timeout (2 seconds)\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error('Mobile auth timeout')), 2000);\n        });\n\n        const sessionPromise = supabase.auth.getSession();\n        \n        const { data: { session } } = await Promise.race([sessionPromise, timeoutPromise]);\n        \n        setSession(session);\n        setUser(session?.user ?? null);\n        \n        if (session?.user) {\n          console.log('ðŸ“± Mobile user found, setting role...');\n          const cachedRole = getCachedRole(session.user.id);\n          if (cachedRole) {\n            setUserRole(cachedRole);\n          } else {\n            setUserRole('inspector');\n            // Background role fetch for mobile\n            fetchUserRole(session.user.id, false).then(role => {\n              setUserRole(role);\n            }).catch(() => {\n              console.warn('ðŸ“± Background mobile role fetch failed');\n            });\n          }\n        } else {\n          setUserRole(null);\n          console.log('ðŸ“± No mobile session found');\n        }\n        \n        setLoading(false);\n        setError(null);\n        console.log('ðŸ“± Mobile auth initialization complete');\n        resolve();\n        \n      } catch (error) {\n        console.error('ðŸ“± Mobile auth initialization error:', error);\n        setUser(null);\n        setSession(null);\n        setUserRole(null);\n        setError('Mobile authentication failed');\n        setLoading(false);\n        resolve();\n      }\n    });\n\n    initializationRef.current = initPromise;\n    return initPromise;\n  }, [setSession, setUser, setUserRole, setLoading, setError, fetchUserRole, initializationRef]);\n\n  return { initializeAuth };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAuthRecovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAuthState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useAuthStateListener.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[216,219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[216,219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[248,251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[248,251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { getCachedRole } from '@/utils/mobileCacheUtils';\n\ninterface UseAuthStateListenerProps {\n  setSession: (session: any) => void;\n  setUser: (user: any) => void;\n  setUserRole: (role: string | null) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  fetchUserRole: (userId: string, useCache?: boolean) => Promise<string>;\n  initializeAuth: () => Promise<void>;\n}\n\nexport const useAuthStateListener = ({\n  setSession,\n  setUser,\n  setUserRole,\n  setLoading,\n  setError,\n  fetchUserRole,\n  initializeAuth\n}: UseAuthStateListenerProps) => {\n  \n  useEffect(() => {\n    let isMounted = true;\n    \n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        if (!isMounted) return;\n        \n        console.log('ðŸ“± Mobile auth state changed:', event, session?.user?.email);\n        \n        setSession(session);\n        setUser(session?.user ?? null);\n        \n        if (session?.user) {\n          const cachedRole = getCachedRole(session.user.id);\n          if (cachedRole) {\n            setUserRole(cachedRole);\n          } else {\n            setUserRole('inspector');\n            \n            // Background mobile role fetch\n            fetchUserRole(session.user.id, false).then(role => {\n              if (isMounted) {\n                setUserRole(role);\n              }\n            }).catch(error => {\n              console.error('ðŸ“± Background mobile role fetch failed:', error);\n            });\n          }\n        } else {\n          if (isMounted) {\n            setUserRole(null);\n          }\n        }\n        \n        if (isMounted) {\n          setLoading(false);\n          setError(null);\n        }\n      }\n    );\n\n    initializeAuth().catch((error) => {\n      if (isMounted) {\n        console.error('ðŸ“± Failed to initialize mobile auth:', error);\n        setLoading(false);\n      }\n    });\n\n    return () => {\n      isMounted = false;\n      subscription.unsubscribe();\n    };\n  }, [setSession, setUser, setUserRole, setLoading, setError, fetchUserRole, initializeAuth]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useCamera.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4459,4462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4459,4462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'startCamera'. Either include it or remove the dependency array.","line":180,"column":6,"nodeType":"ArrayExpression","endLine":180,"endColumn":51,"suggestions":[{"desc":"Update the dependencies array to be: [isSupported, getAvailableDevices, autoStart, startCamera]","fix":{"range":[5316,5361],"text":"[isSupported, getAvailableDevices, autoStart, startCamera]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7042,7045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7042,7045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Camera Hook for STR Certified Mobile Photo Capture\n\nimport { useState, useEffect, useCallback, useRef, MutableRefObject } from 'react';\n\nexport interface CameraOptions {\n  videoRef: MutableRefObject<HTMLVideoElement | null>;\n  facingMode?: 'user' | 'environment';\n  resolution?: {\n    width: number;\n    height: number;\n  };\n  autoStart?: boolean;\n}\n\nexport interface CameraState {\n  stream: MediaStream | null;\n  isReady: boolean;\n  error: string | null;\n  hasPermission: boolean;\n  isLoading: boolean;\n  currentDeviceId: string | null;\n  availableDevices: MediaDeviceInfo[];\n}\n\nexport interface UseCameraReturn extends CameraState {\n  requestPermission: () => Promise<void>;\n  startCamera: () => Promise<void>;\n  stopCamera: () => void;\n  switchCamera: () => Promise<void>;\n  takePhoto: () => Promise<Blob | null>;\n  getCurrentCamera: () => MediaDeviceInfo | null;\n  getCameraCapabilities: () => MediaTrackCapabilities | null;\n}\n\nexport const useCamera = (options: CameraOptions): UseCameraReturn => {\n  const {\n    videoRef,\n    facingMode = 'environment',\n    resolution = { width: 1920, height: 1080 },\n    autoStart = true\n  } = options;\n\n  // State\n  const [state, setState] = useState<CameraState>({\n    stream: null,\n    isReady: false,\n    error: null,\n    hasPermission: false,\n    isLoading: true,\n    currentDeviceId: null,\n    availableDevices: []\n  });\n\n  // Refs\n  const streamRef = useRef<MediaStream | null>(null);\n  const permissionCheckRef = useRef<boolean>(false);\n\n  // Check if media devices are supported\n  const isSupported = useCallback(() => {\n    return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n  }, []);\n\n  // Get available camera devices\n  const getAvailableDevices = useCallback(async (): Promise<MediaDeviceInfo[]> => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Failed to enumerate devices:', error);\n      return [];\n    }\n  }, []);\n\n  // Check camera permission\n  const checkPermission = useCallback(async (): Promise<boolean> => {\n    if (!isSupported()) {\n      setState(prev => ({\n        ...prev,\n        error: 'Camera not supported on this device',\n        hasPermission: false,\n        isLoading: false\n      }));\n      return false;\n    }\n\n    try {\n      // Check if we already have permission by looking at device labels\n      const devices = await getAvailableDevices();\n      const hasLabels = devices.some(device => device.label !== '');\n      \n      if (hasLabels) {\n        setState(prev => ({\n          ...prev,\n          hasPermission: true,\n          availableDevices: devices\n        }));\n        return true;\n      }\n\n      // Try to check permission state if available (Chrome 64+)\n      if (navigator.permissions && navigator.permissions.query) {\n        try {\n          const result = await navigator.permissions.query({ name: 'camera' as PermissionName });\n          const granted = result.state === 'granted';\n          setState(prev => ({\n            ...prev,\n            hasPermission: granted\n          }));\n          return granted;\n        } catch (e) {\n          // Permissions API not fully supported\n        }\n      }\n\n      return false;\n    } catch (error) {\n      console.error('Permission check failed:', error);\n      return false;\n    }\n  }, [isSupported, getAvailableDevices]);\n\n  // Request camera permission\n  const requestPermission = useCallback(async (): Promise<void> => {\n    if (!isSupported()) {\n      setState(prev => ({\n        ...prev,\n        error: 'Camera not supported on this device',\n        hasPermission: false,\n        isLoading: false\n      }));\n      return;\n    }\n\n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      // Request a temporary stream to trigger permission prompt\n      const tempStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: false\n      });\n\n      // Stop the temporary stream\n      tempStream.getTracks().forEach(track => track.stop());\n\n      // Update available devices\n      const devices = await getAvailableDevices();\n      \n      setState(prev => ({\n        ...prev,\n        hasPermission: true,\n        availableDevices: devices,\n        isLoading: false\n      }));\n\n      // Auto-start camera if enabled\n      if (autoStart) {\n        await startCamera();\n      }\n    } catch (error: any) {\n      let errorMessage = 'Failed to access camera';\n      \n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Camera permission denied';\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No camera found on this device';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Camera is already in use by another application';\n      } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {\n        errorMessage = 'Camera does not support the requested resolution';\n      }\n\n      setState(prev => ({\n        ...prev,\n        error: errorMessage,\n        hasPermission: false,\n        isLoading: false\n      }));\n    }\n  }, [isSupported, getAvailableDevices, autoStart]);\n\n  // Start camera with specified constraints\n  const startCamera = useCallback(async (): Promise<void> => {\n    if (!state.hasPermission) {\n      await requestPermission();\n      return;\n    }\n\n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      // Stop existing stream if any\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n\n      // Build constraints\n      const constraints: MediaStreamConstraints = {\n        audio: false,\n        video: {\n          facingMode: state.currentDeviceId ? undefined : facingMode,\n          deviceId: state.currentDeviceId ? { exact: state.currentDeviceId } : undefined,\n          width: { ideal: resolution.width },\n          height: { ideal: resolution.height }\n        }\n      };\n\n      // Get stream\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      streamRef.current = stream;\n\n      // Attach to video element\n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        \n        // Wait for video to be ready\n        await new Promise<void>((resolve) => {\n          if (videoRef.current) {\n            videoRef.current.onloadedmetadata = () => {\n              videoRef.current?.play();\n              resolve();\n            };\n          }\n        });\n      }\n\n      // Get current device ID\n      const videoTrack = stream.getVideoTracks()[0];\n      const settings = videoTrack.getSettings();\n      \n      setState(prev => ({\n        ...prev,\n        stream,\n        isReady: true,\n        isLoading: false,\n        currentDeviceId: settings.deviceId || null\n      }));\n    } catch (error: any) {\n      console.error('Failed to start camera:', error);\n      \n      setState(prev => ({\n        ...prev,\n        error: error.message || 'Failed to start camera',\n        isReady: false,\n        isLoading: false\n      }));\n    }\n  }, [state.hasPermission, state.currentDeviceId, facingMode, resolution, videoRef, requestPermission]);\n\n  // Stop camera\n  const stopCamera = useCallback((): void => {\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n\n    if (videoRef.current) {\n      videoRef.current.srcObject = null;\n    }\n\n    setState(prev => ({\n      ...prev,\n      stream: null,\n      isReady: false\n    }));\n  }, [videoRef]);\n\n  // Switch between front and back camera\n  const switchCamera = useCallback(async (): Promise<void> => {\n    if (state.availableDevices.length < 2) {\n      setState(prev => ({\n        ...prev,\n        error: 'Only one camera available'\n      }));\n      return;\n    }\n\n    // Find next device\n    const currentIndex = state.availableDevices.findIndex(\n      device => device.deviceId === state.currentDeviceId\n    );\n    const nextIndex = (currentIndex + 1) % state.availableDevices.length;\n    const nextDevice = state.availableDevices[nextIndex];\n\n    setState(prev => ({\n      ...prev,\n      currentDeviceId: nextDevice.deviceId\n    }));\n\n    // Restart camera with new device\n    await startCamera();\n  }, [state.availableDevices, state.currentDeviceId, startCamera]);\n\n  // Take a photo\n  const takePhoto = useCallback(async (): Promise<Blob | null> => {\n    if (!videoRef.current || !state.isReady) {\n      return null;\n    }\n\n    try {\n      // Create canvas\n      const canvas = document.createElement('canvas');\n      const video = videoRef.current;\n      \n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n      \n      const ctx = canvas.getContext('2d');\n      if (!ctx) return null;\n      \n      // Draw video frame\n      ctx.drawImage(video, 0, 0);\n      \n      // Convert to blob\n      return new Promise<Blob | null>((resolve) => {\n        canvas.toBlob(\n          (blob) => resolve(blob),\n          'image/jpeg',\n          0.95\n        );\n      });\n    } catch (error) {\n      console.error('Failed to take photo:', error);\n      return null;\n    }\n  }, [videoRef, state.isReady]);\n\n  // Get current camera info\n  const getCurrentCamera = useCallback((): MediaDeviceInfo | null => {\n    if (!state.currentDeviceId) return null;\n    return state.availableDevices.find(device => device.deviceId === state.currentDeviceId) || null;\n  }, [state.currentDeviceId, state.availableDevices]);\n\n  // Get camera capabilities\n  const getCameraCapabilities = useCallback((): MediaTrackCapabilities | null => {\n    if (!state.stream) return null;\n    \n    try {\n      const videoTrack = state.stream.getVideoTracks()[0];\n      if (videoTrack && 'getCapabilities' in videoTrack) {\n        return videoTrack.getCapabilities();\n      }\n    } catch (error) {\n      console.error('Failed to get capabilities:', error);\n    }\n    \n    return null;\n  }, [state.stream]);\n\n  // Initial permission check\n  useEffect(() => {\n    if (!permissionCheckRef.current) {\n      permissionCheckRef.current = true;\n      checkPermission().then(hasPermission => {\n        setState(prev => ({ ...prev, isLoading: false }));\n        if (hasPermission && autoStart) {\n          startCamera();\n        }\n      });\n    }\n  }, [checkPermission, autoStart, startCamera]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopCamera();\n    };\n  }, [stopCamera]);\n\n  return {\n    ...state,\n    requestPermission,\n    startCamera,\n    stopCamera,\n    switchCamera,\n    takePhoto,\n    getCurrentCamera,\n    getCameraCapabilities\n  };\n};\n\n// Utility hook for checking camera support\nexport const useCameraSupport = () => {\n  const [isSupported, setIsSupported] = useState(false);\n  const [checkedSupport, setCheckedSupport] = useState(false);\n\n  useEffect(() => {\n    const checkSupport = async () => {\n      const supported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n      setIsSupported(supported);\n      setCheckedSupport(true);\n    };\n\n    checkSupport();\n  }, []);\n\n  return { isSupported, checkedSupport };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useCategories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useChannelManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[265,268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[265,268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[503,506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[503,506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[625,628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[625,628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useRef, useCallback, useEffect } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { debugLogger } from '@/utils/debugLogger';\n\n// Global channel registry to prevent duplicate channels\nconst channelRegistry = new Map<string, any>();\nconst subscriptionRegistry = new Map<string, 'pending' | 'subscribed' | 'error'>();\nconst subscriptionPromises = new Map<string, Promise<void>>();\n\nexport const useChannelManager = () => {\n  const channelsRef = useRef<Map<string, any>>(new Map());\n  const isMountedRef = useRef(true);\n\n  const createChannel = useCallback((channelName: string, config: any) => {\n    debugLogger.debug('ChannelManager', 'Creating channel', { channelName });\n\n    // Check if channel already exists globally\n    if (channelRegistry.has(channelName)) {\n      const existingChannel = channelRegistry.get(channelName);\n      debugLogger.info('ChannelManager', 'Reusing existing channel', { channelName });\n      \n      // Store reference locally too\n      if (!channelsRef.current.has(channelName)) {\n        channelsRef.current.set(channelName, existingChannel);\n      }\n      \n      return existingChannel;\n    }\n\n    // Clean up any existing channel with this name (defensive)\n    if (channelsRef.current.has(channelName)) {\n      const existingChannel = channelsRef.current.get(channelName);\n      try {\n        supabase.removeChannel(existingChannel);\n        debugLogger.debug('ChannelManager', 'Cleaned up existing channel', { channelName });\n      } catch (error) {\n        debugLogger.warn('ChannelManager', 'Error removing existing channel', { channelName, error });\n      }\n    }\n\n    debugLogger.info('ChannelManager', 'Creating new channel', { channelName });\n\n    // Create new channel\n    const channel = supabase.channel(channelName);\n    \n    // Apply configuration\n    Object.keys(config).forEach(key => {\n      if (typeof config[key] === 'function') {\n        channel.on('postgres_changes', config[key].filter, config[key].callback);\n      }\n    });\n\n    // Store in registries\n    channelsRef.current.set(channelName, channel);\n    channelRegistry.set(channelName, channel);\n    subscriptionRegistry.set(channelName, 'pending');\n\n    debugLogger.debug('ChannelManager', 'Channel created and stored', { channelName });\n    return channel;\n  }, []);\n\n  const subscribeChannel = useCallback(async (channelName: string, onStatusChange?: (status: string) => void) => {\n    if (!isMountedRef.current) {\n      debugLogger.warn('ChannelManager', 'Attempted to subscribe to unmounted component', { channelName });\n      return;\n    }\n\n    debugLogger.debug('ChannelManager', 'Subscribing to channel', { channelName });\n\n    // Check if subscription is already in progress or completed\n    const currentStatus = subscriptionRegistry.get(channelName);\n    if (currentStatus === 'subscribed') {\n      debugLogger.info('ChannelManager', 'Channel already subscribed', { channelName });\n      onStatusChange?.('SUBSCRIBED');\n      return;\n    }\n    \n    if (currentStatus === 'pending') {\n      debugLogger.info('ChannelManager', 'Subscription already pending', { channelName });\n      // Wait for existing subscription to complete\n      const existingPromise = subscriptionPromises.get(channelName);\n      if (existingPromise) {\n        await existingPromise;\n        onStatusChange?.('SUBSCRIBED');\n        return;\n      }\n    }\n\n    const channel = channelsRef.current.get(channelName) || channelRegistry.get(channelName);\n    if (!channel) {\n      debugLogger.error('ChannelManager', 'Channel not found for subscription', { channelName });\n      return;\n    }\n\n    // Create subscription promise to prevent race conditions\n    const subscriptionPromise = new Promise<void>((resolve, reject) => {\n      try {\n        debugLogger.info('ChannelManager', 'Starting subscription', { channelName });\n        subscriptionRegistry.set(channelName, 'pending');\n        \n        channel.subscribe((status: string) => {\n          debugLogger.info('ChannelManager', 'Channel subscription status', { channelName, status });\n          \n          if (status === 'SUBSCRIBED') {\n            subscriptionRegistry.set(channelName, 'subscribed');\n            resolve();\n          } else if (status === 'CHANNEL_ERROR') {\n            subscriptionRegistry.set(channelName, 'error');\n            reject(new Error('Channel subscription error'));\n          }\n          \n          onStatusChange?.(status);\n        });\n      } catch (error) {\n        debugLogger.error('ChannelManager', 'Error subscribing to channel', { channelName, error });\n        subscriptionRegistry.set(channelName, 'error');\n        reject(error);\n      }\n    });\n\n    subscriptionPromises.set(channelName, subscriptionPromise);\n\n    try {\n      await subscriptionPromise;\n      debugLogger.info('ChannelManager', 'Channel subscription successful', { channelName });\n    } catch (error) {\n      debugLogger.error('ChannelManager', 'Subscription failed', { channelName, error });\n    } finally {\n      subscriptionPromises.delete(channelName);\n    }\n  }, []);\n\n  const cleanupChannel = useCallback((channelName: string) => {\n    debugLogger.info('ChannelManager', 'Cleaning up channel', { channelName });\n    \n    const channel = channelsRef.current.get(channelName);\n    if (channel) {\n      try {\n        supabase.removeChannel(channel);\n        debugLogger.debug('ChannelManager', 'Channel removed from Supabase', { channelName });\n      } catch (error) {\n        debugLogger.warn('ChannelManager', 'Error removing channel', { channelName, error });\n      }\n    }\n    \n    // Clean up all references\n    channelsRef.current.delete(channelName);\n    channelRegistry.delete(channelName);\n    subscriptionRegistry.delete(channelName);\n    subscriptionPromises.delete(channelName);\n    \n    debugLogger.debug('ChannelManager', 'Channel cleanup complete', { channelName });\n  }, []);\n\n  const cleanupAllChannels = useCallback(() => {\n    debugLogger.info('ChannelManager', 'Cleaning up all channels');\n    \n    const channelNames = Array.from(channelsRef.current.keys());\n    channelNames.forEach(channelName => cleanupChannel(channelName));\n    \n    debugLogger.info('ChannelManager', 'All channels cleaned up', { count: channelNames.length });\n  }, [cleanupChannel]);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    debugLogger.debug('ChannelManager', 'Hook mounted');\n    \n    return () => {\n      isMountedRef.current = false;\n      debugLogger.debug('ChannelManager', 'Hook unmounting, cleaning up');\n      cleanupAllChannels();\n    };\n  }, [cleanupAllChannels]);\n\n  return {\n    createChannel,\n    subscribeChannel,\n    cleanupChannel,\n    cleanupAllChannels\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useChecklistItemMedia.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useCleanAuth.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loading'. Either include it or remove the dependency array.","line":78,"column":6,"nodeType":"ArrayExpression","endLine":78,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loading]","fix":{"range":[2298,2300],"text":"[loading]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect } from 'react';\nimport { User } from '@supabase/supabase-js';\nimport { supabase } from '@/integrations/supabase/client';\nimport { debugLogger } from '@/utils/debugLogger';\n\nexport const useCleanAuth = () => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    debugLogger.info('CleanAuth', 'Initializing clean auth system');\n\n    let isMounted = true;\n\n    const initializeAuth = async () => {\n      try {\n        debugLogger.debug('CleanAuth', 'Fetching session');\n        const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n        \n        if (!isMounted) return;\n\n        if (sessionError) {\n          debugLogger.error('CleanAuth', 'Session error', sessionError);\n          setError(sessionError.message);\n          setUser(null);\n        } else {\n          debugLogger.info('CleanAuth', 'Session fetched successfully', { \n            hasSession: !!session,\n            userId: session?.user?.id,\n            email: session?.user?.email \n          });\n          setUser(session?.user ?? null);\n          setError(null);\n        }\n      } catch (err) {\n        if (!isMounted) return;\n        \n        debugLogger.error('CleanAuth', 'Auth initialization failed', err);\n        const errorMessage = err instanceof Error ? err.message : 'Authentication failed';\n        setError(errorMessage);\n        setUser(null);\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    initializeAuth();\n\n    // Set up auth state listener\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (event, session) => {\n        if (!isMounted) return;\n        \n        debugLogger.info('CleanAuth', 'Auth state changed', { \n          event, \n          hasSession: !!session,\n          userId: session?.user?.id \n        });\n        \n        setUser(session?.user ?? null);\n        setError(null);\n        \n        if (loading) {\n          setLoading(false);\n        }\n      }\n    );\n\n    return () => {\n      isMounted = false;\n      debugLogger.debug('CleanAuth', 'Cleaning up auth subscription');\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    user,\n    loading,\n    error,\n    isAuthenticated: !!user && !error\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useDataIntegrity.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[345,348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[345,348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3977,3980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3977,3980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'runIntegrityChecks'. Either include it or remove the dependency array.","line":154,"column":6,"nodeType":"ArrayExpression","endLine":154,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [inspectionId, runIntegrityChecks]","fix":{"range":[4735,4749],"text":"[inspectionId, runIntegrityChecks]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect } from 'react';\nimport { useToast } from '@/hooks/use-toast';\nimport { supabase } from '@/integrations/supabase/client';\n\ninterface DataIntegrityCheck {\n  id: string;\n  type: 'missing_data' | 'orphaned_record' | 'duplicate_data' | 'invalid_state';\n  severity: 'low' | 'medium' | 'high';\n  message: string;\n  data?: any;\n}\n\nexport const useDataIntegrity = (inspectionId?: string) => {\n  const [checks, setChecks] = useState<DataIntegrityCheck[]>([]);\n  const [isChecking, setIsChecking] = useState(false);\n  const { toast } = useToast();\n\n  const runIntegrityChecks = async () => {\n    if (!inspectionId) return;\n    \n    setIsChecking(true);\n    const issues: DataIntegrityCheck[] = [];\n\n    try {\n      // Check for orphaned media items\n      const { data: orphanedMedia } = await supabase\n        .from('media')\n        .select('id, checklist_item_id')\n        .not('checklist_item_id', 'in', \n          `(SELECT id FROM checklist_items WHERE inspection_id = '${inspectionId}')`\n        );\n\n      if (orphanedMedia && orphanedMedia.length > 0) {\n        issues.push({\n          id: 'orphaned-media',\n          type: 'orphaned_record',\n          severity: 'medium',\n          message: `Found ${orphanedMedia.length} orphaned media items`,\n          data: orphanedMedia\n        });\n      }\n\n      // Check for checklist items without required evidence\n      const { data: itemsWithoutEvidence } = await supabase\n        .from('checklist_items')\n        .select('id, label, status')\n        .eq('inspection_id', inspectionId)\n        .in('status', ['completed', 'failed'])\n        .not('id', 'in', \n          `(SELECT DISTINCT checklist_item_id FROM media)`\n        );\n\n      if (itemsWithoutEvidence && itemsWithoutEvidence.length > 0) {\n        issues.push({\n          id: 'missing-evidence',\n          type: 'missing_data',\n          severity: 'high',\n          message: `${itemsWithoutEvidence.length} completed items missing evidence`,\n          data: itemsWithoutEvidence\n        });\n      }\n\n      // Check for duplicate checklist items\n      const { data: duplicates } = await supabase\n        .rpc('analyze_checklist_duplicates');\n\n      if (duplicates && duplicates.length > 0) {\n        const inspectionDuplicates = duplicates.filter(d => d.inspection_id === inspectionId);\n        if (inspectionDuplicates.length > 0) {\n          issues.push({\n            id: 'duplicate-items',\n            type: 'duplicate_data',\n            severity: 'high',\n            message: `Found duplicate checklist items`,\n            data: inspectionDuplicates\n          });\n        }\n      }\n\n      setChecks(issues);\n\n      if (issues.length > 0) {\n        const highSeverityIssues = issues.filter(i => i.severity === 'high').length;\n        if (highSeverityIssues > 0) {\n          toast({\n            title: \"Data Integrity Issues Found\",\n            description: `Found ${highSeverityIssues} high-priority issues that need attention.`,\n            variant: \"destructive\",\n          });\n        }\n      }\n\n    } catch (error) {\n      console.error('Data integrity check failed:', error);\n      toast({\n        title: \"Integrity Check Failed\",\n        description: \"Unable to complete data integrity checks.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsChecking(false);\n    }\n  };\n\n  const fixIssue = async (issueId: string) => {\n    const issue = checks.find(c => c.id === issueId);\n    if (!issue) return;\n\n    try {\n      switch (issue.type) {\n        case 'duplicate_data':\n          if (issueId === 'duplicate-items') {\n            await supabase.rpc('cleanup_duplicate_checklist_items');\n            toast({\n              title: \"Duplicates Cleaned\",\n              description: \"Duplicate checklist items have been removed.\",\n            });\n          }\n          break;\n        \n        case 'orphaned_record':\n          if (issueId === 'orphaned-media' && issue.data) {\n            const mediaIds = issue.data.map((item: any) => item.id);\n            await supabase\n              .from('media')\n              .delete()\n              .in('id', mediaIds);\n            toast({\n              title: \"Orphaned Records Cleaned\",\n              description: \"Orphaned media items have been removed.\",\n            });\n          }\n          break;\n      }\n\n      // Remove the fixed issue from the list\n      setChecks(prev => prev.filter(c => c.id !== issueId));\n      \n    } catch (error) {\n      console.error('Failed to fix issue:', error);\n      toast({\n        title: \"Fix Failed\",\n        description: \"Unable to fix the data integrity issue.\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  useEffect(() => {\n    if (inspectionId) {\n      runIntegrityChecks();\n    }\n  }, [inspectionId]);\n\n  return {\n    checks,\n    isChecking,\n    runIntegrityChecks,\n    fixIssue,\n    hasIssues: checks.length > 0,\n    highPriorityIssues: checks.filter(c => c.severity === 'high').length\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useDebugInfoCombiner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[56,59],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[56,59],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[78,81],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[78,81],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[106,109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[106,109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport const useDebugInfoCombiner = (\n  authDebugInfo: any,\n  loadDebugInfo: any,\n  submissionDebugInfo: any\n) => {\n  return {\n    ...authDebugInfo,\n    ...loadDebugInfo,\n    ...submissionDebugInfo\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useDebugInspectionData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useEnhancedOfflineStorage.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'storageState.photos' and 'syncOfflinePhotos'. Either include them or remove the dependency array.","line":88,"column":6,"nodeType":"ArrayExpression","endLine":88,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [isOnline, storageState.photos, syncOfflinePhotos]","fix":{"range":[2603,2613],"text":"[isOnline, storageState.photos, syncOfflinePhotos]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'cleanupUploadedPhotos'. Either include it or remove the dependency array.","line":148,"column":6,"nodeType":"ArrayExpression","endLine":148,"endColumn":59,"suggestions":[{"desc":"Update the dependencies array to be: [storageState.photos, calculateStorageMetrics, toast, cleanupUploadedPhotos]","fix":{"range":[4332,4385],"text":"[storageState.photos, calculateStorageMetrics, toast, cleanupUploadedPhotos]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useNetworkStatus } from \"@/hooks/useNetworkStatus\";\n\ninterface OfflinePhoto {\n  id: string;\n  checklistItemId: string;\n  inspectionId: string;\n  file: File;\n  timestamp: number;\n  uploaded: boolean;\n  retryCount: number;\n  lastError?: string;\n}\n\ninterface OfflineStorageState {\n  photos: OfflinePhoto[];\n  syncInProgress: boolean;\n  lastSyncAttempt: Date | null;\n  totalPendingSize: number;\n}\n\nexport const useEnhancedOfflineStorage = () => {\n  const [storageState, setStorageState] = useState<OfflineStorageState>({\n    photos: [],\n    syncInProgress: false,\n    lastSyncAttempt: null,\n    totalPendingSize: 0\n  });\n  \n  const isOnline = useNetworkStatus();\n  const { toast } = useToast();\n\n  // Calculate storage metrics\n  const calculateStorageMetrics = useCallback((photos: OfflinePhoto[]) => {\n    const totalSize = photos.reduce((acc, photo) => acc + photo.file.size, 0);\n    return {\n      totalPendingSize: totalSize,\n      pendingCount: photos.filter(p => !p.uploaded).length,\n      failedCount: photos.filter(p => p.retryCount > 0 && !p.uploaded).length\n    };\n  }, []);\n\n  // Load offline photos on mount\n  useEffect(() => {\n    const loadOfflinePhotos = () => {\n      try {\n        const stored = localStorage.getItem('doublecheck_offline_photos_v2');\n        if (stored) {\n          const photos = JSON.parse(stored);\n          const metrics = calculateStorageMetrics(photos);\n          \n          setStorageState(prev => ({\n            ...prev,\n            photos,\n            totalPendingSize: metrics.totalPendingSize\n          }));\n          \n          console.log('ðŸ“± Loaded offline photos:', {\n            total: photos.length,\n            pending: metrics.pendingCount,\n            failed: metrics.failedCount,\n            totalSize: `${(metrics.totalPendingSize / 1024 / 1024).toFixed(2)}MB`\n          });\n        }\n      } catch (error) {\n        console.error('ðŸ“± Error loading offline photos:', error);\n        toast({\n          title: \"Storage Error\",\n          description: \"Failed to load offline photos from storage.\",\n          variant: \"destructive\",\n        });\n      }\n    };\n\n    loadOfflinePhotos();\n  }, [calculateStorageMetrics, toast]);\n\n  // Auto-sync when coming back online\n  useEffect(() => {\n    if (isOnline && storageState.photos.some(p => !p.uploaded)) {\n      console.log('ðŸ“± Network restored, starting auto-sync...');\n      setTimeout(() => {\n        syncOfflinePhotos();\n      }, 2000); // Wait 2 seconds for network to stabilize\n    }\n  }, [isOnline]);\n\n  const savePhotoOffline = useCallback(async (\n    file: File,\n    checklistItemId: string,\n    inspectionId: string\n  ): Promise<string> => {\n    console.log('ðŸ“± Saving photo offline:', { \n      size: `${(file.size / 1024).toFixed(2)}KB`,\n      type: file.type \n    });\n\n    const photoId = `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const offlinePhoto: OfflinePhoto = {\n      id: photoId,\n      checklistItemId,\n      inspectionId,\n      file,\n      timestamp: Date.now(),\n      uploaded: false,\n      retryCount: 0\n    };\n\n    const updatedPhotos = [...storageState.photos, offlinePhoto];\n    const metrics = calculateStorageMetrics(updatedPhotos);\n    \n    setStorageState(prev => ({\n      ...prev,\n      photos: updatedPhotos,\n      totalPendingSize: metrics.totalPendingSize\n    }));\n    \n    // Save metadata to localStorage (without file data for size limits)\n    try {\n      const photoMetadata = updatedPhotos.map(photo => ({\n        ...photo,\n        file: null // Don't store file in localStorage\n      }));\n      \n      localStorage.setItem('doublecheck_offline_photos_v2', JSON.stringify(photoMetadata));\n      \n      toast({\n        title: \"Photo saved offline\",\n        description: `Photo will sync when online. ${metrics.pendingCount + 1} pending.`,\n      });\n    } catch (error) {\n      console.error('ðŸ“± Error saving to localStorage:', error);\n      \n      // If storage is full, try to clean up old uploaded photos\n      cleanupUploadedPhotos();\n      \n      toast({\n        title: \"Storage Warning\",\n        description: \"Local storage is getting full. Some photos may not be saved.\",\n        variant: \"destructive\",\n      });\n    }\n\n    return photoId;\n  }, [storageState.photos, calculateStorageMetrics, toast]);\n\n  const syncOfflinePhotos = useCallback(async () => {\n    if (storageState.syncInProgress || !isOnline) {\n      console.log('ðŸ“± Sync skipped:', { \n        syncInProgress: storageState.syncInProgress, \n        isOnline \n      });\n      return;\n    }\n\n    const pendingPhotos = storageState.photos.filter(p => !p.uploaded && p.retryCount < 3);\n    \n    if (pendingPhotos.length === 0) {\n      console.log('ðŸ“± No photos to sync');\n      return;\n    }\n\n    console.log(`ðŸ“± Starting sync of ${pendingPhotos.length} photos...`);\n    \n    setStorageState(prev => ({\n      ...prev,\n      syncInProgress: true,\n      lastSyncAttempt: new Date()\n    }));\n\n    let successCount = 0;\n    let failureCount = 0;\n\n    for (const photo of pendingPhotos) {\n      try {\n        // Simulate upload - replace with actual upload logic\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        // Mark as uploaded\n        setStorageState(prev => ({\n          ...prev,\n          photos: prev.photos.map(p => \n            p.id === photo.id ? { ...p, uploaded: true } : p\n          )\n        }));\n        \n        successCount++;\n        console.log(`ðŸ“± Uploaded photo ${photo.id}`);\n        \n      } catch (error) {\n        console.error(`ðŸ“± Failed to upload photo ${photo.id}:`, error);\n        \n        // Increment retry count\n        setStorageState(prev => ({\n          ...prev,\n          photos: prev.photos.map(p => \n            p.id === photo.id \n              ? { \n                  ...p, \n                  retryCount: p.retryCount + 1,\n                  lastError: error instanceof Error ? error.message : 'Upload failed'\n                } \n              : p\n          )\n        }));\n        \n        failureCount++;\n      }\n    }\n\n    setStorageState(prev => ({\n      ...prev,\n      syncInProgress: false\n    }));\n\n    if (successCount > 0) {\n      toast({\n        title: \"Sync Complete\",\n        description: `${successCount} photos uploaded successfully.`,\n      });\n    }\n\n    if (failureCount > 0) {\n      toast({\n        title: \"Sync Issues\",\n        description: `${failureCount} photos failed to upload. Will retry later.`,\n        variant: \"destructive\",\n      });\n    }\n\n    console.log('ðŸ“± Sync completed:', { successCount, failureCount });\n  }, [storageState.syncInProgress, storageState.photos, isOnline, toast]);\n\n  const cleanupUploadedPhotos = useCallback(() => {\n    const remainingPhotos = storageState.photos.filter(p => !p.uploaded);\n    const metrics = calculateStorageMetrics(remainingPhotos);\n    \n    setStorageState(prev => ({\n      ...prev,\n      photos: remainingPhotos,\n      totalPendingSize: metrics.totalPendingSize\n    }));\n    \n    localStorage.setItem('doublecheck_offline_photos_v2', JSON.stringify(\n      remainingPhotos.map(photo => ({ ...photo, file: null }))\n    ));\n    \n    console.log('ðŸ“± Cleaned up uploaded photos');\n  }, [storageState.photos, calculateStorageMetrics]);\n\n  const forceRetryFailed = useCallback(() => {\n    setStorageState(prev => ({\n      ...prev,\n      photos: prev.photos.map(p => \n        p.retryCount > 0 && !p.uploaded \n          ? { ...p, retryCount: 0, lastError: undefined }\n          : p\n      )\n    }));\n    \n    if (isOnline) {\n      syncOfflinePhotos();\n    }\n  }, [isOnline, syncOfflinePhotos]);\n\n  const getStorageStats = useCallback(() => {\n    const metrics = calculateStorageMetrics(storageState.photos);\n    return {\n      ...metrics,\n      isOnline,\n      syncInProgress: storageState.syncInProgress,\n      lastSyncAttempt: storageState.lastSyncAttempt,\n      storageUsageMB: (metrics.totalPendingSize / 1024 / 1024).toFixed(2)\n    };\n  }, [storageState, isOnline, calculateStorageMetrics]);\n\n  return {\n    isOnline,\n    photos: storageState.photos,\n    syncInProgress: storageState.syncInProgress,\n    savePhotoOffline,\n    syncOfflinePhotos,\n    cleanupUploadedPhotos,\n    forceRetryFailed,\n    getStorageStats\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useEnhancedPropertySubmission.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[476,479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[476,479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { usePropertyMutation } from \"./usePropertyMutation\";\nimport { usePropertySubmissionState } from \"./usePropertySubmissionState\";\nimport { usePropertyErrorHandler } from \"@/utils/propertySubmissionErrors\";\nimport { useSimplePropertyValidation } from \"./useSimplePropertyValidation\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const useEnhancedPropertySubmission = (user: any, userRole: string) => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const editId = searchParams.get('edit');\n  const isEditing = !!editId;\n\n  // Use the simplified validation hook\n  const { validateSubmission } = useSimplePropertyValidation();\n  const { executePropertyMutation } = usePropertyMutation();\n  const { \n    isLoading, \n    setIsLoading, \n    submissionDebugInfo, \n    updateDebugInfo \n  } = usePropertySubmissionState();\n  const { \n    handleSubmissionError, \n    handleUnexpectedError, \n    handleSuccess \n  } = usePropertyErrorHandler();\n\n  const submitProperty = async (formData: PropertyFormData, isOnline: boolean) => {\n    console.log('ðŸš€ Starting enhanced property submission process...');\n    \n    // Pre-submission validation\n    if (!validateSubmission(user, isOnline, formData)) {\n      return false;\n    }\n\n    setIsLoading(true);\n    const submitStartTime = Date.now();\n\n    try {\n      const result = await executePropertyMutation(formData, user, isEditing, editId);\n      const { data, error } = result;\n      const submitDuration = Date.now() - submitStartTime;\n\n      if (error) {\n        console.error(`âŒ Database error during ${isEditing ? 'update' : 'insert'}:`, {\n          error: {\n            message: error.message,\n            code: error.code,\n            details: error.details,\n            hint: error.hint\n          },\n          operation: isEditing ? 'update' : 'insert',\n          userId: user.id,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        });\n\n        updateDebugInfo({\n          submitError: {\n            operation: isEditing ? 'update' : 'insert',\n            error: error.message,\n            code: error.code,\n            details: error.details,\n            hint: error.hint,\n            duration: submitDuration,\n            timestamp: new Date().toISOString()\n          }\n        });\n\n        handleSubmissionError(error, isEditing);\n        return false;\n      }\n\n      console.log(`âœ… Property ${isEditing ? 'updated' : 'created'} successfully:`, {\n        data,\n        duration: submitDuration,\n        timestamp: new Date().toISOString()\n      });\n\n      updateDebugInfo({\n        submitSuccess: {\n          operation: isEditing ? 'update' : 'insert',\n          propertyId: data?.id,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      handleSuccess(formData.name.trim(), isEditing);\n\n      // Small delay to ensure UI feedback is seen\n      setTimeout(() => {\n        navigate('/properties');\n      }, 500);\n\n      return true;\n    } catch (error) {\n      const submitDuration = Date.now() - submitStartTime;\n      console.error(`ðŸ’¥ Unexpected error during ${isEditing ? 'update' : 'create'}:`, {\n        error: error instanceof Error ? {\n          message: error.message,\n          stack: error.stack,\n          name: error.name\n        } : error,\n        duration: submitDuration,\n        timestamp: new Date().toISOString()\n      });\n\n      updateDebugInfo({\n        unexpectedSubmitError: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          stack: error instanceof Error ? error.stack : undefined,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      handleUnexpectedError();\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const getSubmissionStats = () => {\n    return {\n      isEditing,\n      userId: user?.id,\n      userRole,\n      timestamp: new Date().toISOString()\n    };\n  };\n\n  return {\n    isLoading,\n    submitProperty,\n    submissionDebugInfo,\n    getSubmissionStats\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useEnhancedPropertySubmissionLogic.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[572,575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[572,575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { usePropertyFormValidation } from \"./usePropertyFormValidation\";\nimport { usePropertyMutation } from \"./usePropertyMutation\";\nimport { usePropertySubmissionState } from \"./usePropertySubmissionState\";\nimport { usePropertySubmissionMonitoring } from \"./usePropertySubmissionMonitoring\";\nimport { usePropertySubmissionRetry } from \"./usePropertySubmissionRetry\";\nimport { usePropertyErrorHandler } from \"@/utils/propertySubmissionErrors\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const useEnhancedPropertySubmissionLogic = (user: any, isEditing: boolean, editId: string | null) => {\n  const { validateSubmission } = usePropertyFormValidation();\n  const { executePropertyMutation } = usePropertyMutation();\n  const { \n    isLoading, \n    setIsLoading, \n    submissionDebugInfo, \n    updateDebugInfo \n  } = usePropertySubmissionState();\n  const {\n    startSubmissionTracking,\n    recordError,\n    recordRetry,\n    completeSubmission,\n    getSubmissionStats\n  } = usePropertySubmissionMonitoring();\n  const { \n    isRetryable,\n    showRetryToast,\n    createBackoffDelay\n  } = usePropertySubmissionRetry();\n  const { \n    handleSubmissionError, \n    handleUnexpectedError, \n    handleSuccess \n  } = usePropertyErrorHandler();\n\n  const executeSubmissionWithRetry = async (formData: PropertyFormData): Promise<boolean> => {\n    const submitStartTime = Date.now();\n    let retryCount = 0;\n    const maxRetries = 2;\n\n    // Retry logic with exponential backoff\n    while (retryCount <= maxRetries) {\n      try {\n        if (retryCount > 0) {\n          recordRetry();\n          console.log(`ðŸ”„ Retry attempt ${retryCount}/${maxRetries}`);\n          \n          // Exponential backoff delay\n          const backoffDelay = createBackoffDelay(retryCount);\n          await new Promise(resolve => setTimeout(resolve, backoffDelay));\n        }\n\n        const result = await executePropertyMutation(formData, user, isEditing, editId);\n        const { data, error } = result;\n\n        if (error) {\n          const submitDuration = Date.now() - submitStartTime;\n          console.error(`âŒ Database error on attempt ${retryCount + 1}:`, {\n            error: {\n              message: error.message,\n              code: error.code,\n              details: error.details,\n              hint: error.hint\n            },\n            operation: isEditing ? 'update' : 'insert',\n            userId: user.id,\n            attempt: retryCount + 1\n          });\n\n          recordError(error);\n          \n          // Check if error is retryable\n          const canRetry = isRetryable(error);\n          \n          if (canRetry && retryCount < maxRetries) {\n            retryCount++;\n            showRetryToast(retryCount, maxRetries);\n            continue; // Retry\n          } else {\n            // Non-retryable error or max retries exceeded\n            updateDebugInfo({\n              submitError: {\n                operation: isEditing ? 'update' : 'insert',\n                error: error.message,\n                code: error.code,\n                details: error.details,\n                hint: error.hint,\n                attempts: retryCount + 1,\n                duration: submitDuration,\n                timestamp: new Date().toISOString()\n              }\n            });\n\n            handleSubmissionError(error, isEditing);\n            return false;\n          }\n        }\n\n        // Success!\n        const submitDuration = Date.now() - submitStartTime;\n        console.log(`âœ… Property ${isEditing ? 'updated' : 'created'} successfully:`, {\n          data,\n          attempts: retryCount + 1\n        });\n\n        updateDebugInfo({\n          submitSuccess: {\n            operation: isEditing ? 'update' : 'insert',\n            propertyId: data?.id,\n            attempts: retryCount + 1,\n            duration: submitDuration,\n            timestamp: new Date().toISOString()\n          }\n        });\n\n        handleSuccess(formData.name.trim(), isEditing);\n        return true;\n\n      } catch (error) {\n        const submitDuration = Date.now() - submitStartTime;\n        console.error(`ðŸ’¥ Unexpected error on attempt ${retryCount + 1}:`, {\n          error: error instanceof Error ? {\n            message: error.message,\n            stack: error.stack,\n            name: error.name\n          } : error,\n          attempt: retryCount + 1\n        });\n\n        recordError(error);\n        \n        if (retryCount < maxRetries) {\n          retryCount++;\n          showRetryToast(retryCount, maxRetries, true);\n          continue; // Retry\n        } else {\n          updateDebugInfo({\n            unexpectedSubmitError: {\n              error: error instanceof Error ? error.message : 'Unknown error',\n              stack: error instanceof Error ? error.stack : undefined,\n              attempts: retryCount + 1,\n              duration: submitDuration,\n              timestamp: new Date().toISOString()\n            }\n          });\n\n          handleUnexpectedError();\n          return false;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  return {\n    isLoading,\n    setIsLoading,\n    submissionDebugInfo,\n    validateSubmission,\n    executeSubmissionWithRetry,\n    startSubmissionTracking,\n    completeSubmission,\n    getSubmissionStats\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useErrorHandling.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[472,475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[472,475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[818,821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[818,821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1026,1029],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1026,1029],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1074,1077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1074,1077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1115,1118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1115,1118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1384,1387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1384,1387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'config' object makes the dependencies of useCallback Hook (at line 236) change on every render. To fix this, wrap the initialization of 'config' in its own useMemo() Hook.","line":54,"column":9,"nodeType":"VariableDeclarator","endLine":54,"endColumn":52},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'config' object makes the dependencies of useCallback Hook (at line 279) change on every render. To fix this, wrap the initialization of 'config' in its own useMemo() Hook.","line":54,"column":9,"nodeType":"VariableDeclarator","endLine":54,"endColumn":52},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'clearError'. Either include it or remove the dependency array.","line":126,"column":6,"nodeType":"ArrayExpression","endLine":126,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [clearError, config, toast]","fix":{"range":[3475,3490],"text":"[clearError, config, toast]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3980,3983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3980,3983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4032,4035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4032,4035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'retry'. Either include it or remove the dependency array.","line":173,"column":6,"nodeType":"ArrayExpression","endLine":173,"endColumn":47,"suggestions":[{"desc":"Update the dependencies array to be: [config.autoRetry, config.context, config.maxRetries, config.retryDelay, errorState.retryCount, retry, setError]","fix":{"range":[4629,4670],"text":"[config.autoRetry, config.context, config.maxRetries, config.retryDelay, errorState.retryCount, retry, setError]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4778,4781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4778,4781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'retry'. Either include it or remove the dependency array.","line":197,"column":6,"nodeType":"ArrayExpression","endLine":197,"endColumn":60,"suggestions":[{"desc":"Update the dependencies array to be: [config.autoRetry, config.maxRetries, config.retryDelay, errorState.retryCount, handleError, retry, setError]","fix":{"range":[5376,5430],"text":"[config.autoRetry, config.maxRetries, config.retryDelay, errorState.retryCount, handleError, retry, setError]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6658,6661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6658,6661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7807,7810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7807,7810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9059,9062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9059,9062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":353,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9197,9200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9197,9200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useRef, useEffect } from 'react';\nimport { useToast } from '@/components/ui/use-toast';\nimport { apiErrorHandler, ApiError, ApiErrorContext } from '@/lib/error/api-error-handler';\nimport { errorReporter } from '@/lib/monitoring/error-reporter';\nimport { env } from '@/lib/config/environment';\n\nexport interface ErrorState {\n  error: Error | ApiError | null;\n  isError: boolean;\n  errorMessage: string | null;\n  errorDetails: Record<string, any> | null;\n  errorId: string | null;\n  retryCount: number;\n  isRetrying: boolean;\n}\n\nexport interface UseErrorHandlingOptions {\n  showToast?: boolean;\n  autoRetry?: boolean;\n  maxRetries?: number;\n  retryDelay?: number;\n  onError?: (error: Error | ApiError) => void;\n  onRetry?: () => void;\n  onSuccess?: () => void;\n  context?: Record<string, any>;\n  resetOnUnmount?: boolean;\n}\n\nexport interface ErrorHandlingUtils {\n  error: ErrorState;\n  setError: (error: Error | ApiError | string | null) => void;\n  clearError: () => void;\n  handleError: (error: any, context?: ApiErrorContext | Record<string, any>) => void;\n  handleApiError: (error: any, apiContext: ApiErrorContext) => Promise<void>;\n  retry: () => Promise<void>;\n  isLoading: boolean;\n  setIsLoading: (loading: boolean) => void;\n  withErrorHandling: <T>(\n    asyncFn: () => Promise<T>,\n    options?: { showLoading?: boolean; context?: Record<string, any> }\n  ) => Promise<T | null>;\n}\n\nconst DEFAULT_OPTIONS: UseErrorHandlingOptions = {\n  showToast: true,\n  autoRetry: false,\n  maxRetries: 3,\n  retryDelay: 1000,\n  resetOnUnmount: true,\n};\n\nexport function useErrorHandling(options?: UseErrorHandlingOptions): ErrorHandlingUtils {\n  const { toast } = useToast();\n  const config = { ...DEFAULT_OPTIONS, ...options };\n  const retryFnRef = useRef<(() => Promise<void>) | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const [errorState, setErrorState] = useState<ErrorState>({\n    error: null,\n    isError: false,\n    errorMessage: null,\n    errorDetails: null,\n    errorId: null,\n    retryCount: 0,\n    isRetrying: false,\n  });\n\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (config.resetOnUnmount) {\n        if (retryTimeoutRef.current) {\n          clearTimeout(retryTimeoutRef.current);\n        }\n      }\n    };\n  }, [config.resetOnUnmount]);\n\n  /**\n   * Set error state\n   */\n  const setError = useCallback((error: Error | ApiError | string | null) => {\n    if (!error) {\n      clearError();\n      return;\n    }\n\n    const errorObj = typeof error === 'string' ? new Error(error) : error;\n    const errorId = errorReporter.reportError(errorObj, {\n      ...config.context,\n      source: 'useErrorHandling',\n    });\n\n    const errorMessage = 'userMessage' in errorObj && errorObj.userMessage\n      ? errorObj.userMessage\n      : errorObj.message;\n\n    setErrorState({\n      error: errorObj,\n      isError: true,\n      errorMessage,\n      errorDetails: 'details' in errorObj ? errorObj.details : null,\n      errorId,\n      retryCount: 0,\n      isRetrying: false,\n    });\n\n    // Show toast if enabled\n    if (config.showToast) {\n      toast({\n        title: 'Error',\n        description: errorMessage,\n        variant: 'destructive',\n      });\n    }\n\n    // Call error callback\n    config.onError?.(errorObj);\n\n    // Log in development\n    if (env.isDevelopment()) {\n      console.error('[useErrorHandling]', errorObj);\n    }\n  }, [config, toast]);\n\n  /**\n   * Clear error state\n   */\n  const clearError = useCallback(() => {\n    setErrorState({\n      error: null,\n      isError: false,\n      errorMessage: null,\n      errorDetails: null,\n      errorId: null,\n      retryCount: 0,\n      isRetrying: false,\n    });\n\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n      retryTimeoutRef.current = null;\n    }\n  }, []);\n\n  /**\n   * Handle generic errors\n   */\n  const handleError = useCallback((\n    error: any,\n    context?: ApiErrorContext | Record<string, any>\n  ) => {\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    \n    // Add context to error reporting\n    errorReporter.reportError(errorObj, {\n      ...config.context,\n      ...context,\n      source: 'useErrorHandling',\n    });\n\n    setError(errorObj);\n\n    // Auto-retry logic\n    if (config.autoRetry && errorState.retryCount < (config.maxRetries || 3)) {\n      const delay = config.retryDelay || 1000;\n      retryTimeoutRef.current = setTimeout(() => {\n        retry();\n      }, delay * Math.pow(2, errorState.retryCount)); // Exponential backoff\n    }\n  }, [config, errorState.retryCount, setError]);\n\n  /**\n   * Handle API errors specifically\n   */\n  const handleApiError = useCallback(async (\n    error: any,\n    apiContext: ApiErrorContext\n  ) => {\n    try {\n      const apiError = await apiErrorHandler.handleError(error, apiContext);\n      setError(apiError);\n\n      // Auto-retry for retryable API errors\n      if (config.autoRetry && apiError.retry && errorState.retryCount < (config.maxRetries || 3)) {\n        const delay = config.retryDelay || 1000;\n        retryTimeoutRef.current = setTimeout(() => {\n          retry();\n        }, delay * Math.pow(2, errorState.retryCount));\n      }\n    } catch (err) {\n      // Fallback if error handler fails\n      handleError(err, apiContext);\n    }\n  }, [config, errorState.retryCount, handleError, setError]);\n\n  /**\n   * Retry the last failed operation\n   */\n  const retry = useCallback(async () => {\n    if (!retryFnRef.current || errorState.isRetrying) return;\n\n    setErrorState(prev => ({\n      ...prev,\n      isRetrying: true,\n      retryCount: prev.retryCount + 1,\n    }));\n\n    config.onRetry?.();\n\n    try {\n      await retryFnRef.current();\n      \n      // Success - clear error\n      clearError();\n      config.onSuccess?.();\n      \n      toast({\n        title: 'Success',\n        description: 'Operation completed successfully',\n      });\n    } catch (error) {\n      // Retry failed\n      setErrorState(prev => ({\n        ...prev,\n        isRetrying: false,\n      }));\n\n      // Update error with new retry count\n      if (error instanceof Error || (error && typeof error === 'object' && 'message' in error)) {\n        handleError(error, { retry: true, attempt: errorState.retryCount + 1 });\n      }\n    }\n  }, [errorState.isRetrying, errorState.retryCount, config, clearError, handleError, toast]);\n\n  /**\n   * Wrapper function for async operations with error handling\n   */\n  const withErrorHandling = useCallback(async <T,>(\n    asyncFn: () => Promise<T>,\n    options?: { showLoading?: boolean; context?: Record<string, any> }\n  ): Promise<T | null> => {\n    // Store the function for potential retry\n    retryFnRef.current = async () => {\n      await asyncFn();\n    };\n\n    if (options?.showLoading) {\n      setIsLoading(true);\n    }\n\n    try {\n      clearError();\n      const result = await asyncFn();\n      \n      config.onSuccess?.();\n      \n      if (options?.showLoading) {\n        setIsLoading(false);\n      }\n      \n      return result;\n    } catch (error) {\n      if (options?.showLoading) {\n        setIsLoading(false);\n      }\n\n      // Check if it's an API error\n      if (options?.context && 'url' in options.context && 'method' in options.context) {\n        await handleApiError(error, options.context as ApiErrorContext);\n      } else {\n        handleError(error, options?.context);\n      }\n\n      return null;\n    }\n  }, [clearError, config, handleApiError, handleError]);\n\n  return {\n    error: errorState,\n    setError,\n    clearError,\n    handleError,\n    handleApiError,\n    retry,\n    isLoading,\n    setIsLoading,\n    withErrorHandling,\n  };\n}\n\n/**\n * Hook for handling form errors\n */\nexport function useFormErrorHandling<T extends Record<string, any>>() {\n  const [fieldErrors, setFieldErrors] = useState<Partial<Record<keyof T, string>>>({});\n  const { toast } = useToast();\n\n  const setFieldError = useCallback((field: keyof T, error: string | null) => {\n    setFieldErrors(prev => {\n      if (error) {\n        return { ...prev, [field]: error };\n      } else {\n        const { [field]: _, ...rest } = prev;\n        return rest;\n      }\n    });\n  }, []);\n\n  const clearFieldErrors = useCallback(() => {\n    setFieldErrors({});\n  }, []);\n\n  const handleValidationError = useCallback((errors: Partial<Record<keyof T, string>>) => {\n    setFieldErrors(errors);\n    \n    // Show first error in toast\n    const firstError = Object.values(errors).find(Boolean);\n    if (firstError) {\n      toast({\n        title: 'Validation Error',\n        description: firstError as string,\n        variant: 'destructive',\n      });\n    }\n  }, [toast]);\n\n  return {\n    fieldErrors,\n    setFieldError,\n    clearFieldErrors,\n    handleValidationError,\n    hasErrors: Object.keys(fieldErrors).length > 0,\n  };\n}\n\n/**\n * Hook for handling async operations with loading and error states\n */\nexport function useAsyncError() {\n  const [state, setState] = useState<{\n    loading: boolean;\n    error: Error | null;\n    data: any;\n  }>({\n    loading: false,\n    error: null,\n    data: null,\n  });\n\n  const execute = useCallback(async (asyncFunction: () => Promise<any>) => {\n    setState({ loading: true, error: null, data: null });\n\n    try {\n      const data = await asyncFunction();\n      setState({ loading: false, error: null, data });\n      return data;\n    } catch (error) {\n      const errorObj = error instanceof Error ? error : new Error(String(error));\n      setState({ loading: false, error: errorObj, data: null });\n      throw errorObj;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    setState({ loading: false, error: null, data: null });\n  }, []);\n\n  return {\n    ...state,\n    execute,\n    reset,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useFastAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useFastPropertyFormState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useFileUpload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useImageOptimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useInspectionData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useInspectionFilters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useInspectorAssignments.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useInspectorCollaboration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[354,357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[354,357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[511,514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[511,514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'fetchActiveInspectors' and 'fetchConflicts'. Either include them or remove the dependency array.","line":70,"column":6,"nodeType":"ArrayExpression","endLine":70,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [fetchActiveInspectors, fetchConflicts, inspectionId]","fix":{"range":[2030,2044],"text":"[fetchActiveInspectors, fetchConflicts, inspectionId]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2678,2681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2678,2681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3469,3472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3469,3472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3553,3556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3553,3556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect, useCallback } from \"react\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useAuth } from \"@/hooks/useAuth\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { Tables } from \"@/integrations/supabase/types\";\n\ntype InspectorPresence = Tables<'inspector_presence'> & {\n  metadata: Record<string, any>;\n};\n\ntype CollaborationConflict = Tables<'collaboration_conflicts'> & {\n  inspector_1_action: Record<string, any>;\n  inspector_2_action: Record<string, any>;\n};\n\nexport const useInspectorCollaboration = (inspectionId: string) => {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const [activeInspectors, setActiveInspectors] = useState<InspectorPresence[]>([]);\n  const [conflicts, setConflicts] = useState<CollaborationConflict[]>([]);\n\n  // Subscribe to inspector presence updates\n  useEffect(() => {\n    if (!inspectionId) return;\n\n    const presenceChannel = supabase\n      .channel(`inspector-presence-${inspectionId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'inspector_presence',\n          filter: `inspection_id=eq.${inspectionId}`\n        },\n        (payload) => {\n          console.log('Presence update:', payload);\n          fetchActiveInspectors();\n        }\n      )\n      .subscribe();\n\n    // Subscribe to collaboration conflicts\n    const conflictsChannel = supabase\n      .channel(`conflicts-${inspectionId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'collaboration_conflicts',\n          filter: `inspection_id=eq.${inspectionId}`\n        },\n        (payload) => {\n          console.log('Conflict update:', payload);\n          fetchConflicts();\n        }\n      )\n      .subscribe();\n\n    // Initial data fetch\n    fetchActiveInspectors();\n    fetchConflicts();\n\n    return () => {\n      supabase.removeChannel(presenceChannel);\n      supabase.removeChannel(conflictsChannel);\n    };\n  }, [inspectionId]);\n\n  const fetchActiveInspectors = useCallback(async () => {\n    if (!inspectionId) return;\n\n    try {\n      const { data, error } = await supabase\n        .from('inspector_presence')\n        .select('*')\n        .eq('inspection_id', inspectionId)\n        .neq('status', 'offline')\n        .gte('last_seen', new Date(Date.now() - 5 * 60 * 1000).toISOString()); // Active in last 5 minutes\n\n      if (error) throw error;\n\n      // Transform the data to ensure metadata is properly typed\n      const transformedData: InspectorPresence[] = (data || []).map(item => ({\n        ...item,\n        metadata: (item.metadata as Record<string, any>) || {}\n      }));\n\n      setActiveInspectors(transformedData);\n    } catch (error) {\n      console.error('Error fetching active inspectors:', error);\n    }\n  }, [inspectionId]);\n\n  const fetchConflicts = useCallback(async () => {\n    if (!inspectionId) return;\n\n    try {\n      const { data, error } = await supabase\n        .from('collaboration_conflicts')\n        .select('*')\n        .eq('inspection_id', inspectionId)\n        .eq('resolution_status', 'pending')\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      // Transform the data to ensure actions are properly typed\n      const transformedData: CollaborationConflict[] = (data || []).map(item => ({\n        ...item,\n        inspector_1_action: (item.inspector_1_action as Record<string, any>) || {},\n        inspector_2_action: (item.inspector_2_action as Record<string, any>) || {}\n      }));\n\n      setConflicts(transformedData);\n    } catch (error) {\n      console.error('Error fetching conflicts:', error);\n    }\n  }, [inspectionId]);\n\n  const assignChecklistItem = useCallback(async (itemId: string) => {\n    if (!user) return;\n\n    try {\n      const { data, error } = await supabase.rpc('assign_checklist_item', {\n        p_item_id: itemId,\n        p_inspector_id: user.id\n      });\n\n      if (error) throw error;\n\n      toast({\n        title: \"Item Assigned\",\n        description: \"You've been assigned to this checklist item.\",\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Error assigning checklist item:', error);\n      toast({\n        title: \"Assignment Failed\",\n        description: \"Failed to assign item. It may already be assigned to another inspector.\",\n        variant: \"destructive\",\n      });\n      return null;\n    }\n  }, [user, toast]);\n\n  const resolveConflict = useCallback(async (\n    conflictId: string,\n    resolution: 'resolved' | 'escalated',\n    notes?: string\n  ) => {\n    if (!user) return;\n\n    try {\n      const { error } = await supabase\n        .from('collaboration_conflicts')\n        .update({\n          resolution_status: resolution,\n          resolved_by: user.id,\n          resolved_at: new Date().toISOString(),\n          resolution_notes: notes || null,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', conflictId);\n\n      if (error) throw error;\n\n      toast({\n        title: \"Conflict Resolved\",\n        description: `Conflict has been ${resolution}.`,\n      });\n\n      fetchConflicts();\n    } catch (error) {\n      console.error('Error resolving conflict:', error);\n      toast({\n        title: \"Resolution Failed\",\n        description: \"Failed to resolve conflict. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  }, [user, toast, fetchConflicts]);\n\n  return {\n    activeInspectors,\n    conflicts,\n    assignChecklistItem,\n    resolveConflict,\n    fetchActiveInspectors,\n    fetchConflicts\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useInspectorPresence.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[735,738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[735,738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'heartbeatInterval' is never reassigned. Use 'const' instead.","line":129,"column":5,"nodeType":"Identifier","messageId":"useConst","endLine":129,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useEffect, useCallback, useRef } from \"react\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useAuth } from \"@/hooks/useAuth\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useChannelManager } from \"@/hooks/useChannelManager\";\n\nexport const useInspectorPresence = (inspectionId: string) => {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const { cleanupChannel } = useChannelManager();\n  const retryTimeoutRef = useRef<NodeJS.Timeout>();\n  const isUpdatingRef = useRef(false);\n  const isMountedRef = useRef(true);\n\n  const updatePresence = useCallback(async (\n    status: 'online' | 'offline' | 'viewing' | 'working',\n    currentItemId?: string,\n    metadata?: Record<string, any>\n  ) => {\n    if (!user || !inspectionId || isUpdatingRef.current || !isMountedRef.current) return;\n\n    isUpdatingRef.current = true;\n\n    try {\n      const { error } = await supabase.rpc('update_inspector_presence', {\n        p_inspection_id: inspectionId,\n        p_status: status,\n        p_current_item_id: currentItemId || null,\n        p_metadata: metadata ? JSON.stringify(metadata) : '{}'\n      });\n\n      if (error) {\n        console.error('Failed to update presence:', error);\n        \n        // Only show toast for critical errors, not for routine connection issues\n        if (error.code !== 'PGRST301' && !error.message.includes('infinite recursion')) {\n          toast({\n            title: \"Presence Update Failed\",\n            description: \"Failed to update your presence status.\",\n            variant: \"destructive\",\n          });\n        }\n        \n        // Retry after a delay for certain types of errors\n        if (retryTimeoutRef.current) clearTimeout(retryTimeoutRef.current);\n        if (isMountedRef.current) {\n          retryTimeoutRef.current = setTimeout(() => {\n            if (isMountedRef.current) {\n              updatePresence(status, currentItemId, metadata);\n            }\n          }, 3000);\n        }\n        \n        throw error;\n      }\n\n      // Clear any pending retries on success\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = undefined;\n      }\n\n    } catch (error) {\n      console.error('Error updating inspector presence:', error);\n      // Don't throw here to prevent cascading errors\n    } finally {\n      isUpdatingRef.current = false;\n    }\n  }, [user, inspectionId, toast]);\n\n  // Update presence on mount and when user becomes active\n  useEffect(() => {\n    if (!user || !inspectionId) return;\n\n    let heartbeatInterval: NodeJS.Timeout;\n    isMountedRef.current = true;\n\n    // Set initial presence with error handling\n    const setInitialPresence = async () => {\n      if (!isMountedRef.current) return;\n      \n      try {\n        await updatePresence('online');\n      } catch (error) {\n        console.error('Failed to set initial presence:', error);\n      }\n    };\n\n    setInitialPresence();\n\n    // Update presence on visibility change\n    const handleVisibilityChange = () => {\n      if (!isMountedRef.current) return;\n      \n      try {\n        updatePresence(document.hidden ? 'offline' : 'online');\n      } catch (error) {\n        console.error('Failed to update presence on visibility change:', error);\n      }\n    };\n\n    // Update presence on beforeunload\n    const handleBeforeUnload = () => {\n      if (!isMountedRef.current) return;\n      \n      try {\n        // Use sendBeacon for more reliable cleanup on page unload\n        const presenceData = {\n          inspection_id: inspectionId,\n          status: 'offline',\n          inspector_id: user.id\n        };\n        \n        if (navigator.sendBeacon) {\n          navigator.sendBeacon('/api/presence-cleanup', JSON.stringify(presenceData));\n        } else {\n          updatePresence('offline');\n        }\n      } catch (error) {\n        console.error('Failed to update presence on beforeunload:', error);\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    window.addEventListener('beforeunload', handleBeforeUnload);\n\n    // Heartbeat to keep presence alive (reduced frequency to avoid excessive calls)\n    heartbeatInterval = setInterval(() => {\n      if (!document.hidden && isMountedRef.current) {\n        updatePresence('online');\n      }\n    }, 45000); // Increased to 45 seconds\n\n    return () => {\n      isMountedRef.current = false;\n      \n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      \n      if (heartbeatInterval) clearInterval(heartbeatInterval);\n      if (retryTimeoutRef.current) clearTimeout(retryTimeoutRef.current);\n      \n      // Clean up any presence-related channels\n      cleanupChannel(`presence-indicator-${inspectionId}`);\n      \n      // Mark as offline on cleanup (but don't block component unmounting)\n      updatePresence('offline').catch(console.error);\n    };\n  }, [user, inspectionId, updatePresence, cleanupChannel]);\n\n  return { updatePresence };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useKeyboardNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useLearningAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMediaUpload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileAuthHooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileDataManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileErrorRecovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileInspectionFlow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileInspectionOptimizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobileOptimizedInspection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobilePropertyActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useMobilePropertyData.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1267,1270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1267,1270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useCallback } from \"react\";\nimport { supabase } from \"@/integrations/supabase/client\";\n\ninterface MobilePropertyData {\n  property_id: string;\n  property_name: string;\n  property_address: string;\n  property_vrbo_url: string | null;\n  property_airbnb_url: string | null;\n  property_status: string;\n  property_created_at: string;\n  inspection_count: number;\n  completed_inspection_count: number;\n  active_inspection_count: number;\n  latest_inspection_id: string | null;\n  latest_inspection_completed: boolean | null;\n}\n\nexport const useMobilePropertyData = (userId?: string) => {\n  return useQuery({\n    queryKey: ['mobile-properties', userId],\n    queryFn: async () => {\n      console.log('ðŸ“± Fetching mobile property data...');\n      const startTime = Date.now();\n\n      try {\n        // Mobile-optimized query with timeout\n        const queryPromise = supabase.rpc('get_properties_with_inspections');\n\n        // Mobile timeout (5 seconds)\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error('Mobile query timeout - please check your connection')), 5000);\n        });\n\n        const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;\n\n        const fetchDuration = Date.now() - startTime;\n        \n        if (error) {\n          console.error('âŒ Mobile property fetch error:', error);\n          throw new Error(`Failed to load properties: ${error.message}`);\n        }\n\n        console.log(`âœ… Mobile properties loaded in ${fetchDuration}ms`, {\n          count: data?.length || 0,\n          fetchDuration,\n          timestamp: new Date().toISOString()\n        });\n\n        return (data || []) as MobilePropertyData[];\n      } catch (error) {\n        console.error('âŒ Mobile property data fetch failed:', error);\n        throw error;\n      }\n    },\n    staleTime: 30000, // 30 seconds stale time for mobile\n    gcTime: 300000, // 5 minutes cache for mobile\n    refetchOnWindowFocus: false,\n    refetchOnReconnect: true,\n    retry: (failureCount, error) => {\n      console.log(`ðŸ”„ Mobile property query retry attempt ${failureCount + 1}`);\n      return failureCount < 1; // Only 1 retry on mobile\n    },\n    retryDelay: 2000,\n    enabled: !!userId\n  });\n};\n\nexport const useMobilePropertyStatus = () => {\n  const getPropertyStatus = useCallback((completedCount: number, activeCount: number) => {\n    if (activeCount > 0) {\n      return {\n        status: 'in-progress',\n        color: 'bg-yellow-500',\n        textLabel: 'In Progress',\n        badgeColor: 'bg-yellow-100 text-yellow-800'\n      };\n    }\n    \n    if (completedCount > 0) {\n      return {\n        status: 'completed',\n        color: 'bg-green-500',\n        textLabel: 'Completed',\n        badgeColor: 'bg-green-100 text-green-800'\n      };\n    }\n    \n    return {\n      status: 'pending',\n      color: 'bg-gray-500',\n      textLabel: 'Not Started',\n      badgeColor: 'bg-gray-100 text-gray-800'\n    };\n  }, []);\n\n  return { getPropertyStatus };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useNetworkStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useNotesHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useOfflineStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useOptimizedInspectionData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useOptimizedPropertyData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useOptimizedPropertySelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePerformanceMonitoring.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'createAlert'. Either include it or remove the dependency array.","line":159,"column":6,"nodeType":"ArrayExpression","endLine":159,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [thresholds.fps, options.enableAlerts, createAlert]","fix":{"range":[4575,4613],"text":"[thresholds.fps, options.enableAlerts, createAlert]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4777,4780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4777,4780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'createAlert'. Either include it or remove the dependency array.","line":193,"column":6,"nodeType":"ArrayExpression","endLine":193,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [thresholds.memoryUsage, options.enableAlerts, createAlert]","fix":{"range":[5628,5674],"text":"[thresholds.memoryUsage, options.enableAlerts, createAlert]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'createAlert'. Either include it or remove the dependency array.","line":231,"column":6,"nodeType":"ArrayExpression","endLine":231,"endColumn":71,"suggestions":[{"desc":"Update the dependencies array to be: [options.sampleRate, options.enableAlerts, thresholds.renderTime, createAlert]","fix":{"range":[6759,6824],"text":"[options.sampleRate, options.enableAlerts, thresholds.renderTime, createAlert]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'createAlert'. Either include it or remove the dependency array.","line":290,"column":6,"nodeType":"ArrayExpression","endLine":290,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [thresholds.aiProcessingTime, options.enableAlerts, createAlert]","fix":{"range":[8531,8582],"text":"[thresholds.aiProcessingTime, options.enableAlerts, createAlert]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'createAlert'. Either include it or remove the dependency array.","line":333,"column":6,"nodeType":"ArrayExpression","endLine":333,"endColumn":56,"suggestions":[{"desc":"Update the dependencies array to be: [thresholds.interactionTime, options.enableAlerts, createAlert]","fix":{"range":[9811,9861],"text":"[thresholds.interactionTime, options.enableAlerts, createAlert]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":396,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":396,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11535,11538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11535,11538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":483,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13983,13986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13983,13986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":493,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":493,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14228,14231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14228,14231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'mountTime.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'mountTime.current' to a variable inside the effect, and use that variable in the cleanup function.","line":647,"column":54,"nodeType":"Identifier","endLine":647,"endColumn":61},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'updateCount.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'updateCount.current' to a variable inside the effect, and use that variable in the cleanup function.","line":648,"column":96,"nodeType":"Identifier","endLine":648,"endColumn":103},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'updateCount.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'updateCount.current' to a variable inside the effect, and use that variable in the cleanup function.","line":661,"column":30,"nodeType":"Identifier","endLine":661,"endColumn":37}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'trackRender'. Either include it or remove the dependency array.","line":450,"column":6,"nodeType":"ArrayExpression","endLine":450,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [trackRender]","fix":{"range":[13246,13248],"text":"[trackRender]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'componentName'. Either include it or remove the dependency array.","line":650,"column":6,"nodeType":"ArrayExpression","endLine":650,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [componentName]","fix":{"range":[18637,18639],"text":"[componentName]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":4,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance Monitoring Hook for STR Certified\n// Tracks component renders, AI processing, and user interactions\n\nimport { useEffect, useRef, useState, useCallback, useMemo } from 'react';\nimport { useQuery, useMutation } from '@tanstack/react-query';\n\ninterface PerformanceMetrics {\n  renderTime: number;\n  aiProcessingTime: number;\n  interactionTime: number;\n  memoryUsage: number;\n  fps: number;\n}\n\ninterface PerformanceAlert {\n  id: string;\n  type: 'slow_render' | 'ai_delay' | 'memory_warning' | 'fps_drop' | 'interaction_lag';\n  severity: 'warning' | 'error' | 'critical';\n  message: string;\n  timestamp: Date;\n  metrics: Partial<PerformanceMetrics>;\n  suggestions?: string[];\n}\n\ninterface UsePerformanceMonitoringOptions {\n  componentName: string;\n  enableAlerts?: boolean;\n  thresholds?: {\n    renderTime?: number;      // ms\n    aiProcessingTime?: number; // ms\n    interactionTime?: number;  // ms\n    memoryUsage?: number;      // MB\n    fps?: number;             // frames per second\n  };\n  sampleRate?: number; // 0-1, percentage of events to track\n  onAlert?: (alert: PerformanceAlert) => void;\n}\n\ninterface UsePerformanceMonitoringReturn {\n  // Current metrics\n  metrics: PerformanceMetrics;\n  isPerformant: boolean;\n  \n  // Tracking methods\n  trackRender: () => void;\n  trackAIProcessing: (operation: string) => PerformanceTracker;\n  trackInteraction: (interaction: string) => PerformanceTracker;\n  \n  // Alerts\n  alerts: PerformanceAlert[];\n  clearAlerts: () => void;\n  \n  // Analysis\n  getReport: () => PerformanceReport;\n  optimize: () => OptimizationSuggestion[];\n}\n\nexport const usePerformanceMonitoring = (\n  options: UsePerformanceMonitoringOptions\n): UsePerformanceMonitoringReturn => {\n  // State\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({\n    renderTime: 0,\n    aiProcessingTime: 0,\n    interactionTime: 0,\n    memoryUsage: 0,\n    fps: 60\n  });\n  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);\n\n  // Refs\n  const renderCount = useRef(0);\n  const renderStartTime = useRef<number>(0);\n  const metricsHistory = useRef<PerformanceMetrics[]>([]);\n  const fpsFrames = useRef<number[]>([]);\n  const lastFrameTime = useRef<number>(performance.now());\n  const animationFrame = useRef<number>();\n\n  // Default thresholds\n  const thresholds = useMemo(() => ({\n    renderTime: 16.67,      // 60fps target\n    aiProcessingTime: 1000, // 1 second\n    interactionTime: 100,   // 100ms for responsive feel\n    memoryUsage: 100,       // 100MB\n    fps: 30,                // Minimum acceptable FPS\n    ...options.thresholds\n  }), [options.thresholds]);\n\n  // Initialize performance observer\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    // Track render time\n    renderStartTime.current = performance.now();\n\n    // Create Performance Observer for long tasks\n    if ('PerformanceObserver' in window) {\n      try {\n        const observer = new PerformanceObserver((list) => {\n          for (const entry of list.getEntries()) {\n            if (entry.duration > thresholds.renderTime) {\n              handlePerformanceEntry(entry);\n            }\n          }\n        });\n\n        observer.observe({ entryTypes: ['measure', 'navigation'] });\n\n        return () => observer.disconnect();\n      } catch (error) {\n        console.warn('PerformanceObserver not supported:', error);\n      }\n    }\n  }, [thresholds.renderTime]);\n\n  // Monitor FPS\n  useEffect(() => {\n    const measureFPS = () => {\n      const now = performance.now();\n      const delta = now - lastFrameTime.current;\n      lastFrameTime.current = now;\n\n      // Calculate FPS\n      const fps = 1000 / delta;\n      fpsFrames.current.push(fps);\n\n      // Keep only last 60 frames\n      if (fpsFrames.current.length > 60) {\n        fpsFrames.current.shift();\n      }\n\n      // Update average FPS\n      const avgFPS = fpsFrames.current.reduce((a, b) => a + b, 0) / fpsFrames.current.length;\n      \n      setMetrics(prev => {\n        const updated = { ...prev, fps: Math.round(avgFPS) };\n        \n        // Check for FPS drops\n        if (avgFPS < thresholds.fps && options.enableAlerts) {\n          createAlert('fps_drop', 'critical', \n            `FPS dropped to ${Math.round(avgFPS)}`,\n            { fps: avgFPS }\n          );\n        }\n        \n        return updated;\n      });\n\n      animationFrame.current = requestAnimationFrame(measureFPS);\n    };\n\n    animationFrame.current = requestAnimationFrame(measureFPS);\n\n    return () => {\n      if (animationFrame.current) {\n        cancelAnimationFrame(animationFrame.current);\n      }\n    };\n  }, [thresholds.fps, options.enableAlerts]);\n\n  // Monitor memory usage\n  useEffect(() => {\n    if (!('memory' in performance)) return;\n\n    const checkMemory = () => {\n      const memory = (performance as any).memory;\n      const usedMB = memory.usedJSHeapSize / 1024 / 1024;\n      \n      setMetrics(prev => {\n        const updated = { ...prev, memoryUsage: Math.round(usedMB) };\n        \n        // Check for high memory usage\n        if (usedMB > thresholds.memoryUsage && options.enableAlerts) {\n          createAlert('memory_warning', 'warning',\n            `High memory usage: ${Math.round(usedMB)}MB`,\n            { memoryUsage: usedMB },\n            [\n              'Consider lazy loading components',\n              'Implement virtualization for long lists',\n              'Clear unused cache data'\n            ]\n          );\n        }\n        \n        return updated;\n      });\n    };\n\n    const interval = setInterval(checkMemory, 5000); // Check every 5 seconds\n    checkMemory(); // Initial check\n\n    return () => clearInterval(interval);\n  }, [thresholds.memoryUsage, options.enableAlerts]);\n\n  // Track component renders\n  const trackRender = useCallback(() => {\n    renderCount.current++;\n    \n    // Sample based on rate\n    if (Math.random() > (options.sampleRate || 1)) return;\n\n    const renderTime = performance.now() - renderStartTime.current;\n    \n    setMetrics(prev => {\n      const updated = { ...prev, renderTime };\n      metricsHistory.current.push(updated);\n      \n      // Keep only last 100 entries\n      if (metricsHistory.current.length > 100) {\n        metricsHistory.current.shift();\n      }\n      \n      // Check for slow renders\n      if (renderTime > thresholds.renderTime && options.enableAlerts) {\n        createAlert('slow_render', 'warning',\n          `Slow render detected: ${renderTime.toFixed(2)}ms`,\n          { renderTime },\n          [\n            'Use React.memo for expensive components',\n            'Optimize re-renders with useMemo/useCallback',\n            'Consider code splitting'\n          ]\n        );\n      }\n      \n      return updated;\n    });\n\n    // Mark for next render\n    renderStartTime.current = performance.now();\n  }, [options.sampleRate, options.enableAlerts, thresholds.renderTime]);\n\n  // Track AI processing\n  const trackAIProcessing = useCallback((operation: string): PerformanceTracker => {\n    const startTime = performance.now();\n    let completed = false;\n\n    const tracker: PerformanceTracker = {\n      complete: () => {\n        if (completed) return;\n        completed = true;\n\n        const duration = performance.now() - startTime;\n        \n        setMetrics(prev => {\n          const updated = { ...prev, aiProcessingTime: duration };\n          \n          // Check for slow AI processing\n          if (duration > thresholds.aiProcessingTime && options.enableAlerts) {\n            createAlert('ai_delay', 'error',\n              `Slow AI processing for ${operation}: ${duration.toFixed(0)}ms`,\n              { aiProcessingTime: duration },\n              [\n                'Enable response caching',\n                'Use smaller model variants',\n                'Implement progressive loading'\n              ]\n            );\n          }\n          \n          // Log to performance timeline\n          if ('performance' in window && 'measure' in performance) {\n            try {\n              performance.mark(`ai-${operation}-end`);\n              performance.measure(\n                `AI: ${operation}`,\n                `ai-${operation}-start`,\n                `ai-${operation}-end`\n              );\n            } catch (e) {\n              // Marks might not exist\n            }\n          }\n          \n          return updated;\n        });\n      },\n      \n      cancel: () => {\n        completed = true;\n      }\n    };\n\n    // Mark start\n    if ('performance' in window && 'mark' in performance) {\n      performance.mark(`ai-${operation}-start`);\n    }\n\n    return tracker;\n  }, [thresholds.aiProcessingTime, options.enableAlerts]);\n\n  // Track user interactions\n  const trackInteraction = useCallback((interaction: string): PerformanceTracker => {\n    const startTime = performance.now();\n    let completed = false;\n\n    const tracker: PerformanceTracker = {\n      complete: () => {\n        if (completed) return;\n        completed = true;\n\n        const duration = performance.now() - startTime;\n        \n        setMetrics(prev => {\n          const updated = { ...prev, interactionTime: duration };\n          \n          // Check for laggy interactions\n          if (duration > thresholds.interactionTime && options.enableAlerts) {\n            createAlert('interaction_lag', 'warning',\n              `Slow interaction \"${interaction}\": ${duration.toFixed(0)}ms`,\n              { interactionTime: duration },\n              [\n                'Debounce expensive operations',\n                'Use optimistic updates',\n                'Move heavy computation to Web Workers'\n              ]\n            );\n          }\n          \n          // Log interaction\n          logInteraction(interaction, duration);\n          \n          return updated;\n        });\n      },\n      \n      cancel: () => {\n        completed = true;\n      }\n    };\n\n    return tracker;\n  }, [thresholds.interactionTime, options.enableAlerts]);\n\n  // Create performance alert\n  const createAlert = useCallback((\n    type: PerformanceAlert['type'],\n    severity: PerformanceAlert['severity'],\n    message: string,\n    metrics: Partial<PerformanceMetrics>,\n    suggestions?: string[]\n  ) => {\n    const alert: PerformanceAlert = {\n      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      severity,\n      message,\n      timestamp: new Date(),\n      metrics,\n      suggestions\n    };\n\n    setAlerts(prev => [...prev.slice(-9), alert]); // Keep last 10 alerts\n    \n    // Notify callback\n    options.onAlert?.(alert);\n    \n    // Log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[Performance Alert] ${message}`, metrics);\n    }\n  }, [options]);\n\n  // Clear alerts\n  const clearAlerts = useCallback(() => {\n    setAlerts([]);\n  }, []);\n\n  // Generate performance report\n  const getReport = useCallback((): PerformanceReport => {\n    const history = metricsHistory.current;\n    \n    if (history.length === 0) {\n      return {\n        componentName: options.componentName,\n        renderCount: renderCount.current,\n        averages: { ...metrics },\n        percentiles: {\n          p50: { ...metrics },\n          p75: { ...metrics },\n          p90: { ...metrics },\n          p95: { ...metrics },\n          p99: { ...metrics }\n        },\n        alerts: alerts.length,\n        suggestions: []\n      };\n    }\n\n    // Calculate averages\n    const averages = history.reduce((acc, m) => {\n      Object.keys(m).forEach(key => {\n        acc[key] = (acc[key] || 0) + m[key as keyof PerformanceMetrics];\n      });\n      return acc;\n    }, {} as any);\n\n    Object.keys(averages).forEach(key => {\n      averages[key] /= history.length;\n    });\n\n    // Calculate percentiles for render time\n    const renderTimes = history.map(m => m.renderTime).sort((a, b) => a - b);\n    const getPercentile = (p: number) => {\n      const index = Math.ceil((p / 100) * renderTimes.length) - 1;\n      return renderTimes[Math.max(0, index)];\n    };\n\n    const percentiles = {\n      p50: { ...averages, renderTime: getPercentile(50) },\n      p75: { ...averages, renderTime: getPercentile(75) },\n      p90: { ...averages, renderTime: getPercentile(90) },\n      p95: { ...averages, renderTime: getPercentile(95) },\n      p99: { ...averages, renderTime: getPercentile(99) }\n    };\n\n    // Generate suggestions\n    const suggestions = generateOptimizationSuggestions(averages, percentiles);\n\n    return {\n      componentName: options.componentName,\n      renderCount: renderCount.current,\n      averages,\n      percentiles,\n      alerts: alerts.length,\n      suggestions\n    };\n  }, [options.componentName, metrics, alerts]);\n\n  // Generate optimization suggestions\n  const optimize = useCallback((): OptimizationSuggestion[] => {\n    const report = getReport();\n    return report.suggestions;\n  }, [getReport]);\n\n  // Check if performance is acceptable\n  const isPerformant = useMemo(() => {\n    return (\n      metrics.renderTime < thresholds.renderTime &&\n      metrics.aiProcessingTime < thresholds.aiProcessingTime &&\n      metrics.interactionTime < thresholds.interactionTime &&\n      metrics.memoryUsage < thresholds.memoryUsage &&\n      metrics.fps >= thresholds.fps\n    );\n  }, [metrics, thresholds]);\n\n  // Track initial render\n  useEffect(() => {\n    trackRender();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    metrics,\n    isPerformant,\n    trackRender,\n    trackAIProcessing,\n    trackInteraction,\n    alerts,\n    clearAlerts,\n    getReport,\n    optimize\n  };\n};\n\n// Performance tracker interface\ninterface PerformanceTracker {\n  complete: () => void;\n  cancel: () => void;\n}\n\n// Helper functions\n\nfunction handlePerformanceEntry(entry: PerformanceEntry): void {\n  // Log long tasks\n  if (entry.duration > 50) {\n    console.warn(`Long task detected: ${entry.name} (${entry.duration.toFixed(2)}ms)`);\n  }\n}\n\nfunction logInteraction(interaction: string, duration: number): void {\n  // Log to analytics\n  if (typeof window !== 'undefined' && 'gtag' in window) {\n    (window as any).gtag('event', 'timing_complete', {\n      name: interaction,\n      value: Math.round(duration),\n      event_category: 'User Interaction'\n    });\n  }\n}\n\nfunction generateOptimizationSuggestions(\n  averages: PerformanceMetrics,\n  percentiles: any\n): OptimizationSuggestion[] {\n  const suggestions: OptimizationSuggestion[] = [];\n\n  // Render performance\n  if (averages.renderTime > 16.67) {\n    suggestions.push({\n      category: 'rendering',\n      priority: 'high',\n      issue: `Average render time is ${averages.renderTime.toFixed(2)}ms`,\n      suggestion: 'Optimize component rendering',\n      actions: [\n        'Use React.memo for expensive child components',\n        'Move state closer to where it\\'s used',\n        'Use useMemo for expensive computations',\n        'Consider virtualization for long lists'\n      ],\n      estimatedImpact: 'high'\n    });\n  }\n\n  // AI performance\n  if (averages.aiProcessingTime > 500) {\n    suggestions.push({\n      category: 'ai_processing',\n      priority: 'medium',\n      issue: `AI processing takes ${averages.aiProcessingTime.toFixed(0)}ms on average`,\n      suggestion: 'Optimize AI operations',\n      actions: [\n        'Implement response caching',\n        'Use progressive loading for results',\n        'Consider using faster model variants',\n        'Batch similar requests'\n      ],\n      estimatedImpact: 'medium'\n    });\n  }\n\n  // Memory usage\n  if (averages.memoryUsage > 50) {\n    suggestions.push({\n      category: 'memory',\n      priority: 'medium',\n      issue: `Memory usage is ${averages.memoryUsage.toFixed(0)}MB`,\n      suggestion: 'Reduce memory footprint',\n      actions: [\n        'Implement lazy loading',\n        'Clear unused data from state',\n        'Use weak references for cache',\n        'Optimize image sizes'\n      ],\n      estimatedImpact: 'medium'\n    });\n  }\n\n  // FPS\n  if (averages.fps < 50) {\n    suggestions.push({\n      category: 'animation',\n      priority: 'high',\n      issue: `FPS is ${averages.fps}, below smooth threshold`,\n      suggestion: 'Improve animation performance',\n      actions: [\n        'Use CSS transforms instead of position',\n        'Reduce DOM mutations during animation',\n        'Use will-change CSS property',\n        'Consider using Web Animations API'\n      ],\n      estimatedImpact: 'high'\n    });\n  }\n\n  return suggestions;\n}\n\n// Hook for monitoring specific AI operations\nexport const useAIPerformanceMonitoring = (operationName: string) => {\n  const [metrics, setMetrics] = useState<AIOperationMetrics>({\n    callCount: 0,\n    totalTime: 0,\n    averageTime: 0,\n    minTime: Infinity,\n    maxTime: 0,\n    errors: 0,\n    cacheHits: 0,\n    cacheMisses: 0\n  });\n\n  const track = useCallback(async <T,>(\n    operation: () => Promise<T>,\n    options?: { cached?: boolean }\n  ): Promise<T> => {\n    const startTime = performance.now();\n    \n    try {\n      const result = await operation();\n      const duration = performance.now() - startTime;\n      \n      setMetrics(prev => ({\n        callCount: prev.callCount + 1,\n        totalTime: prev.totalTime + duration,\n        averageTime: (prev.totalTime + duration) / (prev.callCount + 1),\n        minTime: Math.min(prev.minTime, duration),\n        maxTime: Math.max(prev.maxTime, duration),\n        errors: prev.errors,\n        cacheHits: prev.cacheHits + (options?.cached ? 1 : 0),\n        cacheMisses: prev.cacheMisses + (options?.cached ? 0 : 1)\n      }));\n      \n      return result;\n    } catch (error) {\n      setMetrics(prev => ({\n        ...prev,\n        errors: prev.errors + 1\n      }));\n      throw error;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    setMetrics({\n      callCount: 0,\n      totalTime: 0,\n      averageTime: 0,\n      minTime: Infinity,\n      maxTime: 0,\n      errors: 0,\n      cacheHits: 0,\n      cacheMisses: 0\n    });\n  }, []);\n\n  return { metrics, track, reset };\n};\n\n// Hook for monitoring component lifecycle\nexport const useComponentLifecycleMonitoring = (componentName: string) => {\n  const mountTime = useRef(performance.now());\n  const updateCount = useRef(0);\n  const [lifecycle, setLifecycle] = useState<ComponentLifecycle>({\n    mounted: true,\n    mountDuration: 0,\n    updates: 0,\n    lastUpdateDuration: 0,\n    totalUpdateTime: 0\n  });\n\n  useEffect(() => {\n    // Component mounted\n    const mountDuration = performance.now() - mountTime.current;\n    setLifecycle(prev => ({ ...prev, mountDuration }));\n\n    return () => {\n      // Component unmounting\n      const lifetime = performance.now() - mountTime.current;\n      console.log(`[${componentName}] Unmounting after ${lifetime.toFixed(0)}ms, ${updateCount.current} updates`);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  useEffect(() => {\n    // Track updates\n    const updateStart = performance.now();\n    updateCount.current++;\n\n    return () => {\n      const updateDuration = performance.now() - updateStart;\n      setLifecycle(prev => ({\n        ...prev,\n        updates: updateCount.current,\n        lastUpdateDuration: updateDuration,\n        totalUpdateTime: prev.totalUpdateTime + updateDuration\n      }));\n    };\n  });\n\n  return lifecycle;\n};\n\n// Types\n\ninterface PerformanceReport {\n  componentName: string;\n  renderCount: number;\n  averages: PerformanceMetrics;\n  percentiles: {\n    p50: PerformanceMetrics;\n    p75: PerformanceMetrics;\n    p90: PerformanceMetrics;\n    p95: PerformanceMetrics;\n    p99: PerformanceMetrics;\n  };\n  alerts: number;\n  suggestions: OptimizationSuggestion[];\n}\n\ninterface OptimizationSuggestion {\n  category: 'rendering' | 'ai_processing' | 'memory' | 'animation' | 'interaction';\n  priority: 'low' | 'medium' | 'high';\n  issue: string;\n  suggestion: string;\n  actions: string[];\n  estimatedImpact: 'low' | 'medium' | 'high';\n}\n\ninterface AIOperationMetrics {\n  callCount: number;\n  totalTime: number;\n  averageTime: number;\n  minTime: number;\n  maxTime: number;\n  errors: number;\n  cacheHits: number;\n  cacheMisses: number;\n}\n\ninterface ComponentLifecycle {\n  mounted: boolean;\n  mountDuration: number;\n  updates: number;\n  lastUpdateDuration: number;\n  totalUpdateTime: number;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePhotoComparison.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePhotoGuidance.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'enableOfflineMode' and 'loadProgress'. Either include them or remove the dependency array.","line":279,"column":6,"nodeType":"ArrayExpression","endLine":279,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [checklistItem.id, enableOfflineMode, loadProgress]","fix":{"range":[7186,7204],"text":"[checklistItem.id, enableOfflineMode, loadProgress]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'enableOfflineMode' and 'saveProgress'. Either include them or remove the dependency array.","line":291,"column":6,"nodeType":"ArrayExpression","endLine":291,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [enableOfflineMode, guidanceState, saveProgress]","fix":{"range":[7508,7523],"text":"[enableOfflineMode, guidanceState, saveProgress]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":455,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12119,12122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12119,12122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":465,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12417,12420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12417,12420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Photo Guidance Hook for STR Certified\n\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport { useQuery, useMutation } from '@tanstack/react-query';\nimport type { ChecklistItem } from '@/types/photo';\n\nexport interface PhotoGuidanceStep {\n  id: string;\n  title: string;\n  description: string;\n  icon: string;\n  requiredQualityScore: number;\n  tips: string[];\n  examplePhotoUrl?: string;\n  focusAreas?: Array<{\n    label: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  }>;\n}\n\nexport interface PhotoGuidanceState {\n  currentStep: number;\n  totalSteps: number;\n  stepsCompleted: number;\n  isComplete: boolean;\n  currentGuidance: string;\n  history: Array<{\n    stepId: string;\n    timestamp: Date;\n    qualityScore: number;\n    photoUrl?: string;\n  }>;\n}\n\nexport interface UsePhotoGuidanceOptions {\n  checklistItem: ChecklistItem;\n  referencePhoto?: string;\n  enableOfflineMode?: boolean;\n  autoAdvance?: boolean;\n}\n\nexport interface UsePhotoGuidanceReturn {\n  currentStep: number;\n  guidance: PhotoGuidanceState;\n  steps: PhotoGuidanceStep[];\n  isComplete: boolean;\n  isLoading: boolean;\n  error: Error | null;\n  nextStep: () => void;\n  previousStep: () => void;\n  goToStep: (step: number) => void;\n  markStepComplete: (qualityScore: number, photoUrl?: string) => void;\n  resetGuidance: () => void;\n  getProgress: () => number;\n  getCurrentRequirements: () => string[];\n  saveProgress: () => Promise<void>;\n  loadProgress: () => Promise<void>;\n}\n\n// Default guidance steps for different room types\nconst DEFAULT_GUIDANCE_STEPS: Record<string, PhotoGuidanceStep[]> = {\n  bedroom: [\n    {\n      id: 'overview',\n      title: 'Room Overview',\n      description: 'Capture the entire room from the doorway',\n      icon: 'ðŸšª',\n      requiredQualityScore: 70,\n      tips: [\n        'Stand in the doorway',\n        'Include all major furniture',\n        'Ensure good lighting',\n        'Keep device level'\n      ],\n      focusAreas: [\n        { label: 'Bed', x: 30, y: 40, width: 40, height: 30 },\n        { label: 'Window', x: 70, y: 20, width: 25, height: 40 }\n      ]\n    },\n    {\n      id: 'bed_detail',\n      title: 'Bed & Linens',\n      description: 'Focus on bed condition and cleanliness',\n      icon: 'ðŸ›ï¸',\n      requiredQualityScore: 80,\n      tips: [\n        'Get close to show linen quality',\n        'Check for stains or damage',\n        'Include pillows and covers',\n        'Capture from a 45-degree angle'\n      ]\n    },\n    {\n      id: 'storage',\n      title: 'Storage Areas',\n      description: 'Capture closets, dressers, and nightstands',\n      icon: 'ðŸ—„ï¸',\n      requiredQualityScore: 75,\n      tips: [\n        'Open closet doors',\n        'Show drawer interiors if needed',\n        'Check for damage or wear',\n        'Ensure adequate lighting inside'\n      ]\n    },\n    {\n      id: 'amenities',\n      title: 'Room Amenities',\n      description: 'Document TV, AC, outlets, and switches',\n      icon: 'ðŸ“º',\n      requiredQualityScore: 75,\n      tips: [\n        'Test all electronics',\n        'Show remote controls',\n        'Check outlet functionality',\n        'Document any issues'\n      ]\n    }\n  ],\n  bathroom: [\n    {\n      id: 'overview',\n      title: 'Bathroom Overview',\n      description: 'Capture the entire bathroom',\n      icon: 'ðŸš¿',\n      requiredQualityScore: 70,\n      tips: [\n        'Stand in doorway',\n        'Include all fixtures',\n        'Check for water damage',\n        'Ensure good ventilation'\n      ]\n    },\n    {\n      id: 'fixtures',\n      title: 'Fixtures & Plumbing',\n      description: 'Focus on sink, toilet, and shower/tub',\n      icon: 'ðŸš°',\n      requiredQualityScore: 85,\n      tips: [\n        'Check for leaks or damage',\n        'Test water pressure',\n        'Look for mold or mildew',\n        'Document any issues'\n      ]\n    },\n    {\n      id: 'amenities',\n      title: 'Bathroom Amenities',\n      description: 'Towels, toiletries, and storage',\n      icon: 'ðŸ§´',\n      requiredQualityScore: 75,\n      tips: [\n        'Check towel quality',\n        'Verify toiletries provided',\n        'Open cabinets and drawers',\n        'Note any missing items'\n      ]\n    }\n  ],\n  kitchen: [\n    {\n      id: 'overview',\n      title: 'Kitchen Overview',\n      description: 'Capture the entire kitchen space',\n      icon: 'ðŸ³',\n      requiredQualityScore: 70,\n      tips: [\n        'Show all major appliances',\n        'Include countertops',\n        'Capture from multiple angles',\n        'Ensure good lighting'\n      ]\n    },\n    {\n      id: 'appliances',\n      title: 'Appliances',\n      description: 'Document all kitchen appliances',\n      icon: 'ðŸ”Œ',\n      requiredQualityScore: 80,\n      tips: [\n        'Open refrigerator and oven',\n        'Test all appliances',\n        'Check for cleanliness',\n        'Note any malfunctions'\n      ]\n    },\n    {\n      id: 'cookware',\n      title: 'Cookware & Utensils',\n      description: 'Show available cooking items',\n      icon: 'ðŸ´',\n      requiredQualityScore: 75,\n      tips: [\n        'Open all cabinets',\n        'Document cookware condition',\n        'Check for complete sets',\n        'Note any missing items'\n      ]\n    }\n  ],\n  'living-room': [\n    {\n      id: 'overview',\n      title: 'Living Room Overview',\n      description: 'Capture the entire living space',\n      icon: 'ðŸ›‹ï¸',\n      requiredQualityScore: 70,\n      tips: [\n        'Show seating arrangements',\n        'Include entertainment center',\n        'Capture natural lighting',\n        'Take from room corners'\n      ]\n    },\n    {\n      id: 'seating',\n      title: 'Seating & Comfort',\n      description: 'Focus on sofas and chairs',\n      icon: 'ðŸª‘',\n      requiredQualityScore: 75,\n      tips: [\n        'Check for stains or damage',\n        'Test furniture stability',\n        'Show cushion condition',\n        'Document any wear'\n      ]\n    },\n    {\n      id: 'entertainment',\n      title: 'Entertainment Setup',\n      description: 'TV, sound system, and controls',\n      icon: 'ðŸ“º',\n      requiredQualityScore: 75,\n      tips: [\n        'Test all electronics',\n        'Check remote controls',\n        'Verify cable/streaming access',\n        'Document model numbers'\n      ]\n    }\n  ]\n};\n\nexport const usePhotoGuidance = (options: UsePhotoGuidanceOptions): UsePhotoGuidanceReturn => {\n  const {\n    checklistItem,\n    referencePhoto,\n    enableOfflineMode = true,\n    autoAdvance = false\n  } = options;\n\n  // Determine room type from checklist item\n  const roomType = checklistItem.roomName?.toLowerCase().replace(/\\s+/g, '-') || 'bedroom';\n  const guidanceSteps = DEFAULT_GUIDANCE_STEPS[roomType] || DEFAULT_GUIDANCE_STEPS.bedroom;\n\n  // State management\n  const [currentStep, setCurrentStep] = useState(0);\n  const [guidanceState, setGuidanceState] = useState<PhotoGuidanceState>({\n    currentStep: 0,\n    totalSteps: guidanceSteps.length,\n    stepsCompleted: 0,\n    isComplete: false,\n    currentGuidance: guidanceSteps[0]?.description || '',\n    history: []\n  });\n\n  // Refs\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Load saved progress on mount\n  useEffect(() => {\n    if (enableOfflineMode) {\n      loadProgress();\n    }\n  }, [checklistItem.id]);\n\n  // Auto-save progress\n  useEffect(() => {\n    if (enableOfflineMode && guidanceState.history.length > 0) {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n      saveTimeoutRef.current = setTimeout(() => {\n        saveProgress();\n      }, 1000);\n    }\n  }, [guidanceState]);\n\n  // Navigation functions\n  const nextStep = useCallback(() => {\n    if (currentStep < guidanceSteps.length - 1) {\n      const newStep = currentStep + 1;\n      setCurrentStep(newStep);\n      setGuidanceState(prev => ({\n        ...prev,\n        currentStep: newStep,\n        currentGuidance: guidanceSteps[newStep].description\n      }));\n    }\n  }, [currentStep, guidanceSteps]);\n\n  const previousStep = useCallback(() => {\n    if (currentStep > 0) {\n      const newStep = currentStep - 1;\n      setCurrentStep(newStep);\n      setGuidanceState(prev => ({\n        ...prev,\n        currentStep: newStep,\n        currentGuidance: guidanceSteps[newStep].description\n      }));\n    }\n  }, [currentStep, guidanceSteps]);\n\n  const goToStep = useCallback((step: number) => {\n    if (step >= 0 && step < guidanceSteps.length) {\n      setCurrentStep(step);\n      setGuidanceState(prev => ({\n        ...prev,\n        currentStep: step,\n        currentGuidance: guidanceSteps[step].description\n      }));\n    }\n  }, [guidanceSteps]);\n\n  const markStepComplete = useCallback((qualityScore: number, photoUrl?: string) => {\n    const stepId = guidanceSteps[currentStep].id;\n    \n    setGuidanceState(prev => {\n      // Check if step already completed\n      const alreadyCompleted = prev.history.some(h => h.stepId === stepId);\n      \n      const newHistory = [...prev.history];\n      if (!alreadyCompleted) {\n        newHistory.push({\n          stepId,\n          timestamp: new Date(),\n          qualityScore,\n          photoUrl\n        });\n      }\n\n      const stepsCompleted = new Set(newHistory.map(h => h.stepId)).size;\n      const isComplete = stepsCompleted === guidanceSteps.length;\n\n      return {\n        ...prev,\n        history: newHistory,\n        stepsCompleted,\n        isComplete\n      };\n    });\n\n    // Auto-advance if enabled and quality meets requirements\n    if (autoAdvance && qualityScore >= guidanceSteps[currentStep].requiredQualityScore) {\n      setTimeout(() => nextStep(), 500);\n    }\n  }, [currentStep, guidanceSteps, autoAdvance, nextStep]);\n\n  const resetGuidance = useCallback(() => {\n    setCurrentStep(0);\n    setGuidanceState({\n      currentStep: 0,\n      totalSteps: guidanceSteps.length,\n      stepsCompleted: 0,\n      isComplete: false,\n      currentGuidance: guidanceSteps[0]?.description || '',\n      history: []\n    });\n    \n    // Clear saved progress\n    if (enableOfflineMode) {\n      localStorage.removeItem(`photo_guidance_${checklistItem.id}`);\n    }\n  }, [guidanceSteps, checklistItem.id, enableOfflineMode]);\n\n  const getProgress = useCallback(() => {\n    return (guidanceState.stepsCompleted / guidanceState.totalSteps) * 100;\n  }, [guidanceState]);\n\n  const getCurrentRequirements = useCallback(() => {\n    const currentGuidanceStep = guidanceSteps[currentStep];\n    return [\n      `Minimum quality score: ${currentGuidanceStep.requiredQualityScore}%`,\n      ...currentGuidanceStep.tips\n    ];\n  }, [currentStep, guidanceSteps]);\n\n  const saveProgress = useCallback(async () => {\n    if (!enableOfflineMode) return;\n    \n    const progressData = {\n      checklistItemId: checklistItem.id,\n      currentStep,\n      guidanceState,\n      savedAt: new Date().toISOString()\n    };\n    \n    localStorage.setItem(\n      `photo_guidance_${checklistItem.id}`,\n      JSON.stringify(progressData)\n    );\n  }, [checklistItem.id, currentStep, guidanceState, enableOfflineMode]);\n\n  const loadProgress = useCallback(async () => {\n    if (!enableOfflineMode) return;\n    \n    try {\n      const saved = localStorage.getItem(`photo_guidance_${checklistItem.id}`);\n      if (saved) {\n        const progressData = JSON.parse(saved);\n        \n        // Restore state\n        setCurrentStep(progressData.currentStep);\n        setGuidanceState(progressData.guidanceState);\n      }\n    } catch (error) {\n      console.error('Failed to load progress:', error);\n    }\n  }, [checklistItem.id, enableOfflineMode]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    currentStep,\n    guidance: guidanceState,\n    steps: guidanceSteps,\n    isComplete: guidanceState.isComplete,\n    isLoading: false,\n    error: null,\n    nextStep,\n    previousStep,\n    goToStep,\n    markStepComplete,\n    resetGuidance,\n    getProgress,\n    getCurrentRequirements,\n    saveProgress,\n    loadProgress\n  };\n};\n\n// Utility hook for offline guidance caching\nexport const useOfflineGuidance = () => {\n  const [cachedGuidance, setCachedGuidance] = useState<Record<string, any>>({});\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const loadCachedGuidance = () => {\n      try {\n        const keys = Object.keys(localStorage).filter(key => \n          key.startsWith('photo_guidance_')\n        );\n        \n        const cached: Record<string, any> = {};\n        keys.forEach(key => {\n          try {\n            cached[key] = JSON.parse(localStorage.getItem(key) || '{}');\n          } catch (e) {\n            // Skip invalid entries\n          }\n        });\n        \n        setCachedGuidance(cached);\n      } catch (error) {\n        console.error('Failed to load cached guidance:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadCachedGuidance();\n  }, []);\n\n  const clearCache = useCallback(() => {\n    Object.keys(localStorage)\n      .filter(key => key.startsWith('photo_guidance_'))\n      .forEach(key => localStorage.removeItem(key));\n    setCachedGuidance({});\n  }, []);\n\n  const getCachedProgress = useCallback((checklistItemId: string) => {\n    return cachedGuidance[`photo_guidance_${checklistItemId}`];\n  }, [cachedGuidance]);\n\n  return {\n    cachedGuidance,\n    isLoading,\n    clearCache,\n    getCachedProgress\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyForm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyFormAuth.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[440,443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[440,443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect } from \"react\";\nimport { useAuth } from \"@/components/AuthProvider\";\nimport { useAuthRecovery } from \"@/hooks/useAuthRecovery\";\n\ninterface AuthDebugInfo {\n  authStatus: {\n    authenticated: boolean;\n    userId?: string;\n    userEmail?: string;\n    userRole?: string;\n    timestamp: string;\n    roleSource: 'database' | 'fallback' | 'default';\n    loadingState: boolean;\n    error?: string;\n    recoveryState?: any;\n  };\n}\n\nexport const usePropertyFormAuth = () => {\n  const { user, userRole, loading, error } = useAuth();\n  const { recoveryState, attemptRecovery, canRecover } = useAuthRecovery();\n  const [authDebugInfo, setAuthDebugInfo] = useState<AuthDebugInfo>({} as AuthDebugInfo);\n\n  // Enhanced authentication validation with recovery support\n  useEffect(() => {\n    console.log('ðŸ” PropertyFormAuth - Auth state updated:', {\n      user: !!user,\n      userRole,\n      loading,\n      error,\n      recoveryState,\n      timestamp: new Date().toISOString()\n    });\n\n    if (loading && !recoveryState.isRecovering) {\n      console.log('â³ Auth still loading...');\n      setAuthDebugInfo({\n        authStatus: {\n          authenticated: false,\n          loadingState: loading,\n          roleSource: 'default',\n          timestamp: new Date().toISOString(),\n          error: error || undefined,\n          recoveryState\n        }\n      });\n      return;\n    }\n\n    if (error && canRecover) {\n      console.warn('âš ï¸ Auth error detected:', error);\n      setAuthDebugInfo({\n        authStatus: {\n          authenticated: false,\n          loadingState: loading,\n          roleSource: 'default',\n          timestamp: new Date().toISOString(),\n          error,\n          recoveryState\n        }\n      });\n      return;\n    }\n\n    if (!user && !loading) {\n      console.warn('âš ï¸ User not authenticated');\n      setAuthDebugInfo({\n        authStatus: {\n          authenticated: false,\n          loadingState: loading,\n          roleSource: 'default',\n          timestamp: new Date().toISOString(),\n          error: error || undefined,\n          recoveryState\n        }\n      });\n      return;\n    }\n\n    // Determine role source for debugging\n    const roleSource = userRole === 'inspector' ? 'fallback' : 'database';\n\n    console.log('ðŸ‘¤ Enhanced Auth Status:', {\n      user: {\n        id: user?.id,\n        email: user?.email,\n        role: userRole,\n        roleSource,\n        loading,\n        error\n      },\n      recoveryState,\n      timestamp: new Date().toISOString()\n    });\n\n    setAuthDebugInfo({\n      authStatus: {\n        authenticated: !!user,\n        userId: user?.id,\n        userEmail: user?.email,\n        userRole: userRole || 'inspector',\n        roleSource,\n        loadingState: loading,\n        timestamp: new Date().toISOString(),\n        error: error || undefined,\n        recoveryState\n      }\n    });\n  }, [user, userRole, loading, error, recoveryState, canRecover]);\n\n  return {\n    user,\n    userRole,\n    loading,\n    error,\n    authDebugInfo,\n    recoveryState,\n    attemptRecovery,\n    canRecover\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyFormState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyFormValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2466,2469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2466,2469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\ninterface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport const usePropertyFormValidation = () => {\n  const { toast } = useToast();\n\n  const validateFormData = (formData: PropertyFormData): ValidationResult => {\n    const errors: string[] = [];\n\n    // Name validation\n    if (!formData.name || formData.name.trim().length === 0) {\n      errors.push(\"Property name is required\");\n    } else if (formData.name.trim().length < 2) {\n      errors.push(\"Property name must be at least 2 characters long\");\n    } else if (formData.name.trim().length > 200) {\n      errors.push(\"Property name cannot exceed 200 characters\");\n    }\n\n    // Address validation\n    if (!formData.address || formData.address.trim().length === 0) {\n      errors.push(\"Property address is required\");\n    } else if (formData.address.trim().length < 5) {\n      errors.push(\"Address must be at least 5 characters long\");\n    } else if (formData.address.trim().length > 500) {\n      errors.push(\"Address cannot exceed 500 characters\");\n    }\n\n    // URL validation (optional but if provided must be valid)\n    if (formData.vrbo_url && formData.vrbo_url.trim()) {\n      if (!isValidUrl(formData.vrbo_url.trim())) {\n        errors.push(\"Vrbo URL must be a valid URL\");\n      } else if (!formData.vrbo_url.toLowerCase().includes('vrbo.com')) {\n        errors.push(\"Vrbo URL must be from vrbo.com domain\");\n      }\n    }\n\n    if (formData.airbnb_url && formData.airbnb_url.trim()) {\n      if (!isValidUrl(formData.airbnb_url.trim())) {\n        errors.push(\"Airbnb URL must be a valid URL\");\n      } else if (!formData.airbnb_url.toLowerCase().includes('airbnb.com')) {\n        errors.push(\"Airbnb URL must be from airbnb.com domain\");\n      }\n    }\n\n    // At least one URL should be provided\n    const hasVrbo = formData.vrbo_url && formData.vrbo_url.trim();\n    const hasAirbnb = formData.airbnb_url && formData.airbnb_url.trim();\n    \n    if (!hasVrbo && !hasAirbnb) {\n      errors.push(\"At least one listing URL (Vrbo or Airbnb) is required\");\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  };\n\n  const isValidUrl = (url: string): boolean => {\n    try {\n      new URL(url);\n      return url.startsWith('http://') || url.startsWith('https://');\n    } catch {\n      return false;\n    }\n  };\n\n  const validateSubmission = (\n    user: any,\n    isOnline: boolean,\n    formData: PropertyFormData\n  ): boolean => {\n    console.log('ðŸ” Starting comprehensive validation...', {\n      hasUser: !!user,\n      isOnline,\n      formData: {\n        name: formData.name?.substring(0, 50) + (formData.name?.length > 50 ? '...' : ''),\n        address: formData.address?.substring(0, 50) + (formData.address?.length > 50 ? '...' : ''),\n        hasVrbo: !!formData.vrbo_url,\n        hasAirbnb: !!formData.airbnb_url\n      }\n    });\n\n    // Authentication check\n    if (!user) {\n      console.error('âŒ Validation failed: No authenticated user');\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please log in to add or edit properties.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Network check\n    if (!isOnline) {\n      console.error('âŒ Validation failed: No network connection');\n      toast({\n        title: \"Network Error\",\n        description: \"Please check your internet connection and try again.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Form data validation\n    const validation = validateFormData(formData);\n    if (!validation.isValid) {\n      console.error('âŒ Validation failed: Form errors', validation.errors);\n      toast({\n        title: \"Validation Error\",\n        description: validation.errors[0], // Show first error\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    console.log('âœ… All validation checks passed');\n    return true;\n  };\n\n  return { \n    validateSubmission,\n    validateFormData \n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[650,653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[650,653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useToast } from \"@/hooks/use-toast\";\n\ninterface LoadDebugInfo {\n  loadError?: {\n    error: string;\n    code?: string;\n    details?: string;\n    hint?: string;\n    propertyId: string;\n    timestamp: string;\n  };\n  unexpectedLoadError?: {\n    error: string;\n    stack?: string;\n    timestamp: string;\n  };\n  loadedProperty?: {\n    id: string;\n    name: string;\n    hasVrboUrl: boolean;\n    hasAirbnbUrl: boolean;\n    timestamp: string;\n  };\n}\n\nexport const usePropertyLoader = (user: any) => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const { toast } = useToast();\n  const editId = searchParams.get('edit');\n  const isEditing = !!editId;\n\n  const [isLoadingProperty, setIsLoadingProperty] = useState(false);\n  const [loadDebugInfo, setLoadDebugInfo] = useState<LoadDebugInfo>({});\n\n  const loadProperty = async () => {\n    if (!isEditing || !editId || !user) return null;\n\n    setIsLoadingProperty(true);\n    console.log('ðŸ“ Loading property for editing:', editId);\n    \n    try {\n      console.log('ðŸ” Fetching property data...');\n      const { data, error } = await supabase\n        .from('properties')\n        .select('*')\n        .eq('id', editId)\n        .single();\n\n      if (error) {\n        console.error('âŒ Error loading property:', {\n          error,\n          propertyId: editId,\n          userId: user.id\n        });\n        \n        setLoadDebugInfo(prev => ({\n          ...prev,\n          loadError: {\n            error: error.message,\n            code: error.code,\n            details: error.details,\n            hint: error.hint,\n            propertyId: editId,\n            timestamp: new Date().toISOString()\n          }\n        }));\n\n        toast({\n          title: \"Error Loading Property\",\n          description: `Failed to load property: ${error.message}`,\n          variant: \"destructive\",\n        });\n        navigate('/properties');\n        return null;\n      }\n\n      console.log('âœ… Property loaded successfully:', data);\n      setLoadDebugInfo(prev => ({\n        ...prev,\n        loadedProperty: {\n          id: data.id,\n          name: data.name,\n          hasVrboUrl: !!data.vrbo_url,\n          hasAirbnbUrl: !!data.airbnb_url,\n          timestamp: new Date().toISOString()\n        }\n      }));\n\n      return {\n        name: data.name || \"\",\n        address: data.address || \"\",\n        vrbo_url: data.vrbo_url || \"\",\n        airbnb_url: data.airbnb_url || \"\"\n      };\n    } catch (error) {\n      console.error('ðŸ’¥ Unexpected error loading property:', error);\n      \n      setLoadDebugInfo(prev => ({\n        ...prev,\n        unexpectedLoadError: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          stack: error instanceof Error ? error.stack : undefined,\n          timestamp: new Date().toISOString()\n        }\n      }));\n\n      toast({\n        title: \"Error\",\n        description: \"An unexpected error occurred while loading the property.\",\n        variant: \"destructive\",\n      });\n      navigate('/properties');\n      return null;\n    } finally {\n      setIsLoadingProperty(false);\n    }\n  };\n\n  return {\n    isEditing,\n    isLoadingProperty,\n    loadProperty,\n    loadDebugInfo\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyMutation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[256,259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[256,259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { supabase } from \"@/integrations/supabase/client\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const usePropertyMutation = () => {\n  const executePropertyMutation = async (\n    formData: PropertyFormData,\n    user: any,\n    isEditing: boolean,\n    editId: string | null\n  ) => {\n    const submitData = {\n      name: formData.name.trim(),\n      address: formData.address.trim(),\n      vrbo_url: formData.vrbo_url.trim() || null,\n      airbnb_url: formData.airbnb_url.trim() || null,\n    };\n\n    console.log(`${isEditing ? 'ðŸ“ Updating' : 'âž• Creating'} property with data:`, {\n      ...submitData,\n      userId: user.id,\n      userEmail: user.email,\n      isEditing,\n      editId,\n      timestamp: new Date().toISOString()\n    });\n\n    if (isEditing) {\n      console.log('ðŸ”„ Executing UPDATE operation...');\n      return await supabase\n        .from('properties')\n        .update({\n          ...submitData,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', editId)\n        .select()\n        .single();\n    } else {\n      console.log('ðŸ†• Executing INSERT operation...');\n      return await supabase\n        .from('properties')\n        .insert({\n          ...submitData,\n          added_by: user.id,\n          created_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n    }\n  };\n\n  return { executePropertyMutation };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyScraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertySelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertySubmission.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[456,459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[456,459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { usePropertyValidation } from \"./usePropertyValidation\";\nimport { usePropertyMutation } from \"./usePropertyMutation\";\nimport { usePropertySubmissionState } from \"./usePropertySubmissionState\";\nimport { usePropertyErrorHandler } from \"@/utils/propertySubmissionErrors\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const usePropertySubmission = (user: any, userRole: string) => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const editId = searchParams.get('edit');\n  const isEditing = !!editId;\n\n  // Use the smaller, focused hooks\n  const { validateSubmission } = usePropertyValidation();\n  const { executePropertyMutation } = usePropertyMutation();\n  const { \n    isLoading, \n    setIsLoading, \n    submissionDebugInfo, \n    updateDebugInfo \n  } = usePropertySubmissionState();\n  const { \n    handleSubmissionError, \n    handleUnexpectedError, \n    handleSuccess \n  } = usePropertyErrorHandler();\n\n  const submitProperty = async (formData: PropertyFormData, isOnline: boolean) => {\n    console.log('ðŸš€ Starting form submission process...');\n    \n    // Pre-submission validation\n    if (!validateSubmission(user, isOnline, formData)) {\n      return false;\n    }\n\n    setIsLoading(true);\n    const submitStartTime = Date.now();\n\n    try {\n      const result = await executePropertyMutation(formData, user, isEditing, editId);\n      const { data, error } = result;\n      const submitDuration = Date.now() - submitStartTime;\n\n      if (error) {\n        console.error(`âŒ Database error during ${isEditing ? 'update' : 'insert'}:`, {\n          error: {\n            message: error.message,\n            code: error.code,\n            details: error.details,\n            hint: error.hint\n          },\n          operation: isEditing ? 'update' : 'insert',\n          userId: user.id,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        });\n\n        updateDebugInfo({\n          submitError: {\n            operation: isEditing ? 'update' : 'insert',\n            error: error.message,\n            code: error.code,\n            details: error.details,\n            hint: error.hint,\n            duration: submitDuration,\n            timestamp: new Date().toISOString()\n          }\n        });\n\n        handleSubmissionError(error, isEditing);\n        return false;\n      }\n\n      console.log(`âœ… Property ${isEditing ? 'updated' : 'created'} successfully:`, {\n        data,\n        duration: submitDuration,\n        timestamp: new Date().toISOString()\n      });\n\n      updateDebugInfo({\n        submitSuccess: {\n          operation: isEditing ? 'update' : 'insert',\n          propertyId: data?.id,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      handleSuccess(formData.name.trim(), isEditing);\n\n      // Small delay to ensure UI feedback is seen\n      setTimeout(() => {\n        navigate('/properties');\n      }, 500);\n\n      return true;\n    } catch (error) {\n      const submitDuration = Date.now() - submitStartTime;\n      console.error(`ðŸ’¥ Unexpected error during ${isEditing ? 'update' : 'create'}:`, {\n        error: error instanceof Error ? {\n          message: error.message,\n          stack: error.stack,\n          name: error.name\n        } : error,\n        duration: submitDuration,\n        timestamp: new Date().toISOString()\n      });\n\n      updateDebugInfo({\n        unexpectedSubmitError: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          stack: error instanceof Error ? error.stack : undefined,\n          duration: submitDuration,\n          timestamp: new Date().toISOString()\n        }\n      });\n\n      handleUnexpectedError();\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return {\n    isLoading,\n    submitProperty,\n    submissionDebugInfo\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertySubmissionMonitoring.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[158,161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[158,161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1009,1012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1009,1012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\n\ninterface SubmissionMetrics {\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  attempts: number;\n  errors: any[];\n  success: boolean;\n}\n\ninterface MonitoringState {\n  currentSubmission: SubmissionMetrics | null;\n  recentSubmissions: SubmissionMetrics[];\n}\n\nexport const usePropertySubmissionMonitoring = () => {\n  const [state, setState] = useState<MonitoringState>({\n    currentSubmission: null,\n    recentSubmissions: []\n  });\n\n  const startSubmissionTracking = () => {\n    const submission: SubmissionMetrics = {\n      startTime: Date.now(),\n      attempts: 1,\n      errors: [],\n      success: false\n    };\n\n    setState(prev => ({\n      ...prev,\n      currentSubmission: submission\n    }));\n\n    console.log('ðŸ“Š Started submission tracking:', {\n      startTime: new Date(submission.startTime).toISOString(),\n      submissionId: submission.startTime\n    });\n\n    return submission.startTime; // Return as submission ID\n  };\n\n  const recordError = (error: any) => {\n    setState(prev => {\n      if (!prev.currentSubmission) return prev;\n\n      const updatedSubmission = {\n        ...prev.currentSubmission,\n        errors: [...prev.currentSubmission.errors, {\n          timestamp: Date.now(),\n          error: error instanceof Error ? {\n            message: error.message,\n            stack: error.stack,\n            name: error.name\n          } : error\n        }]\n      };\n\n      console.log('âŒ Recorded submission error:', {\n        submissionId: updatedSubmission.startTime,\n        errorCount: updatedSubmission.errors.length,\n        latestError: updatedSubmission.errors[updatedSubmission.errors.length - 1]\n      });\n\n      return {\n        ...prev,\n        currentSubmission: updatedSubmission\n      };\n    });\n  };\n\n  const recordRetry = () => {\n    setState(prev => {\n      if (!prev.currentSubmission) return prev;\n\n      const updatedSubmission = {\n        ...prev.currentSubmission,\n        attempts: prev.currentSubmission.attempts + 1\n      };\n\n      console.log('ðŸ”„ Recorded submission retry:', {\n        submissionId: updatedSubmission.startTime,\n        attemptNumber: updatedSubmission.attempts\n      });\n\n      return {\n        ...prev,\n        currentSubmission: updatedSubmission\n      };\n    });\n  };\n\n  const completeSubmission = (success: boolean) => {\n    setState(prev => {\n      if (!prev.currentSubmission) return prev;\n\n      const completedSubmission: SubmissionMetrics = {\n        ...prev.currentSubmission,\n        endTime: Date.now(),\n        duration: Date.now() - prev.currentSubmission.startTime,\n        success\n      };\n\n      console.log(`${success ? 'âœ…' : 'âŒ'} Completed submission tracking:`, {\n        submissionId: completedSubmission.startTime,\n        success,\n        duration: completedSubmission.duration,\n        attempts: completedSubmission.attempts,\n        errorCount: completedSubmission.errors.length\n      });\n\n      // Keep only the last 10 submissions for memory efficiency\n      const recentSubmissions = [\n        completedSubmission,\n        ...prev.recentSubmissions.slice(0, 9)\n      ];\n\n      return {\n        currentSubmission: null,\n        recentSubmissions\n      };\n    });\n  };\n\n  const getSubmissionStats = () => {\n    const { recentSubmissions } = state;\n    \n    if (recentSubmissions.length === 0) {\n      return {\n        totalSubmissions: 0,\n        successRate: 0,\n        averageDuration: 0,\n        commonErrors: []\n      };\n    }\n\n    const successCount = recentSubmissions.filter(s => s.success).length;\n    const submissionsWithDuration = recentSubmissions.filter(s => s.duration && typeof s.duration === 'number');\n    \n    // Calculate total duration\n    const totalDuration = submissionsWithDuration.reduce((sum: number, s) => {\n      return sum + (s.duration as number);\n    }, 0);\n    \n    const allErrors = recentSubmissions.flatMap(s => s.errors);\n    const errorCounts = allErrors.reduce((acc, errorEntry) => {\n      const errorKey = errorEntry.error?.message || 'Unknown error';\n      acc[errorKey] = (acc[errorKey] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const commonErrors = Object.entries(errorCounts)\n      .sort(([, a], [, b]) => (b as number) - (a as number))\n      .slice(0, 5)\n      .map(([error, count]) => ({ error, count }));\n\n    // Calculate average duration\n    const averageDuration = submissionsWithDuration.length > 0 \n      ? totalDuration / submissionsWithDuration.length \n      : 0;\n\n    return {\n      totalSubmissions: recentSubmissions.length,\n      successRate: (successCount / recentSubmissions.length) * 100,\n      averageDuration,\n      commonErrors\n    };\n  };\n\n  return {\n    startSubmissionTracking,\n    recordError,\n    recordRetry,\n    completeSubmission,\n    getSubmissionStats,\n    currentSubmission: state.currentSubmission,\n    recentSubmissions: state.recentSubmissions\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertySubmissionRetry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[161,164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[161,164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useToast } from \"@/hooks/use-toast\";\n\nexport const usePropertySubmissionRetry = () => {\n  const { toast } = useToast();\n\n  const isRetryable = (error: any): boolean => {\n    // Network/timeout errors are retryable\n    if (error.code === 'PGRST301' || // Network error\n        error.code === 'PGRST504' || // Gateway timeout\n        error.message?.includes('timeout') ||\n        error.message?.includes('network') ||\n        error.message?.includes('connection')) {\n      return true;\n    }\n    \n    // Authentication errors might be retryable (token refresh)\n    if (error.code === '42501' || error.message?.includes('JWT')) {\n      return true;\n    }\n    \n    // Business logic errors are not retryable\n    if (error.code === '23505' || // Unique constraint\n        error.code === 'PGRST116' || // Not found\n        error.message?.includes('violates')) {\n      return false;\n    }\n    \n    // Default to retryable for unknown errors\n    return true;\n  };\n\n  const showRetryToast = (attempt: number, maxRetries: number, isUnexpected: boolean = false) => {\n    const title = isUnexpected ? \"Unexpected Error\" : \"Connection Issue\";\n    toast({\n      title,\n      description: `Retrying... (${attempt}/${maxRetries})`,\n    });\n  };\n\n  const createBackoffDelay = (attempt: number): number => {\n    // Exponential backoff: 1s, 2s\n    return Math.pow(2, attempt - 1) * 1000;\n  };\n\n  return {\n    isRetryable,\n    showRetryToast,\n    createBackoffDelay\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertySubmissionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/usePropertyValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[235,238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[235,238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const usePropertyValidation = () => {\n  const { toast } = useToast();\n\n  const validateSubmission = (\n    user: any,\n    isOnline: boolean,\n    formData: PropertyFormData\n  ): boolean => {\n    if (!user) {\n      console.error('âŒ No authenticated user found');\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please log in to add or edit properties.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    if (!isOnline) {\n      console.error('âŒ No network connection');\n      toast({\n        title: \"Network Error\",\n        description: \"Please check your internet connection and try again.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Additional validation can be added here\n    return true;\n  };\n\n  return { validateSubmission };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useReliablePropertySubmission.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[326,329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[326,329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const useReliablePropertySubmission = (user: any) => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const editId = searchParams.get('edit');\n  const isEditing = !!editId;\n  const { toast } = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n\n  const validateSubmission = (formData: PropertyFormData, isOnline: boolean): boolean => {\n    console.log('ðŸ” Validating submission...', { formData, isOnline, hasUser: !!user });\n\n    // Check authentication\n    if (!user) {\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please log in to add or edit properties.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Check network\n    if (!isOnline) {\n      toast({\n        title: \"Network Error\",\n        description: \"Please check your internet connection and try again.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Validate form data\n    if (!formData.name || formData.name.trim().length < 2) {\n      toast({\n        title: \"Validation Error\",\n        description: \"Property name must be at least 2 characters long.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    if (!formData.address || formData.address.trim().length < 5) {\n      toast({\n        title: \"Validation Error\",\n        description: \"Please provide a complete address.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Check that at least one URL is provided\n    const hasVrbo = formData.vrbo_url && formData.vrbo_url.trim();\n    const hasAirbnb = formData.airbnb_url && formData.airbnb_url.trim();\n    \n    if (!hasVrbo && !hasAirbnb) {\n      toast({\n        title: \"Validation Error\",\n        description: \"At least one listing URL (Vrbo or Airbnb) is required.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    return true;\n  };\n\n  const submitProperty = async (formData: PropertyFormData, isOnline: boolean) => {\n    console.log('ðŸš€ Starting property submission...', { isEditing, formData });\n    \n    if (!validateSubmission(formData, isOnline)) {\n      return false;\n    }\n\n    setIsLoading(true);\n\n    try {\n      const submitData = {\n        name: formData.name.trim(),\n        address: formData.address.trim(),\n        vrbo_url: formData.vrbo_url.trim() || null,\n        airbnb_url: formData.airbnb_url.trim() || null,\n      };\n\n      console.log('ðŸ“ Submitting data:', submitData);\n\n      let result;\n      if (isEditing) {\n        result = await supabase\n          .from('properties')\n          .update({\n            ...submitData,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', editId)\n          .select()\n          .single();\n      } else {\n        result = await supabase\n          .from('properties')\n          .insert({\n            ...submitData,\n            added_by: user.id,\n            created_at: new Date().toISOString()\n          })\n          .select()\n          .single();\n      }\n\n      const { data, error } = result;\n\n      if (error) {\n        console.error('âŒ Database error:', error);\n        \n        let errorMessage = \"An error occurred while saving the property.\";\n        \n        if (error.code === '23505') {\n          if (error.message?.includes('properties_name')) {\n            errorMessage = \"A property with this name already exists.\";\n          } else if (error.message?.includes('vrbo_url')) {\n            errorMessage = \"This Vrbo URL is already registered.\";\n          } else if (error.message?.includes('airbnb_url')) {\n            errorMessage = \"This Airbnb URL is already registered.\";\n          }\n        } else if (error.code === '42501' || error.message?.includes('JWT')) {\n          errorMessage = \"Your session has expired. Please log in again.\";\n        } else if (error.message?.includes('violates row-level security')) {\n          errorMessage = \"You don't have permission to perform this action.\";\n        }\n\n        toast({\n          title: `Error ${isEditing ? 'Updating' : 'Creating'} Property`,\n          description: errorMessage,\n          variant: \"destructive\",\n        });\n        return false;\n      }\n\n      console.log('âœ… Property saved successfully:', data);\n\n      toast({\n        title: `Property ${isEditing ? 'Updated' : 'Added'}`,\n        description: `The property \"${formData.name.trim()}\" has been ${isEditing ? 'updated' : 'added'} successfully.`,\n      });\n\n      setTimeout(() => {\n        navigate('/properties');\n      }, 500);\n\n      return true;\n    } catch (error) {\n      console.error('ðŸ’¥ Unexpected error:', error);\n      \n      toast({\n        title: \"Unexpected Error\",\n        description: \"An unexpected error occurred. Please try again or contact support if the problem persists.\",\n        variant: \"destructive\",\n      });\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return {\n    isLoading,\n    submitProperty,\n    isEditing\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useRobustInspectionCreation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useRobustMobileInspectionFlow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useRobustPropertyActions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[751,754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[751,754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { supabase } from \"@/integrations/supabase/client\";\n\ninterface PropertyActionError {\n  type: 'network' | 'validation' | 'auth' | 'system';\n  message: string;\n  action: string;\n  retryable: boolean;\n}\n\ninterface PropertyActionState {\n  isLoading: boolean;\n  error: PropertyActionError | null;\n  retryCount: number;\n}\n\nexport const useRobustPropertyActions = () => {\n  const [actionState, setActionState] = useState<PropertyActionState>({\n    isLoading: false,\n    error: null,\n    retryCount: 0\n  });\n  \n  const { toast } = useToast();\n  const navigate = useNavigate();\n\n  const classifyError = (error: any, action: string): PropertyActionError => {\n    const errorMessage = error?.message || 'Unknown error occurred';\n    \n    if (errorMessage.includes('network') || errorMessage.includes('fetch')) {\n      return {\n        type: 'network',\n        message: 'Network connection failed. Please check your internet.',\n        action,\n        retryable: true\n      };\n    }\n    \n    if (errorMessage.includes('unauthorized') || errorMessage.includes('forbidden')) {\n      return {\n        type: 'auth',\n        message: 'You don\\'t have permission to perform this action.',\n        action,\n        retryable: false\n      };\n    }\n    \n    if (errorMessage.includes('validation') || errorMessage.includes('invalid')) {\n      return {\n        type: 'validation',\n        message: 'The data provided is invalid. Please check and try again.',\n        action,\n        retryable: false\n      };\n    }\n    \n    return {\n      type: 'system',\n      message: errorMessage,\n      action,\n      retryable: true\n    };\n  };\n\n  const executeWithRetry = useCallback(async <T>(\n    operation: () => Promise<T>,\n    actionName: string,\n    maxRetries = 3\n  ): Promise<T | null> => {\n    setActionState(prev => ({ ...prev, isLoading: true, error: null }));\n    \n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const result = await operation();\n        \n        setActionState({\n          isLoading: false,\n          error: null,\n          retryCount: 0\n        });\n        \n        return result;\n      } catch (error) {\n        console.error(`âŒ ${actionName} attempt ${attempt + 1} failed:`, error);\n        \n        const classifiedError = classifyError(error, actionName);\n        \n        if (attempt === maxRetries || !classifiedError.retryable) {\n          setActionState({\n            isLoading: false,\n            error: classifiedError,\n            retryCount: attempt + 1\n          });\n          \n          toast({\n            title: `${actionName} Failed`,\n            description: classifiedError.message,\n            variant: \"destructive\",\n          });\n          \n          return null;\n        }\n        \n        setActionState(prev => ({ ...prev, retryCount: attempt + 1 }));\n        \n        // Wait before retry (exponential backoff)\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n      }\n    }\n    \n    return null;\n  }, [toast]);\n\n  const deleteProperty = useCallback(async (propertyId: string) => {\n    console.log('ðŸ—‘ï¸ Starting comprehensive property deletion:', propertyId);\n    \n    return executeWithRetry(async () => {\n      // First, delete all related inspections and their data\n      const { data: inspections, error: fetchError } = await supabase\n        .from('inspections')\n        .select('id')\n        .eq('property_id', propertyId);\n      \n      if (fetchError) throw fetchError;\n      \n      if (inspections && inspections.length > 0) {\n        const inspectionIds = inspections.map(i => i.id);\n        \n        // Delete checklist items for all inspections\n        const { error: checklistError } = await supabase\n          .from('checklist_items')\n          .delete()\n          .in('inspection_id', inspectionIds);\n        \n        if (checklistError) throw checklistError;\n        \n        // Delete media for all inspections\n        const { error: mediaError } = await supabase\n          .from('media')\n          .delete()\n          .in('checklist_item_id', \n            await supabase\n              .from('checklist_items')\n              .select('id')\n              .in('inspection_id', inspectionIds)\n              .then(res => res.data?.map(item => item.id) || [])\n          );\n        \n        // Delete inspections\n        const { error: inspectionError } = await supabase\n          .from('inspections')\n          .delete()\n          .eq('property_id', propertyId);\n        \n        if (inspectionError) throw inspectionError;\n      }\n      \n      // Finally, delete the property\n      const { error: propertyError } = await supabase\n        .from('properties')\n        .delete()\n        .eq('id', propertyId);\n      \n      if (propertyError) throw propertyError;\n      \n      toast({\n        title: \"Property Deleted\",\n        description: \"The property and all associated data have been permanently removed.\",\n      });\n      \n      return true;\n    }, 'Delete Property');\n  }, [executeWithRetry, toast]);\n\n  const editProperty = useCallback((propertyId: string) => {\n    try {\n      console.log('ðŸ”§ Navigating to edit property:', propertyId);\n      navigate(`/add-property?edit=${propertyId}`);\n    } catch (error) {\n      console.error('âŒ Navigation error:', error);\n      toast({\n        title: \"Navigation Failed\",\n        description: \"Could not navigate to edit page. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  }, [navigate, toast]);\n\n  const startInspection = useCallback(async (propertyId: string) => {\n    console.log('ðŸš€ Starting inspection for property:', propertyId);\n    \n    return executeWithRetry(async () => {\n      // Check if there's already an active inspection\n      const { data: existingInspection, error: checkError } = await supabase\n        .from('inspections')\n        .select('id')\n        .eq('property_id', propertyId)\n        .eq('completed', false)\n        .single();\n      \n      if (checkError && checkError.code !== 'PGRST116') {\n        throw checkError;\n      }\n      \n      if (existingInspection) {\n        console.log('ðŸ“‹ Joining existing inspection:', existingInspection.id);\n        navigate(`/inspection/${existingInspection.id}`);\n        return existingInspection.id;\n      }\n      \n      // Create new inspection\n      const { data: newInspection, error: createError } = await supabase\n        .from('inspections')\n        .insert({\n          property_id: propertyId,\n          start_time: new Date().toISOString(),\n          completed: false\n        })\n        .select()\n        .single();\n      \n      if (createError) throw createError;\n      \n      console.log('âœ… Created new inspection:', newInspection.id);\n      navigate(`/inspection/${newInspection.id}`);\n      \n      toast({\n        title: \"Inspection Started\",\n        description: \"A new inspection has been created successfully.\",\n      });\n      \n      return newInspection.id;\n    }, 'Start Inspection');\n  }, [executeWithRetry, navigate, toast]);\n\n  const clearError = useCallback(() => {\n    setActionState(prev => ({ ...prev, error: null }));\n  }, []);\n\n  const retry = useCallback(() => {\n    if (actionState.error?.retryable) {\n      setActionState(prev => ({ ...prev, error: null, retryCount: 0 }));\n    }\n  }, [actionState.error]);\n\n  return {\n    deleteProperty,\n    editProperty,\n    startInspection,\n    actionState,\n    clearError,\n    retry\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useSimpleAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useSimplePropertySubmission.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[413,416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[413,416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState } from \"react\";\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { supabase } from \"@/integrations/supabase/client\";\nimport { useMobileAuth } from \"@/hooks/useMobileAuth\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\ninterface ExtendedPropertyFormData extends PropertyFormData {\n  scraped_vrbo_data?: any;\n}\n\nexport const useSimplePropertySubmission = () => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const editId = searchParams.get('edit');\n  const isEditing = !!editId;\n  const { toast } = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n  const { user, isAuthenticated } = useMobileAuth();\n\n  const validateForm = (formData: PropertyFormData): boolean => {\n    // Check authentication\n    if (!isAuthenticated || !user) {\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please log in to add or edit properties.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Validate form data\n    if (!formData.name || formData.name.trim().length < 2) {\n      toast({\n        title: \"Validation Error\",\n        description: \"Property name must be at least 2 characters long.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    if (!formData.address || formData.address.trim().length < 5) {\n      toast({\n        title: \"Validation Error\",\n        description: \"Please provide a complete address.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Check that at least one URL is provided\n    const hasVrbo = formData.vrbo_url && formData.vrbo_url.trim();\n    const hasAirbnb = formData.airbnb_url && formData.airbnb_url.trim();\n    \n    if (!hasVrbo && !hasAirbnb) {\n      toast({\n        title: \"Validation Error\",\n        description: \"At least one listing URL (Vrbo or Airbnb) is required.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    return true;\n  };\n\n  const submitProperty = async (formData: ExtendedPropertyFormData) => {\n    console.log('ðŸš€ Starting simple property submission...', { isEditing, formData });\n    \n    if (!validateForm(formData)) {\n      return false;\n    }\n\n    setIsLoading(true);\n\n    try {\n      const submitData = {\n        name: formData.name.trim(),\n        address: formData.address.trim(),\n        vrbo_url: formData.vrbo_url.trim() || null,\n        airbnb_url: formData.airbnb_url.trim() || null,\n        scraped_data: formData.scraped_vrbo_data || null,\n      };\n\n      console.log('ðŸ“ Submitting data:', submitData);\n\n      let result;\n      if (isEditing) {\n        result = await supabase\n          .from('properties')\n          .update({\n            ...submitData,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', editId)\n          .select()\n          .single();\n      } else {\n        result = await supabase\n          .from('properties')\n          .insert({\n            ...submitData,\n            added_by: user.id,\n            created_at: new Date().toISOString()\n          })\n          .select()\n          .single();\n      }\n\n      const { data, error } = result;\n\n      if (error) {\n        console.error('âŒ Database error:', error);\n        \n        let errorMessage = \"An error occurred while saving the property.\";\n        \n        if (error.code === '23505') {\n          if (error.message?.includes('properties_name')) {\n            errorMessage = \"A property with this name already exists.\";\n          } else if (error.message?.includes('vrbo_url')) {\n            errorMessage = \"This Vrbo URL is already registered.\";\n          } else if (error.message?.includes('airbnb_url')) {\n            errorMessage = \"This Airbnb URL is already registered.\";\n          }\n        } else if (error.code === '42501' || error.message?.includes('JWT')) {\n          errorMessage = \"Your session has expired. Please log in again.\";\n        } else if (error.message?.includes('violates row-level security')) {\n          errorMessage = \"You don't have permission to perform this action.\";\n        }\n\n        toast({\n          title: `Error ${isEditing ? 'Updating' : 'Creating'} Property`,\n          description: errorMessage,\n          variant: \"destructive\",\n        });\n        return false;\n      }\n\n      console.log('âœ… Property saved successfully:', data);\n\n      toast({\n        title: `Property ${isEditing ? 'Updated' : 'Added'}`,\n        description: `The property \"${formData.name.trim()}\" has been ${isEditing ? 'updated' : 'added'} successfully.`,\n      });\n\n      setTimeout(() => {\n        navigate('/properties');\n      }, 500);\n\n      return true;\n    } catch (error) {\n      console.error('ðŸ’¥ Unexpected error:', error);\n      \n      toast({\n        title: \"Unexpected Error\",\n        description: \"An unexpected error occurred. Please try again or contact support if the problem persists.\",\n        variant: \"destructive\",\n      });\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return {\n    isLoading,\n    submitProperty,\n    isEditing\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useSimplePropertyValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1867,1870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1867,1870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useToast } from \"@/hooks/use-toast\";\nimport type { PropertyFormData } from \"@/types/propertySubmission\";\n\nexport const useSimplePropertyValidation = () => {\n  const { toast } = useToast();\n\n  const isValidUrl = (url: string): boolean => {\n    try {\n      new URL(url);\n      return url.startsWith('http://') || url.startsWith('https://');\n    } catch {\n      return false;\n    }\n  };\n\n  const validateFormData = (formData: PropertyFormData) => {\n    const errors: string[] = [];\n\n    // Name validation\n    if (!formData.name || formData.name.trim().length === 0) {\n      errors.push(\"Property name is required\");\n    } else if (formData.name.trim().length < 2) {\n      errors.push(\"Property name must be at least 2 characters long\");\n    }\n\n    // Address validation\n    if (!formData.address || formData.address.trim().length === 0) {\n      errors.push(\"Property address is required\");\n    } else if (formData.address.trim().length < 5) {\n      errors.push(\"Address must be at least 5 characters long\");\n    }\n\n    // URL validation (optional but if provided must be valid)\n    if (formData.vrbo_url && formData.vrbo_url.trim()) {\n      if (!isValidUrl(formData.vrbo_url.trim())) {\n        errors.push(\"Vrbo URL must be a valid URL\");\n      }\n    }\n\n    if (formData.airbnb_url && formData.airbnb_url.trim()) {\n      if (!isValidUrl(formData.airbnb_url.trim())) {\n        errors.push(\"Airbnb URL must be a valid URL\");\n      }\n    }\n\n    // At least one URL should be provided\n    const hasVrbo = formData.vrbo_url && formData.vrbo_url.trim();\n    const hasAirbnb = formData.airbnb_url && formData.airbnb_url.trim();\n    \n    if (!hasVrbo && !hasAirbnb) {\n      errors.push(\"At least one listing URL (Vrbo or Airbnb) is required\");\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  };\n\n  const validateSubmission = (\n    user: any,\n    isOnline: boolean,\n    formData: PropertyFormData\n  ): boolean => {\n    console.log('ðŸ” Starting validation...', {\n      hasUser: !!user,\n      isOnline,\n      formDataValid: !!formData.name && !!formData.address\n    });\n\n    // Authentication check\n    if (!user) {\n      console.error('âŒ Validation failed: No authenticated user');\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please log in to add or edit properties.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Network check\n    if (!isOnline) {\n      console.error('âŒ Validation failed: No network connection');\n      toast({\n        title: \"Network Error\",\n        description: \"Please check your internet connection and try again.\",\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    // Form data validation\n    const validation = validateFormData(formData);\n    if (!validation.isValid) {\n      console.error('âŒ Validation failed: Form errors', validation.errors);\n      toast({\n        title: \"Validation Error\",\n        description: validation.errors[0], // Show first error\n        variant: \"destructive\",\n      });\n      return false;\n    }\n\n    console.log('âœ… All validation checks passed');\n    return true;\n  };\n\n  return { \n    validateSubmission,\n    validateFormData \n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useSimplifiedInspectionData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useSmartCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useVideoRecording.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'stopRecording'. Either include it or remove the dependency array.","line":221,"column":6,"nodeType":"ArrayExpression","endLine":221,"endColumn":98,"suggestions":[{"desc":"Update the dependencies array to be: [hasPermission, stream, maxDuration, audioEnabled, updateStatus, onStats, requestPermission, stopRecording]","fix":{"range":[6380,6472],"text":"[hasPermission, stream, maxDuration, audioEnabled, updateStatus, onStats, requestPermission, stopRecording]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'videoProcessorRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'videoProcessorRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":368,"column":27,"nodeType":"Identifier","endLine":368,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Recording Hook for STR Certified\n\nimport { useState, useCallback, useRef, useEffect, MutableRefObject } from 'react';\nimport { useMutation } from '@tanstack/react-query';\nimport { createVideoProcessor } from '@/lib/video/video-processor';\nimport type {\n  VideoRecording,\n  VideoStatus,\n  VideoRecordingConfig,\n  VideoRecordingStats,\n  VideoTimestamp\n} from '@/types/video';\n\nexport interface UseVideoRecordingOptions {\n  videoRef?: MutableRefObject<HTMLVideoElement | null>;\n  maxDuration?: number;\n  audioEnabled?: boolean;\n  onStats?: (stats: VideoRecordingStats) => void;\n  onStatusChange?: (status: VideoStatus) => void;\n  autoSave?: boolean;\n  compressionEnabled?: boolean;\n}\n\nexport interface UseVideoRecordingReturn {\n  // State\n  status: VideoStatus;\n  stream: MediaStream | null;\n  recording: VideoRecording | null;\n  isRecording: boolean;\n  isPaused: boolean;\n  duration: number;\n  error: Error | null;\n  \n  // Controls\n  startRecording: (propertyId: string, inspectorId: string) => Promise<void>;\n  pauseRecording: () => void;\n  resumeRecording: () => void;\n  stopRecording: () => Promise<VideoRecording | null>;\n  cancelRecording: () => void;\n  \n  // Permissions\n  hasPermission: boolean;\n  requestPermission: () => Promise<void>;\n  \n  // Processing\n  isProcessing: boolean;\n  processingProgress: number;\n  timestamps: VideoTimestamp[];\n}\n\nexport const useVideoRecording = (\n  options: UseVideoRecordingOptions = {}\n): UseVideoRecordingReturn => {\n  const {\n    videoRef,\n    maxDuration = 600, // 10 minutes default\n    audioEnabled = true,\n    onStats,\n    onStatusChange,\n    autoSave = true,\n    compressionEnabled = true\n  } = options;\n\n  // State\n  const [status, setStatus] = useState<VideoStatus>('stopped');\n  const [stream, setStream] = useState<MediaStream | null>(null);\n  const [recording, setRecording] = useState<VideoRecording | null>(null);\n  const [duration, setDuration] = useState(0);\n  const [hasPermission, setHasPermission] = useState(false);\n  const [processingProgress, setProcessingProgress] = useState(0);\n  const [timestamps, setTimestamps] = useState<VideoTimestamp[]>([]);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Refs\n  const videoProcessorRef = useRef(createVideoProcessor());\n  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const startTimeRef = useRef<number>(0);\n  const pausedDurationRef = useRef<number>(0);\n  const lastPauseTimeRef = useRef<number>(0);\n  const currentPropertyIdRef = useRef<string>('');\n  const currentInspectorIdRef = useRef<string>('');\n\n  // Derived state\n  const isRecording = status === 'recording';\n  const isPaused = status === 'paused';\n  const isProcessing = status === 'processing' || status === 'analyzing';\n\n  // Update status and notify\n  const updateStatus = useCallback((newStatus: VideoStatus) => {\n    setStatus(newStatus);\n    onStatusChange?.(newStatus);\n  }, [onStatusChange]);\n\n  // Check camera permission\n  const checkPermission = useCallback(async (): Promise<boolean> => {\n    try {\n      // Check if we already have a stream\n      if (stream) {\n        setHasPermission(true);\n        return true;\n      }\n\n      // Try to check permission without triggering prompt\n      if (navigator.permissions && navigator.permissions.query) {\n        try {\n          const result = await navigator.permissions.query({ name: 'camera' as PermissionName });\n          const granted = result.state === 'granted';\n          setHasPermission(granted);\n          return granted;\n        } catch {\n          // Permissions API not supported\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }, [stream]);\n\n  // Request camera permission\n  const requestPermission = useCallback(async (): Promise<void> => {\n    try {\n      const constraints: MediaStreamConstraints = {\n        video: {\n          width: { ideal: 1920 },\n          height: { ideal: 1080 },\n          facingMode: 'environment'\n        },\n        audio: audioEnabled\n      };\n\n      const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n      setStream(mediaStream);\n      setHasPermission(true);\n      setError(null);\n\n      // Attach to video element if provided\n      if (videoRef?.current) {\n        videoRef.current.srcObject = mediaStream;\n      }\n    } catch (err) {\n      const error = err as Error;\n      setError(error);\n      setHasPermission(false);\n      throw error;\n    }\n  }, [audioEnabled, videoRef]);\n\n  // Start recording\n  const startRecording = useCallback(async (\n    propertyId: string,\n    inspectorId: string\n  ): Promise<void> => {\n    try {\n      setError(null);\n      \n      // Ensure we have permission\n      if (!hasPermission) {\n        await requestPermission();\n      }\n\n      if (!stream) {\n        throw new Error('No media stream available');\n      }\n\n      // Store IDs\n      currentPropertyIdRef.current = propertyId;\n      currentInspectorIdRef.current = inspectorId;\n\n      // Reset timing\n      startTimeRef.current = Date.now();\n      pausedDurationRef.current = 0;\n      setDuration(0);\n\n      // Start duration tracking\n      durationIntervalRef.current = setInterval(() => {\n        const elapsed = Date.now() - startTimeRef.current - pausedDurationRef.current;\n        const seconds = Math.floor(elapsed / 1000);\n        setDuration(seconds);\n\n        // Auto-stop at max duration\n        if (seconds >= maxDuration) {\n          stopRecording();\n        }\n      }, 100);\n\n      // Configure recording\n      const recordingConfig: VideoRecordingConfig = {\n        maxDuration,\n        targetResolution: { width: 1920, height: 1080, aspectRatio: '16:9' },\n        targetBitrate: 2500,\n        audioEnabled,\n        stabilizationEnabled: true,\n        autoFocusEnabled: true,\n        lowLightEnhancement: true\n      };\n\n      // Start recording\n      updateStatus('recording');\n      \n      const processor = videoProcessorRef.current;\n      const videoRecording = await processor.recordWalkthrough(\n        stream,\n        recordingConfig,\n        onStats\n      );\n\n      // Update with property and inspector IDs\n      videoRecording.propertyId = propertyId;\n      videoRecording.inspectorId = inspectorId;\n      \n      setRecording(videoRecording);\n      \n    } catch (err) {\n      const error = err as Error;\n      setError(error);\n      updateStatus('failed');\n      throw error;\n    }\n  }, [hasPermission, stream, maxDuration, audioEnabled, onStats, requestPermission, updateStatus]);\n\n  // Pause recording\n  const pauseRecording = useCallback(() => {\n    if (status === 'recording') {\n      lastPauseTimeRef.current = Date.now();\n      videoProcessorRef.current.pauseRecording();\n      updateStatus('paused');\n    }\n  }, [status, updateStatus]);\n\n  // Resume recording\n  const resumeRecording = useCallback(() => {\n    if (status === 'paused') {\n      pausedDurationRef.current += Date.now() - lastPauseTimeRef.current;\n      videoProcessorRef.current.resumeRecording();\n      updateStatus('recording');\n    }\n  }, [status, updateStatus]);\n\n  // Stop recording\n  const stopRecording = useCallback(async (): Promise<VideoRecording | null> => {\n    try {\n      // Clear duration interval\n      if (durationIntervalRef.current) {\n        clearInterval(durationIntervalRef.current);\n        durationIntervalRef.current = null;\n      }\n\n      // Stop recording\n      videoProcessorRef.current.stopRecording();\n      updateStatus('processing');\n\n      if (!recording) {\n        throw new Error('No recording available');\n      }\n\n      // Process video frames\n      setProcessingProgress(20);\n      const extractedTimestamps = await videoProcessorRef.current.processVideoFrames(\n        recording.file\n      );\n      \n      setProcessingProgress(60);\n      \n      // Analyze video content\n      const analysis = await videoProcessorRef.current.analyzeVideoContent(\n        recording.file,\n        extractedTimestamps\n      );\n      \n      setProcessingProgress(80);\n      \n      // Generate navigation timestamps\n      const navigationTimestamps = videoProcessorRef.current.generateTimestamps(analysis);\n      \n      // Update recording with analysis\n      const finalRecording: VideoRecording = {\n        ...recording,\n        timestamps: navigationTimestamps,\n        status: 'completed',\n        processedAt: new Date()\n      };\n      \n      setRecording(finalRecording);\n      setTimestamps(navigationTimestamps);\n      setProcessingProgress(100);\n      \n      // Save if auto-save enabled\n      if (autoSave) {\n        await saveRecording(finalRecording);\n      }\n      \n      updateStatus('completed');\n      return finalRecording;\n      \n    } catch (err) {\n      const error = err as Error;\n      setError(error);\n      updateStatus('failed');\n      return null;\n    } finally {\n      setProcessingProgress(0);\n    }\n  }, [recording, autoSave, updateStatus]);\n\n  // Cancel recording\n  const cancelRecording = useCallback(() => {\n    // Clear duration interval\n    if (durationIntervalRef.current) {\n      clearInterval(durationIntervalRef.current);\n      durationIntervalRef.current = null;\n    }\n\n    // Stop processor\n    videoProcessorRef.current.stopRecording();\n    \n    // Reset state\n    setRecording(null);\n    setDuration(0);\n    setTimestamps([]);\n    updateStatus('stopped');\n  }, [updateStatus]);\n\n  // Save recording to storage\n  const saveRecording = async (recording: VideoRecording): Promise<void> => {\n    try {\n      // In production, this would upload to cloud storage\n      // For now, we'll save to IndexedDB or localStorage\n      const savedRecordings = JSON.parse(\n        localStorage.getItem('video_recordings') || '[]'\n      );\n      \n      // Save metadata only (not the actual file)\n      const metadata = {\n        id: recording.id,\n        propertyId: recording.propertyId,\n        inspectorId: recording.inspectorId,\n        duration: recording.duration,\n        size: recording.size,\n        createdAt: recording.createdAt,\n        timestamps: recording.timestamps.length\n      };\n      \n      savedRecordings.push(metadata);\n      localStorage.setItem('video_recordings', JSON.stringify(savedRecordings));\n      \n    } catch (error) {\n      console.error('Failed to save recording:', error);\n    }\n  };\n\n  // Initialize permission check\n  useEffect(() => {\n    checkPermission();\n  }, [checkPermission]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Clear intervals\n      if (durationIntervalRef.current) {\n        clearInterval(durationIntervalRef.current);\n      }\n      \n      // Stop any active recording\n      if (status === 'recording' || status === 'paused') {\n        videoProcessorRef.current.stopRecording();\n      }\n      \n      // Stop media stream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [status, stream]);\n\n  return {\n    // State\n    status,\n    stream,\n    recording,\n    isRecording,\n    isPaused,\n    duration,\n    error,\n    \n    // Controls\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    cancelRecording,\n    \n    // Permissions\n    hasPermission,\n    requestPermission,\n    \n    // Processing\n    isProcessing,\n    processingProgress,\n    timestamps\n  };\n};\n\n// Hook for managing multiple video recordings\nexport const useVideoRecordingManager = () => {\n  const [recordings, setRecordings] = useState<VideoRecording[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load saved recordings\n  useEffect(() => {\n    const loadRecordings = async () => {\n      try {\n        const saved = localStorage.getItem('video_recordings');\n        if (saved) {\n          setRecordings(JSON.parse(saved));\n        }\n      } catch (error) {\n        console.error('Failed to load recordings:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadRecordings();\n  }, []);\n\n  // Delete recording\n  const deleteRecording = useCallback((id: string) => {\n    setRecordings(prev => {\n      const updated = prev.filter(r => r.id !== id);\n      localStorage.setItem('video_recordings', JSON.stringify(updated));\n      return updated;\n    });\n  }, []);\n\n  // Get recordings for property\n  const getPropertyRecordings = useCallback((propertyId: string) => {\n    return recordings.filter(r => r.propertyId === propertyId);\n  }, [recordings]);\n\n  return {\n    recordings,\n    isLoading,\n    deleteRecording,\n    getPropertyRecordings\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/hooks/useVideoReview.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'markAsReviewed'. Either include it or remove the dependency array.","line":185,"column":6,"nodeType":"ArrayExpression","endLine":185,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [videoRef, isPlaying, markAsReviewed]","fix":{"range":[6355,6376],"text":"[videoRef, isPlaying, markAsReviewed]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Review Hook for STR Certified Auditor Interface\n\nimport { useState, useEffect, useCallback, useRef, MutableRefObject } from 'react';\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport type { VideoRecording, VideoTimestamp, SceneType } from '@/types/video';\nimport type { VideoAnnotation } from '@/components/audit/VideoAnnotationTools';\n\nexport interface VideoBookmark {\n  id: string;\n  time: number;\n  description: string;\n  createdAt: Date;\n}\n\nexport interface UseVideoReviewReturn {\n  // Playback state\n  isPlaying: boolean;\n  currentTime: number;\n  duration: number;\n  buffered: number;\n  volume: number;\n  playbackRate: number;\n  \n  // Scene information\n  currentScene: VideoTimestamp | null;\n  nearestTimestamp: VideoTimestamp | null;\n  activeScenes: VideoTimestamp[];\n  \n  // Controls\n  play: () => void;\n  pause: () => void;\n  seek: (time: number) => void;\n  setVolume: (volume: number) => void;\n  setPlaybackRate: (rate: number) => void;\n  \n  // Navigation\n  jumpToTimestamp: (timestamp: VideoTimestamp) => void;\n  jumpToNextScene: () => void;\n  jumpToPreviousScene: () => void;\n  jumpToRoom: (roomType: string) => void;\n  \n  // Bookmarks\n  bookmarks: VideoBookmark[];\n  addBookmark: (time: number, description: string) => void;\n  removeBookmark: (id: string) => void;\n  isBookmarked: (time: number) => boolean;\n  \n  // Annotations\n  annotations: VideoAnnotation[];\n  addAnnotation: (annotation: Omit<VideoAnnotation, 'id' | 'createdAt'>) => void;\n  updateAnnotation: (id: string, annotation: Partial<VideoAnnotation>) => void;\n  deleteAnnotation: (id: string) => void;\n  \n  // Review progress\n  reviewProgress: number;\n  markAsReviewed: (startTime: number, endTime: number) => void;\n  isReviewed: (time: number) => boolean;\n  reviewedSegments: Array<{ start: number; end: number }>;\n}\n\nexport const useVideoReview = (\n  video: VideoRecording,\n  videoRef: MutableRefObject<HTMLVideoElement | null>\n): UseVideoReviewReturn => {\n  // Playback state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(video.duration);\n  const [buffered, setBuffered] = useState(0);\n  const [volume, setVolume] = useState(1);\n  const [playbackRate, setPlaybackRate] = useState(1);\n\n  // Scene state\n  const [currentScene, setCurrentScene] = useState<VideoTimestamp | null>(null);\n  const [nearestTimestamp, setNearestTimestamp] = useState<VideoTimestamp | null>(null);\n\n  // Bookmarks and annotations\n  const [bookmarks, setBookmarks] = useState<VideoBookmark[]>([]);\n  const [annotations, setAnnotations] = useState<VideoAnnotation[]>([]);\n  \n  // Review progress\n  const [reviewedSegments, setReviewedSegments] = useState<Array<{ start: number; end: number }>>([]);\n  const progressTrackingRef = useRef<{ start: number; accumulated: number }>({ start: 0, accumulated: 0 });\n\n  // Load saved data\n  useEffect(() => {\n    // Load bookmarks\n    const savedBookmarks = localStorage.getItem(`video_bookmarks_${video.id}`);\n    if (savedBookmarks) {\n      setBookmarks(JSON.parse(savedBookmarks));\n    }\n\n    // Load annotations\n    const savedAnnotations = localStorage.getItem(`video_annotations_${video.id}`);\n    if (savedAnnotations) {\n      setAnnotations(JSON.parse(savedAnnotations));\n    }\n\n    // Load review progress\n    const savedProgress = localStorage.getItem(`video_progress_${video.id}`);\n    if (savedProgress) {\n      setReviewedSegments(JSON.parse(savedProgress));\n    }\n  }, [video.id]);\n\n  // Save data on changes\n  useEffect(() => {\n    localStorage.setItem(`video_bookmarks_${video.id}`, JSON.stringify(bookmarks));\n  }, [bookmarks, video.id]);\n\n  useEffect(() => {\n    localStorage.setItem(`video_annotations_${video.id}`, JSON.stringify(annotations));\n  }, [annotations, video.id]);\n\n  useEffect(() => {\n    localStorage.setItem(`video_progress_${video.id}`, JSON.stringify(reviewedSegments));\n  }, [reviewedSegments, video.id]);\n\n  // Video event handlers\n  useEffect(() => {\n    const videoElement = videoRef.current;\n    if (!videoElement) return;\n\n    const handleTimeUpdate = () => {\n      setCurrentTime(videoElement.currentTime);\n      \n      // Update buffered amount\n      if (videoElement.buffered.length > 0) {\n        const bufferedEnd = videoElement.buffered.end(videoElement.buffered.length - 1);\n        setBuffered(bufferedEnd);\n      }\n\n      // Track review progress\n      if (isPlaying) {\n        progressTrackingRef.current.accumulated += \n          videoElement.currentTime - progressTrackingRef.current.start;\n        progressTrackingRef.current.start = videoElement.currentTime;\n      }\n    };\n\n    const handlePlay = () => {\n      setIsPlaying(true);\n      progressTrackingRef.current.start = videoElement.currentTime;\n    };\n\n    const handlePause = () => {\n      setIsPlaying(false);\n      // Mark segment as reviewed\n      if (progressTrackingRef.current.accumulated > 2) { // At least 2 seconds\n        const start = Math.max(0, videoElement.currentTime - progressTrackingRef.current.accumulated);\n        const end = videoElement.currentTime;\n        markAsReviewed(start, end);\n      }\n      progressTrackingRef.current.accumulated = 0;\n    };\n\n    const handleLoadedMetadata = () => {\n      setDuration(videoElement.duration);\n    };\n\n    const handleVolumeChange = () => {\n      setVolume(videoElement.volume);\n    };\n\n    const handleRateChange = () => {\n      setPlaybackRate(videoElement.playbackRate);\n    };\n\n    // Add event listeners\n    videoElement.addEventListener('timeupdate', handleTimeUpdate);\n    videoElement.addEventListener('play', handlePlay);\n    videoElement.addEventListener('pause', handlePause);\n    videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);\n    videoElement.addEventListener('volumechange', handleVolumeChange);\n    videoElement.addEventListener('ratechange', handleRateChange);\n\n    return () => {\n      videoElement.removeEventListener('timeupdate', handleTimeUpdate);\n      videoElement.removeEventListener('play', handlePlay);\n      videoElement.removeEventListener('pause', handlePause);\n      videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      videoElement.removeEventListener('volumechange', handleVolumeChange);\n      videoElement.removeEventListener('ratechange', handleRateChange);\n    };\n  }, [videoRef, isPlaying]);\n\n  // Update current scene based on time\n  useEffect(() => {\n    const scene = video.timestamps.find(\n      ts => currentTime >= ts.time && \n            currentTime < (video.timestamps[video.timestamps.indexOf(ts) + 1]?.time || duration)\n    );\n    setCurrentScene(scene || null);\n\n    // Find nearest timestamp\n    let nearest = video.timestamps[0];\n    let minDiff = Math.abs(video.timestamps[0].time - currentTime);\n    \n    for (const ts of video.timestamps) {\n      const diff = Math.abs(ts.time - currentTime);\n      if (diff < minDiff) {\n        minDiff = diff;\n        nearest = ts;\n      }\n    }\n    \n    setNearestTimestamp(minDiff < 10 ? nearest : null); // Within 10 seconds\n  }, [currentTime, video.timestamps, duration]);\n\n  // Calculate active scenes (within view)\n  const activeScenes = video.timestamps.filter(\n    ts => Math.abs(ts.time - currentTime) < 30 // Within 30 seconds\n  );\n\n  // Playback controls\n  const play = useCallback(() => {\n    videoRef.current?.play();\n  }, [videoRef]);\n\n  const pause = useCallback(() => {\n    videoRef.current?.pause();\n  }, [videoRef]);\n\n  const seek = useCallback((time: number) => {\n    if (videoRef.current) {\n      videoRef.current.currentTime = Math.max(0, Math.min(time, duration));\n    }\n  }, [videoRef, duration]);\n\n  const updateVolume = useCallback((vol: number) => {\n    if (videoRef.current) {\n      videoRef.current.volume = Math.max(0, Math.min(1, vol));\n    }\n  }, [videoRef]);\n\n  const updatePlaybackRate = useCallback((rate: number) => {\n    if (videoRef.current) {\n      videoRef.current.playbackRate = rate;\n    }\n  }, [videoRef]);\n\n  // Navigation\n  const jumpToTimestamp = useCallback((timestamp: VideoTimestamp) => {\n    seek(timestamp.time);\n  }, [seek]);\n\n  const jumpToNextScene = useCallback(() => {\n    const nextScene = video.timestamps.find(ts => ts.time > currentTime);\n    if (nextScene) {\n      jumpToTimestamp(nextScene);\n    }\n  }, [currentTime, video.timestamps, jumpToTimestamp]);\n\n  const jumpToPreviousScene = useCallback(() => {\n    const previousScenes = video.timestamps.filter(ts => ts.time < currentTime - 1);\n    if (previousScenes.length > 0) {\n      jumpToTimestamp(previousScenes[previousScenes.length - 1]);\n    }\n  }, [currentTime, video.timestamps, jumpToTimestamp]);\n\n  const jumpToRoom = useCallback((roomType: string) => {\n    const roomScene = video.timestamps.find(ts => ts.roomDetected === roomType);\n    if (roomScene) {\n      jumpToTimestamp(roomScene);\n    }\n  }, [video.timestamps, jumpToTimestamp]);\n\n  // Bookmarks\n  const addBookmark = useCallback((time: number, description: string) => {\n    const bookmark: VideoBookmark = {\n      id: `bookmark_${Date.now()}`,\n      time,\n      description,\n      createdAt: new Date()\n    };\n    setBookmarks(prev => [...prev, bookmark].sort((a, b) => a.time - b.time));\n  }, []);\n\n  const removeBookmark = useCallback((id: string) => {\n    setBookmarks(prev => prev.filter(b => b.id !== id));\n  }, []);\n\n  const isBookmarked = useCallback((time: number): boolean => {\n    return bookmarks.some(b => Math.abs(b.time - time) < 1);\n  }, [bookmarks]);\n\n  // Annotations\n  const addAnnotation = useCallback((annotation: Omit<VideoAnnotation, 'id' | 'createdAt'>) => {\n    const newAnnotation: VideoAnnotation = {\n      ...annotation,\n      id: `annotation_${Date.now()}`,\n      createdAt: new Date()\n    };\n    setAnnotations(prev => [...prev, newAnnotation].sort((a, b) => a.timestamp - b.timestamp));\n  }, []);\n\n  const updateAnnotation = useCallback((id: string, updates: Partial<VideoAnnotation>) => {\n    setAnnotations(prev => prev.map(a => a.id === id ? { ...a, ...updates } : a));\n  }, []);\n\n  const deleteAnnotation = useCallback((id: string) => {\n    setAnnotations(prev => prev.filter(a => a.id !== id));\n  }, []);\n\n  // Review progress\n  const markAsReviewed = useCallback((startTime: number, endTime: number) => {\n    setReviewedSegments(prev => {\n      // Merge overlapping segments\n      const newSegment = { start: startTime, end: endTime };\n      const merged = [...prev, newSegment].sort((a, b) => a.start - b.start);\n      \n      const result: typeof prev = [];\n      for (const segment of merged) {\n        if (result.length === 0) {\n          result.push(segment);\n        } else {\n          const last = result[result.length - 1];\n          if (segment.start <= last.end) {\n            // Merge segments\n            last.end = Math.max(last.end, segment.end);\n          } else {\n            result.push(segment);\n          }\n        }\n      }\n      \n      return result;\n    });\n  }, []);\n\n  const isReviewed = useCallback((time: number): boolean => {\n    return reviewedSegments.some(seg => time >= seg.start && time <= seg.end);\n  }, [reviewedSegments]);\n\n  // Calculate review progress\n  const reviewProgress = (() => {\n    const totalReviewed = reviewedSegments.reduce(\n      (sum, seg) => sum + (seg.end - seg.start),\n      0\n    );\n    return Math.min(100, (totalReviewed / duration) * 100);\n  })();\n\n  return {\n    // Playback state\n    isPlaying,\n    currentTime,\n    duration,\n    buffered,\n    volume,\n    playbackRate,\n    \n    // Scene information\n    currentScene,\n    nearestTimestamp,\n    activeScenes,\n    \n    // Controls\n    play,\n    pause,\n    seek,\n    setVolume: updateVolume,\n    setPlaybackRate: updatePlaybackRate,\n    \n    // Navigation\n    jumpToTimestamp,\n    jumpToNextScene,\n    jumpToPreviousScene,\n    jumpToRoom,\n    \n    // Bookmarks\n    bookmarks,\n    addBookmark,\n    removeBookmark,\n    isBookmarked,\n    \n    // Annotations\n    annotations,\n    addAnnotation,\n    updateAnnotation,\n    deleteAnnotation,\n    \n    // Review progress\n    reviewProgress,\n    markAsReviewed,\n    isReviewed,\n    reviewedSegments\n  };\n};\n\n// Hook for managing video review sessions\nexport const useVideoReviewSession = (videoId: string, auditorId: string) => {\n  const [sessionId] = useState(`session_${Date.now()}`);\n  const [sessionStart] = useState(new Date());\n  const [sessionNotes, setSessionNotes] = useState('');\n\n  // Save session data\n  const saveSession = useCallback(async (\n    annotations: VideoAnnotation[],\n    reviewProgress: number,\n    reviewedSegments: Array<{ start: number; end: number }>\n  ) => {\n    const sessionData = {\n      id: sessionId,\n      videoId,\n      auditorId,\n      startTime: sessionStart,\n      endTime: new Date(),\n      annotations,\n      reviewProgress,\n      reviewedSegments,\n      notes: sessionNotes\n    };\n\n    // In production, this would save to database\n    localStorage.setItem(`review_session_${sessionId}`, JSON.stringify(sessionData));\n    \n    return sessionData;\n  }, [sessionId, videoId, auditorId, sessionStart, sessionNotes]);\n\n  // Load previous sessions\n  const loadSessions = useCallback(() => {\n    const sessions = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith('review_session_')) {\n        try {\n          const session = JSON.parse(localStorage.getItem(key) || '{}');\n          if (session.videoId === videoId) {\n            sessions.push(session);\n          }\n        } catch (error) {\n          console.error('Failed to load session:', error);\n        }\n      }\n    }\n    return sessions.sort((a, b) => \n      new Date(b.startTime).getTime() - new Date(a.startTime).getTime()\n    );\n  }, [videoId]);\n\n  return {\n    sessionId,\n    sessionStart,\n    sessionNotes,\n    setSessionNotes,\n    saveSession,\n    loadSessions\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/integrations/supabase/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/integrations/supabase/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/adr-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[890,893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[890,893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Architecture Decision Records (ADR) Manager for STR Certified\n// Integrates with AI decision logging system for comprehensive architectural documentation\n\nimport { aiDecisionLogger } from './decision-logger';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport { supabase } from '../supabase';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// ADR Types\nexport interface ADRRecord {\n  id: string;\n  number: number;\n  title: string;\n  status: ADRStatus;\n  context: string;\n  decision: string;\n  rationale: string;\n  consequences: ADRConsequences;\n  implementation: string;\n  alternatives_considered: string;\n  related_decisions: string[];\n  monitoring_and_review: string;\n  notes: string;\n  ai_agent_info: AIAgentInfo;\n  created_date: string;\n  last_modified: string;\n  file_path: string;\n  metadata: Record<string, any>;\n}\n\nexport type ADRStatus = 'proposed' | 'accepted' | 'rejected' | 'superseded';\n\nexport interface ADRConsequences {\n  positive: string[];\n  negative: string[];\n}\n\nexport interface AIAgentInfo {\n  created_by: string;\n  date: string;\n  session_id: string;\n  decision_logger_id?: string;\n  context_handoff_id?: string;\n}\n\nexport interface ADRQuery {\n  status?: ADRStatus;\n  ai_agent?: string;\n  date_range?: {\n    start: string;\n    end: string;\n  };\n  search_term?: string;\n  tags?: string[];\n  limit?: number;\n}\n\nexport interface ADRTemplate {\n  title: string;\n  context: string;\n  decision: string;\n  rationale: string;\n  positive_consequences: string[];\n  negative_consequences: string[];\n  implementation: string;\n  alternatives: string[];\n  related_decisions: string[];\n  monitoring: string;\n  notes: string;\n}\n\nexport class ADRManager {\n  private static instance: ADRManager;\n  private adrs: ADRRecord[] = [];\n  private adrDirectory: string;\n  private nextADRNumber: number = 1;\n\n  private constructor() {\n    this.adrDirectory = path.join(process.cwd(), 'ADR');\n    this.loadExistingADRs();\n  }\n\n  static getInstance(): ADRManager {\n    if (!ADRManager.instance) {\n      ADRManager.instance = new ADRManager();\n    }\n    return ADRManager.instance;\n  }\n\n  /**\n   * Create a new ADR from template\n   */\n  async createADR(template: ADRTemplate): Promise<string> {\n    const adrNumber = this.getNextADRNumber();\n    const adrId = this.generateADRId(adrNumber);\n    \n    const adr: ADRRecord = {\n      id: adrId,\n      number: adrNumber,\n      title: template.title,\n      status: 'proposed',\n      context: template.context,\n      decision: template.decision,\n      rationale: template.rationale,\n      consequences: {\n        positive: template.positive_consequences,\n        negative: template.negative_consequences\n      },\n      implementation: template.implementation,\n      alternatives_considered: template.alternatives.join('\\n'),\n      related_decisions: template.related_decisions,\n      monitoring_and_review: template.monitoring,\n      notes: template.notes,\n      ai_agent_info: {\n        created_by: this.getCurrentAIAgent(),\n        date: new Date().toISOString().split('T')[0],\n        session_id: this.getCurrentSessionId(),\n        decision_logger_id: undefined,\n        context_handoff_id: undefined\n      },\n      created_date: new Date().toISOString(),\n      last_modified: new Date().toISOString(),\n      file_path: this.generateADRFilePath(adrNumber, template.title),\n      metadata: {}\n    };\n\n    // Add to local cache\n    this.adrs.push(adr);\n    this.nextADRNumber = adrNumber + 1;\n\n    // Generate markdown content\n    const markdownContent = this.generateMarkdownContent(adr);\n    \n    try {\n      // Write to file\n      await this.writeADRFile(adr.file_path, markdownContent);\n      \n      // Log the ADR creation\n      const decisionId = await aiDecisionLogger.logSimpleDecision(\n        `Created ADR-${adrNumber.toString().padStart(4, '0')}: ${template.title}`,\n        'architectural_choice',\n        `Created Architecture Decision Record for: ${template.decision}`,\n        [adr.file_path],\n        'high'\n      );\n      \n      adr.ai_agent_info.decision_logger_id = decisionId;\n      \n      // Persist to database\n      await this.persistADR(adr);\n      \n      logger.info(`ADR created: ${adr.title}`, {\n        adr_id: adrId,\n        adr_number: adrNumber,\n        status: adr.status,\n        file_path: adr.file_path\n      }, 'ADR_CREATION');\n      \n      return adrId;\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'ADR_CREATION',\n        adr_id: adrId,\n        adr_number: adrNumber,\n        title: template.title\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Create a simple ADR with minimal input\n   */\n  async createSimpleADR(\n    title: string,\n    decision: string,\n    rationale: string,\n    context: string = 'Not specified'\n  ): Promise<string> {\n    return this.createADR({\n      title,\n      context,\n      decision,\n      rationale,\n      positive_consequences: ['Decision implemented'],\n      negative_consequences: ['No significant negative consequences identified'],\n      implementation: 'To be implemented',\n      alternatives: ['No alternatives considered'],\n      related_decisions: [],\n      monitoring: 'No specific monitoring planned',\n      notes: 'Simple ADR created during AI session'\n    });\n  }\n\n  /**\n   * Update ADR status\n   */\n  async updateADRStatus(adrId: string, newStatus: ADRStatus, notes?: string): Promise<void> {\n    const adr = this.adrs.find(a => a.id === adrId);\n    if (!adr) {\n      throw new Error(`ADR not found: ${adrId}`);\n    }\n\n    const oldStatus = adr.status;\n    adr.status = newStatus;\n    adr.last_modified = new Date().toISOString();\n    \n    if (notes) {\n      adr.notes += `\\n\\n**Status Change (${new Date().toISOString()})**: ${oldStatus} â†’ ${newStatus}\\n${notes}`;\n    }\n\n    // Regenerate markdown content\n    const markdownContent = this.generateMarkdownContent(adr);\n    \n    try {\n      await this.writeADRFile(adr.file_path, markdownContent);\n      await this.persistADR(adr);\n      \n      await aiDecisionLogger.logSimpleDecision(\n        `Updated ADR-${adr.number.toString().padStart(4, '0')} status: ${oldStatus} â†’ ${newStatus}`,\n        'architectural_choice',\n        `Status change for ADR \"${adr.title}\": ${notes || 'No additional notes'}`,\n        [adr.file_path],\n        'medium'\n      );\n      \n      logger.info(`ADR status updated: ${adr.title}`, {\n        adr_id: adrId,\n        old_status: oldStatus,\n        new_status: newStatus,\n        notes: notes\n      }, 'ADR_STATUS_UPDATE');\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'ADR_STATUS_UPDATE',\n        adr_id: adrId,\n        old_status: oldStatus,\n        new_status: newStatus\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Supersede an ADR with a new one\n   */\n  async supersedeADR(oldADRId: string, newADRTemplate: ADRTemplate): Promise<string> {\n    const oldADR = this.adrs.find(a => a.id === oldADRId);\n    if (!oldADR) {\n      throw new Error(`ADR not found: ${oldADRId}`);\n    }\n\n    // Create new ADR\n    const newADRId = await this.createADR({\n      ...newADRTemplate,\n      related_decisions: [...newADRTemplate.related_decisions, `ADR-${oldADR.number.toString().padStart(4, '0')}`]\n    });\n\n    // Update old ADR status\n    await this.updateADRStatus(oldADRId, 'superseded', `Superseded by new ADR: ${newADRId}`);\n\n    return newADRId;\n  }\n\n  /**\n   * Query ADRs\n   */\n  queryADRs(query: ADRQuery): ADRRecord[] {\n    let filtered = [...this.adrs];\n\n    if (query.status) {\n      filtered = filtered.filter(adr => adr.status === query.status);\n    }\n\n    if (query.ai_agent) {\n      filtered = filtered.filter(adr => adr.ai_agent_info.created_by === query.ai_agent);\n    }\n\n    if (query.date_range) {\n      filtered = filtered.filter(adr => {\n        const created = new Date(adr.created_date);\n        const start = new Date(query.date_range!.start);\n        const end = new Date(query.date_range!.end);\n        return created >= start && created <= end;\n      });\n    }\n\n    if (query.search_term) {\n      const searchTerm = query.search_term.toLowerCase();\n      filtered = filtered.filter(adr => \n        adr.title.toLowerCase().includes(searchTerm) ||\n        adr.context.toLowerCase().includes(searchTerm) ||\n        adr.decision.toLowerCase().includes(searchTerm) ||\n        adr.rationale.toLowerCase().includes(searchTerm)\n      );\n    }\n\n    // Sort by number (newest first)\n    filtered.sort((a, b) => b.number - a.number);\n\n    if (query.limit) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get ADR by ID\n   */\n  getADRById(id: string): ADRRecord | null {\n    return this.adrs.find(adr => adr.id === id) || null;\n  }\n\n  /**\n   * Get ADR by number\n   */\n  getADRByNumber(number: number): ADRRecord | null {\n    return this.adrs.find(adr => adr.number === number) || null;\n  }\n\n  /**\n   * Get all ADRs\n   */\n  getAllADRs(): ADRRecord[] {\n    return [...this.adrs].sort((a, b) => a.number - b.number);\n  }\n\n  /**\n   * Get active ADRs (accepted status)\n   */\n  getActiveADRs(): ADRRecord[] {\n    return this.queryADRs({ status: 'accepted' });\n  }\n\n  /**\n   * Generate ADR index\n   */\n  generateADRIndex(): string {\n    const adrs = this.getAllADRs();\n    \n    return `# Architecture Decision Records (ADRs)\n\nThis directory contains Architecture Decision Records for STR Certified.\n\n## Index\n\n${adrs.map(adr => `- [ADR-${adr.number.toString().padStart(4, '0')}](${path.basename(adr.file_path)}) - ${adr.title} (${adr.status})`).join('\\n')}\n\n## Status Summary\n\n- **Proposed**: ${adrs.filter(a => a.status === 'proposed').length}\n- **Accepted**: ${adrs.filter(a => a.status === 'accepted').length}\n- **Rejected**: ${adrs.filter(a => a.status === 'rejected').length}\n- **Superseded**: ${adrs.filter(a => a.status === 'superseded').length}\n\n## Recent ADRs\n\n${adrs.slice(0, 5).map(adr => `- [ADR-${adr.number.toString().padStart(4, '0')}](${path.basename(adr.file_path)}) - ${adr.title} (${adr.ai_agent_info.date})`).join('\\n')}\n\n---\n*This index was automatically generated by the ADR Management System.*\n*Last updated: ${new Date().toISOString()}*\n`;\n  }\n\n  /**\n   * Export ADRs\n   */\n  exportADRs(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.adrs, null, 2);\n    } else {\n      const headers = ['number', 'title', 'status', 'created_date', 'ai_agent', 'decision', 'rationale'];\n      const rows = this.adrs.map(adr => [\n        adr.number,\n        adr.title,\n        adr.status,\n        adr.created_date,\n        adr.ai_agent_info.created_by,\n        adr.decision.substring(0, 100) + '...',\n        adr.rationale.substring(0, 100) + '...'\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private loadExistingADRs(): void {\n    try {\n      // This would load existing ADRs from the filesystem\n      // For now, just initialize with empty array\n      this.adrs = [];\n      this.nextADRNumber = 1;\n    } catch (error) {\n      logger.error('Failed to load existing ADRs', error, 'ADR_LOAD');\n    }\n  }\n\n  private getNextADRNumber(): number {\n    return this.nextADRNumber;\n  }\n\n  private generateADRId(number: number): string {\n    return `adr_${number.toString().padStart(4, '0')}_${Date.now()}`;\n  }\n\n  private generateADRFilePath(number: number, title: string): string {\n    const sanitizedTitle = title.toLowerCase()\n      .replace(/[^a-z0-9\\s-]/g, '')\n      .replace(/\\s+/g, '-')\n      .substring(0, 50);\n    \n    return path.join(this.adrDirectory, `${number.toString().padStart(4, '0')}-${sanitizedTitle}.md`);\n  }\n\n  private generateMarkdownContent(adr: ADRRecord): string {\n    return `# ADR-${adr.number.toString().padStart(4, '0')}: ${adr.title}\n\n## Status\n${adr.status.charAt(0).toUpperCase() + adr.status.slice(1)}\n\n## Context\n${adr.context}\n\n## Decision\n${adr.decision}\n\n## Rationale\n${adr.rationale}\n\n## Consequences\n### Positive\n${adr.consequences.positive.map(c => `- ${c}`).join('\\n')}\n\n### Negative\n${adr.consequences.negative.map(c => `- ${c}`).join('\\n')}\n\n## Implementation\n${adr.implementation}\n\n## Alternatives Considered\n${adr.alternatives_considered}\n\n## Related Decisions\n${adr.related_decisions.map(d => `- ${d}`).join('\\n')}\n\n## Monitoring and Review\n${adr.monitoring_and_review}\n\n## Notes\n${adr.notes}\n\n## AI Agent Information\n- **Created by**: ${adr.ai_agent_info.created_by}\n- **Date**: ${adr.ai_agent_info.date}\n- **Session ID**: ${adr.ai_agent_info.session_id}\n- **Decision Logger ID**: ${adr.ai_agent_info.decision_logger_id || 'N/A'}\n- **Context Handoff ID**: ${adr.ai_agent_info.context_handoff_id || 'N/A'}\n\n---\n*This ADR was created as part of the AI decision logging and multi-AI collaboration system for STR Certified.*\n*Last modified: ${adr.last_modified}*`;\n  }\n\n  private async writeADRFile(filePath: string, content: string): Promise<void> {\n    // In a real implementation, this would write to the filesystem\n    // For now, just simulate the operation\n    logger.info(`ADR file would be written to: ${filePath}`, { content_length: content.length }, 'ADR_FILE_WRITE');\n  }\n\n  private async persistADR(adr: ADRRecord): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('architecture_decision_records')\n        .upsert([{\n          id: adr.id,\n          number: adr.number,\n          title: adr.title,\n          status: adr.status,\n          context: adr.context,\n          decision: adr.decision,\n          rationale: adr.rationale,\n          consequences: adr.consequences,\n          implementation: adr.implementation,\n          alternatives_considered: adr.alternatives_considered,\n          related_decisions: adr.related_decisions,\n          monitoring_and_review: adr.monitoring_and_review,\n          notes: adr.notes,\n          ai_agent_info: adr.ai_agent_info,\n          created_date: adr.created_date,\n          last_modified: adr.last_modified,\n          file_path: adr.file_path,\n          metadata: adr.metadata\n        }]);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      logger.error('Failed to persist ADR to database', error, 'ADR_PERSIST');\n      throw error;\n    }\n  }\n\n  private getCurrentAIAgent(): string {\n    return process.env.AI_AGENT || 'claude-sonnet-4';\n  }\n\n  private getCurrentSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// Export singleton instance\nexport const adrManager = ADRManager.getInstance();\n\n// Convenience functions\nexport const createADR = adrManager.createADR.bind(adrManager);\nexport const createSimpleADR = adrManager.createSimpleADR.bind(adrManager);\nexport const updateADRStatus = adrManager.updateADRStatus.bind(adrManager);\nexport const supersedeADR = adrManager.supersedeADR.bind(adrManager);\nexport const queryADRs = adrManager.queryADRs.bind(adrManager);\nexport const getADRById = adrManager.getADRById.bind(adrManager);\nexport const getADRByNumber = adrManager.getADRByNumber.bind(adrManager);\nexport const getAllADRs = adrManager.getAllADRs.bind(adrManager);\nexport const getActiveADRs = adrManager.getActiveADRs.bind(adrManager);\nexport const generateADRIndex = adrManager.generateADRIndex.bind(adrManager);\nexport const exportADRs = adrManager.exportADRs.bind(adrManager);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/code-review-trail.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1099,1102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1099,1102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Code Review Trail for STR Certified\n// Tracks what AI reviewed and approved with decision justification\n\nimport { aiDecisionLogger } from './decision-logger';\nimport { aiSessionManager } from './session-manager';\nimport { aiLearningRepository } from './learning-repository';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport { supabase } from '../supabase';\n\n// Code Review Types\nexport interface CodeReviewEntry {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  ai_agent: string;\n  review_type: ReviewType;\n  scope: ReviewScope;\n  files_reviewed: FileReview[];\n  overall_assessment: OverallAssessment;\n  findings: ReviewFinding[];\n  recommendations: ReviewRecommendation[];\n  approvals: CodeApproval[];\n  security_assessment: SecurityAssessment;\n  performance_assessment: PerformanceAssessment;\n  quality_metrics: QualityMetrics;\n  decision_justification: string;\n  confidence: number; // 0-100\n  review_duration_minutes: number;\n  follow_up_required: boolean;\n  follow_up_items: string[];\n  metadata: Record<string, any>;\n}\n\nexport type ReviewType = \n  | 'pre_commit'\n  | 'post_commit'\n  | 'pull_request'\n  | 'architecture_review'\n  | 'security_review'\n  | 'performance_review'\n  | 'code_quality'\n  | 'bug_fix_review'\n  | 'feature_review'\n  | 'refactoring_review'\n  | 'documentation_review'\n  | 'test_review'\n  | 'deployment_review'\n  | 'emergency_review'\n  | 'compliance_review';\n\nexport interface ReviewScope {\n  files_count: number;\n  lines_of_code: number;\n  complexity_score: number;\n  risk_level: 'low' | 'medium' | 'high' | 'critical';\n  change_type: 'addition' | 'modification' | 'deletion' | 'refactoring' | 'migration';\n  impact_areas: string[];\n  dependencies_affected: string[];\n  testing_scope: string[];\n}\n\nexport interface FileReview {\n  file_path: string;\n  file_type: string;\n  lines_reviewed: number;\n  complexity_score: number;\n  change_summary: string;\n  review_status: 'approved' | 'approved_with_comments' | 'needs_changes' | 'rejected';\n  findings: ReviewFinding[];\n  time_spent_minutes: number;\n  ai_confidence: number;\n  review_notes: string;\n}\n\nexport interface OverallAssessment {\n  status: 'approved' | 'approved_with_comments' | 'needs_changes' | 'rejected';\n  risk_score: number; // 0-100\n  quality_score: number; // 0-100\n  maintainability_score: number; // 0-100\n  readability_score: number; // 0-100\n  test_coverage_score: number; // 0-100\n  security_score: number; // 0-100\n  performance_score: number; // 0-100\n  overall_confidence: number; // 0-100\n}\n\nexport interface ReviewFinding {\n  id: string;\n  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';\n  category: FindingCategory;\n  title: string;\n  description: string;\n  file_path: string;\n  line_number?: number;\n  code_snippet?: string;\n  suggested_fix?: string;\n  rationale: string;\n  impact: string;\n  effort_to_fix: 'low' | 'medium' | 'high';\n  blocking: boolean;\n  references: string[];\n  tags: string[];\n}\n\nexport type FindingCategory = \n  | 'security_vulnerability'\n  | 'performance_issue'\n  | 'code_quality'\n  | 'maintainability'\n  | 'readability'\n  | 'naming_convention'\n  | 'architecture_violation'\n  | 'best_practice'\n  | 'testing_issue'\n  | 'documentation'\n  | 'accessibility'\n  | 'error_handling'\n  | 'resource_management'\n  | 'api_design'\n  | 'data_validation'\n  | 'business_logic'\n  | 'user_experience'\n  | 'compliance'\n  | 'technical_debt'\n  | 'code_duplication';\n\nexport interface ReviewRecommendation {\n  id: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  category: 'improvement' | 'optimization' | 'security' | 'performance' | 'maintainability';\n  title: string;\n  description: string;\n  implementation_steps: string[];\n  expected_impact: string;\n  effort_estimation: string;\n  dependencies: string[];\n  timeline: string;\n  risk_mitigation: string;\n}\n\nexport interface CodeApproval {\n  file_path: string;\n  approval_type: 'full' | 'conditional' | 'partial';\n  conditions: string[];\n  approved_sections: CodeSection[];\n  restrictions: string[];\n  monitoring_requirements: string[];\n  rollback_plan?: string;\n  expiry_date?: string;\n  approver_notes: string;\n}\n\nexport interface CodeSection {\n  start_line: number;\n  end_line: number;\n  description: string;\n  justification: string;\n  risk_level: 'low' | 'medium' | 'high';\n}\n\nexport interface SecurityAssessment {\n  overall_security_score: number; // 0-100\n  vulnerabilities_found: number;\n  critical_vulnerabilities: number;\n  security_best_practices_score: number;\n  data_protection_score: number;\n  authentication_score: number;\n  authorization_score: number;\n  input_validation_score: number;\n  output_sanitization_score: number;\n  security_recommendations: string[];\n  compliance_status: Record<string, boolean>;\n}\n\nexport interface PerformanceAssessment {\n  overall_performance_score: number; // 0-100\n  performance_issues_found: number;\n  critical_performance_issues: number;\n  memory_usage_score: number;\n  cpu_usage_score: number;\n  network_efficiency_score: number;\n  database_optimization_score: number;\n  caching_strategy_score: number;\n  scalability_score: number;\n  performance_recommendations: string[];\n  benchmark_results?: Record<string, number>;\n}\n\nexport interface QualityMetrics {\n  cyclomatic_complexity: number;\n  maintainability_index: number;\n  code_duplication_percentage: number;\n  test_coverage_percentage: number;\n  documentation_coverage: number;\n  naming_consistency_score: number;\n  error_handling_score: number;\n  logging_adequacy_score: number;\n  dependency_health_score: number;\n  architecture_compliance_score: number;\n}\n\nexport interface ReviewQuery {\n  ai_agent?: string;\n  review_type?: ReviewType;\n  status?: OverallAssessment['status'];\n  risk_level?: ReviewScope['risk_level'];\n  date_range?: {\n    start: string;\n    end: string;\n  };\n  files?: string[];\n  severity?: ReviewFinding['severity'];\n  category?: FindingCategory;\n  approved_only?: boolean;\n  limit?: number;\n}\n\nexport interface ReviewSummary {\n  total_reviews: number;\n  reviews_by_type: Record<ReviewType, number>;\n  average_quality_score: number;\n  average_security_score: number;\n  average_performance_score: number;\n  approval_rate: number;\n  findings_by_severity: Record<string, number>;\n  common_issues: Array<{ issue: string; frequency: number }>;\n  review_efficiency: {\n    average_duration: number;\n    files_per_hour: number;\n    lines_per_hour: number;\n  };\n}\n\nexport class AICodeReviewTrail {\n  private static instance: AICodeReviewTrail;\n  private reviews: CodeReviewEntry[] = [];\n  private maxLocalReviews = 500;\n  private activeReview: CodeReviewEntry | null = null;\n  private reviewStartTime: Date | null = null;\n\n  private constructor() {}\n\n  static getInstance(): AICodeReviewTrail {\n    if (!AICodeReviewTrail.instance) {\n      AICodeReviewTrail.instance = new AICodeReviewTrail();\n    }\n    return AICodeReviewTrail.instance;\n  }\n\n  /**\n   * Start a new code review\n   */\n  async startReview(\n    review_type: ReviewType,\n    scope: ReviewScope,\n    files: string[]\n  ): Promise<string> {\n    const reviewId = this.generateReviewId();\n    const sessionId = this.getCurrentSessionId();\n    \n    this.reviewStartTime = new Date();\n    \n    const review: CodeReviewEntry = {\n      id: reviewId,\n      timestamp: new Date().toISOString(),\n      session_id: sessionId,\n      ai_agent: this.getCurrentAIAgent(),\n      review_type,\n      scope,\n      files_reviewed: files.map(file => ({\n        file_path: file,\n        file_type: this.getFileType(file),\n        lines_reviewed: 0,\n        complexity_score: 0,\n        change_summary: '',\n        review_status: 'approved',\n        findings: [],\n        time_spent_minutes: 0,\n        ai_confidence: 0,\n        review_notes: ''\n      })),\n      overall_assessment: {\n        status: 'approved',\n        risk_score: 0,\n        quality_score: 0,\n        maintainability_score: 0,\n        readability_score: 0,\n        test_coverage_score: 0,\n        security_score: 0,\n        performance_score: 0,\n        overall_confidence: 0\n      },\n      findings: [],\n      recommendations: [],\n      approvals: [],\n      security_assessment: this.getDefaultSecurityAssessment(),\n      performance_assessment: this.getDefaultPerformanceAssessment(),\n      quality_metrics: this.getDefaultQualityMetrics(),\n      decision_justification: '',\n      confidence: 0,\n      review_duration_minutes: 0,\n      follow_up_required: false,\n      follow_up_items: [],\n      metadata: {}\n    };\n\n    this.activeReview = review;\n    \n    // Log review start\n    await aiDecisionLogger.logSimpleDecision(\n      `Started code review: ${review_type}`,\n      'code_creation',\n      `Code review started for ${files.length} files`,\n      files,\n      'medium'\n    );\n\n    logger.info(`Code review started: ${review_type}`, {\n      review_id: reviewId,\n      files_count: files.length,\n      scope: scope,\n      ai_agent: this.getCurrentAIAgent()\n    }, 'AI_CODE_REVIEW_START');\n\n    return reviewId;\n  }\n\n  /**\n   * Add a finding to the current review\n   */\n  async addFinding(finding: Omit<ReviewFinding, 'id'>): Promise<string> {\n    if (!this.activeReview) {\n      throw new Error('No active review. Start a review first.');\n    }\n\n    const findingId = this.generateFindingId();\n    const fullFinding: ReviewFinding = {\n      id: findingId,\n      ...finding\n    };\n\n    this.activeReview.findings.push(fullFinding);\n\n    // Add to file-specific findings\n    const fileReview = this.activeReview.files_reviewed.find(f => f.file_path === finding.file_path);\n    if (fileReview) {\n      fileReview.findings.push(fullFinding);\n    }\n\n    // Update overall assessment based on finding severity\n    this.updateOverallAssessment();\n\n    logger.info(`Finding added to review: ${finding.title}`, {\n      finding_id: findingId,\n      severity: finding.severity,\n      category: finding.category,\n      file_path: finding.file_path,\n      review_id: this.activeReview.id\n    }, 'AI_CODE_REVIEW_FINDING');\n\n    return findingId;\n  }\n\n  /**\n   * Add a recommendation to the current review\n   */\n  async addRecommendation(recommendation: Omit<ReviewRecommendation, 'id'>): Promise<string> {\n    if (!this.activeReview) {\n      throw new Error('No active review. Start a review first.');\n    }\n\n    const recommendationId = this.generateRecommendationId();\n    const fullRecommendation: ReviewRecommendation = {\n      id: recommendationId,\n      ...recommendation\n    };\n\n    this.activeReview.recommendations.push(fullRecommendation);\n\n    logger.info(`Recommendation added to review: ${recommendation.title}`, {\n      recommendation_id: recommendationId,\n      priority: recommendation.priority,\n      category: recommendation.category,\n      review_id: this.activeReview.id\n    }, 'AI_CODE_REVIEW_RECOMMENDATION');\n\n    return recommendationId;\n  }\n\n  /**\n   * Approve code sections\n   */\n  async approveCode(\n    file_path: string,\n    approval_type: CodeApproval['approval_type'],\n    sections: CodeSection[],\n    justification: string,\n    conditions: string[] = []\n  ): Promise<void> {\n    if (!this.activeReview) {\n      throw new Error('No active review. Start a review first.');\n    }\n\n    const approval: CodeApproval = {\n      file_path,\n      approval_type,\n      conditions,\n      approved_sections: sections,\n      restrictions: [],\n      monitoring_requirements: [],\n      approver_notes: justification\n    };\n\n    this.activeReview.approvals.push(approval);\n\n    // Log approval\n    await aiDecisionLogger.logSimpleDecision(\n      `Approved code: ${file_path}`,\n      'code_creation',\n      `Code approval (${approval_type}): ${justification}`,\n      [file_path],\n      'medium'\n    );\n\n    logger.info(`Code approved: ${file_path}`, {\n      approval_type,\n      sections_count: sections.length,\n      conditions_count: conditions.length,\n      review_id: this.activeReview.id\n    }, 'AI_CODE_REVIEW_APPROVAL');\n  }\n\n  /**\n   * Complete the current review\n   */\n  async completeReview(\n    decision_justification: string,\n    overall_status: OverallAssessment['status'],\n    confidence: number\n  ): Promise<void> {\n    if (!this.activeReview) {\n      throw new Error('No active review. Start a review first.');\n    }\n\n    const reviewDuration = this.reviewStartTime \n      ? Math.round((Date.now() - this.reviewStartTime.getTime()) / (1000 * 60))\n      : 0;\n\n    // Update final assessment\n    this.activeReview.overall_assessment.status = overall_status;\n    this.activeReview.overall_assessment.overall_confidence = confidence;\n    this.activeReview.decision_justification = decision_justification;\n    this.activeReview.confidence = confidence;\n    this.activeReview.review_duration_minutes = reviewDuration;\n    this.activeReview.follow_up_required = this.activeReview.findings.some(f => f.blocking);\n    this.activeReview.follow_up_items = this.activeReview.findings\n      .filter(f => f.blocking)\n      .map(f => f.title);\n\n    // Calculate final metrics\n    this.calculateFinalMetrics();\n\n    // Add to reviews list\n    this.reviews.push(this.activeReview);\n\n    // Maintain local cache size\n    if (this.reviews.length > this.maxLocalReviews) {\n      this.reviews = this.reviews.slice(-this.maxLocalReviews);\n    }\n\n    // Log completion\n    await aiDecisionLogger.logSimpleDecision(\n      `Completed code review: ${this.activeReview.review_type}`,\n      'code_creation',\n      `Review completed with ${overall_status} status: ${decision_justification}`,\n      this.activeReview.files_reviewed.map(f => f.file_path),\n      'medium'\n    );\n\n    // Add learning if there are significant findings\n    if (this.activeReview.findings.length > 0) {\n      await aiLearningRepository.addSimpleLearning(\n        `Code review pattern: ${this.activeReview.review_type}`,\n        `Found ${this.activeReview.findings.length} issues during code review`,\n        'pattern_discovered',\n        'code_quality',\n        confidence\n      );\n    }\n\n    logger.info(`Code review completed: ${this.activeReview.review_type}`, {\n      review_id: this.activeReview.id,\n      status: overall_status,\n      findings_count: this.activeReview.findings.length,\n      recommendations_count: this.activeReview.recommendations.length,\n      duration_minutes: reviewDuration,\n      confidence\n    }, 'AI_CODE_REVIEW_COMPLETE');\n\n    try {\n      await this.persistReview(this.activeReview);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_CODE_REVIEW_PERSIST',\n        review_id: this.activeReview.id,\n        review_type: this.activeReview.review_type\n      });\n    }\n\n    // Clear active review\n    this.activeReview = null;\n    this.reviewStartTime = null;\n  }\n\n  /**\n   * Quick review for simple changes\n   */\n  async quickReview(\n    files: string[],\n    change_description: string,\n    justification: string,\n    confidence: number = 85\n  ): Promise<string> {\n    const reviewId = await this.startReview('pre_commit', {\n      files_count: files.length,\n      lines_of_code: 100, // Estimated\n      complexity_score: 3, // Low complexity\n      risk_level: 'low',\n      change_type: 'modification',\n      impact_areas: ['functionality'],\n      dependencies_affected: [],\n      testing_scope: ['unit_tests']\n    }, files);\n\n    // Quick assessment\n    if (this.activeReview) {\n      this.activeReview.overall_assessment = {\n        status: 'approved',\n        risk_score: 20,\n        quality_score: 85,\n        maintainability_score: 85,\n        readability_score: 85,\n        test_coverage_score: 80,\n        security_score: 90,\n        performance_score: 85,\n        overall_confidence: confidence\n      };\n\n      // Auto-approve all files\n      for (const file of files) {\n        await this.approveCode(file, 'full', [{\n          start_line: 1,\n          end_line: 1000,\n          description: change_description,\n          justification,\n          risk_level: 'low'\n        }], justification);\n      }\n    }\n\n    await this.completeReview(justification, 'approved', confidence);\n\n    return reviewId;\n  }\n\n  /**\n   * Query reviews\n   */\n  queryReviews(query: ReviewQuery): CodeReviewEntry[] {\n    let filtered = [...this.reviews];\n\n    if (query.ai_agent) {\n      filtered = filtered.filter(r => r.ai_agent === query.ai_agent);\n    }\n\n    if (query.review_type) {\n      filtered = filtered.filter(r => r.review_type === query.review_type);\n    }\n\n    if (query.status) {\n      filtered = filtered.filter(r => r.overall_assessment.status === query.status);\n    }\n\n    if (query.risk_level) {\n      filtered = filtered.filter(r => r.scope.risk_level === query.risk_level);\n    }\n\n    if (query.date_range) {\n      filtered = filtered.filter(r => {\n        const timestamp = new Date(r.timestamp);\n        const start = new Date(query.date_range!.start);\n        const end = new Date(query.date_range!.end);\n        return timestamp >= start && timestamp <= end;\n      });\n    }\n\n    if (query.files && query.files.length > 0) {\n      filtered = filtered.filter(r => \n        r.files_reviewed.some(f => \n          query.files!.some(qf => f.file_path.includes(qf))\n        )\n      );\n    }\n\n    if (query.severity) {\n      filtered = filtered.filter(r => \n        r.findings.some(f => f.severity === query.severity)\n      );\n    }\n\n    if (query.category) {\n      filtered = filtered.filter(r => \n        r.findings.some(f => f.category === query.category)\n      );\n    }\n\n    if (query.approved_only) {\n      filtered = filtered.filter(r => r.overall_assessment.status === 'approved');\n    }\n\n    // Sort by timestamp (newest first)\n    filtered.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n    if (query.limit) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get review by ID\n   */\n  getReviewById(reviewId: string): CodeReviewEntry | null {\n    return this.reviews.find(r => r.id === reviewId) || null;\n  }\n\n  /**\n   * Get review summary\n   */\n  getReviewSummary(): ReviewSummary {\n    const totalReviews = this.reviews.length;\n    \n    const reviewsByType = this.reviews.reduce((acc, r) => {\n      acc[r.review_type] = (acc[r.review_type] || 0) + 1;\n      return acc;\n    }, {} as Record<ReviewType, number>);\n\n    const averageQualityScore = totalReviews > 0 \n      ? this.reviews.reduce((sum, r) => sum + r.overall_assessment.quality_score, 0) / totalReviews \n      : 0;\n\n    const averageSecurityScore = totalReviews > 0 \n      ? this.reviews.reduce((sum, r) => sum + r.overall_assessment.security_score, 0) / totalReviews \n      : 0;\n\n    const averagePerformanceScore = totalReviews > 0 \n      ? this.reviews.reduce((sum, r) => sum + r.overall_assessment.performance_score, 0) / totalReviews \n      : 0;\n\n    const approvedReviews = this.reviews.filter(r => r.overall_assessment.status === 'approved').length;\n    const approvalRate = totalReviews > 0 ? (approvedReviews / totalReviews) * 100 : 0;\n\n    const allFindings = this.reviews.flatMap(r => r.findings);\n    const findingsBySeverity = allFindings.reduce((acc, f) => {\n      acc[f.severity] = (acc[f.severity] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const issueCounts = allFindings.reduce((acc, f) => {\n      acc[f.category] = (acc[f.category] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const commonIssues = Object.entries(issueCounts)\n      .map(([issue, frequency]) => ({ issue, frequency }))\n      .sort((a, b) => b.frequency - a.frequency)\n      .slice(0, 10);\n\n    const totalDuration = this.reviews.reduce((sum, r) => sum + r.review_duration_minutes, 0);\n    const totalFiles = this.reviews.reduce((sum, r) => sum + r.files_reviewed.length, 0);\n    const totalLines = this.reviews.reduce((sum, r) => sum + r.scope.lines_of_code, 0);\n\n    const reviewEfficiency = {\n      average_duration: totalReviews > 0 ? totalDuration / totalReviews : 0,\n      files_per_hour: totalDuration > 0 ? (totalFiles / totalDuration) * 60 : 0,\n      lines_per_hour: totalDuration > 0 ? (totalLines / totalDuration) * 60 : 0\n    };\n\n    return {\n      total_reviews: totalReviews,\n      reviews_by_type: reviewsByType,\n      average_quality_score: averageQualityScore,\n      average_security_score: averageSecurityScore,\n      average_performance_score: averagePerformanceScore,\n      approval_rate: approvalRate,\n      findings_by_severity: findingsBySeverity,\n      common_issues: commonIssues,\n      review_efficiency: reviewEfficiency\n    };\n  }\n\n  /**\n   * Export reviews\n   */\n  exportReviews(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.reviews, null, 2);\n    } else {\n      const headers = ['timestamp', 'review_type', 'status', 'files_count', 'findings_count', 'quality_score', 'security_score', 'ai_agent'];\n      const rows = this.reviews.map(r => [\n        r.timestamp,\n        r.review_type,\n        r.overall_assessment.status,\n        r.files_reviewed.length,\n        r.findings.length,\n        r.overall_assessment.quality_score,\n        r.overall_assessment.security_score,\n        r.ai_agent\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateReviewId(): string {\n    return `review_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateFindingId(): string {\n    return `finding_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateRecommendationId(): string {\n    return `recommendation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getCurrentSessionId(): string {\n    const session = aiSessionManager.getCurrentSession();\n    return session?.id || `session_${Date.now()}`;\n  }\n\n  private getCurrentAIAgent(): string {\n    return process.env.AI_AGENT || 'claude-sonnet-4';\n  }\n\n  private getFileType(filePath: string): string {\n    const extension = filePath.split('.').pop()?.toLowerCase();\n    return extension || 'unknown';\n  }\n\n  private updateOverallAssessment(): void {\n    if (!this.activeReview) return;\n\n    const criticalFindings = this.activeReview.findings.filter(f => f.severity === 'critical').length;\n    const highFindings = this.activeReview.findings.filter(f => f.severity === 'high').length;\n    const blockingFindings = this.activeReview.findings.filter(f => f.blocking).length;\n\n    // Update status based on findings\n    if (criticalFindings > 0 || blockingFindings > 0) {\n      this.activeReview.overall_assessment.status = 'rejected';\n    } else if (highFindings > 0) {\n      this.activeReview.overall_assessment.status = 'needs_changes';\n    } else if (this.activeReview.findings.length > 0) {\n      this.activeReview.overall_assessment.status = 'approved_with_comments';\n    } else {\n      this.activeReview.overall_assessment.status = 'approved';\n    }\n\n    // Update risk score\n    this.activeReview.overall_assessment.risk_score = Math.min(100, \n      (criticalFindings * 30) + (highFindings * 15) + (this.activeReview.findings.length * 5)\n    );\n  }\n\n  private calculateFinalMetrics(): void {\n    if (!this.activeReview) return;\n\n    // Calculate average confidence from file reviews\n    const avgConfidence = this.activeReview.files_reviewed.length > 0\n      ? this.activeReview.files_reviewed.reduce((sum, f) => sum + f.ai_confidence, 0) / this.activeReview.files_reviewed.length\n      : 0;\n\n    this.activeReview.overall_assessment.overall_confidence = avgConfidence;\n\n    // Update quality metrics based on findings\n    const qualityIssues = this.activeReview.findings.filter(f => f.category === 'code_quality').length;\n    this.activeReview.overall_assessment.quality_score = Math.max(0, 100 - (qualityIssues * 10));\n\n    const securityIssues = this.activeReview.findings.filter(f => f.category === 'security_vulnerability').length;\n    this.activeReview.overall_assessment.security_score = Math.max(0, 100 - (securityIssues * 20));\n\n    const performanceIssues = this.activeReview.findings.filter(f => f.category === 'performance_issue').length;\n    this.activeReview.overall_assessment.performance_score = Math.max(0, 100 - (performanceIssues * 15));\n  }\n\n  private getDefaultSecurityAssessment(): SecurityAssessment {\n    return {\n      overall_security_score: 85,\n      vulnerabilities_found: 0,\n      critical_vulnerabilities: 0,\n      security_best_practices_score: 85,\n      data_protection_score: 85,\n      authentication_score: 85,\n      authorization_score: 85,\n      input_validation_score: 85,\n      output_sanitization_score: 85,\n      security_recommendations: [],\n      compliance_status: {}\n    };\n  }\n\n  private getDefaultPerformanceAssessment(): PerformanceAssessment {\n    return {\n      overall_performance_score: 85,\n      performance_issues_found: 0,\n      critical_performance_issues: 0,\n      memory_usage_score: 85,\n      cpu_usage_score: 85,\n      network_efficiency_score: 85,\n      database_optimization_score: 85,\n      caching_strategy_score: 85,\n      scalability_score: 85,\n      performance_recommendations: []\n    };\n  }\n\n  private getDefaultQualityMetrics(): QualityMetrics {\n    return {\n      cyclomatic_complexity: 5,\n      maintainability_index: 85,\n      code_duplication_percentage: 5,\n      test_coverage_percentage: 80,\n      documentation_coverage: 75,\n      naming_consistency_score: 85,\n      error_handling_score: 85,\n      logging_adequacy_score: 80,\n      dependency_health_score: 85,\n      architecture_compliance_score: 85\n    };\n  }\n\n  private async persistReview(review: CodeReviewEntry): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('ai_code_reviews')\n        .insert([{\n          id: review.id,\n          timestamp: review.timestamp,\n          session_id: review.session_id,\n          ai_agent: review.ai_agent,\n          review_type: review.review_type,\n          scope: review.scope,\n          files_reviewed: review.files_reviewed,\n          overall_assessment: review.overall_assessment,\n          findings: review.findings,\n          recommendations: review.recommendations,\n          approvals: review.approvals,\n          security_assessment: review.security_assessment,\n          performance_assessment: review.performance_assessment,\n          quality_metrics: review.quality_metrics,\n          decision_justification: review.decision_justification,\n          confidence: review.confidence,\n          review_duration_minutes: review.review_duration_minutes,\n          follow_up_required: review.follow_up_required,\n          follow_up_items: review.follow_up_items,\n          metadata: review.metadata\n        }]);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      logger.error('Failed to persist code review to database', error, 'AI_CODE_REVIEW_PERSIST');\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const aiCodeReviewTrail = AICodeReviewTrail.getInstance();\n\n// Convenience functions\nexport const startReview = aiCodeReviewTrail.startReview.bind(aiCodeReviewTrail);\nexport const addFinding = aiCodeReviewTrail.addFinding.bind(aiCodeReviewTrail);\nexport const addRecommendation = aiCodeReviewTrail.addRecommendation.bind(aiCodeReviewTrail);\nexport const approveCode = aiCodeReviewTrail.approveCode.bind(aiCodeReviewTrail);\nexport const completeReview = aiCodeReviewTrail.completeReview.bind(aiCodeReviewTrail);\nexport const quickReview = aiCodeReviewTrail.quickReview.bind(aiCodeReviewTrail);\nexport const queryReviews = aiCodeReviewTrail.queryReviews.bind(aiCodeReviewTrail);\nexport const getReviewById = aiCodeReviewTrail.getReviewById.bind(aiCodeReviewTrail);\nexport const getReviewSummary = aiCodeReviewTrail.getReviewSummary.bind(aiCodeReviewTrail);\nexport const exportReviews = aiCodeReviewTrail.exportReviews.bind(aiCodeReviewTrail);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/context-handoff.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[857,860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[857,860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Context Handoff System for STR Certified\n// Enables seamless handoffs between different AI coding sessions\n\nimport { aiDecisionLogger, AIDecision, AIDecisionType } from './decision-logger';\nimport { logger } from '../../utils/logger';\nimport { supabase } from '../supabase';\nimport { errorReporter } from '../monitoring/error-reporter';\n\n// Context Handoff Types\nexport interface AIContextHandoff {\n  id: string;\n  session_id: string;\n  timestamp: string;\n  from_ai_agent: string;\n  to_ai_agent?: string;\n  handoff_type: HandoffType;\n  context: HandoffContext;\n  system_state: SystemState;\n  completion_status: CompletionStatus;\n  priority_items: PriorityItem[];\n  warnings: Warning[];\n  recommendations: Recommendation[];\n  technical_debt: TechnicalDebt[];\n  learning_insights: LearningInsight[];\n  next_steps: NextStep[];\n  metadata: Record<string, any>;\n}\n\nexport type HandoffType = \n  | 'session_end'\n  | 'task_completion'\n  | 'escalation'\n  | 'shift_change'\n  | 'emergency_handoff'\n  | 'planned_transition'\n  | 'context_preservation';\n\nexport interface HandoffContext {\n  current_task: string;\n  user_request: string;\n  progress_summary: string;\n  completed_objectives: string[];\n  incomplete_objectives: string[];\n  blocked_items: BlockedItem[];\n  assumptions_made: string[];\n  constraints_identified: string[];\n  risks_assessed: RiskAssessment[];\n  dependencies_discovered: string[];\n  context_for_next_ai: string;\n}\n\nexport interface SystemState {\n  last_modified_files: FileChange[];\n  active_branches: string[];\n  database_changes: DatabaseChange[];\n  configuration_changes: ConfigurationChange[];\n  dependency_changes: DependencyChange[];\n  test_status: TestStatus;\n  build_status: BuildStatus;\n  deployment_status: DeploymentStatus;\n  error_state: ErrorState;\n  performance_metrics: PerformanceMetrics;\n}\n\nexport interface CompletionStatus {\n  overall_completion: number; // 0-100\n  task_breakdown: TaskCompletion[];\n  quality_metrics: QualityMetrics;\n  testing_coverage: TestingCoverage;\n  documentation_status: DocumentationStatus;\n  code_review_status: CodeReviewStatus;\n}\n\nexport interface PriorityItem {\n  id: string;\n  description: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  urgency: 'immediate' | 'today' | 'this_week' | 'later';\n  category: 'bug' | 'feature' | 'security' | 'performance' | 'maintenance' | 'documentation';\n  estimated_effort: string;\n  dependencies: string[];\n  context: string;\n}\n\nexport interface BlockedItem {\n  description: string;\n  blocking_reason: string;\n  potential_solutions: string[];\n  escalation_needed: boolean;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n}\n\nexport interface Warning {\n  type: 'security' | 'performance' | 'compatibility' | 'data_integrity' | 'user_experience' | 'business_logic';\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  description: string;\n  affected_areas: string[];\n  mitigation_steps: string[];\n  monitoring_required: boolean;\n}\n\nexport interface Recommendation {\n  category: 'architecture' | 'performance' | 'security' | 'usability' | 'maintainability' | 'scalability';\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  description: string;\n  rationale: string;\n  implementation_steps: string[];\n  estimated_impact: string;\n  risks: string[];\n}\n\nexport interface TechnicalDebt {\n  area: string;\n  description: string;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  impact: string;\n  suggested_solution: string;\n  estimated_effort: string;\n  priority_score: number;\n}\n\nexport interface LearningInsight {\n  category: 'pattern_discovered' | 'antipattern_identified' | 'optimization_found' | 'tool_effectiveness' | 'process_improvement';\n  description: string;\n  context: string;\n  confidence: number;\n  applicability: string;\n  validation_needed: boolean;\n}\n\nexport interface NextStep {\n  step: string;\n  description: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  estimated_duration: string;\n  prerequisites: string[];\n  success_criteria: string[];\n  potential_issues: string[];\n}\n\nexport interface FileChange {\n  file_path: string;\n  change_type: 'created' | 'modified' | 'deleted' | 'renamed';\n  lines_changed: number;\n  change_description: string;\n  ai_decision_id?: string;\n}\n\nexport interface DatabaseChange {\n  type: 'schema' | 'data' | 'migration' | 'index' | 'constraint';\n  description: string;\n  impact: 'breaking' | 'non_breaking' | 'enhancement';\n  rollback_plan: string;\n}\n\nexport interface ConfigurationChange {\n  component: string;\n  setting: string;\n  old_value: string;\n  new_value: string;\n  impact: string;\n}\n\nexport interface DependencyChange {\n  package: string;\n  action: 'added' | 'updated' | 'removed';\n  old_version?: string;\n  new_version?: string;\n  reason: string;\n  impact: string;\n}\n\nexport interface TestStatus {\n  unit_tests: { passed: number; failed: number; coverage: number };\n  integration_tests: { passed: number; failed: number; coverage: number };\n  e2e_tests: { passed: number; failed: number; coverage: number };\n  failing_tests: string[];\n  test_coverage_delta: number;\n}\n\nexport interface BuildStatus {\n  status: 'success' | 'failure' | 'warning' | 'in_progress';\n  build_time: number;\n  warnings: string[];\n  errors: string[];\n  artifacts_generated: string[];\n}\n\nexport interface DeploymentStatus {\n  environment: string;\n  status: 'deployed' | 'failed' | 'pending' | 'rollback';\n  version: string;\n  deployment_time?: string;\n  health_check_results: Record<string, boolean>;\n}\n\nexport interface ErrorState {\n  critical_errors: string[];\n  warnings: string[];\n  unhandled_exceptions: string[];\n  performance_issues: string[];\n  security_alerts: string[];\n}\n\nexport interface PerformanceMetrics {\n  build_time: number;\n  test_execution_time: number;\n  bundle_size: number;\n  memory_usage: number;\n  cpu_usage: number;\n  api_response_times: Record<string, number>;\n}\n\nexport interface TaskCompletion {\n  task: string;\n  completion_percentage: number;\n  status: 'completed' | 'in_progress' | 'blocked' | 'not_started';\n  quality_score: number;\n}\n\nexport interface QualityMetrics {\n  code_quality_score: number;\n  security_score: number;\n  performance_score: number;\n  maintainability_score: number;\n  documentation_score: number;\n}\n\nexport interface TestingCoverage {\n  unit_test_coverage: number;\n  integration_test_coverage: number;\n  e2e_test_coverage: number;\n  critical_path_coverage: number;\n}\n\nexport interface DocumentationStatus {\n  api_documentation: 'complete' | 'partial' | 'missing';\n  code_comments: 'complete' | 'partial' | 'missing';\n  user_documentation: 'complete' | 'partial' | 'missing';\n  technical_documentation: 'complete' | 'partial' | 'missing';\n}\n\nexport interface CodeReviewStatus {\n  peer_review_completed: boolean;\n  automated_review_passed: boolean;\n  security_review_passed: boolean;\n  performance_review_passed: boolean;\n  outstanding_issues: string[];\n}\n\nexport interface RiskAssessment {\n  risk_type: 'technical' | 'business' | 'security' | 'performance' | 'usability';\n  probability: 'low' | 'medium' | 'high';\n  impact: 'low' | 'medium' | 'high';\n  description: string;\n  mitigation_strategy: string;\n  monitoring_plan: string;\n}\n\nexport class AIContextHandoffManager {\n  private static instance: AIContextHandoffManager;\n  private handoffs: AIContextHandoff[] = [];\n  private currentContext: AIContextHandoff | null = null;\n  private maxLocalHandoffs = 100;\n\n  private constructor() {}\n\n  static getInstance(): AIContextHandoffManager {\n    if (!AIContextHandoffManager.instance) {\n      AIContextHandoffManager.instance = new AIContextHandoffManager();\n    }\n    return AIContextHandoffManager.instance;\n  }\n\n  /**\n   * Create a new context handoff\n   */\n  async createHandoff(\n    handoffData: Omit<AIContextHandoff, 'id' | 'timestamp'>\n  ): Promise<string> {\n    const handoffId = this.generateHandoffId();\n    \n    const handoff: AIContextHandoff = {\n      id: handoffId,\n      timestamp: new Date().toISOString(),\n      ...handoffData\n    };\n\n    this.handoffs.push(handoff);\n    this.currentContext = handoff;\n\n    // Maintain local cache size\n    if (this.handoffs.length > this.maxLocalHandoffs) {\n      this.handoffs = this.handoffs.slice(-this.maxLocalHandoffs);\n    }\n\n    // Log the handoff\n    await aiDecisionLogger.logSimpleDecision(\n      `Context handoff created: ${handoffData.handoff_type}`,\n      'workflow_optimization',\n      `Creating handoff context for ${handoffData.to_ai_agent || 'next AI agent'}: ${handoffData.context.context_for_next_ai}`,\n      [],\n      'high'\n    );\n\n    logger.info('AI context handoff created', {\n      handoff_id: handoffId,\n      type: handoffData.handoff_type,\n      from_ai: handoffData.from_ai_agent,\n      to_ai: handoffData.to_ai_agent,\n      priority_items: handoffData.priority_items.length,\n      warnings: handoffData.warnings.length,\n      incomplete_objectives: handoffData.context.incomplete_objectives.length\n    }, 'AI_CONTEXT_HANDOFF');\n\n    try {\n      await this.persistHandoff(handoff);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_CONTEXT_HANDOFF',\n        handoff_id: handoffId,\n        handoff_type: handoffData.handoff_type\n      });\n    }\n\n    return handoffId;\n  }\n\n  /**\n   * Get the latest handoff context\n   */\n  getLatestHandoff(): AIContextHandoff | null {\n    return this.currentContext;\n  }\n\n  /**\n   * Get handoff by ID\n   */\n  getHandoffById(id: string): AIContextHandoff | null {\n    return this.handoffs.find(h => h.id === id) || null;\n  }\n\n  /**\n   * Get handoffs by session\n   */\n  getHandoffsBySession(sessionId: string): AIContextHandoff[] {\n    return this.handoffs.filter(h => h.session_id === sessionId);\n  }\n\n  /**\n   * Get handoffs by AI agent\n   */\n  getHandoffsByAI(aiAgent: string): AIContextHandoff[] {\n    return this.handoffs.filter(h => h.from_ai_agent === aiAgent || h.to_ai_agent === aiAgent);\n  }\n\n  /**\n   * Create a simple handoff with minimal context\n   */\n  async createSimpleHandoff(\n    fromAI: string,\n    toAI: string,\n    currentTask: string,\n    contextMessage: string,\n    incompleteItems: string[] = [],\n    warnings: string[] = []\n  ): Promise<string> {\n    const sessionId = this.generateSessionId();\n    \n    return this.createHandoff({\n      session_id: sessionId,\n      from_ai_agent: fromAI,\n      to_ai_agent: toAI,\n      handoff_type: 'planned_transition',\n      context: {\n        current_task: currentTask,\n        user_request: 'Task handoff',\n        progress_summary: contextMessage,\n        completed_objectives: [],\n        incomplete_objectives: incompleteItems,\n        blocked_items: [],\n        assumptions_made: [],\n        constraints_identified: [],\n        risks_assessed: [],\n        dependencies_discovered: [],\n        context_for_next_ai: contextMessage\n      },\n      system_state: this.getDefaultSystemState(),\n      completion_status: this.getDefaultCompletionStatus(),\n      priority_items: incompleteItems.map((item, index) => ({\n        id: `priority_${index}`,\n        description: item,\n        priority: 'medium' as const,\n        urgency: 'today' as const,\n        category: 'feature' as const,\n        estimated_effort: 'Unknown',\n        dependencies: [],\n        context: contextMessage\n      })),\n      warnings: warnings.map(w => ({\n        type: 'business_logic' as const,\n        severity: 'medium' as const,\n        description: w,\n        affected_areas: [],\n        mitigation_steps: [],\n        monitoring_required: false\n      })),\n      recommendations: [],\n      technical_debt: [],\n      learning_insights: [],\n      next_steps: [],\n      metadata: {}\n    });\n  }\n\n  /**\n   * Create emergency handoff\n   */\n  async createEmergencyHandoff(\n    fromAI: string,\n    criticalIssue: string,\n    systemState: Partial<SystemState>,\n    urgentActions: string[]\n  ): Promise<string> {\n    const sessionId = this.generateSessionId();\n    \n    return this.createHandoff({\n      session_id: sessionId,\n      from_ai_agent: fromAI,\n      handoff_type: 'emergency_handoff',\n      context: {\n        current_task: 'Emergency situation handling',\n        user_request: 'Emergency handoff',\n        progress_summary: `Emergency handoff due to: ${criticalIssue}`,\n        completed_objectives: [],\n        incomplete_objectives: urgentActions,\n        blocked_items: [{\n          description: criticalIssue,\n          blocking_reason: 'Critical issue requiring immediate attention',\n          potential_solutions: urgentActions,\n          escalation_needed: true,\n          priority: 'critical'\n        }],\n        assumptions_made: [],\n        constraints_identified: [],\n        risks_assessed: [{\n          risk_type: 'technical',\n          probability: 'high',\n          impact: 'high',\n          description: criticalIssue,\n          mitigation_strategy: 'Immediate action required',\n          monitoring_plan: 'Continuous monitoring'\n        }],\n        dependencies_discovered: [],\n        context_for_next_ai: `EMERGENCY: ${criticalIssue}. Immediate action required: ${urgentActions.join(', ')}`\n      },\n      system_state: { ...this.getDefaultSystemState(), ...systemState },\n      completion_status: this.getDefaultCompletionStatus(),\n      priority_items: urgentActions.map((action, index) => ({\n        id: `emergency_${index}`,\n        description: action,\n        priority: 'critical' as const,\n        urgency: 'immediate' as const,\n        category: 'bug' as const,\n        estimated_effort: 'Unknown',\n        dependencies: [],\n        context: `Emergency action for: ${criticalIssue}`\n      })),\n      warnings: [{\n        type: 'security',\n        severity: 'critical',\n        description: criticalIssue,\n        affected_areas: ['system'],\n        mitigation_steps: urgentActions,\n        monitoring_required: true\n      }],\n      recommendations: [],\n      technical_debt: [],\n      learning_insights: [],\n      next_steps: urgentActions.map((action, index) => ({\n        step: `emergency_step_${index}`,\n        description: action,\n        priority: 'critical' as const,\n        estimated_duration: 'ASAP',\n        prerequisites: [],\n        success_criteria: ['Issue resolved'],\n        potential_issues: ['System instability']\n      })),\n      metadata: { emergency: true, critical_issue: criticalIssue }\n    });\n  }\n\n  /**\n   * Generate handoff summary report\n   */\n  generateHandoffSummary(handoffId: string): string {\n    const handoff = this.getHandoffById(handoffId);\n    if (!handoff) return 'Handoff not found';\n\n    return `\n# AI Context Handoff Summary\nGenerated: ${new Date().toISOString()}\nHandoff ID: ${handoff.id}\nType: ${handoff.handoff_type}\n\n## Transition Details\n- From: ${handoff.from_ai_agent}\n- To: ${handoff.to_ai_agent || 'Next AI Agent'}\n- Session: ${handoff.session_id}\n- Timestamp: ${handoff.timestamp}\n\n## Current Task\n${handoff.context.current_task}\n\n## Progress Summary\n${handoff.context.progress_summary}\n\n## Completed Objectives\n${handoff.context.completed_objectives.map(obj => `- âœ… ${obj}`).join('\\n')}\n\n## Incomplete Objectives\n${handoff.context.incomplete_objectives.map(obj => `- â³ ${obj}`).join('\\n')}\n\n## Priority Items (${handoff.priority_items.length})\n${handoff.priority_items.map(item => `- [${item.priority.toUpperCase()}] ${item.description}`).join('\\n')}\n\n## Warnings (${handoff.warnings.length})\n${handoff.warnings.map(warning => `- âš ï¸ [${warning.severity.toUpperCase()}] ${warning.description}`).join('\\n')}\n\n## Blocked Items (${handoff.context.blocked_items.length})\n${handoff.context.blocked_items.map(item => `- ðŸš« ${item.description} (${item.blocking_reason})`).join('\\n')}\n\n## Next Steps\n${handoff.next_steps.map(step => `- ${step.description}`).join('\\n')}\n\n## Context for Next AI\n${handoff.context.context_for_next_ai}\n\n## System State\n- Build Status: ${handoff.system_state.build_status.status}\n- Test Status: ${handoff.system_state.test_status.unit_tests.passed}/${handoff.system_state.test_status.unit_tests.passed + handoff.system_state.test_status.unit_tests.failed} unit tests passed\n- Modified Files: ${handoff.system_state.last_modified_files.length}\n\n## Completion Status\nOverall: ${handoff.completion_status.overall_completion}%\nQuality Score: ${handoff.completion_status.quality_metrics.code_quality_score}\n`;\n  }\n\n  /**\n   * Export handoffs\n   */\n  exportHandoffs(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.handoffs, null, 2);\n    } else {\n      // CSV format\n      const headers = ['timestamp', 'from_ai', 'to_ai', 'handoff_type', 'current_task', 'completion_percentage', 'priority_items_count', 'warnings_count'];\n      const rows = this.handoffs.map(h => [\n        h.timestamp,\n        h.from_ai_agent,\n        h.to_ai_agent || 'Unknown',\n        h.handoff_type,\n        h.context.current_task,\n        h.completion_status.overall_completion,\n        h.priority_items.length,\n        h.warnings.length\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateHandoffId(): string {\n    return `handoff_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getDefaultSystemState(): SystemState {\n    return {\n      last_modified_files: [],\n      active_branches: ['main'],\n      database_changes: [],\n      configuration_changes: [],\n      dependency_changes: [],\n      test_status: {\n        unit_tests: { passed: 0, failed: 0, coverage: 0 },\n        integration_tests: { passed: 0, failed: 0, coverage: 0 },\n        e2e_tests: { passed: 0, failed: 0, coverage: 0 },\n        failing_tests: [],\n        test_coverage_delta: 0\n      },\n      build_status: {\n        status: 'success',\n        build_time: 0,\n        warnings: [],\n        errors: [],\n        artifacts_generated: []\n      },\n      deployment_status: {\n        environment: 'development',\n        status: 'deployed',\n        version: '1.0.0',\n        health_check_results: {}\n      },\n      error_state: {\n        critical_errors: [],\n        warnings: [],\n        unhandled_exceptions: [],\n        performance_issues: [],\n        security_alerts: []\n      },\n      performance_metrics: {\n        build_time: 0,\n        test_execution_time: 0,\n        bundle_size: 0,\n        memory_usage: 0,\n        cpu_usage: 0,\n        api_response_times: {}\n      }\n    };\n  }\n\n  private getDefaultCompletionStatus(): CompletionStatus {\n    return {\n      overall_completion: 0,\n      task_breakdown: [],\n      quality_metrics: {\n        code_quality_score: 0,\n        security_score: 0,\n        performance_score: 0,\n        maintainability_score: 0,\n        documentation_score: 0\n      },\n      testing_coverage: {\n        unit_test_coverage: 0,\n        integration_test_coverage: 0,\n        e2e_test_coverage: 0,\n        critical_path_coverage: 0\n      },\n      documentation_status: {\n        api_documentation: 'missing',\n        code_comments: 'missing',\n        user_documentation: 'missing',\n        technical_documentation: 'missing'\n      },\n      code_review_status: {\n        peer_review_completed: false,\n        automated_review_passed: false,\n        security_review_passed: false,\n        performance_review_passed: false,\n        outstanding_issues: []\n      }\n    };\n  }\n\n  private async persistHandoff(handoff: AIContextHandoff): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('ai_context_handoffs')\n        .insert([{\n          id: handoff.id,\n          session_id: handoff.session_id,\n          timestamp: handoff.timestamp,\n          from_ai_agent: handoff.from_ai_agent,\n          to_ai_agent: handoff.to_ai_agent,\n          handoff_type: handoff.handoff_type,\n          context: handoff.context,\n          system_state: handoff.system_state,\n          completion_status: handoff.completion_status,\n          priority_items: handoff.priority_items,\n          warnings: handoff.warnings,\n          recommendations: handoff.recommendations,\n          technical_debt: handoff.technical_debt,\n          learning_insights: handoff.learning_insights,\n          next_steps: handoff.next_steps,\n          metadata: handoff.metadata\n        }]);\n\n      if (error) {\n        throw error;\n      }\n\n      logger.info('AI context handoff persisted to database', {\n        handoff_id: handoff.id,\n        session_id: handoff.session_id\n      }, 'AI_CONTEXT_HANDOFF_PERSIST');\n    } catch (error) {\n      logger.error('Failed to persist AI context handoff', error, 'AI_CONTEXT_HANDOFF_PERSIST');\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const aiContextHandoffManager = AIContextHandoffManager.getInstance();\n\n// Convenience functions\nexport const createHandoff = aiContextHandoffManager.createHandoff.bind(aiContextHandoffManager);\nexport const createSimpleHandoff = aiContextHandoffManager.createSimpleHandoff.bind(aiContextHandoffManager);\nexport const createEmergencyHandoff = aiContextHandoffManager.createEmergencyHandoff.bind(aiContextHandoffManager);\nexport const getLatestHandoff = aiContextHandoffManager.getLatestHandoff.bind(aiContextHandoffManager);\nexport const getHandoffById = aiContextHandoffManager.getHandoffById.bind(aiContextHandoffManager);\nexport const generateHandoffSummary = aiContextHandoffManager.generateHandoffSummary.bind(aiContextHandoffManager);\nexport const exportHandoffs = aiContextHandoffManager.exportHandoffs.bind(aiContextHandoffManager);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/decision-logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[778,781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[778,781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Decision Logger Service for STR Certified\n// Tracks AI decisions, reasoning, and context for multi-AI collaboration\n\nimport { logger } from '../../utils/logger';\nimport { supabase } from '../supabase';\nimport { errorReporter } from '../monitoring/error-reporter';\n\n// AI Decision Types\nexport interface AIDecision {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  ai_agent: string; // e.g., \"claude-sonnet-4\", \"gpt-4\", etc.\n  decision_type: AIDecisionType;\n  action: string;\n  context: AIDecisionContext;\n  reasoning: string;\n  confidence: number; // 0-100\n  impact_level: 'low' | 'medium' | 'high' | 'critical';\n  affected_files: string[];\n  related_decisions: string[]; // IDs of related decisions\n  outcomes?: AIDecisionOutcome[];\n  metadata: Record<string, any>;\n}\n\nexport type AIDecisionType = \n  | 'code_creation'\n  | 'code_modification'\n  | 'code_deletion'\n  | 'architectural_choice'\n  | 'bug_fix'\n  | 'refactoring'\n  | 'security_enhancement'\n  | 'performance_optimization'\n  | 'testing_strategy'\n  | 'documentation_update'\n  | 'dependency_change'\n  | 'configuration_change'\n  | 'database_schema_change'\n  | 'api_design'\n  | 'user_interface_change'\n  | 'business_logic_change'\n  | 'integration_change'\n  | 'deployment_change'\n  | 'monitoring_setup'\n  | 'error_handling'\n  | 'data_migration'\n  | 'workflow_optimization'\n  | 'technical_debt_resolution';\n\nexport interface AIDecisionContext {\n  user_request: string;\n  system_state: string;\n  available_information: string[];\n  constraints: string[];\n  assumptions: string[];\n  alternatives_considered: string[];\n  risks_identified: string[];\n  dependencies: string[];\n  success_criteria: string[];\n  rollback_plan?: string;\n}\n\nexport interface AIDecisionOutcome {\n  timestamp: string;\n  outcome_type: 'success' | 'failure' | 'partial_success' | 'needs_review';\n  description: string;\n  metrics?: Record<string, number>;\n  follow_up_actions?: string[];\n  lessons_learned?: string[];\n}\n\nexport interface AIHandoffContext {\n  session_id: string;\n  timestamp: string;\n  ai_agent: string;\n  next_ai_agent?: string;\n  current_state: string;\n  incomplete_tasks: string[];\n  important_decisions: string[];\n  context_for_next_ai: string;\n  technical_debt_identified: string[];\n  recommendations: string[];\n  warnings: string[];\n}\n\nexport interface AIDecisionQuery {\n  session_id?: string;\n  ai_agent?: string;\n  decision_type?: AIDecisionType;\n  date_range?: {\n    start: string;\n    end: string;\n  };\n  impact_level?: AIDecision['impact_level'];\n  files?: string[];\n  limit?: number;\n}\n\nexport class AIDecisionLogger {\n  private static instance: AIDecisionLogger;\n  private decisions: AIDecision[] = [];\n  private currentSessionId: string;\n  private currentAIAgent: string;\n  private handoffContext: AIHandoffContext | null = null;\n  private maxLocalDecisions = 500;\n  private flushInterval = 30000; // 30 seconds\n  private flushTimer: NodeJS.Timeout | null = null;\n\n  private constructor() {\n    this.currentSessionId = this.generateSessionId();\n    this.currentAIAgent = this.detectAIAgent();\n    this.startFlushTimer();\n  }\n\n  static getInstance(): AIDecisionLogger {\n    if (!AIDecisionLogger.instance) {\n      AIDecisionLogger.instance = new AIDecisionLogger();\n    }\n    return AIDecisionLogger.instance;\n  }\n\n  /**\n   * Log a new AI decision with full context\n   */\n  async logDecision(decision: Omit<AIDecision, 'id' | 'timestamp' | 'session_id' | 'ai_agent'>): Promise<string> {\n    const decisionId = this.generateDecisionId();\n    \n    const fullDecision: AIDecision = {\n      id: decisionId,\n      timestamp: new Date().toISOString(),\n      session_id: this.currentSessionId,\n      ai_agent: this.currentAIAgent,\n      ...decision\n    };\n\n    // Add to local cache\n    this.decisions.push(fullDecision);\n\n    // Maintain local cache size\n    if (this.decisions.length > this.maxLocalDecisions) {\n      this.decisions = this.decisions.slice(-this.maxLocalDecisions);\n    }\n\n    // Log to regular logger for development\n    logger.info(`AI Decision: ${decision.action}`, {\n      decision_id: decisionId,\n      type: decision.decision_type,\n      impact: decision.impact_level,\n      confidence: decision.confidence,\n      files: decision.affected_files,\n      reasoning: decision.reasoning.substring(0, 200) + '...'\n    }, 'AI_DECISION');\n\n    try {\n      // Flush immediately for critical decisions\n      if (decision.impact_level === 'critical') {\n        await this.flushToDatabase([fullDecision]);\n      }\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_DECISION_LOGGING',\n        decision_id: decisionId,\n        decision_type: decision.decision_type\n      });\n    }\n\n    return decisionId;\n  }\n\n  /**\n   * Log a simple decision with minimal context\n   */\n  async logSimpleDecision(\n    action: string,\n    decision_type: AIDecisionType,\n    reasoning: string,\n    affected_files: string[] = [],\n    impact_level: AIDecision['impact_level'] = 'medium'\n  ): Promise<string> {\n    return this.logDecision({\n      decision_type,\n      action,\n      context: {\n        user_request: 'Not specified',\n        system_state: 'Current state at time of decision',\n        available_information: ['System analysis', 'Code review'],\n        constraints: [],\n        assumptions: [],\n        alternatives_considered: [],\n        risks_identified: [],\n        dependencies: [],\n        success_criteria: []\n      },\n      reasoning,\n      confidence: 85, // Default confidence\n      impact_level,\n      affected_files,\n      related_decisions: [],\n      metadata: {}\n    });\n  }\n\n  /**\n   * Update decision outcome\n   */\n  async updateDecisionOutcome(\n    decisionId: string,\n    outcome: AIDecisionOutcome\n  ): Promise<void> {\n    const decision = this.decisions.find(d => d.id === decisionId);\n    if (decision) {\n      if (!decision.outcomes) {\n        decision.outcomes = [];\n      }\n      decision.outcomes.push(outcome);\n\n      // Log outcome\n      logger.info(`Decision outcome updated: ${outcome.outcome_type}`, {\n        decision_id: decisionId,\n        outcome_type: outcome.outcome_type,\n        description: outcome.description\n      }, 'AI_DECISION_OUTCOME');\n    }\n  }\n\n  /**\n   * Set handoff context for next AI\n   */\n  setHandoffContext(context: Omit<AIHandoffContext, 'session_id' | 'timestamp' | 'ai_agent'>): void {\n    this.handoffContext = {\n      session_id: this.currentSessionId,\n      timestamp: new Date().toISOString(),\n      ai_agent: this.currentAIAgent,\n      ...context\n    };\n\n    logger.info('AI handoff context set', {\n      next_ai: context.next_ai_agent,\n      incomplete_tasks: context.incomplete_tasks.length,\n      important_decisions: context.important_decisions.length,\n      warnings: context.warnings.length\n    }, 'AI_HANDOFF');\n  }\n\n  /**\n   * Get handoff context from previous AI\n   */\n  getHandoffContext(): AIHandoffContext | null {\n    return this.handoffContext;\n  }\n\n  /**\n   * Query decisions with filters\n   */\n  queryDecisions(query: AIDecisionQuery): AIDecision[] {\n    let filtered = [...this.decisions];\n\n    if (query.session_id) {\n      filtered = filtered.filter(d => d.session_id === query.session_id);\n    }\n\n    if (query.ai_agent) {\n      filtered = filtered.filter(d => d.ai_agent === query.ai_agent);\n    }\n\n    if (query.decision_type) {\n      filtered = filtered.filter(d => d.decision_type === query.decision_type);\n    }\n\n    if (query.impact_level) {\n      filtered = filtered.filter(d => d.impact_level === query.impact_level);\n    }\n\n    if (query.files && query.files.length > 0) {\n      filtered = filtered.filter(d => \n        d.affected_files.some(file => \n          query.files!.some(queryFile => file.includes(queryFile))\n        )\n      );\n    }\n\n    if (query.date_range) {\n      filtered = filtered.filter(d => {\n        const timestamp = new Date(d.timestamp);\n        const start = new Date(query.date_range!.start);\n        const end = new Date(query.date_range!.end);\n        return timestamp >= start && timestamp <= end;\n      });\n    }\n\n    // Sort by timestamp (newest first)\n    filtered.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n    // Apply limit\n    if (query.limit) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get decisions related to specific files\n   */\n  getDecisionsForFiles(files: string[]): AIDecision[] {\n    return this.queryDecisions({ files });\n  }\n\n  /**\n   * Get recent decisions\n   */\n  getRecentDecisions(limit: number = 20): AIDecision[] {\n    return this.queryDecisions({ limit });\n  }\n\n  /**\n   * Get critical decisions\n   */\n  getCriticalDecisions(): AIDecision[] {\n    return this.queryDecisions({ impact_level: 'critical' });\n  }\n\n  /**\n   * Get current session decisions\n   */\n  getCurrentSessionDecisions(): AIDecision[] {\n    return this.queryDecisions({ session_id: this.currentSessionId });\n  }\n\n  /**\n   * Export decisions for analysis\n   */\n  exportDecisions(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.decisions, null, 2);\n    } else {\n      // CSV format\n      const headers = ['timestamp', 'decision_type', 'action', 'confidence', 'impact_level', 'affected_files', 'reasoning'];\n      const rows = this.decisions.map(d => [\n        d.timestamp,\n        d.decision_type,\n        d.action,\n        d.confidence,\n        d.impact_level,\n        d.affected_files.join(';'),\n        d.reasoning.replace(/\"/g, '\"\"')\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Generate decision summary report\n   */\n  generateSummaryReport(): string {\n    const totalDecisions = this.decisions.length;\n    const decisionsByType = this.decisions.reduce((acc, d) => {\n      acc[d.decision_type] = (acc[d.decision_type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const decisionsByImpact = this.decisions.reduce((acc, d) => {\n      acc[d.impact_level] = (acc[d.impact_level] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const avgConfidence = this.decisions.reduce((sum, d) => sum + d.confidence, 0) / totalDecisions;\n\n    return `\n# AI Decision Summary Report\nGenerated: ${new Date().toISOString()}\nSession: ${this.currentSessionId}\nAI Agent: ${this.currentAIAgent}\n\n## Overview\n- Total Decisions: ${totalDecisions}\n- Average Confidence: ${avgConfidence.toFixed(1)}%\n\n## Decisions by Type\n${Object.entries(decisionsByType).map(([type, count]) => `- ${type}: ${count}`).join('\\n')}\n\n## Decisions by Impact Level\n${Object.entries(decisionsByImpact).map(([level, count]) => `- ${level}: ${count}`).join('\\n')}\n\n## Recent Critical Decisions\n${this.getCriticalDecisions().slice(0, 5).map(d => `- ${d.action} (${d.timestamp})`).join('\\n')}\n`;\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateDecisionId(): string {\n    return `decision_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private detectAIAgent(): string {\n    // Try to detect the AI agent from environment or user agent\n    // For now, default to a generic identifier\n    return process.env.AI_AGENT || 'claude-sonnet-4';\n  }\n\n  private startFlushTimer(): void {\n    if (this.flushTimer) return;\n\n    this.flushTimer = setInterval(() => {\n      this.flushToDatabase(this.decisions);\n    }, this.flushInterval);\n  }\n\n  private async flushToDatabase(decisions: AIDecision[]): Promise<void> {\n    if (decisions.length === 0) return;\n\n    try {\n      const { error } = await supabase\n        .from('ai_decisions')\n        .insert(decisions.map(d => ({\n          id: d.id,\n          timestamp: d.timestamp,\n          session_id: d.session_id,\n          ai_agent: d.ai_agent,\n          decision_type: d.decision_type,\n          action: d.action,\n          context: d.context,\n          reasoning: d.reasoning,\n          confidence: d.confidence,\n          impact_level: d.impact_level,\n          affected_files: d.affected_files,\n          related_decisions: d.related_decisions,\n          outcomes: d.outcomes,\n          metadata: d.metadata\n        })));\n\n      if (error) {\n        throw error;\n      }\n\n      logger.info(`Flushed ${decisions.length} AI decisions to database`, {\n        session_id: this.currentSessionId,\n        decisions_count: decisions.length\n      }, 'AI_DECISION_FLUSH');\n    } catch (error) {\n      logger.error('Failed to flush AI decisions to database', error, 'AI_DECISION_FLUSH');\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy(): void {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    // Final flush\n    this.flushToDatabase(this.decisions);\n  }\n}\n\n// Export singleton instance\nexport const aiDecisionLogger = AIDecisionLogger.getInstance();\n\n// Convenience functions\nexport const logAIDecision = aiDecisionLogger.logDecision.bind(aiDecisionLogger);\nexport const logSimpleAIDecision = aiDecisionLogger.logSimpleDecision.bind(aiDecisionLogger);\nexport const updateDecisionOutcome = aiDecisionLogger.updateDecisionOutcome.bind(aiDecisionLogger);\nexport const setHandoffContext = aiDecisionLogger.setHandoffContext.bind(aiDecisionLogger);\nexport const getHandoffContext = aiDecisionLogger.getHandoffContext.bind(aiDecisionLogger);\nexport const queryAIDecisions = aiDecisionLogger.queryDecisions.bind(aiDecisionLogger);\nexport const exportAIDecisions = aiDecisionLogger.exportDecisions.bind(aiDecisionLogger);\nexport const generateDecisionSummary = aiDecisionLogger.generateSummaryReport.bind(aiDecisionLogger);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/dynamic-checklist-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1169,1172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1169,1172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8761,8764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8761,8764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10352,10355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10352,10355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":644,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":644,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21834,21837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21834,21837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Dynamic Checklist Generator for STR Certified MVP\n// Creates property-specific checklists from VRBO data and amenities\n\nimport { STRCertifiedAIService } from './openai-service';\nimport { aiDecisionLogger } from './decision-logger';\nimport { logger } from '../../utils/logger';\nimport type { VRBOPropertyData, PropertyAmenity } from '../scrapers/types';\n\n// Dynamic Checklist Types\nexport interface DynamicChecklistItem {\n  id: string;\n  title: string;\n  description: string;\n  category: ChecklistCategory;\n  required: boolean;\n  evidenceRequired: boolean;\n  safetyRelated: boolean;\n  complianceRequired: boolean;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  estimatedTimeMinutes: number;\n  order: number;\n  roomSpecific?: string;\n  amenityRelated?: string[];\n  passFailOptions: ('pass' | 'fail' | 'not_applicable')[];\n  naRequiresNote: boolean;\n  expectedSubjects: string[];\n  qualityThreshold: number;\n  isVideoWalkthrough?: boolean;\n  canRename?: boolean;\n  instructions?: string;\n  referencePhotos?: string[];\n  metadata: {\n    generatedFrom: 'vrbo_amenity' | 'property_type' | 'safety_requirement' | 'compliance_rule' | 'bedroom_count';\n    sourceData: any;\n    aiGenerated: boolean;\n  };\n}\n\nexport type ChecklistCategory = \n  | 'safety'\n  | 'compliance'\n  | 'amenities'\n  | 'cleanliness'\n  | 'maintenance'\n  | 'documentation'\n  | 'kitchen'\n  | 'bedrooms'\n  | 'bathrooms'\n  | 'outdoor'\n  | 'entertainment'\n  | 'accessibility'\n  | 'emergency'\n  | 'general';\n\nexport interface ChecklistGenerationOptions {\n  includeVideoWalkthrough: boolean;\n  includeSafetyChecks: boolean;\n  includeComplianceChecks: boolean;\n  includeAmenityVerification: boolean;\n  includeRoomSpecificItems: boolean;\n  customRequirements?: string[];\n  jurisdictionRules?: string[];\n  propertyTypeRules?: string[];\n}\n\nexport interface ChecklistGenerationResult {\n  items: DynamicChecklistItem[];\n  totalItems: number;\n  estimatedTimeMinutes: number;\n  categories: Record<ChecklistCategory, number>;\n  generationMetadata: {\n    propertyId: string;\n    generatedAt: string;\n    sourceAmenities: number;\n    aiGenerated: number;\n    manuallyAdded: number;\n    processingTime: number;\n  };\n}\n\nexport class DynamicChecklistGenerator {\n  private static instance: DynamicChecklistGenerator;\n  private aiService: STRCertifiedAIService;\n  private baseRequirements: DynamicChecklistItem[] = [];\n\n  private constructor() {\n    this.aiService = new STRCertifiedAIService({\n      apiKey: import.meta.env.VITE_OPENAI_API_KEY || '',\n      model: 'gpt-4-turbo-preview',\n      maxTokens: 3000,\n      temperature: 0.2\n    });\n    \n    this.initializeBaseRequirements();\n  }\n\n  static getInstance(): DynamicChecklistGenerator {\n    if (!DynamicChecklistGenerator.instance) {\n      DynamicChecklistGenerator.instance = new DynamicChecklistGenerator();\n    }\n    return DynamicChecklistGenerator.instance;\n  }\n\n  /**\n   * Generates a complete dynamic checklist from VRBO property data\n   * @param propertyData - VRBO property data\n   * @param options - Generation options\n   * @returns Promise<ChecklistGenerationResult>\n   */\n  async generateChecklistFromVRBO(\n    propertyData: VRBOPropertyData,\n    options: ChecklistGenerationOptions = {\n      includeVideoWalkthrough: true,\n      includeSafetyChecks: true,\n      includeComplianceChecks: true,\n      includeAmenityVerification: true,\n      includeRoomSpecificItems: true\n    }\n  ): Promise<ChecklistGenerationResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Log checklist generation start\n      await aiDecisionLogger.logSimpleDecision(\n        `Generate dynamic checklist for property`,\n        'architectural_choice',\n        `Generating checklist for ${propertyData.specifications.bedrooms}BR/${propertyData.specifications.bathrooms}BA property with ${propertyData.amenities.length} amenities`,\n        [],\n        'high'\n      );\n\n      const items: DynamicChecklistItem[] = [];\n      let currentOrder = 1;\n\n      // 1. Add video walkthrough as first item (mandatory)\n      if (options.includeVideoWalkthrough) {\n        items.push(this.createVideoWalkthroughItem(currentOrder++));\n      }\n\n      // 2. Generate bedroom-specific items\n      if (options.includeRoomSpecificItems) {\n        const bedroomItems = this.generateBedroomItems(\n          propertyData.specifications.bedrooms,\n          propertyData.rooms,\n          currentOrder\n        );\n        items.push(...bedroomItems);\n        currentOrder += bedroomItems.length;\n      }\n\n      // 3. Generate bathroom items\n      if (options.includeRoomSpecificItems) {\n        const bathroomItems = this.generateBathroomItems(\n          propertyData.specifications.bathrooms,\n          propertyData.rooms,\n          currentOrder\n        );\n        items.push(...bathroomItems);\n        currentOrder += bathroomItems.length;\n      }\n\n      // 4. Generate amenity-specific items\n      if (options.includeAmenityVerification) {\n        const amenityItems = await this.generateAmenityItems(\n          propertyData.amenities,\n          currentOrder\n        );\n        items.push(...amenityItems);\n        currentOrder += amenityItems.length;\n      }\n\n      // 5. Add safety requirements\n      if (options.includeSafetyChecks) {\n        const safetyItems = this.generateSafetyItems(propertyData, currentOrder);\n        items.push(...safetyItems);\n        currentOrder += safetyItems.length;\n      }\n\n      // 6. Add compliance requirements\n      if (options.includeComplianceChecks) {\n        const complianceItems = this.generateComplianceItems(propertyData, currentOrder);\n        items.push(...complianceItems);\n        currentOrder += complianceItems.length;\n      }\n\n      // 7. Add general inspection items\n      const generalItems = this.generateGeneralItems(propertyData, currentOrder);\n      items.push(...generalItems);\n\n      // 8. Use AI to enhance and validate the checklist\n      const enhancedItems = await this.enhanceChecklistWithAI(items, propertyData);\n\n      // Calculate metadata\n      const totalEstimatedTime = enhancedItems.reduce((sum, item) => sum + item.estimatedTimeMinutes, 0);\n      const categories = this.calculateCategoryDistribution(enhancedItems);\n      const aiGenerated = enhancedItems.filter(item => item.metadata.aiGenerated).length;\n\n      const result: ChecklistGenerationResult = {\n        items: enhancedItems,\n        totalItems: enhancedItems.length,\n        estimatedTimeMinutes: totalEstimatedTime,\n        categories,\n        generationMetadata: {\n          propertyId: propertyData.vrboId,\n          generatedAt: new Date().toISOString(),\n          sourceAmenities: propertyData.amenities.length,\n          aiGenerated,\n          manuallyAdded: enhancedItems.length - aiGenerated,\n          processingTime: Date.now() - startTime\n        }\n      };\n\n      logger.info(`Dynamic checklist generated`, {\n        propertyId: propertyData.vrboId,\n        totalItems: result.totalItems,\n        estimatedTime: result.estimatedTimeMinutes,\n        categories: Object.keys(categories).length,\n        processingTime: result.generationMetadata.processingTime\n      }, 'CHECKLIST_GENERATION');\n\n      return result;\n\n    } catch (error) {\n      logger.error('Failed to generate dynamic checklist', error, 'CHECKLIST_GENERATION');\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the mandatory video walkthrough item\n   * @param order - Order in the checklist\n   * @returns DynamicChecklistItem\n   */\n  private createVideoWalkthroughItem(order: number): DynamicChecklistItem {\n    return {\n      id: 'video_walkthrough_001',\n      title: 'Property Video Walkthrough',\n      description: 'Record a comprehensive video walkthrough of the entire property for auditor review and AI analysis',\n      category: 'documentation',\n      required: true,\n      evidenceRequired: true,\n      safetyRelated: false,\n      complianceRequired: false,\n      priority: 'critical',\n      estimatedTimeMinutes: 15,\n      order,\n      passFailOptions: ['pass', 'fail'],\n      naRequiresNote: false,\n      expectedSubjects: ['all_rooms', 'exterior', 'amenities', 'safety_equipment'],\n      qualityThreshold: 80,\n      isVideoWalkthrough: true,\n      canRename: false,\n      instructions: 'Walk through each room slowly, narrating key features and amenities. Show all areas guests will access.',\n      metadata: {\n        generatedFrom: 'safety_requirement',\n        sourceData: { type: 'mandatory_walkthrough' },\n        aiGenerated: false\n      }\n    };\n  }\n\n  /**\n   * Generates bedroom-specific checklist items\n   * @param bedroomCount - Number of bedrooms\n   * @param rooms - Room data from VRBO\n   * @param startOrder - Starting order number\n   * @returns DynamicChecklistItem[]\n   */\n  private generateBedroomItems(\n    bedroomCount: number,\n    rooms: any[],\n    startOrder: number\n  ): DynamicChecklistItem[] {\n    const items: DynamicChecklistItem[] = [];\n    \n    for (let i = 1; i <= bedroomCount; i++) {\n      const bedroomItem: DynamicChecklistItem = {\n        id: `bedroom_${i}_inspection`,\n        title: `Bedroom ${i}`,\n        description: `Inspect bedroom ${i} for cleanliness, safety, and amenities`,\n        category: 'bedrooms',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: true,\n        complianceRequired: false,\n        priority: 'high',\n        estimatedTimeMinutes: 8,\n        order: startOrder + i - 1,\n        roomSpecific: `bedroom_${i}`,\n        passFailOptions: ['pass', 'fail', 'not_applicable'],\n        naRequiresNote: true,\n        expectedSubjects: ['bed', 'furniture', 'lighting', 'windows', 'outlets'],\n        qualityThreshold: 75,\n        canRename: true,\n        instructions: `Check bed quality, linens, furniture condition, lighting, and safety features. Rename if needed (e.g., \"Primary Bedroom\", \"Kids Room\").`,\n        metadata: {\n          generatedFrom: 'bedroom_count',\n          sourceData: { bedroomNumber: i, totalBedrooms: bedroomCount },\n          aiGenerated: false\n        }\n      };\n      \n      items.push(bedroomItem);\n    }\n    \n    return items;\n  }\n\n  /**\n   * Generates bathroom-specific checklist items\n   * @param bathroomCount - Number of bathrooms\n   * @param rooms - Room data from VRBO\n   * @param startOrder - Starting order number\n   * @returns DynamicChecklistItem[]\n   */\n  private generateBathroomItems(\n    bathroomCount: number,\n    rooms: any[],\n    startOrder: number\n  ): DynamicChecklistItem[] {\n    const items: DynamicChecklistItem[] = [];\n    \n    for (let i = 1; i <= bathroomCount; i++) {\n      const bathroomItem: DynamicChecklistItem = {\n        id: `bathroom_${i}_inspection`,\n        title: `Bathroom ${i}`,\n        description: `Inspect bathroom ${i} for cleanliness, functionality, and safety`,\n        category: 'bathrooms',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: true,\n        complianceRequired: true,\n        priority: 'high',\n        estimatedTimeMinutes: 10,\n        order: startOrder + i - 1,\n        roomSpecific: `bathroom_${i}`,\n        passFailOptions: ['pass', 'fail', 'not_applicable'],\n        naRequiresNote: true,\n        expectedSubjects: ['toilet', 'sink', 'shower_tub', 'fixtures', 'ventilation'],\n        qualityThreshold: 80,\n        canRename: false,\n        instructions: `Check all fixtures, plumbing, cleanliness, ventilation, and safety features. Test water pressure and temperature.`,\n        metadata: {\n          generatedFrom: 'property_type',\n          sourceData: { bathroomNumber: i, totalBathrooms: bathroomCount },\n          aiGenerated: false\n        }\n      };\n      \n      items.push(bathroomItem);\n    }\n    \n    return items;\n  }\n\n  /**\n   * Generates amenity-specific checklist items using AI\n   * @param amenities - Property amenities from VRBO\n   * @param startOrder - Starting order number\n   * @returns Promise<DynamicChecklistItem[]>\n   */\n  private async generateAmenityItems(\n    amenities: PropertyAmenity[],\n    startOrder: number\n  ): Promise<DynamicChecklistItem[]> {\n    const items: DynamicChecklistItem[] = [];\n    \n    // Filter high-priority amenities that need verification\n    const verifiableAmenities = amenities.filter(amenity => \n      amenity.priority === 'essential' || \n      amenity.priority === 'important' ||\n      amenity.category === 'safety'\n    );\n\n    for (let i = 0; i < verifiableAmenities.length; i++) {\n      const amenity = verifiableAmenities[i];\n      const item = await this.createAmenityChecklistItem(amenity, startOrder + i);\n      items.push(item);\n    }\n\n    return items;\n  }\n\n  /**\n   * Creates a checklist item for a specific amenity\n   * @param amenity - Property amenity\n   * @param order - Order in checklist\n   * @returns Promise<DynamicChecklistItem>\n   */\n  private async createAmenityChecklistItem(\n    amenity: PropertyAmenity,\n    order: number\n  ): Promise<DynamicChecklistItem> {\n    const amenityInstructions = this.getAmenityInstructions(amenity);\n    \n    return {\n      id: `amenity_${amenity.name.toLowerCase().replace(/\\s+/g, '_')}_${order}`,\n      title: `${amenity.name} Verification`,\n      description: `Verify the ${amenity.name} is present, functional, and matches listing description`,\n      category: this.mapAmenityToCategory(amenity.category),\n      required: amenity.priority === 'essential',\n      evidenceRequired: true,\n      safetyRelated: amenity.category === 'safety',\n      complianceRequired: amenity.category === 'safety' || amenity.category === 'accessibility',\n      priority: this.mapAmenityPriority(amenity.priority),\n      estimatedTimeMinutes: this.getAmenityInspectionTime(amenity),\n      order,\n      amenityRelated: [amenity.name],\n      passFailOptions: ['pass', 'fail', 'not_applicable'],\n      naRequiresNote: true,\n      expectedSubjects: this.getAmenityExpectedSubjects(amenity),\n      qualityThreshold: amenity.priority === 'essential' ? 85 : 75,\n      canRename: false,\n      instructions: amenityInstructions,\n      metadata: {\n        generatedFrom: 'vrbo_amenity',\n        sourceData: amenity,\n        aiGenerated: false\n      }\n    };\n  }\n\n  /**\n   * Generates safety-related checklist items\n   * @param propertyData - VRBO property data\n   * @param startOrder - Starting order number\n   * @returns DynamicChecklistItem[]\n   */\n  private generateSafetyItems(\n    propertyData: VRBOPropertyData,\n    startOrder: number\n  ): DynamicChecklistItem[] {\n    const safetyItems: DynamicChecklistItem[] = [\n      {\n        id: 'smoke_detector_check',\n        title: 'Smoke Detector Inspection',\n        description: 'Verify smoke detectors are present, functional, and have fresh batteries',\n        category: 'safety',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: true,\n        complianceRequired: true,\n        priority: 'critical',\n        estimatedTimeMinutes: 5,\n        order: startOrder,\n        passFailOptions: ['pass', 'fail'],\n        naRequiresNote: false,\n        expectedSubjects: ['smoke_detector', 'battery_indicator', 'test_button'],\n        qualityThreshold: 90,\n        canRename: false,\n        instructions: 'Test each smoke detector and check battery levels. Document any issues.',\n        metadata: {\n          generatedFrom: 'safety_requirement',\n          sourceData: { type: 'smoke_detection' },\n          aiGenerated: false\n        }\n      },\n      {\n        id: 'fire_extinguisher_check',\n        title: 'Fire Extinguisher Inspection',\n        description: 'Verify fire extinguisher is present, accessible, and within inspection dates',\n        category: 'safety',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: true,\n        complianceRequired: true,\n        priority: 'critical',\n        estimatedTimeMinutes: 3,\n        order: startOrder + 1,\n        passFailOptions: ['pass', 'fail', 'not_applicable'],\n        naRequiresNote: true,\n        expectedSubjects: ['fire_extinguisher', 'inspection_tag', 'mounting_bracket'],\n        qualityThreshold: 90,\n        canRename: false,\n        instructions: 'Check expiration date, pressure gauge, and accessibility. Note if not required by local code.',\n        metadata: {\n          generatedFrom: 'safety_requirement',\n          sourceData: { type: 'fire_safety' },\n          aiGenerated: false\n        }\n      },\n      {\n        id: 'emergency_exits_check',\n        title: 'Emergency Exits Inspection',\n        description: 'Verify all emergency exits are clearly marked and unobstructed',\n        category: 'safety',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: true,\n        complianceRequired: true,\n        priority: 'critical',\n        estimatedTimeMinutes: 4,\n        order: startOrder + 2,\n        passFailOptions: ['pass', 'fail'],\n        naRequiresNote: false,\n        expectedSubjects: ['exit_doors', 'exit_signs', 'clear_pathways'],\n        qualityThreshold: 85,\n        canRename: false,\n        instructions: 'Check all exit doors open easily and pathways are clear of obstructions.',\n        metadata: {\n          generatedFrom: 'safety_requirement',\n          sourceData: { type: 'emergency_egress' },\n          aiGenerated: false\n        }\n      }\n    ];\n\n    return safetyItems;\n  }\n\n  /**\n   * Generates compliance-related checklist items\n   * @param propertyData - VRBO property data\n   * @param startOrder - Starting order number\n   * @returns DynamicChecklistItem[]\n   */\n  private generateComplianceItems(\n    propertyData: VRBOPropertyData,\n    startOrder: number\n  ): DynamicChecklistItem[] {\n    const complianceItems: DynamicChecklistItem[] = [\n      {\n        id: 'occupancy_limits_check',\n        title: 'Occupancy Limits Verification',\n        description: 'Verify sleeping arrangements match advertised capacity',\n        category: 'compliance',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: false,\n        complianceRequired: true,\n        priority: 'high',\n        estimatedTimeMinutes: 5,\n        order: startOrder,\n        passFailOptions: ['pass', 'fail'],\n        naRequiresNote: false,\n        expectedSubjects: ['bed_count', 'sleeping_areas', 'capacity_signage'],\n        qualityThreshold: 80,\n        canRename: false,\n        instructions: 'Count actual sleeping spaces and verify they match listing capacity.',\n        metadata: {\n          generatedFrom: 'compliance_rule',\n          sourceData: { maxGuests: propertyData.specifications.maxGuests },\n          aiGenerated: false\n        }\n      }\n    ];\n\n    return complianceItems;\n  }\n\n  /**\n   * Generates general inspection items\n   * @param propertyData - VRBO property data\n   * @param startOrder - Starting order number\n   * @returns DynamicChecklistItem[]\n   */\n  private generateGeneralItems(\n    propertyData: VRBOPropertyData,\n    startOrder: number\n  ): DynamicChecklistItem[] {\n    const generalItems: DynamicChecklistItem[] = [\n      {\n        id: 'overall_cleanliness_check',\n        title: 'Overall Cleanliness Assessment',\n        description: 'Assess general cleanliness and maintenance of the property',\n        category: 'cleanliness',\n        required: true,\n        evidenceRequired: true,\n        safetyRelated: false,\n        complianceRequired: false,\n        priority: 'high',\n        estimatedTimeMinutes: 10,\n        order: startOrder,\n        passFailOptions: ['pass', 'fail'],\n        naRequiresNote: false,\n        expectedSubjects: ['general_condition', 'maintenance_issues', 'cleanliness_level'],\n        qualityThreshold: 75,\n        canRename: false,\n        instructions: 'Document overall property condition, noting any maintenance or cleanliness issues.',\n        metadata: {\n          generatedFrom: 'property_type',\n          sourceData: { type: 'general_inspection' },\n          aiGenerated: false\n        }\n      }\n    ];\n\n    return generalItems;\n  }\n\n  /**\n   * Uses AI to enhance and validate the generated checklist\n   * @param items - Generated checklist items\n   * @param propertyData - VRBO property data\n   * @returns Promise<DynamicChecklistItem[]>\n   */\n  private async enhanceChecklistWithAI(\n    items: DynamicChecklistItem[],\n    propertyData: VRBOPropertyData\n  ): Promise<DynamicChecklistItem[]> {\n    try {\n      const prompt = this.buildEnhancementPrompt(items, propertyData);\n      \n      const response = await this.aiService.generateDynamicChecklist({\n        property_type: propertyData.specifications.propertyType,\n        room_count: {\n          bedrooms: propertyData.specifications.bedrooms,\n          bathrooms: propertyData.specifications.bathrooms\n        },\n        amenities: propertyData.amenities.map(a => a.name),\n        description: propertyData.description,\n        location: propertyData.location,\n        special_features: propertyData.amenities.map(a => a.name)\n      });\n\n      // Merge AI suggestions with existing items\n      const enhancedItems = [...items];\n      \n      // Add AI-generated items that don't conflict with existing ones\n      response.forEach(aiItem => {\n        const existingItem = enhancedItems.find(item => \n          item.title.toLowerCase().includes(aiItem.title.toLowerCase()) ||\n          aiItem.title.toLowerCase().includes(item.title.toLowerCase())\n        );\n        \n        if (!existingItem && aiItem.title && aiItem.description) {\n          enhancedItems.push(this.convertAIItemToChecklistItem(aiItem, enhancedItems.length + 1));\n        }\n      });\n\n      return enhancedItems.sort((a, b) => a.order - b.order);\n    } catch (error) {\n      logger.error('AI enhancement failed, using base checklist', error, 'CHECKLIST_AI_ENHANCEMENT');\n      return items;\n    }\n  }\n\n  /**\n   * Converts AI-generated item to our checklist item format\n   * @param aiItem - AI-generated checklist item\n   * @param order - Order in checklist\n   * @returns DynamicChecklistItem\n   */\n  private convertAIItemToChecklistItem(aiItem: any, order: number): DynamicChecklistItem {\n    return {\n      id: `ai_generated_${order}`,\n      title: aiItem.title,\n      description: aiItem.description,\n      category: aiItem.category || 'general',\n      required: aiItem.required || false,\n      evidenceRequired: true,\n      safetyRelated: aiItem.category === 'safety',\n      complianceRequired: aiItem.category === 'compliance',\n      priority: aiItem.priority || 'medium',\n      estimatedTimeMinutes: aiItem.estimated_time_minutes || 5,\n      order,\n      passFailOptions: ['pass', 'fail', 'not_applicable'],\n      naRequiresNote: true,\n      expectedSubjects: [aiItem.title.toLowerCase().replace(/\\s+/g, '_')],\n      qualityThreshold: 75,\n      canRename: false,\n      metadata: {\n        generatedFrom: 'vrbo_amenity',\n        sourceData: aiItem,\n        aiGenerated: true\n      }\n    };\n  }\n\n  // Helper methods for amenity processing\n\n  private getAmenityInstructions(amenity: PropertyAmenity): string {\n    const instructions: Record<string, string> = {\n      'Hot Tub': 'Check water temperature, cleanliness, and safety features. Verify cover is present.',\n      'Fireplace': 'Inspect safety screen, damper, and surrounding area. Check for soot or damage.',\n      'Pool': 'Verify water clarity, safety barriers, and pool equipment functionality.',\n      'WiFi': 'Test internet connectivity and speed. Check router location and signal strength.',\n      'Kitchen': 'Inspect all appliances, cookware, and cleanliness. Test stove, oven, and refrigerator.',\n      'Parking': 'Verify parking spaces match listing description and are accessible.',\n      'Air Conditioning': 'Test cooling function and check filter condition.',\n      'Heating': 'Test heating system and check thermostat functionality.'\n    };\n    \n    return instructions[amenity.name] || \n           `Verify ${amenity.name} is present, functional, and matches the listing description.`;\n  }\n\n  private mapAmenityToCategory(amenityCategory: string): ChecklistCategory {\n    const categoryMap: Record<string, ChecklistCategory> = {\n      'kitchen': 'kitchen',\n      'outdoor': 'outdoor',\n      'entertainment': 'entertainment',\n      'safety': 'safety',\n      'accessibility': 'accessibility',\n      'general': 'general',\n      'laundry': 'maintenance',\n      'parking': 'general',\n      'connectivity': 'general',\n      'climate': 'maintenance'\n    };\n    \n    return categoryMap[amenityCategory] || 'general';\n  }\n\n  private mapAmenityPriority(amenityPriority: string): 'critical' | 'high' | 'medium' | 'low' {\n    const priorityMap: Record<string, 'critical' | 'high' | 'medium' | 'low'> = {\n      'essential': 'critical',\n      'important': 'high',\n      'nice_to_have': 'medium'\n    };\n    \n    return priorityMap[amenityPriority] || 'medium';\n  }\n\n  private getAmenityInspectionTime(amenity: PropertyAmenity): number {\n    const timeMap: Record<string, number> = {\n      'Hot Tub': 8,\n      'Pool': 10,\n      'Fireplace': 6,\n      'Kitchen': 12,\n      'WiFi': 3,\n      'Air Conditioning': 4,\n      'Heating': 4,\n      'Parking': 2\n    };\n    \n    return timeMap[amenity.name] || 5;\n  }\n\n  private getAmenityExpectedSubjects(amenity: PropertyAmenity): string[] {\n    const subjectMap: Record<string, string[]> = {\n      'Hot Tub': ['hot_tub', 'cover', 'controls', 'safety_features'],\n      'Fireplace': ['fireplace', 'screen', 'damper', 'surrounding_area'],\n      'Pool': ['pool', 'water', 'safety_barriers', 'equipment'],\n      'Kitchen': ['appliances', 'cookware', 'utensils', 'cleanliness'],\n      'WiFi': ['router', 'signal_strength', 'connectivity'],\n      'Parking': ['parking_spaces', 'accessibility', 'markings']\n    };\n    \n    return subjectMap[amenity.name] || [amenity.name.toLowerCase().replace(/\\s+/g, '_')];\n  }\n\n  private buildEnhancementPrompt(items: DynamicChecklistItem[], propertyData: VRBOPropertyData): string {\n    return `\nReview and enhance this STR inspection checklist:\n\nProperty: ${propertyData.title}\nType: ${propertyData.specifications.propertyType}\nBedrooms: ${propertyData.specifications.bedrooms}\nBathrooms: ${propertyData.specifications.bathrooms}\nAmenities: ${propertyData.amenities.map(a => a.name).join(', ')}\n\nCurrent checklist has ${items.length} items. \n\nPlease suggest 3-5 additional items that would improve the inspection quality based on:\n1. Property-specific features mentioned in the description\n2. Location-specific requirements (${propertyData.location.city}, ${propertyData.location.state})\n3. Common issues for this property type\n4. Missing safety or compliance checks\n\nFocus on actionable, specific items that an inspector can verify with photo evidence.\n    `.trim();\n  }\n\n  private calculateCategoryDistribution(items: DynamicChecklistItem[]): Record<ChecklistCategory, number> {\n    const distribution: Record<ChecklistCategory, number> = {\n      safety: 0,\n      compliance: 0,\n      amenities: 0,\n      cleanliness: 0,\n      maintenance: 0,\n      documentation: 0,\n      kitchen: 0,\n      bedrooms: 0,\n      bathrooms: 0,\n      outdoor: 0,\n      entertainment: 0,\n      accessibility: 0,\n      emergency: 0,\n      general: 0\n    };\n\n    items.forEach(item => {\n      distribution[item.category]++;\n    });\n\n    return distribution;\n  }\n\n  private initializeBaseRequirements(): void {\n    // Initialize with any base requirements that should always be included\n    this.baseRequirements = [];\n  }\n}\n\n// Export singleton instance\nexport const dynamicChecklistGenerator = DynamicChecklistGenerator.getInstance();\n\n// Export convenience function\nexport const generateChecklistFromVRBO = dynamicChecklistGenerator.generateChecklistFromVRBO.bind(dynamicChecklistGenerator);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/feedback-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/knowledge-base.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":483,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":483,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13680,13683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13680,13683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":538,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":538,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14993,14996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14993,14996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":544,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":544,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15074,15077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15074,15077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Knowledge Base for STR Certified AI Learning System\n// Manages external knowledge sources for RAG (Retrieval Augmented Generation)\n\nimport type {\n  KnowledgeEntry,\n  KnowledgeCategory\n} from '@/types/learning';\n\nexport class KnowledgeBase {\n  private entries: Map<string, KnowledgeEntry> = new Map();\n  private vectorIndex: VectorIndex;\n  private embeddingModel: EmbeddingModel;\n\n  constructor(\n    embeddingModel: string = 'text-embedding-ada-002',\n    vectorDimension: number = 1536\n  ) {\n    this.embeddingModel = new EmbeddingModel(embeddingModel);\n    this.vectorIndex = new VectorIndex(vectorDimension);\n    this.initializeKnowledgeBase();\n  }\n\n  /**\n   * Adds a new knowledge entry to the base\n   */\n  async addEntry(\n    entry: Omit<KnowledgeEntry, 'id' | 'embeddings' | 'usage' | 'lastUpdated'>\n  ): Promise<KnowledgeEntry> {\n    // Generate ID\n    const id = `kb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Generate embeddings\n    const embeddings = await this.embeddingModel.embed(entry.content);\n\n    // Create full entry\n    const knowledgeEntry: KnowledgeEntry = {\n      ...entry,\n      id,\n      embeddings: {\n        vector: embeddings,\n        model: this.embeddingModel.modelName,\n        dimension: embeddings.length\n      },\n      usage: {\n        queryCount: 0,\n        relevanceScore: 1.0,\n        citationCount: 0\n      },\n      lastUpdated: new Date()\n    };\n\n    // Store entry\n    this.entries.set(id, knowledgeEntry);\n\n    // Index vector\n    await this.vectorIndex.add(id, embeddings, {\n      category: entry.category,\n      tags: entry.metadata.tags\n    });\n\n    return knowledgeEntry;\n  }\n\n  /**\n   * Updates an existing knowledge entry\n   */\n  async updateEntry(\n    id: string,\n    updates: Partial<Omit<KnowledgeEntry, 'id' | 'embeddings'>>\n  ): Promise<KnowledgeEntry | null> {\n    const existing = this.entries.get(id);\n    if (!existing) return null;\n\n    // Update content and regenerate embeddings if content changed\n    let embeddings = existing.embeddings;\n    if (updates.content && updates.content !== existing.content) {\n      const newEmbeddings = await this.embeddingModel.embed(updates.content);\n      embeddings = {\n        vector: newEmbeddings,\n        model: this.embeddingModel.modelName,\n        dimension: newEmbeddings.length\n      };\n\n      // Update vector index\n      await this.vectorIndex.update(id, newEmbeddings);\n    }\n\n    // Create updated entry\n    const updated: KnowledgeEntry = {\n      ...existing,\n      ...updates,\n      embeddings,\n      lastUpdated: new Date()\n    };\n\n    this.entries.set(id, updated);\n    return updated;\n  }\n\n  /**\n   * Searches the knowledge base using semantic similarity\n   */\n  async search(\n    query: string,\n    options: {\n      limit?: number;\n      threshold?: number;\n      categories?: KnowledgeCategory[];\n      tags?: string[];\n      jurisdiction?: string;\n    } = {}\n  ): Promise<SearchResult[]> {\n    const {\n      limit = 5,\n      threshold = 0.7,\n      categories,\n      tags,\n      jurisdiction\n    } = options;\n\n    // Generate query embeddings\n    const queryEmbeddings = await this.embeddingModel.embed(query);\n\n    // Search vector index\n    const similarVectors = await this.vectorIndex.search(queryEmbeddings, limit * 2);\n\n    // Filter and rank results\n    const results: SearchResult[] = [];\n    \n    for (const match of similarVectors) {\n      const entry = this.entries.get(match.id);\n      if (!entry) continue;\n\n      // Apply filters\n      if (categories && !categories.includes(entry.category)) continue;\n      if (tags && !tags.some(tag => entry.metadata.tags.includes(tag))) continue;\n      if (jurisdiction && entry.metadata.jurisdiction !== jurisdiction) continue;\n      if (match.similarity < threshold) continue;\n\n      // Check if entry is still valid\n      if (entry.status !== 'active') continue;\n      if (entry.metadata.expirationDate && entry.metadata.expirationDate < new Date()) continue;\n\n      results.push({\n        entry,\n        similarity: match.similarity,\n        relevance: this.calculateRelevance(entry, query, match.similarity)\n      });\n    }\n\n    // Sort by relevance and limit\n    results.sort((a, b) => b.relevance - a.relevance);\n    const finalResults = results.slice(0, limit);\n\n    // Update usage statistics\n    for (const result of finalResults) {\n      result.entry.usage.queryCount++;\n      result.entry.usage.lastQueried = new Date();\n    }\n\n    return finalResults;\n  }\n\n  /**\n   * Gets entries by category\n   */\n  getByCategory(category: KnowledgeCategory): KnowledgeEntry[] {\n    return Array.from(this.entries.values())\n      .filter(entry => entry.category === category && entry.status === 'active');\n  }\n\n  /**\n   * Gets entries by regulation type\n   */\n  getByRegulationType(\n    regulationType: string,\n    jurisdiction?: string\n  ): KnowledgeEntry[] {\n    return Array.from(this.entries.values())\n      .filter(entry => \n        entry.metadata.regulationType === regulationType &&\n        (!jurisdiction || entry.metadata.jurisdiction === jurisdiction) &&\n        entry.status === 'active'\n      );\n  }\n\n  /**\n   * Validates knowledge base consistency\n   */\n  async validate(): Promise<ValidationReport> {\n    const issues: ValidationIssue[] = [];\n    let validEntries = 0;\n    let expiredEntries = 0;\n    let deprecatedEntries = 0;\n\n    for (const [id, entry] of this.entries) {\n      // Check expiration\n      if (entry.metadata.expirationDate && entry.metadata.expirationDate < new Date()) {\n        expiredEntries++;\n        issues.push({\n          entryId: id,\n          type: 'expired',\n          message: `Entry expired on ${entry.metadata.expirationDate.toISOString()}`\n        });\n      }\n\n      // Check deprecation\n      if (entry.status === 'deprecated') {\n        deprecatedEntries++;\n      }\n\n      // Check embedding consistency\n      if (entry.embeddings.dimension !== this.vectorIndex.dimension) {\n        issues.push({\n          entryId: id,\n          type: 'dimension_mismatch',\n          message: `Embedding dimension ${entry.embeddings.dimension} doesn't match index dimension ${this.vectorIndex.dimension}`\n        });\n      }\n\n      // Check content length\n      if (entry.content.length < 50) {\n        issues.push({\n          entryId: id,\n          type: 'content_too_short',\n          message: 'Content is too short to be useful'\n        });\n      }\n\n      if (entry.status === 'active' && !issues.some(i => i.entryId === id)) {\n        validEntries++;\n      }\n    }\n\n    return {\n      totalEntries: this.entries.size,\n      validEntries,\n      expiredEntries,\n      deprecatedEntries,\n      issues,\n      lastValidated: new Date()\n    };\n  }\n\n  /**\n   * Exports knowledge base to JSON\n   */\n  exportToJSON(): string {\n    const data = {\n      version: '1.0',\n      exported: new Date().toISOString(),\n      entries: Array.from(this.entries.values()).map(entry => ({\n        ...entry,\n        embeddings: {\n          ...entry.embeddings,\n          vector: undefined // Exclude vectors from export\n        }\n      }))\n    };\n\n    return JSON.stringify(data, null, 2);\n  }\n\n  /**\n   * Imports knowledge base from JSON\n   */\n  async importFromJSON(json: string): Promise<ImportResult> {\n    const data = JSON.parse(json);\n    let imported = 0;\n    let skipped = 0;\n    const errors: string[] = [];\n\n    for (const entry of data.entries) {\n      try {\n        // Skip if already exists\n        if (this.entries.has(entry.id)) {\n          skipped++;\n          continue;\n        }\n\n        // Re-generate embeddings\n        const embeddings = await this.embeddingModel.embed(entry.content);\n        \n        const knowledgeEntry: KnowledgeEntry = {\n          ...entry,\n          embeddings: {\n            vector: embeddings,\n            model: this.embeddingModel.modelName,\n            dimension: embeddings.length\n          },\n          lastUpdated: new Date(entry.lastUpdated)\n        };\n\n        this.entries.set(entry.id, knowledgeEntry);\n        await this.vectorIndex.add(entry.id, embeddings, {\n          category: entry.category,\n          tags: entry.metadata.tags\n        });\n\n        imported++;\n      } catch (error) {\n        errors.push(`Failed to import ${entry.id}: ${error}`);\n      }\n    }\n\n    return { imported, skipped, errors };\n  }\n\n  /**\n   * Gets popular/frequently used entries\n   */\n  getPopularEntries(limit: number = 10): KnowledgeEntry[] {\n    return Array.from(this.entries.values())\n      .filter(entry => entry.status === 'active')\n      .sort((a, b) => b.usage.queryCount - a.usage.queryCount)\n      .slice(0, limit);\n  }\n\n  /**\n   * Gets recently updated entries\n   */\n  getRecentlyUpdated(limit: number = 10): KnowledgeEntry[] {\n    return Array.from(this.entries.values())\n      .filter(entry => entry.status === 'active')\n      .sort((a, b) => b.lastUpdated.getTime() - a.lastUpdated.getTime())\n      .slice(0, limit);\n  }\n\n  /**\n   * Cleans up expired and deprecated entries\n   */\n  async cleanup(): Promise<CleanupResult> {\n    let removed = 0;\n    const toRemove: string[] = [];\n\n    for (const [id, entry] of this.entries) {\n      // Remove expired entries older than 30 days\n      if (entry.metadata.expirationDate) {\n        const daysSinceExpiration = (Date.now() - entry.metadata.expirationDate.getTime()) / (1000 * 60 * 60 * 24);\n        if (daysSinceExpiration > 30) {\n          toRemove.push(id);\n        }\n      }\n\n      // Remove deprecated entries with no recent usage\n      if (entry.status === 'deprecated' && entry.usage.queryCount === 0) {\n        toRemove.push(id);\n      }\n    }\n\n    // Remove entries\n    for (const id of toRemove) {\n      this.entries.delete(id);\n      await this.vectorIndex.remove(id);\n      removed++;\n    }\n\n    return {\n      removed,\n      remaining: this.entries.size\n    };\n  }\n\n  // Private helper methods\n\n  private initializeKnowledgeBase(): void {\n    // Initialize with some default knowledge entries\n    const defaultEntries = [\n      {\n        category: 'building_codes' as KnowledgeCategory,\n        title: 'Minimum Room Dimensions',\n        content: 'According to International Residential Code (IRC), habitable rooms must have a floor area of not less than 70 square feet. Habitable rooms, other than kitchens, must be at least 7 feet in any horizontal dimension.',\n        source: 'IRC Section R304.1',\n        metadata: {\n          regulationType: 'building_code' as const,\n          jurisdiction: 'International',\n          tags: ['room-size', 'dimensions', 'habitable-space'],\n          version: '2021',\n          effectiveDate: new Date('2021-01-01')\n        },\n        status: 'active' as const\n      },\n      {\n        category: 'fire_safety' as KnowledgeCategory,\n        title: 'Smoke Detector Requirements',\n        content: 'Smoke alarms shall be installed in each sleeping room, outside each separate sleeping area in the immediate vicinity of the bedrooms, and on each additional story of the dwelling, including basements and habitable attics.',\n        source: 'IRC Section R314.3',\n        metadata: {\n          regulationType: 'fire' as const,\n          jurisdiction: 'International',\n          tags: ['smoke-detector', 'fire-safety', 'bedroom'],\n          version: '2021',\n          effectiveDate: new Date('2021-01-01')\n        },\n        status: 'active' as const\n      },\n      {\n        category: 'ada_compliance' as KnowledgeCategory,\n        title: 'Accessible Route Width',\n        content: 'An accessible route must have a clear width of 36 inches minimum. The clear width of walking surfaces shall be 36 inches minimum, except at doors and doorways.',\n        source: 'ADA Standards Section 403.5',\n        metadata: {\n          regulationType: 'ada' as const,\n          jurisdiction: 'United States',\n          tags: ['accessibility', 'route-width', 'ada'],\n          version: '2010',\n          effectiveDate: new Date('2010-09-15')\n        },\n        status: 'active' as const\n      }\n    ];\n\n    // Add default entries\n    defaultEntries.forEach(entry => {\n      this.addEntry(entry).catch(console.error);\n    });\n  }\n\n  private calculateRelevance(\n    entry: KnowledgeEntry,\n    query: string,\n    similarity: number\n  ): number {\n    let relevance = similarity * 100;\n\n    // Boost for recent entries\n    const daysSinceUpdate = (Date.now() - entry.lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\n    if (daysSinceUpdate < 30) {\n      relevance += 5;\n    }\n\n    // Boost for frequently used entries\n    if (entry.usage.queryCount > 10) {\n      relevance += Math.min(10, entry.usage.queryCount / 10);\n    }\n\n    // Boost for high relevance score\n    relevance += entry.usage.relevanceScore * 5;\n\n    // Penalty for deprecated entries\n    if (entry.status === 'deprecated') {\n      relevance -= 20;\n    }\n\n    return Math.min(100, relevance);\n  }\n}\n\n// Supporting classes\n\nclass EmbeddingModel {\n  constructor(public modelName: string) {}\n\n  async embed(text: string): Promise<number[]> {\n    // Mock embedding generation\n    // In production, would call OpenAI API\n    const hash = this.hashString(text);\n    const embedding = new Array(1536).fill(0);\n    \n    for (let i = 0; i < embedding.length; i++) {\n      embedding[i] = Math.sin(hash * (i + 1)) * Math.cos(hash / (i + 1));\n    }\n\n    return embedding;\n  }\n\n  private hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash);\n  }\n}\n\nclass VectorIndex {\n  private vectors: Map<string, Vector> = new Map();\n\n  constructor(public dimension: number) {}\n\n  async add(id: string, vector: number[], metadata?: any): Promise<void> {\n    this.vectors.set(id, { id, vector, metadata });\n  }\n\n  async update(id: string, vector: number[]): Promise<void> {\n    const existing = this.vectors.get(id);\n    if (existing) {\n      existing.vector = vector;\n    }\n  }\n\n  async remove(id: string): Promise<void> {\n    this.vectors.delete(id);\n  }\n\n  async search(query: number[], limit: number): Promise<VectorMatch[]> {\n    const matches: VectorMatch[] = [];\n\n    for (const [id, vector] of this.vectors) {\n      const similarity = this.cosineSimilarity(query, vector.vector);\n      matches.push({ id, similarity, metadata: vector.metadata });\n    }\n\n    // Sort by similarity and return top matches\n    matches.sort((a, b) => b.similarity - a.similarity);\n    return matches.slice(0, limit);\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) return 0;\n\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    normA = Math.sqrt(normA);\n    normB = Math.sqrt(normB);\n\n    if (normA === 0 || normB === 0) return 0;\n\n    return dotProduct / (normA * normB);\n  }\n}\n\n// Types\n\ninterface Vector {\n  id: string;\n  vector: number[];\n  metadata?: any;\n}\n\ninterface VectorMatch {\n  id: string;\n  similarity: number;\n  metadata?: any;\n}\n\ninterface SearchResult {\n  entry: KnowledgeEntry;\n  similarity: number;\n  relevance: number;\n}\n\ninterface ValidationIssue {\n  entryId: string;\n  type: 'expired' | 'deprecated' | 'dimension_mismatch' | 'content_too_short';\n  message: string;\n}\n\ninterface ValidationReport {\n  totalEntries: number;\n  validEntries: number;\n  expiredEntries: number;\n  deprecatedEntries: number;\n  issues: ValidationIssue[];\n  lastValidated: Date;\n}\n\ninterface ImportResult {\n  imported: number;\n  skipped: number;\n  errors: string[];\n}\n\ninterface CleanupResult {\n  removed: number;\n  remaining: number;\n}\n\n// Export factory function\nexport const createKnowledgeBase = (\n  embeddingModel?: string,\n  vectorDimension?: number\n): KnowledgeBase => {\n  return new KnowledgeBase(embeddingModel, vectorDimension);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/learning-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":337,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10712,10715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10712,10715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":337,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10731,10734],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10731,10734],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":536,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":536,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17431,17434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17431,17434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":543,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":543,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17585,17588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17585,17588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":543,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":543,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17590,17593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17590,17593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":544,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":544,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17608,17611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17608,17611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":586,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":586,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18974,18977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18974,18977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":602,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":602,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19296,19299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19296,19299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":625,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":625,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19862,19865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19862,19865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":639,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20158,20161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20158,20161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Learning Engine for STR Certified\n// Processes auditor feedback to improve AI accuracy over time\n\nimport type {\n  AuditorFeedback,\n  FeedbackCategory,\n  LearningMetrics,\n  LearningInsight,\n  CategoryMetrics,\n  PropertyTypeMetrics,\n  ModelUpdate,\n  TrendData,\n  LearningConfig,\n  LearningProgress,\n  LearningPattern\n} from '@/types/learning';\n\nexport class LearningEngine {\n  private config: LearningConfig;\n  private feedbackBuffer: Map<string, AuditorFeedback[]> = new Map();\n  private metricsCache: Map<string, LearningMetrics> = new Map();\n  private confidenceModels: Map<FeedbackCategory, ConfidenceModel> = new Map();\n  private propertyTypeModels: Map<string, PropertyTypeModel> = new Map();\n  private patternDetector: PatternDetector;\n\n  constructor(config: LearningConfig) {\n    this.config = config;\n    this.patternDetector = new PatternDetector();\n    this.initializeModels();\n  }\n\n  /**\n   * Processes auditor feedback and learns from corrections\n   */\n  async processAuditorFeedback(feedback: AuditorFeedback): Promise<void> {\n    // Add to buffer\n    const bufferKey = this.getBufferKey(feedback);\n    if (!this.feedbackBuffer.has(bufferKey)) {\n      this.feedbackBuffer.set(bufferKey, []);\n    }\n    this.feedbackBuffer.get(bufferKey)!.push(feedback);\n\n    // Extract learning insights\n    const insights = await this.extractInsights(feedback);\n    \n    // Update confidence models immediately for critical feedback\n    if (feedback.auditorCorrection.confidence > this.config.confidenceThreshold) {\n      await this.updateConfidenceModels([feedback]);\n    }\n\n    // Check if we should trigger batch processing\n    const shouldProcess = this.shouldProcessBatch(bufferKey);\n    if (shouldProcess) {\n      await this.processFeedbackBatch(bufferKey);\n    }\n\n    // Detect patterns\n    await this.patternDetector.analyze(feedback);\n\n    // Mark as processed\n    feedback.learningMetadata.processed = true;\n    feedback.learningMetadata.processedAt = new Date();\n  }\n\n  /**\n   * Updates confidence models based on feedback\n   */\n  async updateConfidenceModels(feedbackItems: AuditorFeedback[]): Promise<void> {\n    // Group by category\n    const categoryGroups = this.groupByCategory(feedbackItems);\n\n    for (const [category, items] of categoryGroups) {\n      const model = this.confidenceModels.get(category);\n      if (!model) continue;\n\n      // Calculate accuracy metrics\n      const accuracy = this.calculateAccuracy(items);\n      const confidenceAdjustment = this.calculateConfidenceAdjustment(items);\n\n      // Update model\n      model.updateWithFeedback(items, accuracy, confidenceAdjustment);\n\n      // Store updated model parameters\n      await this.persistModelUpdate(category, model);\n    }\n\n    // Update cross-category correlations\n    await this.updateCrossModelCorrelations(feedbackItems);\n  }\n\n  /**\n   * Categorizes feedback by property type to learn patterns\n   */\n  async categorizeByPropertyType(feedbackItems: AuditorFeedback[]): Promise<Map<string, PropertyTypeMetrics>> {\n    const propertyTypeMap = new Map<string, PropertyTypeMetrics>();\n\n    // Group by property type\n    const propertyGroups = this.groupByPropertyType(feedbackItems);\n\n    for (const [propertyType, items] of propertyGroups) {\n      const metrics = await this.calculatePropertyTypeMetrics(propertyType, items);\n      propertyTypeMap.set(propertyType, metrics);\n\n      // Update property-specific model\n      let model = this.propertyTypeModels.get(propertyType);\n      if (!model) {\n        model = new PropertyTypeModel(propertyType);\n        this.propertyTypeModels.set(propertyType, model);\n      }\n\n      model.updateWithFeedback(items);\n      \n      // Identify property-specific challenges\n      const challenges = await this.identifyPropertyChallenges(propertyType, items);\n      metrics.specificChallenges = challenges;\n    }\n\n    return propertyTypeMap;\n  }\n\n  /**\n   * Generates comprehensive learning report\n   */\n  async generateLearningReport(\n    startDate: Date,\n    endDate: Date\n  ): Promise<LearningMetrics> {\n    // Check cache first\n    const cacheKey = `${startDate.toISOString()}_${endDate.toISOString()}`;\n    if (this.metricsCache.has(cacheKey)) {\n      return this.metricsCache.get(cacheKey)!;\n    }\n\n    // Collect all feedback in period\n    const periodFeedback = await this.getFeedbackInPeriod(startDate, endDate);\n\n    // Calculate overall metrics\n    const accuracyTrend = await this.calculateAccuracyTrend(periodFeedback);\n    const confidenceImprovement = await this.calculateConfidenceImprovement(periodFeedback);\n\n    // Category performance\n    const categoryPerformance = new Map<FeedbackCategory, CategoryMetrics>();\n    const categories = this.getUniqueCategories(periodFeedback);\n    \n    for (const category of categories) {\n      const categoryItems = periodFeedback.filter(f => f.category === category);\n      const metrics = await this.calculateCategoryMetrics(category, categoryItems);\n      categoryPerformance.set(category, metrics);\n    }\n\n    // Property type performance\n    const propertyTypePerformance = await this.categorizeByPropertyType(periodFeedback);\n\n    // Model updates in period\n    const modelUpdates = await this.getModelUpdatesInPeriod(startDate, endDate);\n\n    // Generate insights\n    const insights = await this.generateInsights(periodFeedback, categoryPerformance);\n\n    const report: LearningMetrics = {\n      periodStart: startDate,\n      periodEnd: endDate,\n      accuracyTrend,\n      confidenceImprovement,\n      feedbackVolume: periodFeedback.length,\n      feedbackProcessed: periodFeedback.filter(f => f.learningMetadata.processed).length,\n      categoryPerformance,\n      propertyTypePerformance,\n      modelUpdates,\n      insights\n    };\n\n    // Cache the report\n    this.metricsCache.set(cacheKey, report);\n\n    return report;\n  }\n\n  /**\n   * Generates learning progress report\n   */\n  async getLearningProgress(modelVersion: string): Promise<LearningProgress> {\n    const startDate = await this.getModelStartDate(modelVersion);\n    const currentDate = new Date();\n\n    // Get all feedback since model start\n    const allFeedback = await this.getFeedbackInPeriod(startDate, currentDate);\n\n    // Calculate overall metrics\n    const overallAccuracy = this.calculateOverallAccuracy(allFeedback);\n    const startAccuracy = await this.getInitialAccuracy(modelVersion);\n    const overallImprovement = ((overallAccuracy - startAccuracy) / startAccuracy) * 100;\n\n    // Category progress\n    const categoryProgress = new Map();\n    for (const [category, model] of this.confidenceModels) {\n      const progress = await model.getProgress();\n      categoryProgress.set(category, progress);\n    }\n\n    // Achievements\n    const achievements = await this.checkAchievements(allFeedback, overallAccuracy);\n\n    // Predictions\n    const predictions = await this.generatePredictions(\n      allFeedback,\n      overallAccuracy,\n      categoryProgress\n    );\n\n    return {\n      modelVersion,\n      startDate,\n      currentDate,\n      overallAccuracy,\n      overallImprovement,\n      feedbackProcessed: allFeedback.length,\n      categoryProgress,\n      achievements,\n      predictions\n    };\n  }\n\n  // Private helper methods\n\n  private initializeModels(): void {\n    // Initialize confidence models for each category\n    const categories: FeedbackCategory[] = [\n      'photo_quality',\n      'object_detection',\n      'room_classification',\n      'damage_assessment',\n      'completeness_check',\n      'safety_compliance',\n      'amenity_verification',\n      'measurement_accuracy',\n      'condition_rating'\n    ];\n\n    categories.forEach(category => {\n      this.confidenceModels.set(category, new ConfidenceModel(category));\n    });\n  }\n\n  private getBufferKey(feedback: AuditorFeedback): string {\n    return `${feedback.category}_${feedback.context.propertyType || 'general'}`;\n  }\n\n  private shouldProcessBatch(bufferKey: string): boolean {\n    const buffer = this.feedbackBuffer.get(bufferKey) || [];\n    \n    // Process if we have enough feedback\n    if (buffer.length >= this.config.minFeedbackForUpdate) {\n      return true;\n    }\n\n    // Process if oldest feedback is beyond aggregation window\n    if (buffer.length > 0) {\n      const oldestTime = buffer[0].timestamp.getTime();\n      const windowMs = this.config.feedbackAggregationWindow * 60 * 60 * 1000;\n      return Date.now() - oldestTime > windowMs;\n    }\n\n    return false;\n  }\n\n  private async processFeedbackBatch(bufferKey: string): Promise<void> {\n    const feedback = this.feedbackBuffer.get(bufferKey) || [];\n    if (feedback.length === 0) return;\n\n    // Update models\n    await this.updateConfidenceModels(feedback);\n\n    // Clear buffer\n    this.feedbackBuffer.delete(bufferKey);\n\n    // Check if we should deploy new model\n    if (this.config.updateFrequency === 'realtime') {\n      await this.deployModelUpdates();\n    }\n  }\n\n  private groupByCategory(feedback: AuditorFeedback[]): Map<FeedbackCategory, AuditorFeedback[]> {\n    const groups = new Map<FeedbackCategory, AuditorFeedback[]>();\n    \n    feedback.forEach(item => {\n      if (!groups.has(item.category)) {\n        groups.set(item.category, []);\n      }\n      groups.get(item.category)!.push(item);\n    });\n\n    return groups;\n  }\n\n  private groupByPropertyType(feedback: AuditorFeedback[]): Map<string, AuditorFeedback[]> {\n    const groups = new Map<string, AuditorFeedback[]>();\n    \n    feedback.forEach(item => {\n      const propertyType = item.context.propertyType || 'unknown';\n      if (!groups.has(propertyType)) {\n        groups.set(propertyType, []);\n      }\n      groups.get(propertyType)!.push(item);\n    });\n\n    return groups;\n  }\n\n  private calculateAccuracy(feedback: AuditorFeedback[]): number {\n    if (feedback.length === 0) return 0;\n\n    const correctPredictions = feedback.filter(f => \n      this.isPredictionCorrect(f.aiPrediction.value, f.auditorCorrection.value)\n    ).length;\n\n    return (correctPredictions / feedback.length) * 100;\n  }\n\n  private calculateConfidenceAdjustment(feedback: AuditorFeedback[]): number {\n    const adjustments = feedback.map(f => {\n      const wasCorrect = this.isPredictionCorrect(f.aiPrediction.value, f.auditorCorrection.value);\n      const confidenceDiff = f.aiPrediction.confidence - f.auditorCorrection.confidence;\n      \n      if (wasCorrect) {\n        // Increase confidence if we were correct but not confident enough\n        return confidenceDiff < 0 ? Math.abs(confidenceDiff) * 0.1 : 0;\n      } else {\n        // Decrease confidence if we were wrong\n        return -Math.abs(confidenceDiff) * 0.2;\n      }\n    });\n\n    return adjustments.reduce((sum, adj) => sum + adj, 0) / feedback.length;\n  }\n\n  private isPredictionCorrect(aiValue: any, auditorValue: any): boolean {\n    // Handle different types of values\n    if (typeof aiValue === 'boolean' && typeof auditorValue === 'boolean') {\n      return aiValue === auditorValue;\n    }\n    \n    if (typeof aiValue === 'number' && typeof auditorValue === 'number') {\n      // Allow 10% margin for numeric values\n      return Math.abs(aiValue - auditorValue) / auditorValue < 0.1;\n    }\n    \n    if (typeof aiValue === 'string' && typeof auditorValue === 'string') {\n      return aiValue.toLowerCase() === auditorValue.toLowerCase();\n    }\n    \n    // For complex objects, use JSON comparison\n    return JSON.stringify(aiValue) === JSON.stringify(auditorValue);\n  }\n\n  private async extractInsights(feedback: AuditorFeedback): Promise<LearningInsight[]> {\n    const insights: LearningInsight[] = [];\n\n    // Check for critical accuracy drop\n    if (feedback.aiPrediction.confidence > 80 && !this.isPredictionCorrect(feedback.aiPrediction.value, feedback.auditorCorrection.value)) {\n      insights.push({\n        id: `insight_${Date.now()}_1`,\n        type: 'anomaly',\n        severity: 'critical',\n        title: 'High-confidence incorrect prediction',\n        description: `AI was ${feedback.aiPrediction.confidence}% confident but incorrect in ${feedback.category}`,\n        affectedCategories: [feedback.category],\n        suggestedActions: [\n          'Review similar cases in this category',\n          'Adjust confidence thresholds',\n          'Retrain model with focus on this scenario'\n        ],\n        metrics: {\n          confidenceDrop: feedback.aiPrediction.confidence - feedback.auditorCorrection.confidence\n        },\n        createdAt: new Date()\n      });\n    }\n\n    // Check for pattern emergence\n    const patterns = await this.patternDetector.getRecentPatterns(feedback.category);\n    if (patterns.length > 0) {\n      insights.push({\n        id: `insight_${Date.now()}_2`,\n        type: 'pattern',\n        severity: 'info',\n        title: 'Emerging pattern detected',\n        description: `New pattern in ${feedback.category}: ${patterns[0].description}`,\n        affectedCategories: [feedback.category],\n        suggestedActions: patterns[0].recommendations.immediate,\n        createdAt: new Date()\n      });\n    }\n\n    return insights;\n  }\n\n  private async persistModelUpdate(category: FeedbackCategory, model: ConfidenceModel): Promise<void> {\n    // In production, this would save to database\n    const modelData = model.serialize();\n    localStorage.setItem(`model_${category}`, JSON.stringify(modelData));\n  }\n\n  private async deployModelUpdates(): Promise<void> {\n    // Check if improvements meet threshold\n    const improvements = await this.calculateModelImprovements();\n    \n    if (improvements.averageImprovement >= this.config.minAccuracyImprovement) {\n      // Deploy new models\n      const version = `v${Date.now()}`;\n      \n      for (const [category, model] of this.confidenceModels) {\n        await model.deploy(version);\n      }\n      \n      // Log model update\n      const update: ModelUpdate = {\n        version,\n        timestamp: new Date(),\n        trigger: 'threshold',\n        feedbackIncorporated: this.getTotalFeedbackCount(),\n        improvements: improvements.categoryImprovements,\n        validationResults: await this.validateModels()\n      };\n      \n      await this.logModelUpdate(update);\n    }\n  }\n\n  // Mock implementations for remaining methods\n  private async getFeedbackInPeriod(start: Date, end: Date): Promise<AuditorFeedback[]> {\n    // In production, query from database\n    return [];\n  }\n\n  private async calculateAccuracyTrend(feedback: AuditorFeedback[]): Promise<TrendData> {\n    return {\n      dataPoints: [],\n      trend: 'improving',\n      changePercent: 5.2\n    };\n  }\n\n  private async calculateConfidenceImprovement(feedback: AuditorFeedback[]): Promise<TrendData> {\n    return {\n      dataPoints: [],\n      trend: 'stable',\n      changePercent: 1.8\n    };\n  }\n\n  private getUniqueCategories(feedback: AuditorFeedback[]): FeedbackCategory[] {\n    return [...new Set(feedback.map(f => f.category))];\n  }\n\n  private async calculateCategoryMetrics(\n    category: FeedbackCategory,\n    feedback: AuditorFeedback[]\n  ): Promise<CategoryMetrics> {\n    return {\n      category,\n      totalFeedback: feedback.length,\n      corrections: feedback.filter(f => f.feedbackType === 'correction').length,\n      validations: feedback.filter(f => f.feedbackType === 'validation').length,\n      accuracy: this.calculateAccuracy(feedback),\n      confidenceAvg: feedback.reduce((sum, f) => sum + f.aiPrediction.confidence, 0) / feedback.length,\n      commonErrors: [],\n      improvementRate: 3.5\n    };\n  }\n\n  private async calculatePropertyTypeMetrics(\n    propertyType: string,\n    feedback: AuditorFeedback[]\n  ): Promise<PropertyTypeMetrics> {\n    return {\n      propertyType,\n      inspectionCount: new Set(feedback.map(f => f.inspectionId)).size,\n      feedbackCount: feedback.length,\n      accuracy: this.calculateAccuracy(feedback),\n      specificChallenges: [],\n      learningProgress: {\n        learned: [],\n        inProgress: [],\n        needsMoreData: []\n      }\n    };\n  }\n\n  private async generateInsights(\n    feedback: AuditorFeedback[],\n    categoryPerformance: Map<FeedbackCategory, CategoryMetrics>\n  ): Promise<LearningInsight[]> {\n    const insights: LearningInsight[] = [];\n\n    // Find categories with significant improvement\n    for (const [category, metrics] of categoryPerformance) {\n      if (metrics.improvementRate > 5) {\n        insights.push({\n          id: `achievement_${Date.now()}`,\n          type: 'achievement',\n          severity: 'success',\n          title: `Significant improvement in ${category}`,\n          description: `${metrics.improvementRate.toFixed(1)}% improvement in accuracy`,\n          affectedCategories: [category],\n          metrics: {\n            improvementRate: metrics.improvementRate,\n            accuracy: metrics.accuracy\n          },\n          createdAt: new Date()\n        });\n      }\n    }\n\n    return insights;\n  }\n\n  private async getModelUpdatesInPeriod(start: Date, end: Date): Promise<ModelUpdate[]> {\n    // In production, query from database\n    return [];\n  }\n\n  private async getModelStartDate(version: string): Promise<Date> {\n    // In production, query from database\n    return new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago\n  }\n\n  private async getInitialAccuracy(version: string): Promise<number> {\n    return 75; // Mock initial accuracy\n  }\n\n  private calculateOverallAccuracy(feedback: AuditorFeedback[]): number {\n    return this.calculateAccuracy(feedback);\n  }\n\n  private async checkAchievements(feedback: AuditorFeedback[], accuracy: number): Promise<any[]> {\n    return [];\n  }\n\n  private async generatePredictions(\n    feedback: AuditorFeedback[],\n    currentAccuracy: number,\n    categoryProgress: Map<any, any>\n  ): Promise<any> {\n    return {\n      nextWeekAccuracy: currentAccuracy + 1.2,\n      nextMonthAccuracy: currentAccuracy + 4.5,\n      timeToTarget: 45,\n      bottlenecks: ['Need more data for luxury properties']\n    };\n  }\n\n  private async identifyPropertyChallenges(\n    propertyType: string,\n    feedback: AuditorFeedback[]\n  ): Promise<string[]> {\n    const challenges: string[] = [];\n    \n    // Analyze common errors for this property type\n    const errorTypes = feedback\n      .filter(f => !this.isPredictionCorrect(f.aiPrediction.value, f.auditorCorrection.value))\n      .map(f => f.category);\n    \n    const errorCounts = new Map<string, number>();\n    errorTypes.forEach(error => {\n      errorCounts.set(error, (errorCounts.get(error) || 0) + 1);\n    });\n    \n    // Find most common challenges\n    for (const [category, count] of errorCounts) {\n      if (count > feedback.length * 0.1) { // More than 10% error rate\n        challenges.push(`High error rate in ${category} detection`);\n      }\n    }\n    \n    return challenges;\n  }\n\n  private async updateCrossModelCorrelations(feedback: AuditorFeedback[]): Promise<void> {\n    // Analyze correlations between different categories\n    // This helps identify when errors in one category affect another\n  }\n\n  private async calculateModelImprovements(): Promise<{\n    averageImprovement: number;\n    categoryImprovements: any[];\n  }> {\n    return {\n      averageImprovement: 5.5,\n      categoryImprovements: []\n    };\n  }\n\n  private getTotalFeedbackCount(): number {\n    let total = 0;\n    for (const buffer of this.feedbackBuffer.values()) {\n      total += buffer.length;\n    }\n    return total;\n  }\n\n  private async validateModels(): Promise<any> {\n    return {\n      testSetAccuracy: 82.5,\n      crossValidation: 81.2,\n      auditorApproval: 88.0\n    };\n  }\n\n  private async logModelUpdate(update: ModelUpdate): Promise<void> {\n    // In production, save to database\n    console.log('Model update deployed:', update);\n  }\n}\n\n// Supporting classes\n\nclass ConfidenceModel {\n  constructor(private category: FeedbackCategory) {}\n\n  updateWithFeedback(feedback: AuditorFeedback[], accuracy: number, adjustment: number): void {\n    // Update model parameters based on feedback\n  }\n\n  async getProgress(): Promise<any> {\n    return {\n      startAccuracy: 75,\n      currentAccuracy: 82,\n      improvement: 7,\n      dataPoints: 150,\n      nextMilestone: {\n        target: 85,\n        estimatedDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n        requiredFeedback: 50\n      }\n    };\n  }\n\n  serialize(): any {\n    return {\n      category: this.category,\n      parameters: {},\n      lastUpdated: new Date()\n    };\n  }\n\n  async deploy(version: string): Promise<void> {\n    // Deploy model version\n  }\n}\n\nclass PropertyTypeModel {\n  constructor(private propertyType: string) {}\n\n  updateWithFeedback(feedback: AuditorFeedback[]): void {\n    // Update property-specific patterns\n  }\n}\n\nclass PatternDetector {\n  private patterns: Map<string, LearningPattern[]> = new Map();\n\n  async analyze(feedback: AuditorFeedback): Promise<void> {\n    // Detect patterns in feedback\n  }\n\n  async getRecentPatterns(category: FeedbackCategory): Promise<LearningPattern[]> {\n    return this.patterns.get(category) || [];\n  }\n}\n\n// Export factory function\nexport const createLearningEngine = (config: LearningConfig): LearningEngine => {\n  return new LearningEngine(config);\n};\n\n// Default configuration\nexport const defaultLearningConfig: LearningConfig = {\n  minFeedbackForUpdate: 10,\n  confidenceThreshold: 80,\n  feedbackAggregationWindow: 24, // hours\n  updateFrequency: 'daily',\n  validationSplitRatio: 0.2,\n  minAccuracyImprovement: 2,\n  embeddingModel: 'text-embedding-ada-002',\n  vectorDimension: 1536,\n  similarityThreshold: 0.85,\n  maxRetrievalResults: 5,\n  criticalAccuracyThreshold: 70,\n  targetAccuracy: 90,\n  confidenceDecayRate: 0.05\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/learning-repository.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[846,849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[846,849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2305,2308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2305,2308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3662,3665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3662,3665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3892,3895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3892,3895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Learning Repository for STR Certified\n// Accumulates patterns, learnings, and best practices from AI work\n\nimport { aiDecisionLogger } from './decision-logger';\nimport { aiSessionManager } from './session-manager';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport { supabase } from '../supabase';\n\n// Learning Types\nexport interface LearningEntry {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  ai_agent: string;\n  learning_type: LearningType;\n  category: LearningCategory;\n  title: string;\n  description: string;\n  context: LearningContext;\n  evidence: Evidence[];\n  confidence: number; // 0-100\n  validation_status: ValidationStatus;\n  applicability: Applicability;\n  impact: Impact;\n  related_learnings: string[];\n  tags: string[];\n  metadata: Record<string, any>;\n}\n\nexport type LearningType = \n  | 'pattern_discovered'\n  | 'antipattern_identified'\n  | 'best_practice'\n  | 'optimization_technique'\n  | 'common_mistake'\n  | 'successful_approach'\n  | 'tool_effectiveness'\n  | 'process_improvement'\n  | 'architecture_insight'\n  | 'performance_finding'\n  | 'security_lesson'\n  | 'user_experience_insight'\n  | 'code_quality_rule'\n  | 'debugging_technique'\n  | 'testing_strategy'\n  | 'deployment_practice'\n  | 'monitoring_insight'\n  | 'collaboration_pattern'\n  | 'decision_framework';\n\nexport type LearningCategory =\n  | 'architecture'\n  | 'performance'\n  | 'security'\n  | 'usability'\n  | 'maintainability'\n  | 'scalability'\n  | 'reliability'\n  | 'development_process'\n  | 'testing'\n  | 'deployment'\n  | 'monitoring'\n  | 'collaboration'\n  | 'tools'\n  | 'frameworks'\n  | 'patterns'\n  | 'business_logic'\n  | 'data_management'\n  | 'api_design'\n  | 'mobile_optimization';\n\nexport interface LearningContext {\n  problem_domain: string;\n  technology_stack: string[];\n  team_size: number;\n  project_phase: 'planning' | 'development' | 'testing' | 'deployment' | 'maintenance';\n  constraints: string[];\n  requirements: string[];\n  environment: 'development' | 'staging' | 'production';\n  user_feedback?: string;\n  performance_metrics?: Record<string, number>;\n}\n\nexport interface Evidence {\n  type: 'code_example' | 'performance_data' | 'user_feedback' | 'test_results' | 'metrics' | 'documentation';\n  description: string;\n  data: any;\n  source: string;\n  timestamp: string;\n  reliability: 'high' | 'medium' | 'low';\n}\n\nexport type ValidationStatus = \n  | 'unvalidated'\n  | 'partially_validated'\n  | 'validated'\n  | 'disputed'\n  | 'outdated';\n\nexport interface Applicability {\n  project_types: string[];\n  technology_stacks: string[];\n  team_sizes: string[];\n  complexity_levels: string[];\n  constraints: string[];\n  conditions: string[];\n}\n\nexport interface Impact {\n  performance_impact: 'negative' | 'neutral' | 'positive';\n  maintainability_impact: 'negative' | 'neutral' | 'positive';\n  security_impact: 'negative' | 'neutral' | 'positive';\n  user_experience_impact: 'negative' | 'neutral' | 'positive';\n  development_speed_impact: 'negative' | 'neutral' | 'positive';\n  cost_impact: 'negative' | 'neutral' | 'positive';\n  quantified_metrics?: Record<string, number>;\n}\n\nexport interface LearningPattern {\n  id: string;\n  name: string;\n  description: string;\n  frequency: number;\n  confidence: number;\n  related_learnings: string[];\n  success_rate: number;\n  conditions: string[];\n  outcomes: string[];\n  recommendations: string[];\n}\n\nexport interface KnowledgeGraph {\n  nodes: KnowledgeNode[];\n  edges: KnowledgeEdge[];\n}\n\nexport interface KnowledgeNode {\n  id: string;\n  type: 'learning' | 'pattern' | 'concept' | 'tool' | 'practice';\n  label: string;\n  properties: Record<string, any>;\n  weight: number;\n}\n\nexport interface KnowledgeEdge {\n  source: string;\n  target: string;\n  relationship: 'relates_to' | 'depends_on' | 'contradicts' | 'enhances' | 'replaces';\n  weight: number;\n  properties: Record<string, any>;\n}\n\nexport interface LearningQuery {\n  learning_type?: LearningType;\n  category?: LearningCategory;\n  ai_agent?: string;\n  validation_status?: ValidationStatus;\n  confidence_threshold?: number;\n  technology_stack?: string[];\n  tags?: string[];\n  date_range?: {\n    start: string;\n    end: string;\n  };\n  search_term?: string;\n  limit?: number;\n}\n\nexport interface LearningStats {\n  total_learnings: number;\n  learnings_by_type: Record<LearningType, number>;\n  learnings_by_category: Record<LearningCategory, number>;\n  average_confidence: number;\n  validation_rate: number;\n  top_contributors: Array<{ ai_agent: string; contributions: number }>;\n  trending_patterns: LearningPattern[];\n  knowledge_coverage: Record<string, number>;\n}\n\nexport class AILearningRepository {\n  private static instance: AILearningRepository;\n  private learnings: LearningEntry[] = [];\n  private patterns: LearningPattern[] = [];\n  private knowledgeGraph: KnowledgeGraph = { nodes: [], edges: [] };\n  private maxLocalLearnings = 1000;\n  private patternAnalysisInterval = 300000; // 5 minutes\n  private analysisTimer: NodeJS.Timeout | null = null;\n\n  private constructor() {\n    this.startPatternAnalysis();\n  }\n\n  static getInstance(): AILearningRepository {\n    if (!AILearningRepository.instance) {\n      AILearningRepository.instance = new AILearningRepository();\n    }\n    return AILearningRepository.instance;\n  }\n\n  /**\n   * Add a new learning entry\n   */\n  async addLearning(learning: Omit<LearningEntry, 'id' | 'timestamp'>): Promise<string> {\n    const learningId = this.generateLearningId();\n    \n    const fullLearning: LearningEntry = {\n      id: learningId,\n      timestamp: new Date().toISOString(),\n      ...learning\n    };\n\n    this.learnings.push(fullLearning);\n\n    // Maintain local cache size\n    if (this.learnings.length > this.maxLocalLearnings) {\n      this.learnings = this.learnings.slice(-this.maxLocalLearnings);\n    }\n\n    // Log the learning\n    await aiDecisionLogger.logSimpleDecision(\n      `Added learning: ${learning.title}`,\n      'workflow_optimization',\n      `New ${learning.learning_type} learning added: ${learning.description.substring(0, 100)}...`,\n      [],\n      'low'\n    );\n\n    logger.info(`Learning added: ${learning.title}`, {\n      learning_id: learningId,\n      type: learning.learning_type,\n      category: learning.category,\n      confidence: learning.confidence,\n      ai_agent: learning.ai_agent\n    }, 'AI_LEARNING_ADDED');\n\n    try {\n      await this.persistLearning(fullLearning);\n      this.updateKnowledgeGraph(fullLearning);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_LEARNING_ADD',\n        learning_id: learningId,\n        learning_type: learning.learning_type\n      });\n    }\n\n    return learningId;\n  }\n\n  /**\n   * Add a simple learning with minimal context\n   */\n  async addSimpleLearning(\n    title: string,\n    description: string,\n    learning_type: LearningType,\n    category: LearningCategory,\n    confidence: number = 80\n  ): Promise<string> {\n    const sessionId = this.getCurrentSessionId();\n    \n    return this.addLearning({\n      session_id: sessionId,\n      ai_agent: this.getCurrentAIAgent(),\n      learning_type,\n      category,\n      title,\n      description,\n      context: {\n        problem_domain: 'General',\n        technology_stack: ['React', 'TypeScript', 'Supabase'],\n        team_size: 1,\n        project_phase: 'development',\n        constraints: [],\n        requirements: [],\n        environment: 'development'\n      },\n      evidence: [],\n      confidence,\n      validation_status: 'unvalidated',\n      applicability: {\n        project_types: ['web_application'],\n        technology_stacks: ['React', 'TypeScript'],\n        team_sizes: ['small', 'medium'],\n        complexity_levels: ['medium', 'high'],\n        constraints: [],\n        conditions: []\n      },\n      impact: {\n        performance_impact: 'neutral',\n        maintainability_impact: 'positive',\n        security_impact: 'neutral',\n        user_experience_impact: 'neutral',\n        development_speed_impact: 'positive',\n        cost_impact: 'neutral'\n      },\n      related_learnings: [],\n      tags: [],\n      metadata: {}\n    });\n  }\n\n  /**\n   * Validate a learning entry\n   */\n  async validateLearning(\n    learningId: string,\n    validation_status: ValidationStatus,\n    evidence?: Evidence[],\n    notes?: string\n  ): Promise<void> {\n    const learning = this.learnings.find(l => l.id === learningId);\n    if (!learning) {\n      throw new Error(`Learning not found: ${learningId}`);\n    }\n\n    learning.validation_status = validation_status;\n    \n    if (evidence) {\n      learning.evidence.push(...evidence);\n    }\n    \n    if (notes) {\n      learning.metadata.validation_notes = notes;\n    }\n\n    await aiDecisionLogger.logSimpleDecision(\n      `Validated learning: ${learning.title}`,\n      'workflow_optimization',\n      `Learning validation updated to: ${validation_status}`,\n      [],\n      'low'\n    );\n\n    logger.info(`Learning validated: ${learning.title}`, {\n      learning_id: learningId,\n      validation_status,\n      evidence_count: evidence?.length || 0\n    }, 'AI_LEARNING_VALIDATED');\n\n    try {\n      await this.persistLearning(learning);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_LEARNING_VALIDATION',\n        learning_id: learningId,\n        validation_status\n      });\n    }\n  }\n\n  /**\n   * Query learnings\n   */\n  queryLearnings(query: LearningQuery): LearningEntry[] {\n    let filtered = [...this.learnings];\n\n    if (query.learning_type) {\n      filtered = filtered.filter(l => l.learning_type === query.learning_type);\n    }\n\n    if (query.category) {\n      filtered = filtered.filter(l => l.category === query.category);\n    }\n\n    if (query.ai_agent) {\n      filtered = filtered.filter(l => l.ai_agent === query.ai_agent);\n    }\n\n    if (query.validation_status) {\n      filtered = filtered.filter(l => l.validation_status === query.validation_status);\n    }\n\n    if (query.confidence_threshold) {\n      filtered = filtered.filter(l => l.confidence >= query.confidence_threshold);\n    }\n\n    if (query.technology_stack && query.technology_stack.length > 0) {\n      filtered = filtered.filter(l => \n        query.technology_stack!.some(tech => \n          l.context.technology_stack.includes(tech)\n        )\n      );\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      filtered = filtered.filter(l => \n        query.tags!.some(tag => l.tags.includes(tag))\n      );\n    }\n\n    if (query.date_range) {\n      filtered = filtered.filter(l => {\n        const timestamp = new Date(l.timestamp);\n        const start = new Date(query.date_range!.start);\n        const end = new Date(query.date_range!.end);\n        return timestamp >= start && timestamp <= end;\n      });\n    }\n\n    if (query.search_term) {\n      const searchTerm = query.search_term.toLowerCase();\n      filtered = filtered.filter(l => \n        l.title.toLowerCase().includes(searchTerm) ||\n        l.description.toLowerCase().includes(searchTerm) ||\n        l.tags.some(tag => tag.toLowerCase().includes(searchTerm))\n      );\n    }\n\n    // Sort by confidence and timestamp\n    filtered.sort((a, b) => {\n      if (a.confidence !== b.confidence) {\n        return b.confidence - a.confidence;\n      }\n      return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();\n    });\n\n    if (query.limit) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get learning by ID\n   */\n  getLearningById(id: string): LearningEntry | null {\n    return this.learnings.find(l => l.id === id) || null;\n  }\n\n  /**\n   * Get high-confidence learnings\n   */\n  getHighConfidenceLearnings(threshold: number = 80): LearningEntry[] {\n    return this.queryLearnings({ confidence_threshold: threshold });\n  }\n\n  /**\n   * Get validated learnings\n   */\n  getValidatedLearnings(): LearningEntry[] {\n    return this.queryLearnings({ validation_status: 'validated' });\n  }\n\n  /**\n   * Get learnings by category\n   */\n  getLearningsByCategory(category: LearningCategory): LearningEntry[] {\n    return this.queryLearnings({ category });\n  }\n\n  /**\n   * Get applicable learnings for current context\n   */\n  getApplicableLearnings(\n    technologyStack: string[],\n    projectType: string,\n    teamSize: string\n  ): LearningEntry[] {\n    return this.learnings.filter(l => {\n      const applicability = l.applicability;\n      \n      const techMatch = technologyStack.some(tech => \n        applicability.technology_stacks.includes(tech)\n      );\n      \n      const projectMatch = applicability.project_types.length === 0 || \n        applicability.project_types.includes(projectType);\n      \n      const teamMatch = applicability.team_sizes.length === 0 || \n        applicability.team_sizes.includes(teamSize);\n      \n      return techMatch && projectMatch && teamMatch;\n    });\n  }\n\n  /**\n   * Discover patterns from learnings\n   */\n  discoverPatterns(): LearningPattern[] {\n    // Group learnings by similarity\n    const groupedLearnings = this.groupSimilarLearnings();\n    \n    // Generate patterns from groups\n    const patterns: LearningPattern[] = [];\n    \n    groupedLearnings.forEach((learnings, key) => {\n      if (learnings.length >= 3) { // Minimum frequency for pattern\n        const pattern: LearningPattern = {\n          id: this.generatePatternId(),\n          name: `Pattern: ${key}`,\n          description: this.generatePatternDescription(learnings),\n          frequency: learnings.length,\n          confidence: this.calculatePatternConfidence(learnings),\n          related_learnings: learnings.map(l => l.id),\n          success_rate: this.calculateSuccessRate(learnings),\n          conditions: this.extractCommonConditions(learnings),\n          outcomes: this.extractCommonOutcomes(learnings),\n          recommendations: this.generateRecommendations(learnings)\n        };\n        patterns.push(pattern);\n      }\n    });\n\n    this.patterns = patterns;\n    return patterns;\n  }\n\n  /**\n   * Get learning statistics\n   */\n  getLearningStats(): LearningStats {\n    const totalLearnings = this.learnings.length;\n    \n    const learningsByType = this.learnings.reduce((acc, l) => {\n      acc[l.learning_type] = (acc[l.learning_type] || 0) + 1;\n      return acc;\n    }, {} as Record<LearningType, number>);\n\n    const learningsByCategory = this.learnings.reduce((acc, l) => {\n      acc[l.category] = (acc[l.category] || 0) + 1;\n      return acc;\n    }, {} as Record<LearningCategory, number>);\n\n    const averageConfidence = totalLearnings > 0 \n      ? this.learnings.reduce((sum, l) => sum + l.confidence, 0) / totalLearnings \n      : 0;\n\n    const validatedCount = this.learnings.filter(l => l.validation_status === 'validated').length;\n    const validationRate = totalLearnings > 0 ? (validatedCount / totalLearnings) * 100 : 0;\n\n    const contributorCounts = this.learnings.reduce((acc, l) => {\n      acc[l.ai_agent] = (acc[l.ai_agent] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const topContributors = Object.entries(contributorCounts)\n      .map(([ai_agent, contributions]) => ({ ai_agent, contributions }))\n      .sort((a, b) => b.contributions - a.contributions)\n      .slice(0, 5);\n\n    const knowledgeCoverage = this.calculateKnowledgeCoverage();\n\n    return {\n      total_learnings: totalLearnings,\n      learnings_by_type: learningsByType,\n      learnings_by_category: learningsByCategory,\n      average_confidence: averageConfidence,\n      validation_rate: validationRate,\n      top_contributors: topContributors,\n      trending_patterns: this.patterns.slice(0, 10),\n      knowledge_coverage: knowledgeCoverage\n    };\n  }\n\n  /**\n   * Generate learning recommendations\n   */\n  generateRecommendations(context: LearningContext): LearningEntry[] {\n    const applicableLearnings = this.getApplicableLearnings(\n      context.technology_stack,\n      context.problem_domain,\n      context.team_size.toString()\n    );\n\n    // Filter for high-confidence, validated learnings\n    const highQualityLearnings = applicableLearnings.filter(l => \n      l.confidence >= 70 && \n      l.validation_status === 'validated'\n    );\n\n    // Sort by relevance and impact\n    return highQualityLearnings\n      .sort((a, b) => {\n        const aScore = this.calculateRelevanceScore(a, context);\n        const bScore = this.calculateRelevanceScore(b, context);\n        return bScore - aScore;\n      })\n      .slice(0, 10);\n  }\n\n  /**\n   * Export learnings\n   */\n  exportLearnings(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.learnings, null, 2);\n    } else {\n      const headers = ['timestamp', 'learning_type', 'category', 'title', 'confidence', 'validation_status', 'ai_agent'];\n      const rows = this.learnings.map(l => [\n        l.timestamp,\n        l.learning_type,\n        l.category,\n        l.title,\n        l.confidence,\n        l.validation_status,\n        l.ai_agent\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateLearningId(): string {\n    return `learning_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generatePatternId(): string {\n    return `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getCurrentSessionId(): string {\n    const session = aiSessionManager.getCurrentSession();\n    return session?.id || `session_${Date.now()}`;\n  }\n\n  private getCurrentAIAgent(): string {\n    return process.env.AI_AGENT || 'claude-sonnet-4';\n  }\n\n  private groupSimilarLearnings(): Map<string, LearningEntry[]> {\n    const groups = new Map<string, LearningEntry[]>();\n    \n    this.learnings.forEach(learning => {\n      const key = `${learning.learning_type}_${learning.category}`;\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(learning);\n    });\n\n    return groups;\n  }\n\n  private generatePatternDescription(learnings: LearningEntry[]): string {\n    const commonThemes = this.extractCommonThemes(learnings);\n    return `Common pattern found across ${learnings.length} learnings: ${commonThemes.join(', ')}`;\n  }\n\n  private calculatePatternConfidence(learnings: LearningEntry[]): number {\n    return learnings.reduce((sum, l) => sum + l.confidence, 0) / learnings.length;\n  }\n\n  private calculateSuccessRate(learnings: LearningEntry[]): number {\n    const positiveOutcomes = learnings.filter(l => \n      l.impact.performance_impact === 'positive' || \n      l.impact.maintainability_impact === 'positive'\n    ).length;\n    \n    return learnings.length > 0 ? (positiveOutcomes / learnings.length) * 100 : 0;\n  }\n\n  private extractCommonConditions(learnings: LearningEntry[]): string[] {\n    const conditionCounts = new Map<string, number>();\n    \n    learnings.forEach(l => {\n      l.applicability.conditions.forEach(condition => {\n        conditionCounts.set(condition, (conditionCounts.get(condition) || 0) + 1);\n      });\n    });\n\n    return Array.from(conditionCounts.entries())\n      .filter(([_, count]) => count >= 2)\n      .map(([condition, _]) => condition);\n  }\n\n  private extractCommonOutcomes(learnings: LearningEntry[]): string[] {\n    const outcomeCounts = new Map<string, number>();\n    \n    learnings.forEach(l => {\n      // Extract outcomes from evidence\n      l.evidence.forEach(evidence => {\n        if (evidence.type === 'test_results' || evidence.type === 'performance_data') {\n          const outcome = evidence.description;\n          outcomeCounts.set(outcome, (outcomeCounts.get(outcome) || 0) + 1);\n        }\n      });\n    });\n\n    return Array.from(outcomeCounts.entries())\n      .filter(([_, count]) => count >= 2)\n      .map(([outcome, _]) => outcome);\n  }\n\n  private generateRecommendations(learnings: LearningEntry[]): string[] {\n    const recommendations = new Set<string>();\n    \n    learnings.forEach(l => {\n      if (l.learning_type === 'best_practice' || l.learning_type === 'successful_approach') {\n        recommendations.add(`Apply: ${l.title}`);\n      } else if (l.learning_type === 'antipattern_identified' || l.learning_type === 'common_mistake') {\n        recommendations.add(`Avoid: ${l.title}`);\n      }\n    });\n\n    return Array.from(recommendations);\n  }\n\n  private extractCommonThemes(learnings: LearningEntry[]): string[] {\n    const themes = new Set<string>();\n    \n    learnings.forEach(l => {\n      l.tags.forEach(tag => themes.add(tag));\n      themes.add(l.category);\n    });\n\n    return Array.from(themes);\n  }\n\n  private calculateRelevanceScore(learning: LearningEntry, context: LearningContext): number {\n    let score = learning.confidence;\n\n    // Boost score for matching technology stack\n    const techMatch = context.technology_stack.some(tech => \n      learning.context.technology_stack.includes(tech)\n    );\n    if (techMatch) score += 20;\n\n    // Boost score for matching project phase\n    if (learning.context.project_phase === context.project_phase) {\n      score += 10;\n    }\n\n    // Boost score for validated learnings\n    if (learning.validation_status === 'validated') {\n      score += 15;\n    }\n\n    return score;\n  }\n\n  private calculateKnowledgeCoverage(): Record<string, number> {\n    const coverage: Record<string, number> = {};\n    \n    Object.values(LearningCategory).forEach(category => {\n      const count = this.learnings.filter(l => l.category === category).length;\n      coverage[category] = count;\n    });\n\n    return coverage;\n  }\n\n  private updateKnowledgeGraph(learning: LearningEntry): void {\n    // Add learning as a node\n    const node: KnowledgeNode = {\n      id: learning.id,\n      type: 'learning',\n      label: learning.title,\n      properties: {\n        category: learning.category,\n        type: learning.learning_type,\n        confidence: learning.confidence\n      },\n      weight: learning.confidence\n    };\n\n    this.knowledgeGraph.nodes.push(node);\n\n    // Create edges to related learnings\n    learning.related_learnings.forEach(relatedId => {\n      const edge: KnowledgeEdge = {\n        source: learning.id,\n        target: relatedId,\n        relationship: 'relates_to',\n        weight: 1,\n        properties: {}\n      };\n      this.knowledgeGraph.edges.push(edge);\n    });\n  }\n\n  private startPatternAnalysis(): void {\n    if (this.analysisTimer) return;\n\n    this.analysisTimer = setInterval(() => {\n      this.discoverPatterns();\n    }, this.patternAnalysisInterval);\n  }\n\n  private async persistLearning(learning: LearningEntry): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('ai_learning_repository')\n        .insert([{\n          id: learning.id,\n          timestamp: learning.timestamp,\n          session_id: learning.session_id,\n          ai_agent: learning.ai_agent,\n          learning_type: learning.learning_type,\n          category: learning.category,\n          title: learning.title,\n          description: learning.description,\n          context: learning.context,\n          evidence: learning.evidence,\n          confidence: learning.confidence,\n          validation_status: learning.validation_status,\n          applicability: learning.applicability,\n          impact: learning.impact,\n          related_learnings: learning.related_learnings,\n          tags: learning.tags,\n          metadata: learning.metadata\n        }]);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      logger.error('Failed to persist learning to database', error, 'AI_LEARNING_PERSIST');\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy(): void {\n    if (this.analysisTimer) {\n      clearInterval(this.analysisTimer);\n      this.analysisTimer = null;\n    }\n  }\n}\n\n// Export singleton instance\nexport const aiLearningRepository = AILearningRepository.getInstance();\n\n// Convenience functions\nexport const addLearning = aiLearningRepository.addLearning.bind(aiLearningRepository);\nexport const addSimpleLearning = aiLearningRepository.addSimpleLearning.bind(aiLearningRepository);\nexport const validateLearning = aiLearningRepository.validateLearning.bind(aiLearningRepository);\nexport const queryLearnings = aiLearningRepository.queryLearnings.bind(aiLearningRepository);\nexport const getLearningById = aiLearningRepository.getLearningById.bind(aiLearningRepository);\nexport const getHighConfidenceLearnings = aiLearningRepository.getHighConfidenceLearnings.bind(aiLearningRepository);\nexport const getValidatedLearnings = aiLearningRepository.getValidatedLearnings.bind(aiLearningRepository);\nexport const getLearningsByCategory = aiLearningRepository.getLearningsByCategory.bind(aiLearningRepository);\nexport const getApplicableLearnings = aiLearningRepository.getApplicableLearnings.bind(aiLearningRepository);\nexport const discoverPatterns = aiLearningRepository.discoverPatterns.bind(aiLearningRepository);\nexport const getLearningStats = aiLearningRepository.getLearningStats.bind(aiLearningRepository);\nexport const generateRecommendations = aiLearningRepository.generateRecommendations.bind(aiLearningRepository);\nexport const exportLearnings = aiLearningRepository.exportLearnings.bind(aiLearningRepository);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/openai-service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5702,5705],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5702,5705],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10336,10339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10336,10339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":457,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":457,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13715,13718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13715,13718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// OpenAI Service for STR Certified AI Analysis\n\nimport OpenAI from 'openai';\nimport type {\n  AIAnalysisResult,\n  PhotoComparisonResult,\n  DynamicChecklistItem,\n  PropertyData,\n  AIServiceConfig,\n  AIAnalysisOptions,\n  AIError\n} from './types';\n\nexport class STRCertifiedAIService {\n  private openai: OpenAI;\n  private config: AIServiceConfig;\n\n  constructor(config: AIServiceConfig) {\n    this.config = {\n      model: 'gpt-4-vision-preview',\n      maxTokens: 1000,\n      temperature: 0.3,\n      timeout: 30000,\n      ...config\n    };\n\n    this.openai = new OpenAI({\n      apiKey: this.config.apiKey,\n      timeout: this.config.timeout,\n    });\n  }\n\n  /**\n   * Analyzes an inspection photo using AI vision capabilities\n   * @param file - The image file to analyze\n   * @param checklistContext - Context about what to look for\n   * @param options - Analysis options\n   * @returns Promise<AIAnalysisResult>\n   */\n  async analyzeInspectionPhoto(\n    file: File,\n    checklistContext: string,\n    options: AIAnalysisOptions = {}\n  ): Promise<AIAnalysisResult> {\n    try {\n      // Convert file to base64 for OpenAI API\n      const base64Image = await this.fileToBase64(file);\n      \n      const prompt = this.buildInspectionAnalysisPrompt(checklistContext, options);\n\n      const response = await this.openai.chat.completions.create({\n        model: this.config.model || 'gpt-4-vision-preview',\n        max_tokens: this.config.maxTokens,\n        temperature: this.config.temperature,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'text',\n                text: prompt\n              },\n              {\n                type: 'image_url',\n                image_url: {\n                  url: `data:image/jpeg;base64,${base64Image}`,\n                  detail: 'high'\n                }\n              }\n            ]\n          }\n        ]\n      });\n\n      const content = response.choices[0]?.message?.content;\n      if (!content) {\n        throw new Error('No response from OpenAI');\n      }\n\n      return this.parseAnalysisResponse(content);\n    } catch (error) {\n      throw this.handleAPIError(error);\n    }\n  }\n\n  /**\n   * Generates a dynamic checklist based on property data\n   * @param propertyData - Property information for contextualization\n   * @returns Promise<DynamicChecklistItem[]>\n   */\n  async generateDynamicChecklist(propertyData: PropertyData): Promise<DynamicChecklistItem[]> {\n    try {\n      const prompt = this.buildChecklistGenerationPrompt(propertyData);\n\n      const response = await this.openai.chat.completions.create({\n        model: 'gpt-4-turbo-preview',\n        max_tokens: 2000,\n        temperature: 0.2,\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an expert property inspector specializing in short-term rental compliance and safety. Generate comprehensive inspection checklists based on property characteristics.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ]\n      });\n\n      const content = response.choices[0]?.message?.content;\n      if (!content) {\n        throw new Error('No response from OpenAI');\n      }\n\n      return this.parseChecklistResponse(content);\n    } catch (error) {\n      throw this.handleAPIError(error);\n    }\n  }\n\n  /**\n   * Compares an inspector photo to listing photos for accuracy verification\n   * @param inspectorPhoto - Photo taken by inspector\n   * @param listingPhotos - Array of listing photo URLs\n   * @param roomContext - Context about which room/area is being compared\n   * @returns Promise<PhotoComparisonResult>\n   */\n  async comparePhotoToListing(\n    inspectorPhoto: File,\n    listingPhotos: string[],\n    roomContext: string\n  ): Promise<PhotoComparisonResult> {\n    try {\n      const inspectorBase64 = await this.fileToBase64(inspectorPhoto);\n      \n      // For now, compare to the first listing photo (can be enhanced to compare multiple)\n      const primaryListingPhoto = listingPhotos[0];\n      \n      const prompt = this.buildPhotoComparisonPrompt(roomContext);\n\n      const response = await this.openai.chat.completions.create({\n        model: this.config.model || 'gpt-4-vision-preview',\n        max_tokens: 1000,\n        temperature: 0.1,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'text',\n                text: prompt\n              },\n              {\n                type: 'text',\n                text: 'Inspector Photo:'\n              },\n              {\n                type: 'image_url',\n                image_url: {\n                  url: `data:image/jpeg;base64,${inspectorBase64}`,\n                  detail: 'high'\n                }\n              },\n              {\n                type: 'text',\n                text: 'Listing Photo:'\n              },\n              {\n                type: 'image_url',\n                image_url: {\n                  url: primaryListingPhoto,\n                  detail: 'high'\n                }\n              }\n            ]\n          }\n        ]\n      });\n\n      const content = response.choices[0]?.message?.content;\n      if (!content) {\n        throw new Error('No response from OpenAI');\n      }\n\n      return this.parseComparisonResponse(content);\n    } catch (error) {\n      throw this.handleAPIError(error);\n    }\n  }\n\n  /**\n   * Validates inspection completeness using AI\n   * @param checklistItems - Completed checklist items\n   * @param photos - All inspection photos\n   * @returns Promise<{complete: boolean, missingItems: string[], recommendations: string[]}>\n   */\n  async validateInspectionCompleteness(\n    checklistItems: any[],\n    photos: File[]\n  ): Promise<{\n    complete: boolean;\n    missingItems: string[];\n    recommendations: string[];\n    confidence: number;\n  }> {\n    try {\n      const prompt = this.buildValidationPrompt(checklistItems, photos.length);\n\n      const response = await this.openai.chat.completions.create({\n        model: 'gpt-4-turbo-preview',\n        max_tokens: 1000,\n        temperature: 0.2,\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an expert inspection validator. Analyze checklist completeness and provide recommendations.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ]\n      });\n\n      const content = response.choices[0]?.message?.content;\n      if (!content) {\n        throw new Error('No response from OpenAI');\n      }\n\n      return this.parseValidationResponse(content);\n    } catch (error) {\n      throw this.handleAPIError(error);\n    }\n  }\n\n  // Private helper methods\n\n  private async fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => {\n        const base64 = reader.result as string;\n        // Remove data:image/[type];base64, prefix\n        const base64Data = base64.split(',')[1];\n        resolve(base64Data);\n      };\n      reader.onerror = error => reject(error);\n    });\n  }\n\n  private buildInspectionAnalysisPrompt(context: string, options: AIAnalysisOptions): string {\n    return `\nAnalyze this inspection photo for STR (Short-Term Rental) compliance and safety. Context: ${context}\n\nPlease provide a detailed analysis including:\n1. Detected features and objects\n2. Safety assessment (fire safety, building code compliance, accessibility)\n3. Pass/fail recommendation based on STR standards\n4. Confidence level (0-100)\n5. Detailed reasoning for your assessment\n\n${options.checkSafetyConcerns ? 'Pay special attention to safety concerns and violations.' : ''}\n${options.compareToStandards ? 'Compare against local building codes and STR regulations.' : ''}\n${options.generateRecommendations ? 'Provide specific recommendations for improvement.' : ''}\n\nFormat your response as JSON with the following structure:\n{\n  \"confidence\": number,\n  \"detected_features\": string[],\n  \"pass_fail_recommendation\": \"pass\" | \"fail\" | \"review_required\",\n  \"reasoning\": \"detailed explanation\",\n  \"safety_concerns\": string[],\n  \"compliance_status\": {\n    \"building_code\": boolean,\n    \"fire_safety\": boolean,\n    \"accessibility\": boolean\n  }\n}\n    `.trim();\n  }\n\n  private buildChecklistGenerationPrompt(propertyData: PropertyData): string {\n    return `\nGenerate a comprehensive inspection checklist for this STR property:\n\nProperty Type: ${propertyData.property_type}\nBedrooms: ${propertyData.room_count.bedrooms}\nBathrooms: ${propertyData.room_count.bathrooms}\nAmenities: ${propertyData.amenities.join(', ')}\nDescription: ${propertyData.description}\nLocation: ${propertyData.location.city}, ${propertyData.location.state}\n${propertyData.special_features ? `Special Features: ${propertyData.special_features.join(', ')}` : ''}\n\nGenerate 15-25 specific checklist items that are:\n1. Relevant to this property type and amenities\n2. Focused on safety, compliance, and guest experience\n3. Prioritized by importance (critical, high, medium, low)\n4. Include estimated time for completion\n\nFormat as JSON array of checklist items with this structure:\n{\n  \"id\": \"unique_id\",\n  \"title\": \"Item title\",\n  \"description\": \"Detailed description\",\n  \"required\": boolean,\n  \"ai_generated\": true,\n  \"category\": \"safety|compliance|amenities|cleanliness|maintenance\",\n  \"priority\": \"critical|high|medium|low\",\n  \"estimated_time_minutes\": number\n}\n    `.trim();\n  }\n\n  private buildPhotoComparisonPrompt(roomContext: string): string {\n    return `\nCompare these two photos of ${roomContext} to verify listing accuracy:\n\nAnalyze and provide:\n1. Similarity score (0-100%)\n2. Specific discrepancies found\n3. Assessment of lighting, furniture, layout differences\n4. Overall recommendation (matches_listing, minor_differences, major_discrepancies)\n5. Confidence in comparison\n\nFormat response as JSON:\n{\n  \"similarity_score\": number,\n  \"discrepancies\": string[],\n  \"recommendation\": \"matches_listing\" | \"minor_differences\" | \"major_discrepancies\",\n  \"confidence\": number,\n  \"details\": {\n    \"lighting_differences\": boolean,\n    \"furniture_changes\": boolean,\n    \"structural_differences\": boolean,\n    \"room_layout_match\": boolean\n  }\n}\n    `.trim();\n  }\n\n  private buildValidationPrompt(checklistItems: any[], photoCount: number): string {\n    return `\nValidate the completeness of this STR inspection:\n\nChecklist Items Completed: ${checklistItems.length}\nPhotos Taken: ${photoCount}\n\nChecklist Summary:\n${checklistItems.map(item => `- ${item.title}: ${item.status || 'completed'}`).join('\\n')}\n\nAnalyze if this inspection is complete and provide:\n1. Completeness assessment (true/false)\n2. Missing critical items\n3. Recommendations for improvement\n4. Confidence in assessment\n\nFormat as JSON:\n{\n  \"complete\": boolean,\n  \"missingItems\": string[],\n  \"recommendations\": string[],\n  \"confidence\": number\n}\n    `.trim();\n  }\n\n  private parseAnalysisResponse(content: string): AIAnalysisResult {\n    try {\n      const parsed = JSON.parse(content);\n      return {\n        confidence: parsed.confidence || 0,\n        detected_features: parsed.detected_features || [],\n        pass_fail_recommendation: parsed.pass_fail_recommendation || 'review_required',\n        reasoning: parsed.reasoning || 'Analysis completed',\n        safety_concerns: parsed.safety_concerns,\n        compliance_status: parsed.compliance_status\n      };\n    } catch (error) {\n      // Fallback parsing if JSON is malformed\n      return {\n        confidence: 50,\n        detected_features: ['Analysis completed'],\n        pass_fail_recommendation: 'review_required',\n        reasoning: content.substring(0, 500),\n      };\n    }\n  }\n\n  private parseChecklistResponse(content: string): DynamicChecklistItem[] {\n    try {\n      const parsed = JSON.parse(content);\n      return Array.isArray(parsed) ? parsed : [parsed];\n    } catch (error) {\n      // Return empty array if parsing fails\n      console.error('Failed to parse checklist response:', error);\n      return [];\n    }\n  }\n\n  private parseComparisonResponse(content: string): PhotoComparisonResult {\n    try {\n      const parsed = JSON.parse(content);\n      return {\n        similarity_score: parsed.similarity_score || 0,\n        discrepancies: parsed.discrepancies || [],\n        recommendation: parsed.recommendation || 'major_discrepancies',\n        confidence: parsed.confidence || 0,\n        details: parsed.details || {\n          lighting_differences: false,\n          furniture_changes: false,\n          structural_differences: false,\n          room_layout_match: false\n        }\n      };\n    } catch (error) {\n      return {\n        similarity_score: 0,\n        discrepancies: ['Unable to analyze comparison'],\n        recommendation: 'major_discrepancies',\n        confidence: 0,\n        details: {\n          lighting_differences: false,\n          furniture_changes: false,\n          structural_differences: false,\n          room_layout_match: false\n        }\n      };\n    }\n  }\n\n  private parseValidationResponse(content: string): {\n    complete: boolean;\n    missingItems: string[];\n    recommendations: string[];\n    confidence: number;\n  } {\n    try {\n      const parsed = JSON.parse(content);\n      return {\n        complete: parsed.complete || false,\n        missingItems: parsed.missingItems || [],\n        recommendations: parsed.recommendations || [],\n        confidence: parsed.confidence || 0\n      };\n    } catch (error) {\n      return {\n        complete: false,\n        missingItems: ['Unable to validate'],\n        recommendations: ['Review inspection manually'],\n        confidence: 0\n      };\n    }\n  }\n\n  private handleAPIError(error: any): AIError {\n    if (error.code === 'insufficient_quota') {\n      return {\n        code: 'QUOTA_EXCEEDED',\n        message: 'OpenAI API quota exceeded',\n        details: error,\n        retryable: false\n      };\n    }\n\n    if (error.code === 'rate_limit_exceeded') {\n      return {\n        code: 'RATE_LIMITED',\n        message: 'Rate limit exceeded, please try again later',\n        details: error,\n        retryable: true\n      };\n    }\n\n    if (error.status === 401) {\n      return {\n        code: 'INVALID_API_KEY',\n        message: 'Invalid OpenAI API key',\n        details: error,\n        retryable: false\n      };\n    }\n\n    return {\n      code: 'UNKNOWN_ERROR',\n      message: error.message || 'An unknown error occurred',\n      details: error,\n      retryable: true\n    };\n  }\n}\n\n// Export a singleton instance factory\nexport const createAIService = (config: AIServiceConfig): STRCertifiedAIService => {\n  return new STRCertifiedAIService(config);\n};\n\n// Export default configuration\nexport const DEFAULT_AI_CONFIG: Partial<AIServiceConfig> = {\n  model: 'gpt-4-vision-preview',\n  maxTokens: 1000,\n  temperature: 0.3,\n  timeout: 30000,\n} as const;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/photo-comparison.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11497,11500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11497,11500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":396,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":396,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11522,11525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11522,11525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":532,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":532,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15621,15624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15621,15624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Photo Comparison Engine for STR Certified\n\nimport type {\n  PhotoComparisonResult,\n  PhotoQualityMetrics,\n  DiscrepancyReport,\n  RoomFeatures,\n  ComparisonRecommendation,\n  DiscrepancyType,\n  QualityScore,\n  QualityIssue,\n  QualityImprovement,\n  DetectedFurniture,\n  DetectedFixture,\n  DetectedAmenity,\n  ConditionAssessment,\n  ImageRegion,\n  PhotoComparisonConfig,\n  BatchComparisonResult,\n  ComparisonSummary\n} from '@/types/photo';\n\nexport class PhotoComparisonEngine {\n  private config: PhotoComparisonConfig;\n  private analysisVersion: string = '1.0.0';\n\n  constructor(config: Partial<PhotoComparisonConfig> = {}) {\n    this.config = {\n      similarityThreshold: 75,\n      qualityThreshold: 70,\n      enableAIAnalysis: true,\n      enableManualReview: false,\n      strictMode: false,\n      maxProcessingTime: 30000,\n      ...config\n    };\n  }\n\n  /**\n   * Compares an inspector photo to a listing photo\n   * @param inspectorPhoto - Photo taken by inspector\n   * @param listingPhoto - Reference photo from listing\n   * @param roomContext - Context about the room being compared\n   * @returns Promise<PhotoComparisonResult>\n   */\n  async compareInspectorPhotoToListing(\n    inspectorPhoto: File | string,\n    listingPhoto: string,\n    roomContext?: string\n  ): Promise<PhotoComparisonResult> {\n    const startTime = Date.now();\n\n    try {\n      // Step 1: Analyze photo quality\n      const qualityMetrics = await this.analyzePhotoQuality(inspectorPhoto);\n      \n      // Step 2: Check if quality meets minimum threshold\n      if (qualityMetrics.overall_score < this.config.qualityThreshold) {\n        return this.createLowQualityResult(qualityMetrics, startTime);\n      }\n\n      // Step 3: Detect room features in both photos\n      const inspectorFeatures = await this.detectRoomFeatures(inspectorPhoto);\n      const listingFeatures = await this.detectRoomFeatures(listingPhoto);\n\n      // Step 4: Compare features and calculate similarity\n      const discrepancies = this.compareFeatures(inspectorFeatures, listingFeatures);\n      const similarityScore = this.calculateSimilarityScore(inspectorFeatures, listingFeatures, discrepancies);\n\n      // Step 5: Generate recommendation\n      const recommendation = this.generateRecommendation(similarityScore, discrepancies, qualityMetrics);\n\n      // Step 6: Create comprehensive result\n      return {\n        similarity_score: similarityScore,\n        discrepancies,\n        quality_score: qualityMetrics,\n        recommendation,\n        confidence: this.calculateConfidence(qualityMetrics, discrepancies.length),\n        timestamp: new Date(),\n        processingTime: Date.now() - startTime,\n        metadata: {\n          roomType: roomContext,\n          inspectorPhotoDate: new Date(),\n          analysisVersion: this.analysisVersion\n        }\n      };\n\n    } catch (error) {\n      return this.createErrorResult(error, startTime);\n    }\n  }\n\n  /**\n   * Analyzes photo quality metrics\n   * @param photo - Photo to analyze\n   * @returns Promise<PhotoQualityMetrics>\n   */\n  async analyzePhotoQuality(photo: File | string): Promise<PhotoQualityMetrics> {\n    // Mock implementation - in production, this would use computer vision\n    await this.simulateProcessing(500);\n\n    const mockMetrics: PhotoQualityMetrics = {\n      sharpness: {\n        score: 85,\n        rating: 'good',\n        details: 'Image is sharp with good detail preservation'\n      },\n      lighting: {\n        score: 78,\n        rating: 'good',\n        details: 'Well-lit with minimal shadows'\n      },\n      composition: {\n        score: 82,\n        rating: 'good',\n        details: 'Good framing, captures full room view'\n      },\n      overall_score: 81.7,\n      issues: [],\n      suggestions: []\n    };\n\n    // Simulate quality issues detection\n    if (mockMetrics.sharpness.score < 70) {\n      mockMetrics.issues.push({\n        type: 'blur',\n        severity: 'major',\n        description: 'Image appears blurry or out of focus'\n      });\n      mockMetrics.suggestions.push({\n        action: 'Hold device steady and tap to focus',\n        priority: 'high',\n        icon: 'ðŸ“·',\n        estimatedImprovement: 25\n      });\n    }\n\n    if (mockMetrics.lighting.score < 60) {\n      mockMetrics.issues.push({\n        type: 'underexposed',\n        severity: 'major',\n        description: 'Image is too dark'\n      });\n      mockMetrics.suggestions.push({\n        action: 'Turn on lights or use flash',\n        priority: 'high',\n        icon: 'ðŸ’¡',\n        estimatedImprovement: 30\n      });\n    }\n\n    return mockMetrics;\n  }\n\n  /**\n   * Detects furniture, fixtures, and room condition\n   * @param photo - Photo to analyze\n   * @returns Promise<RoomFeatures>\n   */\n  async detectRoomFeatures(photo: File | string): Promise<RoomFeatures> {\n    // Mock implementation - in production, this would use AI vision\n    await this.simulateProcessing(1000);\n\n    const mockFeatures: RoomFeatures = {\n      furniture: [\n        {\n          type: 'bed',\n          condition: 'excellent',\n          location: { x: 100, y: 200, width: 400, height: 300 },\n          confidence: 95\n        },\n        {\n          type: 'nightstand',\n          condition: 'good',\n          location: { x: 50, y: 250, width: 100, height: 150 },\n          confidence: 88\n        },\n        {\n          type: 'dresser',\n          condition: 'good',\n          location: { x: 550, y: 150, width: 200, height: 250 },\n          confidence: 92\n        }\n      ],\n      fixtures: [\n        {\n          type: 'ceiling_light',\n          working: true,\n          condition: 'excellent',\n          location: { x: 350, y: 50, width: 100, height: 100 },\n          needsMaintenance: false\n        },\n        {\n          type: 'wall_outlet',\n          working: true,\n          condition: 'good',\n          location: { x: 100, y: 400, width: 50, height: 50 },\n          needsMaintenance: false\n        }\n      ],\n      amenities: [\n        {\n          name: 'Smart TV',\n          present: true,\n          functional: true,\n          location: { x: 300, y: 100, width: 200, height: 150 },\n          matchesListing: true\n        },\n        {\n          name: 'Air Conditioning',\n          present: true,\n          functional: true,\n          matchesListing: true\n        }\n      ],\n      condition: {\n        overall: 'excellent',\n        cleanliness: 92,\n        maintenance: 88,\n        damage: [],\n        wearAndTear: 'Minimal wear, well-maintained'\n      },\n      roomType: 'bedroom',\n      confidence: 89\n    };\n\n    return mockFeatures;\n  }\n\n  /**\n   * Generates a comprehensive comparison report\n   * @param results - Array of comparison results\n   * @returns BatchComparisonResult\n   */\n  async generateComparisonReport(\n    results: PhotoComparisonResult[]\n  ): Promise<BatchComparisonResult> {\n    const roomComparisons = new Map<string, PhotoComparisonResult>();\n    const criticalIssues: DiscrepancyReport[] = [];\n    \n    let totalSimilarity = 0;\n    let totalQuality = 0;\n    let matchingPhotos = 0;\n    let minorDifferences = 0;\n    let majorDifferences = 0;\n\n    results.forEach((result, index) => {\n      const roomId = result.metadata.roomType || `room_${index}`;\n      roomComparisons.set(roomId, result);\n      \n      totalSimilarity += result.similarity_score;\n      totalQuality += result.quality_score.overall_score;\n\n      // Categorize results\n      if (result.similarity_score >= 90) {\n        matchingPhotos++;\n      } else if (result.similarity_score >= 70) {\n        minorDifferences++;\n      } else {\n        majorDifferences++;\n      }\n\n      // Collect critical issues\n      result.discrepancies\n        .filter(d => d.severity === 'critical')\n        .forEach(d => criticalIssues.push(d));\n    });\n\n    const summary: ComparisonSummary = {\n      totalPhotos: results.length,\n      matchingPhotos,\n      minorDifferences,\n      majorDifferences,\n      averageSimilarity: totalSimilarity / results.length,\n      averageQuality: totalQuality / results.length,\n      passRate: (matchingPhotos + minorDifferences) / results.length * 100\n    };\n\n    const recommendations = this.generateBatchRecommendations(summary, criticalIssues);\n\n    return {\n      roomComparisons,\n      overallSimilarity: summary.averageSimilarity,\n      criticalIssues,\n      summary,\n      recommendations\n    };\n  }\n\n  // Private helper methods\n\n  private compareFeatures(\n    inspectorFeatures: RoomFeatures,\n    listingFeatures: RoomFeatures\n  ): DiscrepancyReport[] {\n    const discrepancies: DiscrepancyReport[] = [];\n\n    // Compare furniture\n    listingFeatures.furniture.forEach(listingItem => {\n      const found = inspectorFeatures.furniture.find(\n        item => item.type === listingItem.type && \n                this.isLocationSimilar(item.location, listingItem.location)\n      );\n\n      if (!found) {\n        discrepancies.push({\n          type: 'missing_furniture',\n          severity: 'major',\n          description: `${listingItem.type} shown in listing is missing`,\n          location: listingItem.location,\n          confidence: 85\n        });\n      } else if (found.condition !== listingItem.condition && \n                 this.isConditionWorse(found.condition, listingItem.condition)) {\n        discrepancies.push({\n          type: 'damage_detected',\n          severity: 'minor',\n          description: `${found.type} condition has deteriorated`,\n          location: found.location,\n          confidence: 75\n        });\n      }\n    });\n\n    // Compare amenities\n    listingFeatures.amenities.forEach(listingAmenity => {\n      const found = inspectorFeatures.amenities.find(\n        a => a.name === listingAmenity.name\n      );\n\n      if (!found || !found.present) {\n        discrepancies.push({\n          type: 'missing_amenity',\n          severity: 'critical',\n          description: `${listingAmenity.name} advertised but not found`,\n          confidence: 90\n        });\n      } else if (found.present && !found.functional) {\n        discrepancies.push({\n          type: 'maintenance_needed',\n          severity: 'major',\n          description: `${found.name} is not functional`,\n          confidence: 95\n        });\n      }\n    });\n\n    // Check overall condition\n    if (inspectorFeatures.condition.cleanliness < 70) {\n      discrepancies.push({\n        type: 'cleanliness_issue',\n        severity: 'major',\n        description: 'Room cleanliness below acceptable standards',\n        confidence: 88\n      });\n    }\n\n    return discrepancies;\n  }\n\n  private calculateSimilarityScore(\n    inspectorFeatures: RoomFeatures,\n    listingFeatures: RoomFeatures,\n    discrepancies: DiscrepancyReport[]\n  ): number {\n    // Base similarity from feature matching\n    const furnitureMatch = this.calculateFeatureMatchRate(\n      inspectorFeatures.furniture,\n      listingFeatures.furniture\n    );\n    const amenityMatch = this.calculateAmenityMatchRate(\n      inspectorFeatures.amenities,\n      listingFeatures.amenities\n    );\n\n    // Penalty for discrepancies\n    const discrepancyPenalty = discrepancies.reduce((penalty, d) => {\n      switch (d.severity) {\n        case 'critical': return penalty + 15;\n        case 'major': return penalty + 10;\n        case 'minor': return penalty + 5;\n        default: return penalty + 2;\n      }\n    }, 0);\n\n    // Calculate weighted score\n    const baseScore = (furnitureMatch * 0.4 + amenityMatch * 0.6) * 100;\n    const finalScore = Math.max(0, baseScore - discrepancyPenalty);\n\n    return Math.round(finalScore);\n  }\n\n  private calculateFeatureMatchRate(\n    inspectorItems: any[],\n    listingItems: any[]\n  ): number {\n    if (listingItems.length === 0) return 1;\n    \n    let matches = 0;\n    listingItems.forEach(listingItem => {\n      if (inspectorItems.some(item => item.type === listingItem.type)) {\n        matches++;\n      }\n    });\n\n    return matches / listingItems.length;\n  }\n\n  private calculateAmenityMatchRate(\n    inspectorAmenities: DetectedAmenity[],\n    listingAmenities: DetectedAmenity[]\n  ): number {\n    if (listingAmenities.length === 0) return 1;\n    \n    let matches = 0;\n    listingAmenities.forEach(listingAmenity => {\n      const found = inspectorAmenities.find(a => a.name === listingAmenity.name);\n      if (found && found.present && found.functional !== false) {\n        matches++;\n      }\n    });\n\n    return matches / listingAmenities.length;\n  }\n\n  private generateRecommendation(\n    similarityScore: number,\n    discrepancies: DiscrepancyReport[],\n    qualityMetrics: PhotoQualityMetrics\n  ): ComparisonRecommendation {\n    // Check quality first\n    if (qualityMetrics.overall_score < 60) {\n      return 'retake_photo';\n    }\n\n    // Check critical discrepancies\n    const criticalCount = discrepancies.filter(d => d.severity === 'critical').length;\n    if (criticalCount > 0) {\n      return 'significant_discrepancies';\n    }\n\n    // Check similarity score\n    if (similarityScore >= 90) {\n      return 'matches_listing';\n    } else if (similarityScore >= 75) {\n      return 'acceptable_differences';\n    } else if (similarityScore >= 60) {\n      return 'review_required';\n    } else {\n      return 'significant_discrepancies';\n    }\n  }\n\n  private calculateConfidence(\n    qualityMetrics: PhotoQualityMetrics,\n    discrepancyCount: number\n  ): number {\n    // Higher quality and fewer discrepancies increase confidence\n    const qualityFactor = qualityMetrics.overall_score / 100;\n    const discrepancyFactor = Math.max(0, 1 - (discrepancyCount * 0.1));\n    \n    return Math.round((qualityFactor * 0.6 + discrepancyFactor * 0.4) * 100);\n  }\n\n  private isLocationSimilar(loc1: ImageRegion, loc2: ImageRegion): boolean {\n    const centerDist = Math.sqrt(\n      Math.pow((loc1.x + loc1.width/2) - (loc2.x + loc2.width/2), 2) +\n      Math.pow((loc1.y + loc1.height/2) - (loc2.y + loc2.height/2), 2)\n    );\n    \n    return centerDist < 100; // pixels threshold\n  }\n\n  private isConditionWorse(\n    current: string,\n    original: string\n  ): boolean {\n    const conditionOrder = ['new', 'excellent', 'good', 'fair', 'poor'];\n    return conditionOrder.indexOf(current) > conditionOrder.indexOf(original);\n  }\n\n  private generateBatchRecommendations(\n    summary: ComparisonSummary,\n    criticalIssues: DiscrepancyReport[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (summary.passRate < 80) {\n      recommendations.push('Overall pass rate is below acceptable threshold. Review all failed comparisons.');\n    }\n\n    if (summary.averageQuality < 70) {\n      recommendations.push('Photo quality needs improvement. Provide better lighting and camera guidance to inspectors.');\n    }\n\n    if (criticalIssues.length > 0) {\n      recommendations.push(`${criticalIssues.length} critical issues found. Immediate attention required.`);\n    }\n\n    if (summary.majorDifferences > summary.totalPhotos * 0.2) {\n      recommendations.push('High rate of major differences detected. Property may need re-listing or major updates.');\n    }\n\n    return recommendations;\n  }\n\n  private createLowQualityResult(\n    qualityMetrics: PhotoQualityMetrics,\n    startTime: number\n  ): PhotoComparisonResult {\n    return {\n      similarity_score: 0,\n      discrepancies: [{\n        type: 'cleanliness_issue',\n        severity: 'critical',\n        description: 'Photo quality too low for accurate comparison',\n        confidence: 100\n      }],\n      quality_score: qualityMetrics,\n      recommendation: 'retake_photo',\n      confidence: 0,\n      timestamp: new Date(),\n      processingTime: Date.now() - startTime,\n      metadata: {\n        inspectorPhotoDate: new Date(),\n        analysisVersion: this.analysisVersion\n      }\n    };\n  }\n\n  private createErrorResult(error: any, startTime: number): PhotoComparisonResult {\n    return {\n      similarity_score: 0,\n      discrepancies: [{\n        type: 'cleanliness_issue',\n        severity: 'critical',\n        description: `Analysis failed: ${error.message}`,\n        confidence: 0\n      }],\n      quality_score: {\n        sharpness: { score: 0, rating: 'unacceptable' },\n        lighting: { score: 0, rating: 'unacceptable' },\n        composition: { score: 0, rating: 'unacceptable' },\n        overall_score: 0,\n        issues: [],\n        suggestions: []\n      },\n      recommendation: 'retake_photo',\n      confidence: 0,\n      timestamp: new Date(),\n      processingTime: Date.now() - startTime,\n      metadata: {\n        inspectorPhotoDate: new Date(),\n        analysisVersion: this.analysisVersion\n      }\n    };\n  }\n\n  private async simulateProcessing(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Export factory function\nexport const createPhotoComparisonEngine = (\n  config?: Partial<PhotoComparisonConfig>\n): PhotoComparisonEngine => {\n  return new PhotoComparisonEngine(config);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/photo-quality-checker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/photo-quality-service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9650,9653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9650,9653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced Photo Quality Service for STR Certified MVP\n// Validates photo quality and provides re-upload prompts\n\nimport { STRCertifiedAIService } from './openai-service';\nimport { aiDecisionLogger } from './decision-logger';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\n\n// Photo Quality Types\nexport interface PhotoQualityResult {\n  isAcceptable: boolean;\n  qualityScore: number; // 0-100\n  issues: PhotoQualityIssue[];\n  recommendation: QualityRecommendation;\n  confidence: number;\n  processingTime: number;\n  retryPrompt?: string;\n}\n\nexport interface PhotoQualityIssue {\n  type: QualityIssueType;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  fixSuggestion: string;\n  blocking: boolean;\n}\n\nexport type QualityIssueType = \n  | 'blur'\n  | 'low_light'\n  | 'overexposure'\n  | 'poor_composition'\n  | 'wrong_subject'\n  | 'obstruction'\n  | 'poor_angle'\n  | 'resolution_too_low'\n  | 'color_distortion'\n  | 'focus_issues'\n  | 'motion_blur'\n  | 'timestamp_missing'\n  | 'safety_equipment_not_visible'\n  | 'insufficient_coverage';\n\nexport interface QualityRecommendation {\n  action: 'accept' | 'request_retake' | 'manual_review';\n  reason: string;\n  improvements: string[];\n  expectedQuality: number;\n}\n\nexport interface ChecklistItemContext {\n  title: string;\n  description: string;\n  category: string;\n  evidenceRequired: boolean;\n  safetyRelated: boolean;\n  complianceRequired: boolean;\n  expectedSubjects: string[];\n  minimumQuality: number;\n}\n\nexport class PhotoQualityService {\n  private static instance: PhotoQualityService;\n  private aiService: STRCertifiedAIService;\n  private qualityThresholds: Record<string, number> = {\n    safety: 85,\n    compliance: 80,\n    general: 70,\n    documentation: 75,\n    evidence: 90\n  };\n\n  private constructor() {\n    // Initialize AI service with API key from environment\n    this.aiService = new STRCertifiedAIService({\n      apiKey: import.meta.env.VITE_OPENAI_API_KEY || '',\n      model: 'gpt-4-vision-preview',\n      maxTokens: 1000,\n      temperature: 0.1 // Low temperature for consistent quality assessment\n    });\n  }\n\n  static getInstance(): PhotoQualityService {\n    if (!PhotoQualityService.instance) {\n      PhotoQualityService.instance = new PhotoQualityService();\n    }\n    return PhotoQualityService.instance;\n  }\n\n  /**\n   * Validates photo quality for a specific checklist item\n   * @param photo - The photo file to validate\n   * @param context - Context about the checklist item\n   * @returns Promise<PhotoQualityResult>\n   */\n  async validatePhotoQuality(\n    photo: File,\n    context: ChecklistItemContext\n  ): Promise<PhotoQualityResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Log the quality validation attempt\n      await aiDecisionLogger.logSimpleDecision(\n        `Photo quality validation: ${context.title}`,\n        'code_quality',\n        `Validating photo quality for checklist item: ${context.title}`,\n        [`photo_${photo.name}`],\n        'medium'\n      );\n\n      // Get expected quality threshold for this context\n      const expectedQuality = this.getExpectedQuality(context);\n      \n      // Analyze photo with AI\n      const analysisResult = await this.analyzePhotoWithAI(photo, context);\n      \n      // Process and structure the results\n      const result: PhotoQualityResult = {\n        isAcceptable: analysisResult.qualityScore >= expectedQuality,\n        qualityScore: analysisResult.qualityScore,\n        issues: analysisResult.issues,\n        recommendation: this.generateRecommendation(analysisResult, expectedQuality),\n        confidence: analysisResult.confidence,\n        processingTime: Date.now() - startTime,\n        retryPrompt: analysisResult.qualityScore < expectedQuality ? \n          this.generateRetryPrompt(analysisResult.issues, context) : undefined\n      };\n\n      // Log the validation result\n      logger.info(`Photo quality validation completed`, {\n        checklistItem: context.title,\n        qualityScore: result.qualityScore,\n        acceptable: result.isAcceptable,\n        issues: result.issues.length,\n        processingTime: result.processingTime\n      }, 'PHOTO_QUALITY_VALIDATION');\n\n      return result;\n\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'PHOTO_QUALITY_VALIDATION',\n        checklistItem: context.title,\n        photoName: photo.name,\n        photoSize: photo.size\n      });\n\n      // Return fallback result on error\n      return {\n        isAcceptable: false,\n        qualityScore: 0,\n        issues: [{\n          type: 'resolution_too_low',\n          severity: 'high',\n          description: 'Unable to analyze photo quality',\n          fixSuggestion: 'Please try uploading the photo again',\n          blocking: true\n        }],\n        recommendation: {\n          action: 'request_retake',\n          reason: 'Technical error during quality analysis',\n          improvements: ['Try uploading the photo again'],\n          expectedQuality: 70\n        },\n        confidence: 0,\n        processingTime: Date.now() - startTime,\n        retryPrompt: 'There was an issue analyzing your photo. Please try uploading it again.'\n      };\n    }\n  }\n\n  /**\n   * Batch validates multiple photos for efficiency\n   * @param photos - Array of photo files with their contexts\n   * @returns Promise<PhotoQualityResult[]>\n   */\n  async validateMultiplePhotos(\n    photos: Array<{ file: File; context: ChecklistItemContext }>\n  ): Promise<PhotoQualityResult[]> {\n    const results: PhotoQualityResult[] = [];\n    \n    // Process photos in batches to avoid API rate limits\n    const batchSize = 3;\n    for (let i = 0; i < photos.length; i += batchSize) {\n      const batch = photos.slice(i, i + batchSize);\n      \n      const batchResults = await Promise.all(\n        batch.map(({ file, context }) => this.validatePhotoQuality(file, context))\n      );\n      \n      results.push(...batchResults);\n      \n      // Small delay between batches to respect rate limits\n      if (i + batchSize < photos.length) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Generates a user-friendly retry prompt with specific instructions\n   * @param issues - List of quality issues found\n   * @param context - Checklist item context\n   * @returns string\n   */\n  private generateRetryPrompt(issues: PhotoQualityIssue[], context: ChecklistItemContext): string {\n    const blockingIssues = issues.filter(issue => issue.blocking);\n    \n    if (blockingIssues.length === 0) {\n      return 'Your photo has been accepted! You may continue to the next item.';\n    }\n\n    const mainIssue = blockingIssues[0];\n    const suggestions = blockingIssues.map(issue => issue.fixSuggestion).slice(0, 3);\n    \n    const basePrompt = `ðŸ“¸ Photo needs improvement for \"${context.title}\"`;\n    const issueDescription = mainIssue.description;\n    const improvementTips = suggestions.join('\\nâ€¢ ');\n    \n    return `${basePrompt}\\n\\n${issueDescription}\\n\\nTo improve your photo:\\nâ€¢ ${improvementTips}`;\n  }\n\n  /**\n   * Analyzes photo using AI vision capabilities\n   * @param photo - Photo file to analyze\n   * @param context - Checklist item context\n   * @returns Promise with analysis results\n   */\n  private async analyzePhotoWithAI(\n    photo: File,\n    context: ChecklistItemContext\n  ): Promise<{\n    qualityScore: number;\n    issues: PhotoQualityIssue[];\n    confidence: number;\n  }> {\n    const prompt = this.buildQualityAnalysisPrompt(context);\n    \n    try {\n      const analysisResult = await this.aiService.analyzeInspectionPhoto(\n        photo,\n        prompt,\n        {\n          includeDetailedAnalysis: true,\n          checkSafetyConcerns: context.safetyRelated,\n          compareToStandards: context.complianceRequired\n        }\n      );\n\n      return this.parseQualityAnalysis(analysisResult);\n    } catch (error) {\n      logger.error('AI photo analysis failed', error, 'PHOTO_QUALITY_AI');\n      throw error;\n    }\n  }\n\n  /**\n   * Builds the AI prompt for photo quality analysis\n   * @param context - Checklist item context\n   * @returns string\n   */\n  private buildQualityAnalysisPrompt(context: ChecklistItemContext): string {\n    return `\nAnalyze this photo for quality and suitability for STR property inspection.\n\nContext: ${context.title}\nDescription: ${context.description}\nCategory: ${context.category}\nEvidence Required: ${context.evidenceRequired ? 'Yes' : 'No'}\nSafety Related: ${context.safetyRelated ? 'Yes' : 'No'}\nExpected Subjects: ${context.expectedSubjects.join(', ')}\n\nPlease evaluate:\n1. Technical quality (focus, lighting, resolution, composition)\n2. Content relevance (shows expected subjects clearly)\n3. Suitability for inspection purposes\n4. Any safety or compliance issues visible\n\nProvide specific feedback on issues and improvements needed.\nQuality score should be 0-100 where:\n- 90-100: Excellent quality, perfect for inspection\n- 80-89: Good quality, minor improvements possible\n- 70-79: Acceptable quality, some improvements needed\n- 60-69: Poor quality, significant improvements needed\n- 0-59: Unacceptable, retake required\n\nFocus on practical inspection needs rather than artistic quality.\n${context.safetyRelated ? 'Pay special attention to safety equipment and hazards visibility.' : ''}\n${context.complianceRequired ? 'Ensure compliance elements are clearly visible and documented.' : ''}\n    `.trim();\n  }\n\n  /**\n   * Parses AI analysis results into structured format\n   * @param analysisResult - Raw AI analysis result\n   * @returns Structured quality analysis\n   */\n  private parseQualityAnalysis(analysisResult: any): {\n    qualityScore: number;\n    issues: PhotoQualityIssue[];\n    confidence: number;\n  } {\n    const issues: PhotoQualityIssue[] = [];\n    \n    // Extract quality score from reasoning or default to confidence\n    const qualityScore = this.extractQualityScore(analysisResult.reasoning) || \n                        Math.min(analysisResult.confidence, 80);\n    \n    // Parse issues from reasoning\n    const parsedIssues = this.extractIssuesFromReasoning(analysisResult.reasoning);\n    issues.push(...parsedIssues);\n    \n    // Add safety concerns as issues\n    if (analysisResult.safety_concerns && analysisResult.safety_concerns.length > 0) {\n      analysisResult.safety_concerns.forEach((concern: string) => {\n        issues.push({\n          type: 'safety_equipment_not_visible',\n          severity: 'high',\n          description: concern,\n          fixSuggestion: 'Ensure safety equipment is clearly visible and properly positioned',\n          blocking: true\n        });\n      });\n    }\n    \n    return {\n      qualityScore,\n      issues,\n      confidence: analysisResult.confidence\n    };\n  }\n\n  /**\n   * Extracts quality score from AI reasoning text\n   * @param reasoning - AI reasoning text\n   * @returns number | null\n   */\n  private extractQualityScore(reasoning: string): number | null {\n    const scorePatterns = [\n      /quality score:?\\s*(\\d+)/i,\n      /score:?\\s*(\\d+)\\/100/i,\n      /rating:?\\s*(\\d+)/i,\n      /(\\d+)\\/100/,\n      /(\\d+)%/\n    ];\n    \n    for (const pattern of scorePatterns) {\n      const match = reasoning.match(pattern);\n      if (match) {\n        const score = parseInt(match[1]);\n        return score >= 0 && score <= 100 ? score : null;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Extracts issues from AI reasoning text\n   * @param reasoning - AI reasoning text\n   * @returns PhotoQualityIssue[]\n   */\n  private extractIssuesFromReasoning(reasoning: string): PhotoQualityIssue[] {\n    const issues: PhotoQualityIssue[] = [];\n    const lowercaseReasoning = reasoning.toLowerCase();\n    \n    // Define issue patterns to look for\n    const issuePatterns = [\n      {\n        keywords: ['blur', 'blurry', 'out of focus', 'unfocused'],\n        type: 'blur' as QualityIssueType,\n        severity: 'high' as const,\n        description: 'Image is blurry or out of focus',\n        fixSuggestion: 'Hold the camera steady and ensure proper focus before taking the photo'\n      },\n      {\n        keywords: ['dark', 'low light', 'underexposed', 'too dim'],\n        type: 'low_light' as QualityIssueType,\n        severity: 'medium' as const,\n        description: 'Image is too dark or poorly lit',\n        fixSuggestion: 'Increase lighting or use flash, ensure adequate room lighting'\n      },\n      {\n        keywords: ['overexposed', 'too bright', 'washed out', 'glare'],\n        type: 'overexposure' as QualityIssueType,\n        severity: 'medium' as const,\n        description: 'Image is overexposed or too bright',\n        fixSuggestion: 'Reduce lighting or adjust camera settings, avoid direct sunlight'\n      },\n      {\n        keywords: ['poor angle', 'wrong angle', 'composition', 'framing'],\n        type: 'poor_composition' as QualityIssueType,\n        severity: 'medium' as const,\n        description: 'Poor camera angle or composition',\n        fixSuggestion: 'Adjust camera angle to better capture the subject'\n      },\n      {\n        keywords: ['obstruction', 'blocked', 'obstacle', 'partially hidden'],\n        type: 'obstruction' as QualityIssueType,\n        severity: 'high' as const,\n        description: 'Subject is partially obstructed or hidden',\n        fixSuggestion: 'Remove obstructions or change angle to clearly show the subject'\n      },\n      {\n        keywords: ['low resolution', 'pixelated', 'poor quality'],\n        type: 'resolution_too_low' as QualityIssueType,\n        severity: 'medium' as const,\n        description: 'Image resolution is too low',\n        fixSuggestion: 'Use higher camera resolution settings or move closer to the subject'\n      }\n    ];\n\n    // Check for each issue pattern\n    issuePatterns.forEach(pattern => {\n      const hasIssue = pattern.keywords.some(keyword => \n        lowercaseReasoning.includes(keyword)\n      );\n      \n      if (hasIssue) {\n        issues.push({\n          type: pattern.type,\n          severity: pattern.severity,\n          description: pattern.description,\n          fixSuggestion: pattern.fixSuggestion,\n          blocking: pattern.severity === 'high' || pattern.severity === 'critical'\n        });\n      }\n    });\n\n    return issues;\n  }\n\n  /**\n   * Generates recommendation based on quality analysis\n   * @param analysis - Quality analysis results\n   * @param expectedQuality - Expected quality threshold\n   * @returns QualityRecommendation\n   */\n  private generateRecommendation(\n    analysis: { qualityScore: number; issues: PhotoQualityIssue[]; confidence: number },\n    expectedQuality: number\n  ): QualityRecommendation {\n    const blockingIssues = analysis.issues.filter(issue => issue.blocking);\n    \n    if (analysis.qualityScore >= expectedQuality && blockingIssues.length === 0) {\n      return {\n        action: 'accept',\n        reason: 'Photo meets quality standards',\n        improvements: [],\n        expectedQuality\n      };\n    }\n    \n    if (analysis.confidence < 50) {\n      return {\n        action: 'manual_review',\n        reason: 'Low confidence in quality assessment',\n        improvements: ['Consider manual review by auditor'],\n        expectedQuality\n      };\n    }\n    \n    return {\n      action: 'request_retake',\n      reason: `Quality score ${analysis.qualityScore} is below required ${expectedQuality}`,\n      improvements: analysis.issues.map(issue => issue.fixSuggestion).slice(0, 3),\n      expectedQuality\n    };\n  }\n\n  /**\n   * Determines expected quality threshold based on context\n   * @param context - Checklist item context\n   * @returns number\n   */\n  private getExpectedQuality(context: ChecklistItemContext): number {\n    if (context.minimumQuality > 0) {\n      return context.minimumQuality;\n    }\n    \n    if (context.safetyRelated) {\n      return this.qualityThresholds.safety;\n    }\n    \n    if (context.complianceRequired) {\n      return this.qualityThresholds.compliance;\n    }\n    \n    if (context.evidenceRequired) {\n      return this.qualityThresholds.evidence;\n    }\n    \n    return this.qualityThresholds.general;\n  }\n\n  /**\n   * Updates quality thresholds for different categories\n   * @param thresholds - New threshold values\n   */\n  updateQualityThresholds(thresholds: Partial<Record<string, number>>): void {\n    this.qualityThresholds = { ...this.qualityThresholds, ...thresholds };\n  }\n\n  /**\n   * Gets current quality thresholds\n   * @returns Current threshold configuration\n   */\n  getQualityThresholds(): Record<string, number> {\n    return { ...this.qualityThresholds };\n  }\n}\n\n// Export singleton instance\nexport const photoQualityService = PhotoQualityService.getInstance();\n\n// Export convenience functions\nexport const validatePhotoQuality = photoQualityService.validatePhotoQuality.bind(photoQualityService);\nexport const validateMultiplePhotos = photoQualityService.validateMultiplePhotos.bind(photoQualityService);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/session-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[918,921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[918,921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Session Manager for STR Certified\n// Coordinates AI collaboration systems and manages session lifecycle\n\nimport { aiDecisionLogger, AIDecision } from './decision-logger';\nimport { aiContextHandoffManager, AIContextHandoff } from './context-handoff';\nimport { adrManager, ADRRecord } from './adr-manager';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport { supabase } from '../supabase';\n\n// Session Types\nexport interface AISession {\n  id: string;\n  ai_agent: string;\n  start_time: string;\n  end_time?: string;\n  status: SessionStatus;\n  objectives: SessionObjective[];\n  context: SessionContext;\n  decisions: string[]; // Decision IDs\n  handoffs: string[]; // Handoff IDs\n  adrs: string[]; // ADR IDs\n  metrics: SessionMetrics;\n  outcomes: SessionOutcome[];\n  parent_session_id?: string;\n  child_session_ids: string[];\n  metadata: Record<string, any>;\n}\n\nexport type SessionStatus = 'active' | 'completed' | 'paused' | 'aborted' | 'handoff_pending';\n\nexport interface SessionObjective {\n  id: string;\n  description: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  status: 'pending' | 'in_progress' | 'completed' | 'blocked' | 'cancelled';\n  progress: number; // 0-100\n  estimated_completion: string;\n  actual_completion?: string;\n  dependencies: string[];\n  deliverables: string[];\n  success_criteria: string[];\n  notes: string;\n}\n\nexport interface SessionContext {\n  user_request: string;\n  initial_system_state: string;\n  constraints: string[];\n  assumptions: string[];\n  available_resources: string[];\n  previous_session_context?: string;\n  handoff_received?: boolean;\n  handoff_id?: string;\n}\n\nexport interface SessionMetrics {\n  decisions_made: number;\n  files_modified: number;\n  files_created: number;\n  lines_of_code_changed: number;\n  build_time: number;\n  test_coverage_change: number;\n  bugs_fixed: number;\n  features_implemented: number;\n  time_spent_minutes: number;\n  ai_confidence_average: number;\n  quality_score: number;\n}\n\nexport interface SessionOutcome {\n  timestamp: string;\n  outcome_type: 'success' | 'partial_success' | 'failure' | 'handoff';\n  description: string;\n  deliverables_completed: string[];\n  issues_encountered: string[];\n  lessons_learned: string[];\n  recommendations: string[];\n  next_steps: string[];\n}\n\nexport interface SessionQuery {\n  ai_agent?: string;\n  status?: SessionStatus;\n  date_range?: {\n    start: string;\n    end: string;\n  };\n  has_handoffs?: boolean;\n  has_adrs?: boolean;\n  objectives_status?: SessionObjective['status'];\n  limit?: number;\n}\n\nexport interface SessionSummary {\n  total_sessions: number;\n  active_sessions: number;\n  completed_sessions: number;\n  total_decisions: number;\n  total_handoffs: number;\n  total_adrs: number;\n  average_session_duration: number;\n  top_ai_agents: Array<{ agent: string; sessions: number }>;\n  success_rate: number;\n  common_objectives: Array<{ objective: string; frequency: number }>;\n}\n\nexport class AISessionManager {\n  private static instance: AISessionManager;\n  private sessions: AISession[] = [];\n  private currentSession: AISession | null = null;\n  private maxLocalSessions = 200;\n  private sessionTimer: NodeJS.Timeout | null = null;\n  private autoSaveInterval = 60000; // 1 minute\n\n  private constructor() {\n    this.startAutoSave();\n  }\n\n  static getInstance(): AISessionManager {\n    if (!AISessionManager.instance) {\n      AISessionManager.instance = new AISessionManager();\n    }\n    return AISessionManager.instance;\n  }\n\n  /**\n   * Start a new AI session\n   */\n  async startSession(\n    ai_agent: string,\n    objectives: Omit<SessionObjective, 'id'>[],\n    context: SessionContext,\n    parent_session_id?: string\n  ): Promise<string> {\n    const sessionId = this.generateSessionId();\n    \n    const session: AISession = {\n      id: sessionId,\n      ai_agent,\n      start_time: new Date().toISOString(),\n      status: 'active',\n      objectives: objectives.map((obj, index) => ({\n        id: `obj_${index}`,\n        ...obj\n      })),\n      context,\n      decisions: [],\n      handoffs: [],\n      adrs: [],\n      metrics: this.getDefaultMetrics(),\n      outcomes: [],\n      parent_session_id,\n      child_session_ids: [],\n      metadata: {}\n    };\n\n    // If there's a parent session, add this as a child\n    if (parent_session_id) {\n      const parentSession = this.sessions.find(s => s.id === parent_session_id);\n      if (parentSession) {\n        parentSession.child_session_ids.push(sessionId);\n      }\n    }\n\n    // Handle handoff context if present\n    if (context.handoff_received && context.handoff_id) {\n      const handoff = aiContextHandoffManager.getHandoffById(context.handoff_id);\n      if (handoff) {\n        session.handoffs.push(context.handoff_id);\n        // Convert handoff priority items to objectives\n        const handoffObjectives = handoff.priority_items.map((item, index) => ({\n          id: `handoff_obj_${index}`,\n          description: item.description,\n          priority: item.priority,\n          status: 'pending' as const,\n          progress: 0,\n          estimated_completion: item.estimated_effort,\n          dependencies: item.dependencies,\n          deliverables: [],\n          success_criteria: [],\n          notes: item.context\n        }));\n        session.objectives.push(...handoffObjectives);\n      }\n    }\n\n    this.sessions.push(session);\n    this.currentSession = session;\n\n    // Maintain local cache size\n    if (this.sessions.length > this.maxLocalSessions) {\n      this.sessions = this.sessions.slice(-this.maxLocalSessions);\n    }\n\n    // Log session start\n    await aiDecisionLogger.logSimpleDecision(\n      `Started AI session: ${ai_agent}`,\n      'workflow_optimization',\n      `New AI session started with ${objectives.length} objectives`,\n      [],\n      'medium'\n    );\n\n    logger.info(`AI session started: ${ai_agent}`, {\n      session_id: sessionId,\n      objectives_count: objectives.length,\n      parent_session: parent_session_id,\n      handoff_received: context.handoff_received\n    }, 'AI_SESSION_START');\n\n    try {\n      await this.persistSession(session);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_SESSION_START',\n        session_id: sessionId,\n        ai_agent\n      });\n    }\n\n    return sessionId;\n  }\n\n  /**\n   * End the current session\n   */\n  async endSession(\n    sessionId: string,\n    outcome: Omit<SessionOutcome, 'timestamp'>,\n    create_handoff: boolean = false,\n    handoff_context?: string\n  ): Promise<void> {\n    const session = this.sessions.find(s => s.id === sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    session.end_time = new Date().toISOString();\n    session.status = 'completed';\n    session.outcomes.push({\n      ...outcome,\n      timestamp: new Date().toISOString()\n    });\n\n    // Calculate final metrics\n    session.metrics.time_spent_minutes = this.calculateSessionDuration(session);\n    session.metrics.decisions_made = session.decisions.length;\n    \n    // Create handoff if requested\n    if (create_handoff && handoff_context) {\n      const handoffId = await aiContextHandoffManager.createSimpleHandoff(\n        session.ai_agent,\n        'next_ai_agent',\n        'Session handoff',\n        handoff_context,\n        session.objectives\n          .filter(obj => obj.status !== 'completed')\n          .map(obj => obj.description),\n        session.outcomes\n          .filter(o => o.outcome_type === 'failure')\n          .map(o => o.description)\n      );\n      session.handoffs.push(handoffId);\n    }\n\n    // Log session end\n    await aiDecisionLogger.logSimpleDecision(\n      `Ended AI session: ${session.ai_agent}`,\n      'workflow_optimization',\n      `Session completed with ${outcome.outcome_type} outcome`,\n      [],\n      'medium'\n    );\n\n    logger.info(`AI session ended: ${session.ai_agent}`, {\n      session_id: sessionId,\n      duration_minutes: session.metrics.time_spent_minutes,\n      outcome_type: outcome.outcome_type,\n      decisions_made: session.metrics.decisions_made,\n      handoff_created: create_handoff\n    }, 'AI_SESSION_END');\n\n    if (this.currentSession?.id === sessionId) {\n      this.currentSession = null;\n    }\n\n    try {\n      await this.persistSession(session);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_SESSION_END',\n        session_id: sessionId,\n        outcome_type: outcome.outcome_type\n      });\n    }\n  }\n\n  /**\n   * Get current active session\n   */\n  getCurrentSession(): AISession | null {\n    return this.currentSession;\n  }\n\n  /**\n   * Update session objective\n   */\n  async updateObjective(\n    sessionId: string,\n    objectiveId: string,\n    updates: Partial<SessionObjective>\n  ): Promise<void> {\n    const session = this.sessions.find(s => s.id === sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    const objective = session.objectives.find(obj => obj.id === objectiveId);\n    if (!objective) {\n      throw new Error(`Objective not found: ${objectiveId}`);\n    }\n\n    Object.assign(objective, updates);\n\n    // Log objective update\n    await aiDecisionLogger.logSimpleDecision(\n      `Updated session objective: ${objective.description}`,\n      'workflow_optimization',\n      `Objective status: ${objective.status}, progress: ${objective.progress}%`,\n      [],\n      'low'\n    );\n\n    logger.info(`Session objective updated`, {\n      session_id: sessionId,\n      objective_id: objectiveId,\n      status: objective.status,\n      progress: objective.progress\n    }, 'AI_SESSION_OBJECTIVE_UPDATE');\n\n    try {\n      await this.persistSession(session);\n    } catch (error) {\n      errorReporter.reportError(error, {\n        context: 'AI_SESSION_OBJECTIVE_UPDATE',\n        session_id: sessionId,\n        objective_id: objectiveId\n      });\n    }\n  }\n\n  /**\n   * Add decision to session\n   */\n  async addDecisionToSession(sessionId: string, decisionId: string): Promise<void> {\n    const session = this.sessions.find(s => s.id === sessionId);\n    if (session) {\n      session.decisions.push(decisionId);\n      session.metrics.decisions_made = session.decisions.length;\n      await this.persistSession(session);\n    }\n  }\n\n  /**\n   * Add ADR to session\n   */\n  async addADRToSession(sessionId: string, adrId: string): Promise<void> {\n    const session = this.sessions.find(s => s.id === sessionId);\n    if (session) {\n      session.adrs.push(adrId);\n      await this.persistSession(session);\n    }\n  }\n\n  /**\n   * Add handoff to session\n   */\n  async addHandoffToSession(sessionId: string, handoffId: string): Promise<void> {\n    const session = this.sessions.find(s => s.id === sessionId);\n    if (session) {\n      session.handoffs.push(handoffId);\n      await this.persistSession(session);\n    }\n  }\n\n  /**\n   * Query sessions\n   */\n  querySessions(query: SessionQuery): AISession[] {\n    let filtered = [...this.sessions];\n\n    if (query.ai_agent) {\n      filtered = filtered.filter(s => s.ai_agent === query.ai_agent);\n    }\n\n    if (query.status) {\n      filtered = filtered.filter(s => s.status === query.status);\n    }\n\n    if (query.date_range) {\n      filtered = filtered.filter(s => {\n        const start = new Date(s.start_time);\n        const queryStart = new Date(query.date_range!.start);\n        const queryEnd = new Date(query.date_range!.end);\n        return start >= queryStart && start <= queryEnd;\n      });\n    }\n\n    if (query.has_handoffs) {\n      filtered = filtered.filter(s => s.handoffs.length > 0);\n    }\n\n    if (query.has_adrs) {\n      filtered = filtered.filter(s => s.adrs.length > 0);\n    }\n\n    if (query.objectives_status) {\n      filtered = filtered.filter(s => \n        s.objectives.some(obj => obj.status === query.objectives_status)\n      );\n    }\n\n    // Sort by start time (newest first)\n    filtered.sort((a, b) => new Date(b.start_time).getTime() - new Date(a.start_time).getTime());\n\n    if (query.limit) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get session by ID\n   */\n  getSessionById(sessionId: string): AISession | null {\n    return this.sessions.find(s => s.id === sessionId) || null;\n  }\n\n  /**\n   * Get session summary\n   */\n  getSessionSummary(): SessionSummary {\n    const totalSessions = this.sessions.length;\n    const activeSessions = this.sessions.filter(s => s.status === 'active').length;\n    const completedSessions = this.sessions.filter(s => s.status === 'completed').length;\n    const totalDecisions = this.sessions.reduce((sum, s) => sum + s.decisions.length, 0);\n    const totalHandoffs = this.sessions.reduce((sum, s) => sum + s.handoffs.length, 0);\n    const totalAdrs = this.sessions.reduce((sum, s) => sum + s.adrs.length, 0);\n    \n    const durations = this.sessions\n      .filter(s => s.end_time)\n      .map(s => this.calculateSessionDuration(s));\n    const averageSessionDuration = durations.length > 0 \n      ? durations.reduce((sum, d) => sum + d, 0) / durations.length \n      : 0;\n\n    const agentCounts = this.sessions.reduce((acc, s) => {\n      acc[s.ai_agent] = (acc[s.ai_agent] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const topAiAgents = Object.entries(agentCounts)\n      .map(([agent, sessions]) => ({ agent, sessions }))\n      .sort((a, b) => b.sessions - a.sessions)\n      .slice(0, 5);\n\n    const successfulSessions = this.sessions.filter(s => \n      s.outcomes.some(o => o.outcome_type === 'success')\n    ).length;\n    const successRate = totalSessions > 0 ? (successfulSessions / totalSessions) * 100 : 0;\n\n    const objectiveCounts = this.sessions\n      .flatMap(s => s.objectives)\n      .reduce((acc, obj) => {\n        acc[obj.description] = (acc[obj.description] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n    const commonObjectives = Object.entries(objectiveCounts)\n      .map(([objective, frequency]) => ({ objective, frequency }))\n      .sort((a, b) => b.frequency - a.frequency)\n      .slice(0, 10);\n\n    return {\n      total_sessions: totalSessions,\n      active_sessions: activeSessions,\n      completed_sessions: completedSessions,\n      total_decisions: totalDecisions,\n      total_handoffs: totalHandoffs,\n      total_adrs: totalAdrs,\n      average_session_duration: averageSessionDuration,\n      top_ai_agents: topAiAgents,\n      success_rate: successRate,\n      common_objectives: commonObjectives\n    };\n  }\n\n  /**\n   * Generate session report\n   */\n  generateSessionReport(sessionId: string): string {\n    const session = this.getSessionById(sessionId);\n    if (!session) return 'Session not found';\n\n    const duration = this.calculateSessionDuration(session);\n    const completedObjectives = session.objectives.filter(obj => obj.status === 'completed');\n    const pendingObjectives = session.objectives.filter(obj => obj.status !== 'completed');\n\n    return `\n# AI Session Report\nGenerated: ${new Date().toISOString()}\nSession ID: ${session.id}\nAI Agent: ${session.ai_agent}\n\n## Session Overview\n- **Status**: ${session.status}\n- **Duration**: ${duration} minutes\n- **Started**: ${session.start_time}\n- **Ended**: ${session.end_time || 'In progress'}\n\n## Objectives\n### Completed (${completedObjectives.length}/${session.objectives.length})\n${completedObjectives.map(obj => `- âœ… ${obj.description} (${obj.progress}%)`).join('\\n')}\n\n### Pending (${pendingObjectives.length}/${session.objectives.length})\n${pendingObjectives.map(obj => `- â³ ${obj.description} (${obj.progress}%)`).join('\\n')}\n\n## Metrics\n- **Decisions Made**: ${session.metrics.decisions_made}\n- **Files Modified**: ${session.metrics.files_modified}\n- **Files Created**: ${session.metrics.files_created}\n- **Lines Changed**: ${session.metrics.lines_of_code_changed}\n- **Average AI Confidence**: ${session.metrics.ai_confidence_average}%\n- **Quality Score**: ${session.metrics.quality_score}\n\n## Artifacts Created\n- **Decisions**: ${session.decisions.length}\n- **Handoffs**: ${session.handoffs.length}\n- **ADRs**: ${session.adrs.length}\n\n## Outcomes\n${session.outcomes.map(outcome => `\n### ${outcome.outcome_type.toUpperCase()} (${outcome.timestamp})\n${outcome.description}\n\n**Deliverables**: ${outcome.deliverables_completed.join(', ')}\n**Issues**: ${outcome.issues_encountered.join(', ')}\n**Lessons**: ${outcome.lessons_learned.join(', ')}\n`).join('\\n')}\n\n## Context\n**User Request**: ${session.context.user_request}\n**Constraints**: ${session.context.constraints.join(', ')}\n**Assumptions**: ${session.context.assumptions.join(', ')}\n`;\n  }\n\n  /**\n   * Export sessions\n   */\n  exportSessions(format: 'json' | 'csv' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(this.sessions, null, 2);\n    } else {\n      const headers = ['id', 'ai_agent', 'status', 'start_time', 'end_time', 'objectives_count', 'decisions_count', 'duration_minutes'];\n      const rows = this.sessions.map(s => [\n        s.id,\n        s.ai_agent,\n        s.status,\n        s.start_time,\n        s.end_time || 'N/A',\n        s.objectives.length,\n        s.decisions.length,\n        s.end_time ? this.calculateSessionDuration(s) : 'N/A'\n      ]);\n      \n      return [headers.join(','), ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))].join('\\n');\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getDefaultMetrics(): SessionMetrics {\n    return {\n      decisions_made: 0,\n      files_modified: 0,\n      files_created: 0,\n      lines_of_code_changed: 0,\n      build_time: 0,\n      test_coverage_change: 0,\n      bugs_fixed: 0,\n      features_implemented: 0,\n      time_spent_minutes: 0,\n      ai_confidence_average: 0,\n      quality_score: 0\n    };\n  }\n\n  private calculateSessionDuration(session: AISession): number {\n    if (!session.end_time) return 0;\n    \n    const start = new Date(session.start_time);\n    const end = new Date(session.end_time);\n    return Math.round((end.getTime() - start.getTime()) / (1000 * 60));\n  }\n\n  private startAutoSave(): void {\n    if (this.sessionTimer) return;\n\n    this.sessionTimer = setInterval(() => {\n      if (this.currentSession) {\n        this.persistSession(this.currentSession);\n      }\n    }, this.autoSaveInterval);\n  }\n\n  private async persistSession(session: AISession): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('ai_sessions')\n        .upsert([{\n          id: session.id,\n          ai_agent: session.ai_agent,\n          start_time: session.start_time,\n          end_time: session.end_time,\n          status: session.status,\n          objectives: session.objectives,\n          context: session.context,\n          decisions: session.decisions,\n          handoffs: session.handoffs,\n          adrs: session.adrs,\n          metrics: session.metrics,\n          outcomes: session.outcomes,\n          parent_session_id: session.parent_session_id,\n          child_session_ids: session.child_session_ids,\n          metadata: session.metadata\n        }]);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      logger.error('Failed to persist AI session', error, 'AI_SESSION_PERSIST');\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy(): void {\n    if (this.sessionTimer) {\n      clearInterval(this.sessionTimer);\n      this.sessionTimer = null;\n    }\n\n    // End current session if active\n    if (this.currentSession?.status === 'active') {\n      this.endSession(this.currentSession.id, {\n        outcome_type: 'handoff',\n        description: 'Session ended due to system shutdown',\n        deliverables_completed: [],\n        issues_encountered: ['System shutdown'],\n        lessons_learned: [],\n        recommendations: [],\n        next_steps: []\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const aiSessionManager = AISessionManager.getInstance();\n\n// Convenience functions\nexport const startSession = aiSessionManager.startSession.bind(aiSessionManager);\nexport const endSession = aiSessionManager.endSession.bind(aiSessionManager);\nexport const getCurrentSession = aiSessionManager.getCurrentSession.bind(aiSessionManager);\nexport const updateObjective = aiSessionManager.updateObjective.bind(aiSessionManager);\nexport const addDecisionToSession = aiSessionManager.addDecisionToSession.bind(aiSessionManager);\nexport const addADRToSession = aiSessionManager.addADRToSession.bind(aiSessionManager);\nexport const addHandoffToSession = aiSessionManager.addHandoffToSession.bind(aiSessionManager);\nexport const querySessions = aiSessionManager.querySessions.bind(aiSessionManager);\nexport const getSessionById = aiSessionManager.getSessionById.bind(aiSessionManager);\nexport const getSessionSummary = aiSessionManager.getSessionSummary.bind(aiSessionManager);\nexport const generateSessionReport = aiSessionManager.generateSessionReport.bind(aiSessionManager);\nexport const exportSessions = aiSessionManager.exportSessions.bind(aiSessionManager);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/ai/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2145,2148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2145,2148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Analysis Types for STR Certified\n\nexport interface AIAnalysisResult {\n  confidence: number; // 0-100 confidence score\n  detected_features: string[]; // Array of detected features/objects\n  pass_fail_recommendation: 'pass' | 'fail' | 'review_required';\n  reasoning: string; // AI explanation of the analysis\n  safety_concerns?: string[]; // Optional safety issues detected\n  compliance_status?: {\n    building_code: boolean;\n    fire_safety: boolean;\n    accessibility: boolean;\n  };\n}\n\nexport interface PhotoComparisonResult {\n  similarity_score: number; // 0-100 similarity percentage\n  discrepancies: string[]; // List of differences found\n  recommendation: 'matches_listing' | 'minor_differences' | 'major_discrepancies';\n  confidence: number; // 0-100 confidence in comparison\n  details: {\n    lighting_differences: boolean;\n    furniture_changes: boolean;\n    structural_differences: boolean;\n    room_layout_match: boolean;\n  };\n}\n\nexport interface DynamicChecklistItem {\n  id: string;\n  title: string;\n  description: string;\n  required: boolean;\n  ai_generated: boolean;\n  category: string;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  estimated_time_minutes: number;\n  inspection_notes?: string;\n}\n\nexport interface PropertyData {\n  amenities: string[]; // List of property amenities\n  photos: string[]; // URLs to property listing photos\n  description: string; // Property description text\n  room_count: {\n    bedrooms: number;\n    bathrooms: number;\n    total_rooms?: number;\n  };\n  property_type: 'apartment' | 'house' | 'condo' | 'townhouse' | 'other';\n  square_footage?: number;\n  location: {\n    city: string;\n    state: string;\n    country: string;\n  };\n  special_features?: string[]; // Pool, hot tub, fireplace, etc.\n}\n\nexport interface AIServiceConfig {\n  apiKey: string;\n  model?: string;\n  maxTokens?: number;\n  temperature?: number;\n  timeout?: number;\n}\n\nexport interface AIAnalysisOptions {\n  includeDetailedAnalysis?: boolean;\n  checkSafetyConcerns?: boolean;\n  compareToStandards?: boolean;\n  generateRecommendations?: boolean;\n}\n\nexport interface AIError {\n  code: string;\n  message: string;\n  details?: any;\n  retryable: boolean;\n}\n\nexport type AIAnalysisStatus = 'idle' | 'analyzing' | 'completed' | 'error' | 'retrying';\n\nexport interface AIAnalysisState {\n  status: AIAnalysisStatus;\n  result?: AIAnalysisResult;\n  error?: AIError;\n  progress?: number; // 0-100 for long-running analyses\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/config/app-type.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/config/environment.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4113,4116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4113,4116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Environment Configuration and Validation for STR Certified\n// Provides type-safe environment variable access with validation\n\nimport { z } from 'zod';\n\n// Environment variable schema\nconst envSchema = z.object({\n  // Deployment environment\n  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),\n  \n  // Application Type Configuration (for local development)\n  VITE_APP_TYPE: z.enum(['inspector', 'admin']).default('inspector'),\n  \n  // Domain Configuration (for unified deployment)\n  VITE_INSPECTOR_DOMAIN: z.string().default('app.doublecheckverified.com'),\n  VITE_ADMIN_DOMAIN: z.string().default('admin.doublecheckverified.com'),\n  VITE_ENABLE_DOMAIN_ROUTING: z.string().transform(val => val === 'true').default('true'),\n  \n  // API Configuration\n  VITE_API_URL: z.string().url().optional().default('http://localhost:3000'),\n  VITE_PUBLIC_URL: z.string().url().optional(),\n  \n  // Supabase Configuration\n  VITE_SUPABASE_URL: z.string().url(),\n  VITE_SUPABASE_ANON_KEY: z.string().min(1),\n  \n  // OpenAI Configuration\n  VITE_OPENAI_API_KEY: z.string().min(1).optional(),\n  VITE_OPENAI_ORG_ID: z.string().optional(),\n  \n  // Analytics & Monitoring\n  VITE_SENTRY_DSN: z.string().url().optional(),\n  VITE_GA_TRACKING_ID: z.string().optional(),\n  VITE_MIXPANEL_TOKEN: z.string().optional(),\n  \n  // Feature Flags\n  VITE_ENABLE_ANALYTICS: z.string().transform(val => val === 'true').default('false'),\n  VITE_ENABLE_PWA: z.string().transform(val => val === 'true').default('true'),\n  VITE_ENABLE_AI_FEATURES: z.string().transform(val => val === 'true').default('true'),\n  VITE_ENABLE_VIDEO_RECORDING: z.string().transform(val => val === 'true').default('true'),\n  VITE_ENABLE_OFFLINE_MODE: z.string().transform(val => val === 'true').default('true'),\n  \n  // Security\n  VITE_ENCRYPTION_KEY: z.string().min(32).optional(),\n  VITE_JWT_SECRET: z.string().min(32).optional(),\n  \n  // Storage\n  VITE_STORAGE_BUCKET: z.string().default('str-certified-storage'),\n  VITE_MAX_FILE_SIZE: z.string().transform(val => parseInt(val)).default('10485760'), // 10MB\n  VITE_MAX_VIDEO_SIZE: z.string().transform(val => parseInt(val)).default('104857600'), // 100MB\n  \n  // Rate Limiting\n  VITE_API_RATE_LIMIT: z.string().transform(val => parseInt(val)).default('100'),\n  VITE_AI_RATE_LIMIT: z.string().transform(val => parseInt(val)).default('50'),\n  \n  // Cache Configuration\n  VITE_CACHE_TTL: z.string().transform(val => parseInt(val)).default('3600'), // 1 hour\n  VITE_CACHE_MAX_SIZE: z.string().transform(val => parseInt(val)).default('52428800'), // 50MB\n  \n  // Performance\n  VITE_IMAGE_QUALITY: z.string().transform(val => parseFloat(val)).default('0.85'),\n  VITE_THUMBNAIL_SIZE: z.string().transform(val => parseInt(val)).default('300'),\n  \n  // Development\n  VITE_MOCK_API: z.string().transform(val => val === 'true').default('false'),\n  VITE_DEBUG_MODE: z.string().transform(val => val === 'true').default('false'),\n  \n  // Server\n  PORT: z.string().transform(val => parseInt(val)).default('4173'),\n  HOST: z.string().default('0.0.0.0')\n});\n\n// Type for validated environment\nexport type Environment = z.infer<typeof envSchema>;\n\n// Environment validation class\nclass EnvironmentConfig {\n  private static instance: EnvironmentConfig;\n  private env: Environment;\n  private validationErrors: z.ZodError | null = null;\n\n  private constructor() {\n    this.env = this.validateEnvironment();\n  }\n\n  static getInstance(): EnvironmentConfig {\n    if (!EnvironmentConfig.instance) {\n      EnvironmentConfig.instance = new EnvironmentConfig();\n    }\n    return EnvironmentConfig.instance;\n  }\n\n  private validateEnvironment(): Environment {\n    try {\n      // Get all environment variables\n      const env = {\n        NODE_ENV: process.env.NODE_ENV || import.meta.env.MODE,\n        PORT: process.env.PORT,\n        HOST: process.env.HOST,\n        \n        // Import all VITE_ prefixed variables\n        ...Object.entries(import.meta.env).reduce((acc, [key, value]) => {\n          if (key.startsWith('VITE_')) {\n            acc[key] = value;\n          }\n          return acc;\n        }, {} as Record<string, any>)\n      };\n\n      // Validate against schema\n      const validated = envSchema.parse(env);\n      \n      // Log validation success in development\n      if (validated.NODE_ENV === 'development' && validated.VITE_DEBUG_MODE) {\n        console.log('âœ… Environment variables validated successfully');\n      }\n\n      return validated;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        this.validationErrors = error;\n        console.error('âŒ Environment validation failed:', error.errors);\n        \n        // In production, throw error to prevent startup with invalid config\n        if (process.env.NODE_ENV === 'production') {\n          throw new Error('Invalid environment configuration');\n        }\n        \n        // In development, return defaults\n        return envSchema.parse({});\n      }\n      throw error;\n    }\n  }\n\n  // Getters for different configuration sections\n  \n  get api() {\n    return {\n      url: this.env.VITE_API_URL,\n      publicUrl: this.env.VITE_PUBLIC_URL,\n      rateLimit: this.env.VITE_API_RATE_LIMIT\n    };\n  }\n\n  get supabase() {\n    return {\n      url: this.env.VITE_SUPABASE_URL,\n      anonKey: this.env.VITE_SUPABASE_ANON_KEY\n    };\n  }\n\n  get openai() {\n    return {\n      apiKey: this.env.VITE_OPENAI_API_KEY,\n      orgId: this.env.VITE_OPENAI_ORG_ID,\n      rateLimit: this.env.VITE_AI_RATE_LIMIT\n    };\n  }\n\n  get features() {\n    return {\n      analytics: this.env.VITE_ENABLE_ANALYTICS,\n      pwa: this.env.VITE_ENABLE_PWA,\n      ai: this.env.VITE_ENABLE_AI_FEATURES,\n      videoRecording: this.env.VITE_ENABLE_VIDEO_RECORDING,\n      offlineMode: this.env.VITE_ENABLE_OFFLINE_MODE\n    };\n  }\n\n  get monitoring() {\n    return {\n      sentryDsn: this.env.VITE_SENTRY_DSN,\n      gaTrackingId: this.env.VITE_GA_TRACKING_ID,\n      mixpanelToken: this.env.VITE_MIXPANEL_TOKEN\n    };\n  }\n\n  get storage() {\n    return {\n      bucket: this.env.VITE_STORAGE_BUCKET,\n      maxFileSize: this.env.VITE_MAX_FILE_SIZE,\n      maxVideoSize: this.env.VITE_MAX_VIDEO_SIZE\n    };\n  }\n\n  get cache() {\n    return {\n      ttl: this.env.VITE_CACHE_TTL,\n      maxSize: this.env.VITE_CACHE_MAX_SIZE\n    };\n  }\n\n  get performance() {\n    return {\n      imageQuality: this.env.VITE_IMAGE_QUALITY,\n      thumbnailSize: this.env.VITE_THUMBNAIL_SIZE\n    };\n  }\n\n  get security() {\n    return {\n      encryptionKey: this.env.VITE_ENCRYPTION_KEY,\n      jwtSecret: this.env.VITE_JWT_SECRET\n    };\n  }\n\n  get development() {\n    return {\n      mockApi: this.env.VITE_MOCK_API,\n      debugMode: this.env.VITE_DEBUG_MODE\n    };\n  }\n\n  get app() {\n    return {\n      type: this.env.VITE_APP_TYPE\n    };\n  }\n\n  get domains() {\n    return {\n      inspector: this.env.VITE_INSPECTOR_DOMAIN,\n      admin: this.env.VITE_ADMIN_DOMAIN,\n      routingEnabled: this.env.VITE_ENABLE_DOMAIN_ROUTING\n    };\n  }\n\n  get server() {\n    return {\n      port: this.env.PORT,\n      host: this.env.HOST\n    };\n  }\n\n  // Utility methods\n\n  isDevelopment(): boolean {\n    return this.env.NODE_ENV === 'development';\n  }\n\n  isProduction(): boolean {\n    return this.env.NODE_ENV === 'production';\n  }\n\n  isTest(): boolean {\n    return this.env.NODE_ENV === 'test';\n  }\n\n  getEnvironment(): string {\n    return this.env.NODE_ENV;\n  }\n\n  getValidationErrors(): z.ZodError | null {\n    return this.validationErrors;\n  }\n\n  // Check if a required service is configured\n  hasOpenAI(): boolean {\n    return Boolean(this.env.VITE_OPENAI_API_KEY);\n  }\n\n  hasSentry(): boolean {\n    return Boolean(this.env.VITE_SENTRY_DSN);\n  }\n\n  hasAnalytics(): boolean {\n    return this.env.VITE_ENABLE_ANALYTICS && \n           (Boolean(this.env.VITE_GA_TRACKING_ID) || Boolean(this.env.VITE_MIXPANEL_TOKEN));\n  }\n\n  // Get public runtime config (safe to expose to client)\n  getPublicConfig() {\n    return {\n      environment: this.env.NODE_ENV,\n      apiUrl: this.env.VITE_API_URL,\n      publicUrl: this.env.VITE_PUBLIC_URL,\n      features: this.features,\n      storage: {\n        maxFileSize: this.env.VITE_MAX_FILE_SIZE,\n        maxVideoSize: this.env.VITE_MAX_VIDEO_SIZE\n      },\n      performance: this.performance\n    };\n  }\n\n  // Validate specific configuration sections\n  validateApiConfig(): boolean {\n    return Boolean(this.env.VITE_API_URL);\n  }\n\n  validateSupabaseConfig(): boolean {\n    return Boolean(this.env.VITE_SUPABASE_URL && this.env.VITE_SUPABASE_ANON_KEY);\n  }\n\n  validateAIConfig(): boolean {\n    return this.env.VITE_ENABLE_AI_FEATURES ? Boolean(this.env.VITE_OPENAI_API_KEY) : true;\n  }\n\n  // Log configuration (sanitized)\n  logConfiguration(): void {\n    const sanitized = {\n      environment: this.env.NODE_ENV,\n      api: {\n        url: this.env.VITE_API_URL,\n        hasApiKey: Boolean(this.env.VITE_OPENAI_API_KEY)\n      },\n      supabase: {\n        url: this.env.VITE_SUPABASE_URL,\n        hasAnonKey: Boolean(this.env.VITE_SUPABASE_ANON_KEY)\n      },\n      features: this.features,\n      monitoring: {\n        hasSentry: Boolean(this.env.VITE_SENTRY_DSN),\n        hasAnalytics: this.hasAnalytics()\n      }\n    };\n\n    console.log('ðŸ”§ Environment Configuration:', sanitized);\n  }\n}\n\n// Export singleton instance\nexport const env = EnvironmentConfig.getInstance();\n\n// Export convenience functions\nexport const getEnv = () => env;\nexport const isProduction = () => env.isProduction();\nexport const isDevelopment = () => env.isDevelopment();\nexport const isTest = () => env.isTest();\n\n// Export types\nexport type { Environment };\n\n// Validation helper for runtime checks\nexport function validateRequiredEnvVars(): void {\n  const errors: string[] = [];\n\n  if (!env.validateSupabaseConfig()) {\n    errors.push('Missing required Supabase configuration');\n  }\n\n  if (env.features.ai && !env.validateAIConfig()) {\n    errors.push('AI features enabled but OpenAI API key is missing');\n  }\n\n  if (errors.length > 0) {\n    const message = `Environment configuration errors:\\n${errors.join('\\n')}`;\n    \n    if (env.isProduction()) {\n      throw new Error(message);\n    } else {\n      console.warn('âš ï¸', message);\n    }\n  }\n}\n\n// Initialize validation on import\nif (typeof window !== 'undefined' && env.isDevelopment() && env.development.debugMode) {\n  env.logConfiguration();\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/error/api-error-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[463,466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[463,466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[868,871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[868,871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1732,1735],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1732,1735],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":131,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3314,3317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3314,3317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":276,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8162,8165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8162,8165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9275,9278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9275,9278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":335,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":335,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10154,10157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10154,10157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":403,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":403,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12255,12258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12255,12258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ErrorReporter } from '../monitoring/error-reporter';\nimport { env } from '../config/environment';\n\nexport type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';\nexport type ErrorCategory = 'network' | 'validation' | 'authentication' | 'authorization' | 'server' | 'client' | 'unknown';\n\nexport interface ApiError extends Error {\n  status?: number;\n  code?: string;\n  category?: ErrorCategory;\n  severity?: ErrorSeverity;\n  details?: Record<string, any>;\n  retry?: boolean;\n  userMessage?: string;\n  timestamp?: string;\n  requestId?: string;\n}\n\nexport interface RetryConfig {\n  maxAttempts?: number;\n  initialDelay?: number;\n  maxDelay?: number;\n  backoffMultiplier?: number;\n  retryableStatuses?: number[];\n  retryableErrors?: string[];\n}\n\nexport interface ApiErrorContext {\n  url: string;\n  method: string;\n  headers?: Record<string, string>;\n  body?: any;\n  userId?: string;\n  sessionId?: string;\n}\n\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  initialDelay: 1000,\n  maxDelay: 30000,\n  backoffMultiplier: 2,\n  retryableStatuses: [408, 429, 500, 502, 503, 504],\n  retryableErrors: ['NetworkError', 'TimeoutError', 'ECONNREFUSED', 'ENOTFOUND'],\n};\n\nexport class ApiErrorHandler {\n  private static instance: ApiErrorHandler;\n  private retryConfig: RetryConfig;\n  private errorReporter: ErrorReporter;\n\n  private constructor() {\n    this.retryConfig = DEFAULT_RETRY_CONFIG;\n    this.errorReporter = ErrorReporter.getInstance();\n  }\n\n  static getInstance(): ApiErrorHandler {\n    if (!ApiErrorHandler.instance) {\n      ApiErrorHandler.instance = new ApiErrorHandler();\n    }\n    return ApiErrorHandler.instance;\n  }\n\n  /**\n   * Handle API errors with retry logic\n   */\n  async handleError(\n    error: any,\n    context: ApiErrorContext,\n    retryConfig?: RetryConfig\n  ): Promise<ApiError> {\n    const apiError = this.normalizeError(error, context);\n    \n    // Report error to monitoring\n    this.errorReporter.reportError(apiError, {\n      api: true,\n      context,\n      severity: apiError.severity,\n      category: apiError.category,\n    });\n\n    // Log in development\n    if (env.isDevelopment()) {\n      console.error('[API Error]', {\n        error: apiError,\n        context,\n      });\n    }\n\n    return apiError;\n  }\n\n  /**\n   * Execute request with retry logic\n   */\n  async executeWithRetry<T>(\n    request: () => Promise<T>,\n    context: ApiErrorContext,\n    customRetryConfig?: RetryConfig\n  ): Promise<T> {\n    const config = { ...this.retryConfig, ...customRetryConfig };\n    let lastError: ApiError | null = null;\n    let attempt = 0;\n\n    while (attempt < (config.maxAttempts || 3)) {\n      try {\n        return await request();\n      } catch (error) {\n        attempt++;\n        lastError = await this.handleError(error, context, config);\n\n        if (!this.shouldRetry(lastError, attempt, config)) {\n          throw lastError;\n        }\n\n        const delay = this.calculateDelay(attempt, config);\n        \n        if (env.isDevelopment()) {\n          console.log(`[API Retry] Attempt ${attempt}/${config.maxAttempts}, waiting ${delay}ms`);\n        }\n\n        await this.delay(delay);\n      }\n    }\n\n    throw lastError || new Error('Maximum retry attempts reached');\n  }\n\n  /**\n   * Normalize various error types into ApiError\n   */\n  private normalizeError(error: any, context: ApiErrorContext): ApiError {\n    // Already an ApiError\n    if (error instanceof Error && 'category' in error) {\n      return error as ApiError;\n    }\n\n    const apiError: ApiError = new Error(error.message || 'Unknown error') as ApiError;\n    apiError.timestamp = new Date().toISOString();\n\n    // Handle fetch/network errors\n    if (error instanceof TypeError && error.message.includes('fetch')) {\n      apiError.category = 'network';\n      apiError.severity = 'high';\n      apiError.retry = true;\n      apiError.userMessage = 'Network connection error. Please check your internet connection.';\n      return apiError;\n    }\n\n    // Handle HTTP response errors\n    if (error.status || error.response?.status) {\n      const status = error.status || error.response.status;\n      apiError.status = status;\n      apiError.details = error.response?.data || error.data;\n      \n      // Categorize by status code\n      if (status >= 400 && status < 500) {\n        apiError.category = this.categorizeClientError(status);\n        apiError.severity = status === 401 || status === 403 ? 'high' : 'medium';\n        apiError.retry = status === 429; // Retry rate limit errors\n        apiError.userMessage = this.getUserMessage(status, error);\n      } else if (status >= 500) {\n        apiError.category = 'server';\n        apiError.severity = 'high';\n        apiError.retry = true;\n        apiError.userMessage = 'Server error. Please try again later.';\n      }\n    }\n\n    // Handle timeout errors\n    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n      apiError.category = 'network';\n      apiError.severity = 'medium';\n      apiError.retry = true;\n      apiError.userMessage = 'Request timed out. Please try again.';\n    }\n\n    // Handle Supabase errors\n    if (error.code && error.message && error.details) {\n      apiError.code = error.code;\n      apiError.details = error.details;\n      apiError.category = this.categorizeSupabaseError(error.code);\n      apiError.severity = this.getSeverityFromSupabaseError(error.code);\n      apiError.userMessage = this.getSupabaseUserMessage(error);\n    }\n\n    // Default values\n    apiError.category = apiError.category || 'unknown';\n    apiError.severity = apiError.severity || 'medium';\n    apiError.retry = apiError.retry ?? false;\n    apiError.userMessage = apiError.userMessage || 'An unexpected error occurred. Please try again.';\n\n    return apiError;\n  }\n\n  /**\n   * Determine if error should trigger a retry\n   */\n  private shouldRetry(error: ApiError, attempt: number, config: RetryConfig): boolean {\n    // Don't retry if explicitly set to false\n    if (error.retry === false) return false;\n\n    // Check max attempts\n    if (attempt >= (config.maxAttempts || 3)) return false;\n\n    // Check retryable status codes\n    if (error.status && config.retryableStatuses) {\n      if (config.retryableStatuses.includes(error.status)) return true;\n    }\n\n    // Check retryable error messages\n    if (config.retryableErrors) {\n      const errorMessage = error.message.toLowerCase();\n      if (config.retryableErrors.some(msg => errorMessage.includes(msg.toLowerCase()))) {\n        return true;\n      }\n    }\n\n    // Check if error explicitly allows retry\n    return error.retry === true;\n  }\n\n  /**\n   * Calculate delay for retry with exponential backoff\n   */\n  private calculateDelay(attempt: number, config: RetryConfig): number {\n    const { initialDelay = 1000, maxDelay = 30000, backoffMultiplier = 2 } = config;\n    \n    // Exponential backoff with jitter\n    const exponentialDelay = initialDelay * Math.pow(backoffMultiplier, attempt - 1);\n    const jitter = Math.random() * 0.3 * exponentialDelay; // 30% jitter\n    const delay = Math.min(exponentialDelay + jitter, maxDelay);\n    \n    return Math.round(delay);\n  }\n\n  /**\n   * Categorize client errors\n   */\n  private categorizeClientError(status: number): ErrorCategory {\n    switch (status) {\n      case 401:\n        return 'authentication';\n      case 403:\n        return 'authorization';\n      case 400:\n      case 422:\n        return 'validation';\n      default:\n        return 'client';\n    }\n  }\n\n  /**\n   * Categorize Supabase errors\n   */\n  private categorizeSupabaseError(code: string): ErrorCategory {\n    if (code.startsWith('AUTH_')) return 'authentication';\n    if (code.startsWith('PGRST')) return 'server';\n    if (code.includes('NETWORK')) return 'network';\n    return 'unknown';\n  }\n\n  /**\n   * Get severity from Supabase error\n   */\n  private getSeverityFromSupabaseError(code: string): ErrorSeverity {\n    if (code.startsWith('AUTH_')) return 'high';\n    if (code.includes('RATE_LIMIT')) return 'medium';\n    if (code.includes('NETWORK')) return 'high';\n    return 'medium';\n  }\n\n  /**\n   * Get user-friendly message based on status code\n   */\n  private getUserMessage(status: number, error: any): string {\n    const customMessage = error.response?.data?.message || error.data?.message;\n    if (customMessage) return customMessage;\n\n    switch (status) {\n      case 400:\n        return 'Invalid request. Please check your input and try again.';\n      case 401:\n        return 'Please sign in to continue.';\n      case 403:\n        return 'You don\\'t have permission to access this resource.';\n      case 404:\n        return 'The requested resource was not found.';\n      case 409:\n        return 'This action conflicts with existing data.';\n      case 422:\n        return 'The provided data is invalid. Please check and try again.';\n      case 429:\n        return 'Too many requests. Please wait a moment and try again.';\n      case 500:\n        return 'Server error. Our team has been notified.';\n      case 502:\n      case 503:\n      case 504:\n        return 'Service temporarily unavailable. Please try again later.';\n      default:\n        return 'An error occurred. Please try again.';\n    }\n  }\n\n  /**\n   * Get user-friendly message for Supabase errors\n   */\n  private getSupabaseUserMessage(error: any): string {\n    if (error.message.includes('Invalid login credentials')) {\n      return 'Invalid email or password. Please try again.';\n    }\n    if (error.message.includes('User already registered')) {\n      return 'An account with this email already exists.';\n    }\n    if (error.message.includes('Email not confirmed')) {\n      return 'Please verify your email address to continue.';\n    }\n    if (error.message.includes('Invalid token')) {\n      return 'Your session has expired. Please sign in again.';\n    }\n    return error.message || 'An error occurred with the database.';\n  }\n\n  /**\n   * Utility function to delay execution\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Format error for logging\n   */\n  formatErrorForLogging(error: ApiError, context?: ApiErrorContext): Record<string, any> {\n    return {\n      message: error.message,\n      status: error.status,\n      code: error.code,\n      category: error.category,\n      severity: error.severity,\n      timestamp: error.timestamp,\n      stack: error.stack,\n      details: error.details,\n      context: context ? {\n        url: context.url,\n        method: context.method,\n        userId: context.userId,\n        sessionId: context.sessionId,\n      } : undefined,\n    };\n  }\n\n  /**\n   * Check if error is retryable\n   */\n  isRetryableError(error: ApiError): boolean {\n    return error.retry === true || \n           (error.status !== undefined && DEFAULT_RETRY_CONFIG.retryableStatuses!.includes(error.status)) ||\n           DEFAULT_RETRY_CONFIG.retryableErrors!.some(msg => error.message.includes(msg));\n  }\n\n  /**\n   * Get error recovery suggestions\n   */\n  getRecoverySuggestions(error: ApiError): string[] {\n    const suggestions: string[] = [];\n\n    switch (error.category) {\n      case 'network':\n        suggestions.push('Check your internet connection');\n        suggestions.push('Try refreshing the page');\n        suggestions.push('Disable VPN or proxy if active');\n        break;\n      case 'authentication':\n        suggestions.push('Sign in to your account');\n        suggestions.push('Check your credentials');\n        suggestions.push('Reset your password if forgotten');\n        break;\n      case 'authorization':\n        suggestions.push('Contact support for access');\n        suggestions.push('Check your subscription status');\n        break;\n      case 'validation':\n        suggestions.push('Review the form for errors');\n        suggestions.push('Check required fields');\n        suggestions.push('Ensure data formats are correct');\n        break;\n      case 'server':\n        suggestions.push('Wait a few minutes and try again');\n        suggestions.push('Contact support if the issue persists');\n        break;\n    }\n\n    return suggestions;\n  }\n}\n\n// Export singleton instance\nexport const apiErrorHandler = ApiErrorHandler.getInstance();\n\n// Export convenience functions\nexport const handleApiError = (error: any, context: ApiErrorContext) =>\n  apiErrorHandler.handleError(error, context);\n\nexport const executeWithRetry = <T>(\n  request: () => Promise<T>,\n  context: ApiErrorContext,\n  retryConfig?: RetryConfig\n) => apiErrorHandler.executeWithRetry(request, context, retryConfig);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/error/error-boundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4217,4220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4217,4220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4245,4248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4245,4248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4311,4314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4311,4314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":221,"column":10,"nodeType":"Identifier","messageId":"localComponents","endLine":221,"endColumn":30}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { Component, ErrorInfo, ReactNode } from 'react';\nimport { ErrorReporter } from '../monitoring/error-reporter';\nimport { env } from '../config/environment';\n\nexport interface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n  errorId: string | null;\n  retryCount: number;\n}\n\nexport interface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: (props: {\n    error: Error;\n    errorInfo: ErrorInfo;\n    resetError: () => void;\n    errorId: string;\n  }) => ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  isolate?: boolean;\n  level?: 'page' | 'section' | 'component';\n  resetKeys?: Array<string | number>;\n  resetOnPropsChange?: boolean;\n  showErrorDetails?: boolean;\n}\n\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  private resetTimeoutId: NodeJS.Timeout | null = null;\n  private previousResetKeys: Array<string | number> = [];\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    \n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      errorId: null,\n      retryCount: 0,\n    };\n  }\n\n  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {\n    const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    return {\n      hasError: true,\n      error,\n      errorId,\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    const { onError, level = 'component' } = this.props;\n    const { errorId, retryCount } = this.state;\n\n    // Log to console in development\n    if (env.isDevelopment()) {\n      console.error('Error caught by ErrorBoundary:', error);\n      console.error('Error Info:', errorInfo);\n      console.error('Component Stack:', errorInfo.componentStack);\n    }\n\n    // Update state with error info\n    this.setState({ errorInfo });\n\n    // Report to monitoring service\n    ErrorReporter.getInstance().reportError(error, {\n      errorBoundary: true,\n      level,\n      errorId: errorId || undefined,\n      componentStack: errorInfo.componentStack,\n      retryCount,\n      props: this.sanitizeProps(),\n    });\n\n    // Call custom error handler if provided\n    if (onError) {\n      onError(error, errorInfo);\n    }\n\n    // Set up automatic retry for transient errors\n    if (this.shouldAutoRetry(error) && retryCount < 3) {\n      this.scheduleRetry();\n    }\n  }\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps) {\n    const { resetKeys, resetOnPropsChange } = this.props;\n    const { hasError } = this.state;\n\n    // Reset on prop changes if enabled\n    if (hasError && resetOnPropsChange && this.propsHaveChanged(prevProps)) {\n      this.resetError();\n      return;\n    }\n\n    // Reset on resetKeys change\n    if (resetKeys && hasError) {\n      const hasResetKeyChanged = resetKeys.some(\n        (key, index) => key !== this.previousResetKeys[index]\n      );\n\n      if (hasResetKeyChanged) {\n        this.resetError();\n      }\n    }\n\n    this.previousResetKeys = resetKeys || [];\n  }\n\n  componentWillUnmount() {\n    if (this.resetTimeoutId) {\n      clearTimeout(this.resetTimeoutId);\n    }\n  }\n\n  private shouldAutoRetry(error: Error): boolean {\n    // Auto-retry network errors and specific known transient errors\n    const transientErrors = [\n      'NetworkError',\n      'TimeoutError',\n      'ChunkLoadError',\n      'Loading chunk',\n      'Failed to fetch',\n      'Load failed',\n    ];\n\n    return transientErrors.some(msg => \n      error.message.includes(msg) || error.name.includes(msg)\n    );\n  }\n\n  private scheduleRetry() {\n    const { retryCount } = this.state;\n    const delay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff, max 10s\n\n    this.resetTimeoutId = setTimeout(() => {\n      this.setState(prevState => ({\n        hasError: false,\n        error: null,\n        errorInfo: null,\n        retryCount: prevState.retryCount + 1,\n      }));\n    }, delay);\n  }\n\n  private propsHaveChanged(prevProps: ErrorBoundaryProps): boolean {\n    // Simple shallow comparison of props\n    return Object.keys(this.props).some(key => {\n      if (key === 'children' || key === 'fallback') return false;\n      return (this.props as any)[key] !== (prevProps as any)[key];\n    });\n  }\n\n  private sanitizeProps(): Record<string, any> {\n    // Remove sensitive data from props before reporting\n    const { children, fallback, ...safeProps } = this.props;\n    return safeProps;\n  }\n\n  resetError = () => {\n    if (this.resetTimeoutId) {\n      clearTimeout(this.resetTimeoutId);\n      this.resetTimeoutId = null;\n    }\n\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      errorId: null,\n      retryCount: 0,\n    });\n  };\n\n  render() {\n    const { hasError, error, errorInfo, errorId } = this.state;\n    const { children, fallback, isolate = true } = this.props;\n\n    if (hasError && error && errorInfo) {\n      // Use custom fallback if provided\n      if (fallback) {\n        return (\n          <>\n            {fallback({\n              error,\n              errorInfo,\n              resetError: this.resetError,\n              errorId: errorId || 'unknown',\n            })}\n          </>\n        );\n      }\n\n      // Default error UI\n      return (\n        <DefaultErrorFallback\n          error={error}\n          errorInfo={errorInfo}\n          resetError={this.resetError}\n          errorId={errorId || 'unknown'}\n          showDetails={this.props.showErrorDetails ?? env.isDevelopment()}\n        />\n      );\n    }\n\n    // Wrap children in a div if isolation is enabled\n    // This prevents errors from propagating to sibling components\n    if (isolate) {\n      return <div className=\"error-boundary-container\">{children}</div>;\n    }\n\n    return children;\n  }\n}\n\n// Default error fallback component\nfunction DefaultErrorFallback({\n  error,\n  errorInfo,\n  resetError,\n  errorId,\n  showDetails,\n}: {\n  error: Error;\n  errorInfo: ErrorInfo;\n  resetError: () => void;\n  errorId: string;\n  showDetails: boolean;\n}) {\n  return (\n    <div className=\"min-h-[200px] flex items-center justify-center p-6\">\n      <div className=\"max-w-md w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6\">\n        <div className=\"text-center\">\n          <div className=\"mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900\">\n            <svg\n              className=\"h-6 w-6 text-red-600 dark:text-red-400\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\"\n              stroke=\"currentColor\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n              />\n            </svg>\n          </div>\n          \n          <h3 className=\"mt-4 text-lg font-medium text-gray-900 dark:text-gray-100\">\n            Something went wrong\n          </h3>\n          \n          <p className=\"mt-2 text-sm text-gray-500 dark:text-gray-400\">\n            We're sorry for the inconvenience. The error has been reported and we'll look into it.\n          </p>\n\n          {showDetails && (\n            <details className=\"mt-4 text-left\">\n              <summary className=\"cursor-pointer text-sm font-medium text-gray-700 dark:text-gray-300\">\n                Error Details\n              </summary>\n              <div className=\"mt-2 text-xs\">\n                <p className=\"text-gray-600 dark:text-gray-400\">\n                  <strong>Error ID:</strong> {errorId}\n                </p>\n                <p className=\"mt-1 text-gray-600 dark:text-gray-400\">\n                  <strong>Message:</strong> {error.message}\n                </p>\n                <pre className=\"mt-2 p-2 bg-gray-100 dark:bg-gray-900 rounded text-xs overflow-auto max-h-40\">\n                  {error.stack}\n                </pre>\n              </div>\n            </details>\n          )}\n\n          <div className=\"mt-6 flex flex-col sm:flex-row gap-3 justify-center\">\n            <button\n              onClick={resetError}\n              className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\"\n            >\n              Try Again\n            </button>\n            \n            <button\n              onClick={() => window.location.reload()}\n              className=\"inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\"\n            >\n              Refresh Page\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Higher-order component for adding error boundary\nexport function withErrorBoundary<P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<ErrorBoundaryProps, 'children'>\n) {\n  const WrappedComponent = (props: P) => (\n    <ErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;\n\n  return WrappedComponent;\n}\n\n// Hook for imperatively triggering error boundary\nexport function useErrorHandler() {\n  const [error, setError] = React.useState<Error | null>(null);\n\n  React.useEffect(() => {\n    if (error) {\n      throw error;\n    }\n  }, [error]);\n\n  return (error: Error) => {\n    setError(error);\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/integration/system-health.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[377,380],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[377,380],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase } from '../supabase';\nimport { env } from '../config/environment';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport { performanceTracker } from '../monitoring/performance-tracker';\n\nexport interface SystemHealthCheck {\n  component: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime: number;\n  details?: Record<string, any>;\n  error?: string;\n  lastChecked: string;\n}\n\nexport interface SystemHealthReport {\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  checks: SystemHealthCheck[];\n  summary: {\n    totalChecks: number;\n    healthyChecks: number;\n    degradedChecks: number;\n    unhealthyChecks: number;\n    avgResponseTime: number;\n  };\n  recommendations?: string[];\n}\n\nexport interface AIServiceConfig {\n  name: string;\n  endpoint: string;\n  apiKey: string;\n  timeout: number;\n}\n\nexport class SystemHealthValidator {\n  private static instance: SystemHealthValidator;\n  private healthChecks: Map<string, SystemHealthCheck> = new Map();\n\n  private constructor() {}\n\n  static getInstance(): SystemHealthValidator {\n    if (!SystemHealthValidator.instance) {\n      SystemHealthValidator.instance = new SystemHealthValidator();\n    }\n    return SystemHealthValidator.instance;\n  }\n\n  /**\n   * Perform comprehensive system health check\n   */\n  async performFullHealthCheck(): Promise<SystemHealthReport> {\n    const startTime = Date.now();\n    \n    try {\n      // Run all health checks in parallel\n      const checks = await Promise.allSettled([\n        this.checkDatabase(),\n        this.checkAIServices(),\n        this.checkFileUpload(),\n        this.checkVideoProcessing(),\n        this.checkMobileCompatibility(),\n        this.checkOfflineCapabilities(),\n        this.checkAuthenticationSystem(),\n        this.checkEnvironmentConfiguration(),\n      ]);\n\n      const healthChecks = checks.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        } else {\n          const componentNames = [\n            'database',\n            'ai_services',\n            'file_upload',\n            'video_processing',\n            'mobile_compatibility',\n            'offline_capabilities',\n            'authentication',\n            'environment_config',\n          ];\n\n          return {\n            component: componentNames[index] || 'unknown',\n            status: 'unhealthy' as const,\n            responseTime: Date.now() - startTime,\n            error: result.reason?.message || 'Unknown error',\n            lastChecked: new Date().toISOString(),\n          };\n        }\n      });\n\n      // Calculate summary\n      const summary = {\n        totalChecks: healthChecks.length,\n        healthyChecks: healthChecks.filter(c => c.status === 'healthy').length,\n        degradedChecks: healthChecks.filter(c => c.status === 'degraded').length,\n        unhealthyChecks: healthChecks.filter(c => c.status === 'unhealthy').length,\n        avgResponseTime: healthChecks.reduce((sum, c) => sum + c.responseTime, 0) / healthChecks.length,\n      };\n\n      // Determine overall status\n      let overall: SystemHealthReport['overall'] = 'healthy';\n      if (summary.unhealthyChecks > 0) {\n        overall = 'unhealthy';\n      } else if (summary.degradedChecks > 0) {\n        overall = 'degraded';\n      }\n\n      const report: SystemHealthReport = {\n        overall,\n        timestamp: new Date().toISOString(),\n        checks: healthChecks,\n        summary,\n        recommendations: this.generateRecommendations(healthChecks),\n      };\n\n      // Track performance\n      performanceTracker.trackMetric('system_health_check', Date.now() - startTime, 'ms', {\n        overall: report.overall,\n        unhealthyChecks: summary.unhealthyChecks,\n      });\n\n      // Report critical issues\n      if (overall === 'unhealthy') {\n        errorReporter.reportError(new Error('System health check failed'), {\n          category: 'system_health',\n          severity: 'high',\n          details: report,\n        });\n      }\n\n      return report;\n    } catch (error) {\n      throw new Error(`System health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Check database connectivity and performance\n   */\n  private async checkDatabase(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      // Test basic connectivity\n      const { data: connectionTest, error: connectionError } = await supabase\n        .from('properties')\n        .select('id')\n        .limit(1);\n\n      if (connectionError) {\n        throw new Error(`Database connection failed: ${connectionError.message}`);\n      }\n\n      // Test write operations\n      const { error: writeError } = await supabase\n        .from('system_health_logs')\n        .insert({\n          component: 'database',\n          status: 'healthy',\n          checked_at: new Date().toISOString(),\n        });\n\n      const responseTime = Date.now() - startTime;\n\n      // Determine status based on response time and errors\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (writeError) {\n        status = 'degraded';\n      } else if (responseTime > 1000) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'database',\n        status,\n        responseTime,\n        details: {\n          connectionTest: !!connectionTest,\n          writeTest: !writeError,\n          latency: responseTime,\n        },\n        error: writeError?.message,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'database',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Database check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check AI services connectivity and functionality\n   */\n  private async checkAIServices(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      const services = [\n        {\n          name: 'OpenAI',\n          endpoint: 'https://api.openai.com/v1/models',\n          apiKey: env.openai.apiKey,\n        },\n      ];\n\n      const results = await Promise.allSettled(\n        services.map(service => this.testAIService(service))\n      );\n\n      const serviceStatuses = results.map((result, index) => {\n        const serviceName = services[index].name;\n        if (result.status === 'fulfilled') {\n          return { name: serviceName, ...result.value };\n        } else {\n          return {\n            name: serviceName,\n            status: 'unhealthy',\n            error: result.reason?.message || 'Service check failed',\n          };\n        }\n      });\n\n      const responseTime = Date.now() - startTime;\n      const unhealthyServices = serviceStatuses.filter(s => s.status === 'unhealthy');\n      \n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (unhealthyServices.length === serviceStatuses.length) {\n        status = 'unhealthy';\n      } else if (unhealthyServices.length > 0) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'ai_services',\n        status,\n        responseTime,\n        details: {\n          services: serviceStatuses,\n          totalServices: serviceStatuses.length,\n          healthyServices: serviceStatuses.filter(s => s.status === 'healthy').length,\n        },\n        error: unhealthyServices.length > 0 ? `${unhealthyServices.length} service(s) unhealthy` : undefined,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'ai_services',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'AI services check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Test individual AI service\n   */\n  private async testAIService(service: { name: string; endpoint: string; apiKey: string }) {\n    const startTime = Date.now();\n    \n    try {\n      const response = await fetch(service.endpoint, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${service.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        signal: AbortSignal.timeout(5000),\n      });\n\n      const responseTime = Date.now() - startTime;\n\n      if (!response.ok) {\n        return {\n          status: 'unhealthy' as const,\n          responseTime,\n          error: `HTTP ${response.status}: ${response.statusText}`,\n        };\n      }\n\n      // Test rate limits\n      const rateLimitRemaining = response.headers.get('x-ratelimit-remaining');\n      const rateLimitTotal = response.headers.get('x-ratelimit-limit');\n\n      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n      if (rateLimitRemaining && rateLimitTotal) {\n        const remaining = parseInt(rateLimitRemaining);\n        const total = parseInt(rateLimitTotal);\n        if (remaining / total < 0.1) { // Less than 10% remaining\n          status = 'degraded';\n        }\n      }\n\n      return {\n        status,\n        responseTime,\n        details: {\n          rateLimitRemaining,\n          rateLimitTotal,\n          httpStatus: response.status,\n        },\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy' as const,\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Service test failed',\n      };\n    }\n  }\n\n  /**\n   * Check file upload capabilities\n   */\n  private async checkFileUpload(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      // Test storage bucket accessibility\n      const { data: buckets, error: bucketError } = await supabase.storage.listBuckets();\n\n      if (bucketError) {\n        throw new Error(`Storage bucket check failed: ${bucketError.message}`);\n      }\n\n      const requiredBuckets = ['property-photos', 'inspection-videos'];\n      const availableBuckets = buckets?.map(b => b.name) || [];\n      const missingBuckets = requiredBuckets.filter(b => !availableBuckets.includes(b));\n\n      // Test file upload with a small test file\n      const testFile = new Blob(['test'], { type: 'text/plain' });\n      const testFileName = `health-check-${Date.now()}.txt`;\n      \n      const { error: uploadError } = await supabase.storage\n        .from('property-photos')\n        .upload(`test/${testFileName}`, testFile);\n\n      // Clean up test file\n      if (!uploadError) {\n        await supabase.storage\n          .from('property-photos')\n          .remove([`test/${testFileName}`]);\n      }\n\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (missingBuckets.length > 0 || uploadError) {\n        status = missingBuckets.length === requiredBuckets.length ? 'unhealthy' : 'degraded';\n      }\n\n      return {\n        component: 'file_upload',\n        status,\n        responseTime,\n        details: {\n          bucketsFound: availableBuckets.length,\n          bucketsRequired: requiredBuckets.length,\n          missingBuckets,\n          uploadTest: !uploadError,\n        },\n        error: uploadError?.message || (missingBuckets.length > 0 ? `Missing buckets: ${missingBuckets.join(', ')}` : undefined),\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'file_upload',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'File upload check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check video processing pipeline\n   */\n  private async checkVideoProcessing(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      // Check if MediaRecorder API is available\n      const mediaRecorderAvailable = typeof MediaRecorder !== 'undefined';\n      \n      // Check supported video formats\n      const supportedFormats: string[] = [];\n      if (mediaRecorderAvailable) {\n        const formats = ['video/webm', 'video/mp4', 'video/webm;codecs=vp8', 'video/webm;codecs=vp9'];\n        formats.forEach(format => {\n          if (MediaRecorder.isTypeSupported(format)) {\n            supportedFormats.push(format);\n          }\n        });\n      }\n\n      // Check getUserMedia availability\n      const getUserMediaAvailable = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (!mediaRecorderAvailable || !getUserMediaAvailable) {\n        status = 'unhealthy';\n      } else if (supportedFormats.length === 0) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'video_processing',\n        status,\n        responseTime,\n        details: {\n          mediaRecorderAvailable,\n          getUserMediaAvailable,\n          supportedFormats,\n          browserSupport: {\n            webRTC: !!window.RTCPeerConnection,\n            webGL: !!window.WebGLRenderingContext,\n          },\n        },\n        error: !mediaRecorderAvailable ? 'MediaRecorder API not available' : \n               !getUserMediaAvailable ? 'getUserMedia not available' :\n               supportedFormats.length === 0 ? 'No supported video formats' : undefined,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'video_processing',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Video processing check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check mobile compatibility\n   */\n  private async checkMobileCompatibility(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      const capabilities = {\n        touchSupport: 'ontouchstart' in window,\n        orientationAPI: 'orientation' in window || 'onorientationchange' in window,\n        deviceMotion: 'DeviceMotionEvent' in window,\n        geolocation: 'geolocation' in navigator,\n        vibration: 'vibrate' in navigator,\n        camera: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),\n        serviceWorker: 'serviceWorker' in navigator,\n        pushNotifications: 'PushManager' in window,\n        localStorage: (() => {\n          try {\n            localStorage.setItem('test', 'test');\n            localStorage.removeItem('test');\n            return true;\n          } catch {\n            return false;\n          }\n        })(),\n      };\n\n      const supportedFeatures = Object.values(capabilities).filter(Boolean).length;\n      const totalFeatures = Object.keys(capabilities).length;\n      const supportPercentage = (supportedFeatures / totalFeatures) * 100;\n\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (supportPercentage < 50) {\n        status = 'unhealthy';\n      } else if (supportPercentage < 80) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'mobile_compatibility',\n        status,\n        responseTime,\n        details: {\n          capabilities,\n          supportedFeatures,\n          totalFeatures,\n          supportPercentage,\n          userAgent: navigator.userAgent,\n          screenSize: {\n            width: window.screen.width,\n            height: window.screen.height,\n          },\n        },\n        error: supportPercentage < 50 ? 'Low mobile feature support' : undefined,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'mobile_compatibility',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Mobile compatibility check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check offline capabilities\n   */\n  private async checkOfflineCapabilities(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      const offlineCapabilities = {\n        serviceWorker: 'serviceWorker' in navigator,\n        indexedDB: !!window.indexedDB,\n        localStorage: (() => {\n          try {\n            localStorage.setItem('test', 'test');\n            localStorage.removeItem('test');\n            return true;\n          } catch {\n            return false;\n          }\n        })(),\n        cacheAPI: 'caches' in window,\n        backgroundSync: !!(navigator.serviceWorker && 'sync' in window.ServiceWorkerRegistration.prototype),\n      };\n\n      // Test cache functionality\n      let cacheTest = false;\n      if (offlineCapabilities.cacheAPI) {\n        try {\n          const cache = await caches.open('health-check-test');\n          await cache.put(new Request('/test'), new Response('test'));\n          const cached = await cache.match('/test');\n          cacheTest = !!cached;\n          await caches.delete('health-check-test');\n        } catch {\n          cacheTest = false;\n        }\n      }\n\n      const supportedFeatures = Object.values(offlineCapabilities).filter(Boolean).length;\n      const totalFeatures = Object.keys(offlineCapabilities).length;\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (supportedFeatures < 3) {\n        status = 'unhealthy';\n      } else if (supportedFeatures < totalFeatures) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'offline_capabilities',\n        status,\n        responseTime,\n        details: {\n          ...offlineCapabilities,\n          cacheTest,\n          supportedFeatures,\n          totalFeatures,\n          isOnline: navigator.onLine,\n        },\n        error: supportedFeatures < 3 ? 'Insufficient offline support' : undefined,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'offline_capabilities',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Offline capabilities check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check authentication system\n   */\n  private async checkAuthenticationSystem(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      // Check current session\n      const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n      \n      // Test auth endpoint responsiveness\n      const { data: user, error: userError } = await supabase.auth.getUser();\n\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (sessionError || userError) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'authentication',\n        status,\n        responseTime,\n        details: {\n          hasSession: !!session,\n          hasUser: !!user?.user,\n          sessionValid: !sessionError,\n          userValid: !userError,\n          authMethod: session?.user?.app_metadata?.provider || 'unknown',\n        },\n        error: sessionError?.message || userError?.message,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'authentication',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Authentication check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Check environment configuration\n   */\n  private async checkEnvironmentConfiguration(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    \n    try {\n      const config = {\n        hasSupabaseUrl: !!env.supabase.url,\n        hasSupabaseKey: !!env.supabase.anonKey,\n        hasOpenAIKey: !!env.openai.apiKey,\n        environment: env.getEnvironment(),\n        features: env.features,\n        validSupabaseConfig: env.validateSupabaseConfig(),\n        validAIConfig: env.validateAIConfig(),\n      };\n\n      const requiredConfigs = [\n        config.hasSupabaseUrl,\n        config.hasSupabaseKey,\n        config.validSupabaseConfig,\n      ];\n\n      const optionalConfigs = [\n        config.hasOpenAIKey,\n        config.validAIConfig,\n      ];\n\n      const missingRequired = requiredConfigs.filter(c => !c).length;\n      const missingOptional = optionalConfigs.filter(c => !c).length;\n\n      const responseTime = Date.now() - startTime;\n\n      let status: SystemHealthCheck['status'] = 'healthy';\n      if (missingRequired > 0) {\n        status = 'unhealthy';\n      } else if (missingOptional > 0) {\n        status = 'degraded';\n      }\n\n      return {\n        component: 'environment_config',\n        status,\n        responseTime,\n        details: {\n          ...config,\n          missingRequired,\n          missingOptional,\n        },\n        error: missingRequired > 0 ? 'Missing required configuration' : \n               missingOptional > 0 ? 'Missing optional configuration' : undefined,\n        lastChecked: new Date().toISOString(),\n      };\n    } catch (error) {\n      return {\n        component: 'environment_config',\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Environment config check failed',\n        lastChecked: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Generate recommendations based on health check results\n   */\n  private generateRecommendations(checks: SystemHealthCheck[]): string[] {\n    const recommendations: string[] = [];\n    \n    checks.forEach(check => {\n      if (check.status === 'unhealthy') {\n        switch (check.component) {\n          case 'database':\n            recommendations.push('Check database connection and credentials');\n            break;\n          case 'ai_services':\n            recommendations.push('Verify AI service API keys and network connectivity');\n            break;\n          case 'file_upload':\n            recommendations.push('Ensure storage buckets are properly configured');\n            break;\n          case 'video_processing':\n            recommendations.push('Update browser or check camera permissions');\n            break;\n          case 'mobile_compatibility':\n            recommendations.push('Use a modern mobile browser with full feature support');\n            break;\n          case 'offline_capabilities':\n            recommendations.push('Enable service workers and check cache storage');\n            break;\n          case 'authentication':\n            recommendations.push('Check authentication service configuration');\n            break;\n          case 'environment_config':\n            recommendations.push('Review environment variables and configuration');\n            break;\n        }\n      } else if (check.status === 'degraded') {\n        recommendations.push(`Monitor ${check.component} for potential issues`);\n      }\n    });\n\n    if (recommendations.length === 0) {\n      recommendations.push('All systems are operating normally');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get cached health check result\n   */\n  getCachedHealthCheck(component: string): SystemHealthCheck | null {\n    return this.healthChecks.get(component) || null;\n  }\n\n  /**\n   * Cache health check result\n   */\n  cacheHealthCheck(check: SystemHealthCheck): void {\n    this.healthChecks.set(check.component, check);\n  }\n}\n\n// Export singleton instance\nexport const systemHealthValidator = SystemHealthValidator.getInstance();\n\n// Export convenience functions\nexport const performHealthCheck = () => systemHealthValidator.performFullHealthCheck();\nexport const checkComponent = (component: string) => systemHealthValidator.getCachedHealthCheck(component);","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/mobile/photo-optimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6477,6480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6477,6480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6596,6599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6596,6599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6653,6656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6653,6656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6716,6719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6716,6719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6774,6777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6774,6777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":412,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":412,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12198,12201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12198,12201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Photo Optimizer for STR Certified Mobile Upload\n\nimport type { PhotoOptimizationConfig, OptimizationResult, DeviceCapabilities } from '@/types/photo';\n\nexport interface PhotoOptimizerOptions {\n  maxWidth?: number;\n  maxHeight?: number;\n  quality?: number;\n  format?: 'jpeg' | 'webp';\n  maxFileSize?: number;\n  preserveMetadata?: boolean;\n  enableProgressive?: boolean;\n}\n\nexport class PhotoOptimizer {\n  private defaultOptions: Required<PhotoOptimizerOptions> = {\n    maxWidth: 2048,\n    maxHeight: 2048,\n    quality: 0.85,\n    format: 'jpeg',\n    maxFileSize: 5 * 1024 * 1024, // 5MB\n    preserveMetadata: false,\n    enableProgressive: true\n  };\n\n  private canvas: HTMLCanvasElement | null = null;\n  private ctx: CanvasRenderingContext2D | null = null;\n  private deviceCapabilities: DeviceCapabilities | null = null;\n\n  constructor(options: PhotoOptimizerOptions = {}) {\n    this.defaultOptions = { ...this.defaultOptions, ...options };\n    this.initializeCanvas();\n    this.detectDeviceCapabilities();\n  }\n\n  /**\n   * Optimizes a photo for upload while maintaining quality for AI analysis\n   * @param file - Original photo file\n   * @param options - Override default optimization options\n   * @returns Promise<OptimizationResult>\n   */\n  async optimizeForUpload(\n    file: File,\n    options: Partial<PhotoOptimizerOptions> = {}\n  ): Promise<OptimizationResult> {\n    const startTime = performance.now();\n    const opts = { ...this.defaultOptions, ...options };\n\n    try {\n      // Validate input\n      if (!file.type.startsWith('image/')) {\n        throw new Error('Invalid file type. Expected an image.');\n      }\n\n      // Load image\n      const originalImage = await this.loadImage(file);\n      const originalSize = file.size;\n      const originalDimensions = {\n        width: originalImage.width,\n        height: originalImage.height\n      };\n\n      // Calculate optimal dimensions\n      const { width, height } = this.calculateOptimalDimensions(\n        originalImage.width,\n        originalImage.height,\n        opts.maxWidth,\n        opts.maxHeight\n      );\n\n      // Resize image\n      const resizedImage = await this.resizeImage(originalImage, width, height);\n\n      // Apply device-specific optimizations\n      const deviceOptimizedQuality = this.getDeviceOptimizedQuality(opts.quality);\n\n      // Convert to blob with quality adjustments\n      let blob = await this.imageToBlob(resizedImage, opts.format, deviceOptimizedQuality);\n      \n      // If file is still too large, progressively reduce quality\n      if (blob.size > opts.maxFileSize) {\n        blob = await this.progressiveQualityReduction(\n          resizedImage,\n          opts.format,\n          deviceOptimizedQuality,\n          opts.maxFileSize\n        );\n      }\n\n      // Create optimized file\n      const optimizedFile = new File([blob], file.name, {\n        type: `image/${opts.format}`,\n        lastModified: Date.now()\n      });\n\n      // Calculate metrics\n      const compressionRatio = ((originalSize - blob.size) / originalSize) * 100;\n      const processingTime = performance.now() - startTime;\n\n      return {\n        originalFile: file,\n        optimizedFile,\n        originalSize,\n        optimizedSize: blob.size,\n        compressionRatio,\n        originalDimensions,\n        optimizedDimensions: { width, height },\n        format: opts.format,\n        quality: deviceOptimizedQuality,\n        processingTime,\n        success: true,\n        metadata: {\n          deviceCapabilities: this.deviceCapabilities,\n          optimizationSettings: opts\n        }\n      };\n\n    } catch (error) {\n      return {\n        originalFile: file,\n        optimizedFile: file,\n        originalSize: file.size,\n        optimizedSize: file.size,\n        compressionRatio: 0,\n        originalDimensions: { width: 0, height: 0 },\n        optimizedDimensions: { width: 0, height: 0 },\n        format: 'jpeg',\n        quality: 0,\n        processingTime: performance.now() - startTime,\n        success: false,\n        error: error instanceof Error ? error.message : 'Optimization failed'\n      };\n    }\n  }\n\n  /**\n   * Batch optimize multiple photos\n   * @param files - Array of photo files\n   * @param options - Optimization options\n   * @returns Promise<OptimizationResult[]>\n   */\n  async batchOptimize(\n    files: File[],\n    options: Partial<PhotoOptimizerOptions> = {}\n  ): Promise<OptimizationResult[]> {\n    // Process in chunks to avoid memory issues\n    const chunkSize = this.getOptimalBatchSize();\n    const results: OptimizationResult[] = [];\n\n    for (let i = 0; i < files.length; i += chunkSize) {\n      const chunk = files.slice(i, i + chunkSize);\n      const chunkResults = await Promise.all(\n        chunk.map(file => this.optimizeForUpload(file, options))\n      );\n      results.push(...chunkResults);\n    }\n\n    return results;\n  }\n\n  /**\n   * Prepares photo for AI analysis (higher quality preservation)\n   * @param file - Photo file\n   * @returns Promise<OptimizationResult>\n   */\n  async optimizeForAI(file: File): Promise<OptimizationResult> {\n    return this.optimizeForUpload(file, {\n      quality: 0.95,\n      maxWidth: 4096,\n      maxHeight: 4096,\n      maxFileSize: 10 * 1024 * 1024 // 10MB for AI analysis\n    });\n  }\n\n  /**\n   * Creates a thumbnail for preview\n   * @param file - Photo file\n   * @param size - Thumbnail size\n   * @returns Promise<string> - Data URL\n   */\n  async createThumbnail(file: File, size: number = 200): Promise<string> {\n    try {\n      const image = await this.loadImage(file);\n      const { width, height } = this.calculateOptimalDimensions(\n        image.width,\n        image.height,\n        size,\n        size\n      );\n\n      const thumbnail = await this.resizeImage(image, width, height);\n      return thumbnail.toDataURL('image/jpeg', 0.8);\n    } catch (error) {\n      console.error('Failed to create thumbnail:', error);\n      return '';\n    }\n  }\n\n  // Private helper methods\n\n  private initializeCanvas(): void {\n    if (typeof document !== 'undefined') {\n      this.canvas = document.createElement('canvas');\n      this.ctx = this.canvas.getContext('2d');\n    }\n  }\n\n  private detectDeviceCapabilities(): void {\n    if (typeof window === 'undefined') return;\n\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    \n    this.deviceCapabilities = {\n      maxTextureSize: gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 4096,\n      deviceMemory: (navigator as any).deviceMemory || 4,\n      hardwareConcurrency: navigator.hardwareConcurrency || 4,\n      connection: (navigator as any).connection ? {\n        effectiveType: (navigator as any).connection.effectiveType,\n        downlink: (navigator as any).connection.downlink,\n        saveData: (navigator as any).connection.saveData\n      } : null,\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      screenResolution: {\n        width: window.screen.width,\n        height: window.screen.height,\n        pixelRatio: window.devicePixelRatio || 1\n      }\n    };\n  }\n\n  private async loadImage(file: File): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      const url = URL.createObjectURL(file);\n      \n      img.onload = () => {\n        URL.revokeObjectURL(url);\n        resolve(img);\n      };\n      \n      img.onerror = () => {\n        URL.revokeObjectURL(url);\n        reject(new Error('Failed to load image'));\n      };\n      \n      img.src = url;\n    });\n  }\n\n  private calculateOptimalDimensions(\n    originalWidth: number,\n    originalHeight: number,\n    maxWidth: number,\n    maxHeight: number\n  ): { width: number; height: number } {\n    // Don't upscale\n    if (originalWidth <= maxWidth && originalHeight <= maxHeight) {\n      return { width: originalWidth, height: originalHeight };\n    }\n\n    const aspectRatio = originalWidth / originalHeight;\n    let width = maxWidth;\n    let height = maxHeight;\n\n    if (originalWidth / originalHeight > maxWidth / maxHeight) {\n      height = Math.round(maxWidth / aspectRatio);\n    } else {\n      width = Math.round(maxHeight * aspectRatio);\n    }\n\n    return { width, height };\n  }\n\n  private async resizeImage(\n    image: HTMLImageElement,\n    width: number,\n    height: number\n  ): Promise<HTMLCanvasElement> {\n    if (!this.canvas || !this.ctx) {\n      throw new Error('Canvas not initialized');\n    }\n\n    // Use step-down approach for better quality\n    let currentWidth = image.width;\n    let currentHeight = image.height;\n    let currentImage: HTMLImageElement | HTMLCanvasElement = image;\n\n    // Step down in halves for better quality\n    while (currentWidth > width * 2 || currentHeight > height * 2) {\n      currentWidth = Math.round(currentWidth / 2);\n      currentHeight = Math.round(currentHeight / 2);\n      \n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = currentWidth;\n      tempCanvas.height = currentHeight;\n      \n      const tempCtx = tempCanvas.getContext('2d');\n      if (!tempCtx) throw new Error('Failed to get canvas context');\n      \n      tempCtx.imageSmoothingEnabled = true;\n      tempCtx.imageSmoothingQuality = 'high';\n      tempCtx.drawImage(currentImage, 0, 0, currentWidth, currentHeight);\n      \n      currentImage = tempCanvas;\n    }\n\n    // Final resize\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx.imageSmoothingEnabled = true;\n    this.ctx.imageSmoothingQuality = 'high';\n    this.ctx.drawImage(currentImage, 0, 0, width, height);\n\n    const finalCanvas = document.createElement('canvas');\n    finalCanvas.width = width;\n    finalCanvas.height = height;\n    const finalCtx = finalCanvas.getContext('2d');\n    if (!finalCtx) throw new Error('Failed to get canvas context');\n    \n    finalCtx.drawImage(this.canvas, 0, 0);\n    return finalCanvas;\n  }\n\n  private async imageToBlob(\n    canvas: HTMLCanvasElement,\n    format: 'jpeg' | 'webp',\n    quality: number\n  ): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      canvas.toBlob(\n        (blob) => {\n          if (blob) resolve(blob);\n          else reject(new Error('Failed to create blob'));\n        },\n        `image/${format}`,\n        quality\n      );\n    });\n  }\n\n  private async progressiveQualityReduction(\n    canvas: HTMLCanvasElement,\n    format: 'jpeg' | 'webp',\n    startQuality: number,\n    targetSize: number\n  ): Promise<Blob> {\n    let quality = startQuality;\n    let blob = await this.imageToBlob(canvas, format, quality);\n    \n    // Reduce quality in steps until target size is reached\n    while (blob.size > targetSize && quality > 0.3) {\n      quality -= 0.05;\n      blob = await this.imageToBlob(canvas, format, quality);\n    }\n\n    return blob;\n  }\n\n  private getDeviceOptimizedQuality(baseQuality: number): number {\n    if (!this.deviceCapabilities) return baseQuality;\n\n    // Adjust quality based on device capabilities\n    let quality = baseQuality;\n\n    // Lower quality for low-memory devices\n    if (this.deviceCapabilities.deviceMemory < 4) {\n      quality *= 0.9;\n    }\n\n    // Lower quality for slow connections\n    if (this.deviceCapabilities.connection?.effectiveType === '2g' ||\n        this.deviceCapabilities.connection?.effectiveType === 'slow-2g') {\n      quality *= 0.85;\n    }\n\n    // Honor data saver preferences\n    if (this.deviceCapabilities.connection?.saveData) {\n      quality *= 0.8;\n    }\n\n    return Math.max(0.5, Math.min(1, quality));\n  }\n\n  private getOptimalBatchSize(): number {\n    if (!this.deviceCapabilities) return 3;\n\n    const memory = this.deviceCapabilities.deviceMemory;\n    const cores = this.deviceCapabilities.hardwareConcurrency;\n\n    if (memory >= 8 && cores >= 8) return 10;\n    if (memory >= 4 && cores >= 4) return 5;\n    return 3;\n  }\n}\n\n// Export types\nexport interface OptimizationResult {\n  originalFile: File;\n  optimizedFile: File;\n  originalSize: number;\n  optimizedSize: number;\n  compressionRatio: number;\n  originalDimensions: { width: number; height: number };\n  optimizedDimensions: { width: number; height: number };\n  format: string;\n  quality: number;\n  processingTime: number;\n  success: boolean;\n  error?: string;\n  metadata?: any;\n}\n\nexport interface DeviceCapabilities {\n  maxTextureSize: number;\n  deviceMemory: number;\n  hardwareConcurrency: number;\n  connection: {\n    effectiveType: string;\n    downlink: number;\n    saveData: boolean;\n  } | null;\n  userAgent: string;\n  platform: string;\n  screenResolution: {\n    width: number;\n    height: number;\n    pixelRatio: number;\n  };\n}\n\n// Export factory function\nexport const createPhotoOptimizer = (\n  options?: PhotoOptimizerOptions\n): PhotoOptimizer => {\n  return new PhotoOptimizer(options);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/monitoring/ai-metrics.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11308,11311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11308,11311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11321,11324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11321,11324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":368,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":368,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11827,11830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11827,11830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":444,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":444,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14551,14554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14551,14554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":467,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15421,15424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15421,15424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":467,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15434,15437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15434,15437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":518,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17060,17063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17060,17063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":545,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":545,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18239,18242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18239,18242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":556,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":556,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18615,18618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18615,18618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":559,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18659,18662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18659,18662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":559,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18682,18685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18682,18685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":560,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":560,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18722,18725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18722,18725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":571,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":571,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19009,19012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19009,19012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":582,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":582,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19397,19400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19397,19400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":585,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":585,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19478,19481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19478,19481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":596,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":596,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19851,19854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19851,19854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":734,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23772,23775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23772,23775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":736,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":736,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23829,23832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23829,23832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":745,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":745,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24074,24077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24074,24077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":963,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":963,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30529,30532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30529,30532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":970,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":970,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30639,30642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30639,30642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":977,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":977,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30750,30753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30750,30753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":991,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":991,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30976,30979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30976,30979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1021,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1021,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31510,31513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31510,31513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1023,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1023,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31532,31535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31532,31535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1033,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1033,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31695,31698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31695,31698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1064,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1064,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32240,32243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32240,32243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1065,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1065,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32255,32258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32255,32258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1068,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1068,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32341,32344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32341,32344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1103,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1103,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32933,32936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32933,32936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1194,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1194,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34636,34639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34636,34639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Metrics Collection System for STR Certified\n// Tracks performance, accuracy, costs, and usage patterns\n\nexport class AIMetricsCollector {\n  private metrics: MetricsStore;\n  private apiUsageTracker: APIUsageTracker;\n  private performanceMonitor: PerformanceMonitor;\n  private accuracyTracker: AccuracyTracker;\n  private costCalculator: CostCalculator;\n\n  constructor() {\n    this.metrics = new MetricsStore();\n    this.apiUsageTracker = new APIUsageTracker();\n    this.performanceMonitor = new PerformanceMonitor();\n    this.accuracyTracker = new AccuracyTracker();\n    this.costCalculator = new CostCalculator();\n  }\n\n  /**\n   * Tracks AI prediction accuracy by comparing predictions with ground truth\n   */\n  async trackPredictionAccuracy(\n    prediction: PredictionResult,\n    groundTruth?: GroundTruth,\n    feedback?: UserFeedback\n  ): Promise<void> {\n    const timestamp = new Date();\n    \n    // Calculate accuracy metrics\n    const accuracy = groundTruth \n      ? this.calculateAccuracy(prediction, groundTruth)\n      : undefined;\n\n    // Track the prediction\n    const metric: AccuracyMetric = {\n      id: `accuracy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp,\n      predictionId: prediction.id,\n      modelVersion: prediction.modelVersion,\n      category: prediction.category,\n      confidence: prediction.confidence,\n      accuracy,\n      isCorrect: accuracy ? accuracy >= 0.8 : undefined,\n      feedback: feedback ? {\n        rating: feedback.rating,\n        wasHelpful: feedback.wasHelpful,\n        correctedValue: feedback.correctedValue\n      } : undefined,\n      metadata: {\n        processingTime: prediction.processingTime,\n        inputSize: prediction.inputSize,\n        features: prediction.features\n      }\n    };\n\n    // Store metric\n    await this.metrics.store('accuracy', metric);\n    \n    // Update accuracy tracker\n    this.accuracyTracker.addMetric(metric);\n\n    // Check for accuracy degradation\n    const recentAccuracy = await this.accuracyTracker.getRecentAccuracy();\n    if (recentAccuracy < 0.7) {\n      await this.triggerAlert('accuracy_degradation', {\n        currentAccuracy: recentAccuracy,\n        threshold: 0.7,\n        category: prediction.category\n      });\n    }\n  }\n\n  /**\n   * Measures response times for AI operations\n   */\n  async measureResponseTimes(\n    operation: AIOperation,\n    duration: number,\n    metadata?: OperationMetadata\n  ): Promise<void> {\n    const timestamp = new Date();\n\n    const responseMetric: ResponseTimeMetric = {\n      id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp,\n      operation: operation.type,\n      duration,\n      success: operation.success,\n      error: operation.error,\n      metadata: {\n        ...metadata,\n        modelUsed: operation.modelUsed,\n        inputTokens: operation.inputTokens,\n        outputTokens: operation.outputTokens,\n        cached: operation.cached || false\n      }\n    };\n\n    // Store metric\n    await this.metrics.store('response_time', responseMetric);\n\n    // Update performance monitor\n    this.performanceMonitor.recordResponseTime(responseMetric);\n\n    // Check for performance issues\n    if (duration > this.getThreshold(operation.type)) {\n      await this.triggerAlert('slow_response', {\n        operation: operation.type,\n        duration,\n        threshold: this.getThreshold(operation.type)\n      });\n    }\n\n    // Track percentiles\n    const p95 = await this.performanceMonitor.getPercentile(95);\n    const p99 = await this.performanceMonitor.getPercentile(99);\n    \n    await this.metrics.store('percentiles', {\n      timestamp,\n      p50: await this.performanceMonitor.getPercentile(50),\n      p95,\n      p99,\n      operation: operation.type\n    });\n  }\n\n  /**\n   * Monitors API usage including costs and rate limits\n   */\n  async monitorAPIUsage(\n    apiCall: APICall,\n    response: APIResponse\n  ): Promise<void> {\n    const timestamp = new Date();\n\n    // Calculate cost\n    const cost = this.costCalculator.calculate(apiCall, response);\n\n    // Track usage\n    const usageMetric: APIUsageMetric = {\n      id: `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp,\n      endpoint: apiCall.endpoint,\n      model: apiCall.model,\n      inputTokens: apiCall.inputTokens || 0,\n      outputTokens: response.outputTokens || 0,\n      totalTokens: (apiCall.inputTokens || 0) + (response.outputTokens || 0),\n      cost,\n      duration: response.duration,\n      statusCode: response.statusCode,\n      rateLimitInfo: response.headers ? {\n        remaining: parseInt(response.headers['x-ratelimit-remaining'] || '0'),\n        limit: parseInt(response.headers['x-ratelimit-limit'] || '0'),\n        reset: new Date(response.headers['x-ratelimit-reset'] || Date.now())\n      } : undefined,\n      error: response.error\n    };\n\n    // Store metric\n    await this.metrics.store('api_usage', usageMetric);\n\n    // Update trackers\n    this.apiUsageTracker.recordUsage(usageMetric);\n    \n    // Check rate limits\n    if (usageMetric.rateLimitInfo) {\n      const { remaining, limit } = usageMetric.rateLimitInfo;\n      const usagePercent = ((limit - remaining) / limit) * 100;\n      \n      if (usagePercent > 80) {\n        await this.triggerAlert('rate_limit_warning', {\n          endpoint: apiCall.endpoint,\n          remaining,\n          limit,\n          usagePercent\n        });\n      }\n    }\n\n    // Check costs\n    const dailyCost = await this.apiUsageTracker.getDailyCost();\n    const monthlyCost = await this.apiUsageTracker.getMonthlyCost();\n    \n    if (dailyCost > 100) { // $100 daily limit\n      await this.triggerAlert('cost_threshold_daily', {\n        cost: dailyCost,\n        threshold: 100\n      });\n    }\n\n    if (monthlyCost > 2000) { // $2000 monthly limit\n      await this.triggerAlert('cost_threshold_monthly', {\n        cost: monthlyCost,\n        threshold: 2000\n      });\n    }\n  }\n\n  /**\n   * Generates comprehensive performance report\n   */\n  async generatePerformanceReport(\n    startDate: Date,\n    endDate: Date,\n    options: ReportOptions = {}\n  ): Promise<PerformanceReport> {\n    // Gather all metrics\n    const accuracyMetrics = await this.metrics.query('accuracy', startDate, endDate);\n    const responseMetrics = await this.metrics.query('response_time', startDate, endDate);\n    const apiUsageMetrics = await this.metrics.query('api_usage', startDate, endDate);\n\n    // Calculate summary statistics\n    const summary = {\n      accuracy: this.calculateAccuracySummary(accuracyMetrics),\n      performance: this.calculatePerformanceSummary(responseMetrics),\n      usage: this.calculateUsageSummary(apiUsageMetrics),\n      costs: this.calculateCostSummary(apiUsageMetrics)\n    };\n\n    // Identify trends\n    const trends = {\n      accuracyTrend: this.analyzeTrend(accuracyMetrics, 'accuracy'),\n      performanceTrend: this.analyzeTrend(responseMetrics, 'duration'),\n      costTrend: this.analyzeTrend(apiUsageMetrics, 'cost')\n    };\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(summary, trends);\n\n    // Benchmark against targets\n    const benchmarks = this.evaluateBenchmarks(summary);\n\n    // Create report\n    const report: PerformanceReport = {\n      id: `report_${Date.now()}`,\n      generatedAt: new Date(),\n      period: { start: startDate, end: endDate },\n      summary,\n      trends,\n      recommendations,\n      benchmarks,\n      details: {\n        accuracy: {\n          byCategory: this.groupByCategory(accuracyMetrics),\n          byModel: this.groupByModel(accuracyMetrics),\n          errorAnalysis: this.analyzeErrors(accuracyMetrics)\n        },\n        performance: {\n          byOperation: this.groupByOperation(responseMetrics),\n          percentiles: await this.performanceMonitor.getPercentiles(),\n          slowestOperations: this.findSlowestOperations(responseMetrics)\n        },\n        usage: {\n          byEndpoint: this.groupByEndpoint(apiUsageMetrics),\n          byModel: this.groupByModel(apiUsageMetrics),\n          rateLimitStatus: this.analyzeRateLimits(apiUsageMetrics)\n        },\n        costs: {\n          byModel: this.calculateCostsByModel(apiUsageMetrics),\n          byDay: this.calculateDailyCosts(apiUsageMetrics),\n          projections: this.projectFutureCosts(apiUsageMetrics)\n        }\n      },\n      alerts: await this.getActiveAlerts()\n    };\n\n    // Store report\n    await this.metrics.store('reports', report);\n\n    return report;\n  }\n\n  /**\n   * Gets real-time metrics for dashboard\n   */\n  async getRealTimeMetrics(): Promise<RealTimeMetrics> {\n    const now = new Date();\n    const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);\n\n    const recentAccuracy = await this.accuracyTracker.getRecentAccuracy();\n    const avgResponseTime = await this.performanceMonitor.getAverageResponseTime(fiveMinutesAgo);\n    const currentCost = await this.apiUsageTracker.getHourlyCost();\n    const apiHealth = await this.checkAPIHealth();\n\n    return {\n      timestamp: now,\n      accuracy: {\n        current: recentAccuracy,\n        trend: await this.accuracyTracker.getTrend(),\n        byCategory: await this.accuracyTracker.getByCategory()\n      },\n      performance: {\n        avgResponseTime,\n        p95ResponseTime: await this.performanceMonitor.getPercentile(95),\n        slowOperations: await this.performanceMonitor.getSlowOperations(),\n        errorRate: await this.performanceMonitor.getErrorRate()\n      },\n      usage: {\n        requestsPerMinute: await this.apiUsageTracker.getRequestRate(),\n        tokensPerMinute: await this.apiUsageTracker.getTokenRate(),\n        costPerHour: currentCost,\n        remainingQuota: await this.apiUsageTracker.getRemainingQuota()\n      },\n      health: apiHealth,\n      alerts: await this.getActiveAlerts()\n    };\n  }\n\n  /**\n   * Sets up automated monitoring\n   */\n  async setupAutomatedMonitoring(): Promise<void> {\n    // Monitor accuracy every 5 minutes\n    setInterval(async () => {\n      const accuracy = await this.accuracyTracker.getRecentAccuracy();\n      if (accuracy < 0.75) {\n        await this.triggerAlert('low_accuracy', { accuracy });\n      }\n    }, 5 * 60 * 1000);\n\n    // Monitor costs every hour\n    setInterval(async () => {\n      const hourlyCost = await this.apiUsageTracker.getHourlyCost();\n      if (hourlyCost > 10) { // $10/hour threshold\n        await this.triggerAlert('high_hourly_cost', { cost: hourlyCost });\n      }\n    }, 60 * 60 * 1000);\n\n    // Monitor performance every minute\n    setInterval(async () => {\n      const p95 = await this.performanceMonitor.getPercentile(95);\n      if (p95 > 5000) { // 5 second threshold\n        await this.triggerAlert('slow_p95_response', { p95 });\n      }\n    }, 60 * 1000);\n  }\n\n  // Private helper methods\n\n  private calculateAccuracy(prediction: PredictionResult, groundTruth: GroundTruth): number {\n    if (prediction.category === 'object_detection') {\n      return this.calculateIOUAccuracy(prediction.value, groundTruth.value);\n    } else if (prediction.category === 'classification') {\n      return prediction.value === groundTruth.value ? 1 : 0;\n    } else if (prediction.category === 'measurement') {\n      return 1 - Math.abs(prediction.value - groundTruth.value) / groundTruth.value;\n    }\n    return 0;\n  }\n\n  private calculateIOUAccuracy(predicted: any, actual: any): number {\n    // Intersection over Union calculation for object detection\n    // Simplified implementation\n    return 0.85; // Mock value\n  }\n\n  private getThreshold(operationType: string): number {\n    const thresholds: Record<string, number> = {\n      'image_analysis': 3000,\n      'text_generation': 2000,\n      'embedding': 500,\n      'classification': 1000,\n      'object_detection': 4000\n    };\n    return thresholds[operationType] || 2000;\n  }\n\n  private async triggerAlert(type: string, data: any): Promise<void> {\n    const alert: Alert = {\n      id: `alert_${Date.now()}`,\n      type,\n      severity: this.getAlertSeverity(type),\n      timestamp: new Date(),\n      data,\n      status: 'active'\n    };\n\n    await this.metrics.store('alerts', alert);\n    \n    // In production, would send notifications\n    console.warn(`Performance Alert: ${type}`, data);\n  }\n\n  private getAlertSeverity(type: string): 'low' | 'medium' | 'high' | 'critical' {\n    const severities: Record<string, Alert['severity']> = {\n      'accuracy_degradation': 'high',\n      'slow_response': 'medium',\n      'rate_limit_warning': 'high',\n      'cost_threshold_daily': 'critical',\n      'cost_threshold_monthly': 'high',\n      'low_accuracy': 'high',\n      'high_hourly_cost': 'medium',\n      'slow_p95_response': 'medium'\n    };\n    return severities[type] || 'medium';\n  }\n\n  private calculateAccuracySummary(metrics: AccuracyMetric[]): AccuracySummary {\n    const accuracies = metrics.filter(m => m.accuracy !== undefined).map(m => m.accuracy!);\n    return {\n      average: accuracies.reduce((a, b) => a + b, 0) / accuracies.length,\n      min: Math.min(...accuracies),\n      max: Math.max(...accuracies),\n      count: metrics.length,\n      correctPredictions: metrics.filter(m => m.isCorrect).length\n    };\n  }\n\n  private calculatePerformanceSummary(metrics: ResponseTimeMetric[]): PerformanceSummary {\n    const durations = metrics.map(m => m.duration);\n    return {\n      average: durations.reduce((a, b) => a + b, 0) / durations.length,\n      min: Math.min(...durations),\n      max: Math.max(...durations),\n      p50: this.calculatePercentile(durations, 50),\n      p95: this.calculatePercentile(durations, 95),\n      p99: this.calculatePercentile(durations, 99),\n      errorRate: metrics.filter(m => !m.success).length / metrics.length\n    };\n  }\n\n  private calculateUsageSummary(metrics: APIUsageMetric[]): UsageSummary {\n    return {\n      totalRequests: metrics.length,\n      totalTokens: metrics.reduce((sum, m) => sum + m.totalTokens, 0),\n      totalCost: metrics.reduce((sum, m) => sum + m.cost, 0),\n      averageTokensPerRequest: metrics.reduce((sum, m) => sum + m.totalTokens, 0) / metrics.length,\n      rateLimitHits: metrics.filter(m => m.rateLimitInfo?.remaining === 0).length\n    };\n  }\n\n  private calculateCostSummary(metrics: APIUsageMetric[]): CostSummary {\n    const costs = metrics.map(m => m.cost);\n    const costsByModel = this.calculateCostsByModel(metrics);\n    \n    return {\n      total: costs.reduce((a, b) => a + b, 0),\n      average: costs.reduce((a, b) => a + b, 0) / costs.length,\n      byModel: costsByModel,\n      projectedMonthly: this.projectMonthlyCost(metrics)\n    };\n  }\n\n  private analyzeTrend(metrics: any[], field: string): Trend {\n    if (metrics.length < 2) {\n      return { direction: 'stable', change: 0, confidence: 0 };\n    }\n\n    // Simple linear regression\n    const values = metrics.map(m => m[field]).filter(v => v !== undefined);\n    const n = values.length;\n    const sumX = values.reduce((_, __, i) => _ + i, 0);\n    const sumY = values.reduce((a, b) => a + b, 0);\n    const sumXY = values.reduce((sum, y, i) => sum + i * y, 0);\n    const sumX2 = values.reduce((_, __, i) => _ + i * i, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const change = slope * n;\n\n    return {\n      direction: slope > 0.01 ? 'improving' : slope < -0.01 ? 'declining' : 'stable',\n      change: Math.abs(change),\n      confidence: Math.min(0.95, n / 100) // Confidence based on sample size\n    };\n  }\n\n  private generateRecommendations(summary: any, trends: any): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n\n    // Accuracy recommendations\n    if (summary.accuracy.average < 0.8) {\n      recommendations.push({\n        type: 'model_improvement',\n        priority: 'high',\n        title: 'Low Accuracy Detected',\n        description: `Average accuracy is ${(summary.accuracy.average * 100).toFixed(1)}%, below target of 80%`,\n        actions: [\n          'Review and expand training data',\n          'Consider fine-tuning the model',\n          'Analyze error patterns for specific categories'\n        ]\n      });\n    }\n\n    // Performance recommendations\n    if (summary.performance.p95 > 3000) {\n      recommendations.push({\n        type: 'performance_optimization',\n        priority: 'medium',\n        title: 'Slow Response Times',\n        description: `95th percentile response time is ${summary.performance.p95}ms`,\n        actions: [\n          'Enable response caching',\n          'Optimize image sizes before processing',\n          'Consider using faster model variants'\n        ]\n      });\n    }\n\n    // Cost recommendations\n    if (summary.costs.projectedMonthly > 1500) {\n      recommendations.push({\n        type: 'cost_optimization',\n        priority: 'high',\n        title: 'High Projected Costs',\n        description: `Projected monthly cost is $${summary.costs.projectedMonthly.toFixed(2)}`,\n        actions: [\n          'Implement aggressive caching',\n          'Use smaller models where appropriate',\n          'Batch similar requests together'\n        ]\n      });\n    }\n\n    return recommendations;\n  }\n\n  private evaluateBenchmarks(summary: any): BenchmarkResult[] {\n    const benchmarks: BenchmarkConfig[] = [\n      { name: 'Accuracy Target', target: 0.85, actual: summary.accuracy.average, unit: '%', multiplier: 100 },\n      { name: 'Response Time (p95)', target: 2000, actual: summary.performance.p95, unit: 'ms' },\n      { name: 'Error Rate', target: 0.01, actual: summary.performance.errorRate, unit: '%', multiplier: 100 },\n      { name: 'Daily Cost', target: 50, actual: summary.costs.total, unit: '$' }\n    ];\n\n    return benchmarks.map(b => ({\n      name: b.name,\n      target: b.target,\n      actual: b.actual,\n      unit: b.unit,\n      status: b.actual <= b.target ? 'pass' : 'fail',\n      variance: ((b.actual - b.target) / b.target) * 100,\n      displayValue: b.multiplier ? (b.actual * b.multiplier).toFixed(1) : b.actual.toFixed(2)\n    }));\n  }\n\n  private calculatePercentile(values: number[], percentile: number): number {\n    if (values.length === 0) return 0;\n    \n    const sorted = [...values].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[Math.max(0, index)];\n  }\n\n  private groupByCategory(metrics: AccuracyMetric[]): Record<string, any> {\n    const groups: Record<string, AccuracyMetric[]> = {};\n    \n    metrics.forEach(m => {\n      if (!groups[m.category]) groups[m.category] = [];\n      groups[m.category].push(m);\n    });\n\n    return Object.entries(groups).reduce((acc, [category, metrics]) => {\n      acc[category] = this.calculateAccuracySummary(metrics);\n      return acc;\n    }, {} as Record<string, any>);\n  }\n\n  private groupByModel(metrics: any[]): Record<string, any> {\n    const groups: Record<string, any[]> = {};\n    \n    metrics.forEach(m => {\n      const model = m.modelVersion || m.model || 'unknown';\n      if (!groups[model]) groups[model] = [];\n      groups[model].push(m);\n    });\n\n    return groups;\n  }\n\n  private groupByOperation(metrics: ResponseTimeMetric[]): Record<string, any> {\n    const groups: Record<string, ResponseTimeMetric[]> = {};\n    \n    metrics.forEach(m => {\n      if (!groups[m.operation]) groups[m.operation] = [];\n      groups[m.operation].push(m);\n    });\n\n    return Object.entries(groups).reduce((acc, [operation, metrics]) => {\n      acc[operation] = this.calculatePerformanceSummary(metrics);\n      return acc;\n    }, {} as Record<string, any>);\n  }\n\n  private groupByEndpoint(metrics: APIUsageMetric[]): Record<string, any> {\n    const groups: Record<string, APIUsageMetric[]> = {};\n    \n    metrics.forEach(m => {\n      if (!groups[m.endpoint]) groups[m.endpoint] = [];\n      groups[m.endpoint].push(m);\n    });\n\n    return Object.entries(groups).reduce((acc, [endpoint, metrics]) => {\n      acc[endpoint] = this.calculateUsageSummary(metrics);\n      return acc;\n    }, {} as Record<string, any>);\n  }\n\n  private analyzeErrors(metrics: AccuracyMetric[]): ErrorAnalysis {\n    const errors = metrics.filter(m => !m.isCorrect);\n    const errorsByCategory: Record<string, number> = {};\n    \n    errors.forEach(e => {\n      errorsByCategory[e.category] = (errorsByCategory[e.category] || 0) + 1;\n    });\n\n    return {\n      totalErrors: errors.length,\n      errorRate: errors.length / metrics.length,\n      byCategory: errorsByCategory,\n      commonPatterns: this.findCommonErrorPatterns(errors)\n    };\n  }\n\n  private findCommonErrorPatterns(errors: AccuracyMetric[]): string[] {\n    // Simplified pattern detection\n    const patterns: string[] = [];\n    \n    const lowConfidenceErrors = errors.filter(e => e.confidence < 0.5);\n    if (lowConfidenceErrors.length > errors.length * 0.3) {\n      patterns.push('High error rate for low-confidence predictions');\n    }\n\n    return patterns;\n  }\n\n  private findSlowestOperations(metrics: ResponseTimeMetric[]): SlowOperation[] {\n    return metrics\n      .sort((a, b) => b.duration - a.duration)\n      .slice(0, 10)\n      .map(m => ({\n        operation: m.operation,\n        duration: m.duration,\n        timestamp: m.timestamp,\n        metadata: m.metadata\n      }));\n  }\n\n  private analyzeRateLimits(metrics: APIUsageMetric[]): RateLimitAnalysis {\n    const withRateLimits = metrics.filter(m => m.rateLimitInfo);\n    \n    if (withRateLimits.length === 0) {\n      return { status: 'healthy', utilizationPercent: 0 };\n    }\n\n    const latest = withRateLimits[withRateLimits.length - 1];\n    const { remaining, limit } = latest.rateLimitInfo!;\n    const utilizationPercent = ((limit - remaining) / limit) * 100;\n\n    return {\n      status: utilizationPercent > 80 ? 'warning' : 'healthy',\n      utilizationPercent,\n      remaining,\n      limit,\n      resetAt: latest.rateLimitInfo!.reset\n    };\n  }\n\n  private calculateCostsByModel(metrics: APIUsageMetric[]): Record<string, number> {\n    const costs: Record<string, number> = {};\n    \n    metrics.forEach(m => {\n      costs[m.model] = (costs[m.model] || 0) + m.cost;\n    });\n\n    return costs;\n  }\n\n  private calculateDailyCosts(metrics: APIUsageMetric[]): DailyCost[] {\n    const dailyCosts: Record<string, number> = {};\n    \n    metrics.forEach(m => {\n      const date = m.timestamp.toISOString().split('T')[0];\n      dailyCosts[date] = (dailyCosts[date] || 0) + m.cost;\n    });\n\n    return Object.entries(dailyCosts).map(([date, cost]) => ({ date, cost }));\n  }\n\n  private projectFutureCosts(metrics: APIUsageMetric[]): CostProjection {\n    const recentDays = 7;\n    const now = Date.now();\n    const recentMetrics = metrics.filter(m => \n      now - m.timestamp.getTime() < recentDays * 24 * 60 * 60 * 1000\n    );\n\n    const dailyAverage = recentMetrics.reduce((sum, m) => sum + m.cost, 0) / recentDays;\n\n    return {\n      daily: dailyAverage,\n      weekly: dailyAverage * 7,\n      monthly: dailyAverage * 30,\n      confidence: Math.min(0.9, recentMetrics.length / 100)\n    };\n  }\n\n  private projectMonthlyCost(metrics: APIUsageMetric[]): number {\n    return this.projectFutureCosts(metrics).monthly;\n  }\n\n  private async checkAPIHealth(): Promise<APIHealth> {\n    // Check various health indicators\n    const endpoints = ['openai', 'anthropic', 'custom'];\n    const health: APIHealth = {\n      status: 'healthy',\n      endpoints: {}\n    };\n\n    for (const endpoint of endpoints) {\n      // Mock health check\n      health.endpoints[endpoint] = {\n        status: 'operational',\n        latency: Math.random() * 100 + 50,\n        lastChecked: new Date()\n      };\n    }\n\n    return health;\n  }\n\n  private async getActiveAlerts(): Promise<Alert[]> {\n    const alerts = await this.metrics.query('alerts', \n      new Date(Date.now() - 24 * 60 * 60 * 1000), \n      new Date()\n    );\n\n    return alerts.filter((a: Alert) => a.status === 'active');\n  }\n}\n\n// Supporting classes\n\nclass MetricsStore {\n  private data: Map<string, any[]> = new Map();\n\n  async store(type: string, metric: any): Promise<void> {\n    if (!this.data.has(type)) {\n      this.data.set(type, []);\n    }\n    this.data.get(type)!.push(metric);\n\n    // In production, would persist to database\n  }\n\n  async query(type: string, start: Date, end: Date): Promise<any[]> {\n    const metrics = this.data.get(type) || [];\n    return metrics.filter(m => \n      m.timestamp >= start && m.timestamp <= end\n    );\n  }\n}\n\nclass APIUsageTracker {\n  private recentUsage: APIUsageMetric[] = [];\n\n  recordUsage(metric: APIUsageMetric): void {\n    this.recentUsage.push(metric);\n    // Keep only last 1000 entries\n    if (this.recentUsage.length > 1000) {\n      this.recentUsage.shift();\n    }\n  }\n\n  async getDailyCost(): Promise<number> {\n    const dayAgo = Date.now() - 24 * 60 * 60 * 1000;\n    return this.recentUsage\n      .filter(m => m.timestamp.getTime() > dayAgo)\n      .reduce((sum, m) => sum + m.cost, 0);\n  }\n\n  async getMonthlyCost(): Promise<number> {\n    const monthAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    return this.recentUsage\n      .filter(m => m.timestamp.getTime() > monthAgo)\n      .reduce((sum, m) => sum + m.cost, 0);\n  }\n\n  async getHourlyCost(): Promise<number> {\n    const hourAgo = Date.now() - 60 * 60 * 1000;\n    return this.recentUsage\n      .filter(m => m.timestamp.getTime() > hourAgo)\n      .reduce((sum, m) => sum + m.cost, 0);\n  }\n\n  async getRequestRate(): Promise<number> {\n    const minuteAgo = Date.now() - 60 * 1000;\n    const recentRequests = this.recentUsage.filter(m => m.timestamp.getTime() > minuteAgo);\n    return recentRequests.length;\n  }\n\n  async getTokenRate(): Promise<number> {\n    const minuteAgo = Date.now() - 60 * 1000;\n    return this.recentUsage\n      .filter(m => m.timestamp.getTime() > minuteAgo)\n      .reduce((sum, m) => sum + m.totalTokens, 0);\n  }\n\n  async getRemainingQuota(): Promise<RemainingQuota> {\n    const latest = this.recentUsage[this.recentUsage.length - 1];\n    if (!latest?.rateLimitInfo) {\n      return { requests: -1, tokens: -1 };\n    }\n\n    return {\n      requests: latest.rateLimitInfo.remaining,\n      tokens: -1 // Would need token limit info\n    };\n  }\n}\n\nclass PerformanceMonitor {\n  private responseTimes: ResponseTimeMetric[] = [];\n\n  recordResponseTime(metric: ResponseTimeMetric): void {\n    this.responseTimes.push(metric);\n    // Keep only last 1000 entries\n    if (this.responseTimes.length > 1000) {\n      this.responseTimes.shift();\n    }\n  }\n\n  async getAverageResponseTime(since: Date): Promise<number> {\n    const recent = this.responseTimes.filter(m => m.timestamp > since);\n    if (recent.length === 0) return 0;\n    return recent.reduce((sum, m) => sum + m.duration, 0) / recent.length;\n  }\n\n  async getPercentile(percentile: number): Promise<number> {\n    if (this.responseTimes.length === 0) return 0;\n    \n    const durations = this.responseTimes.map(m => m.duration).sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * durations.length) - 1;\n    return durations[Math.max(0, index)];\n  }\n\n  async getPercentiles(): Promise<Record<string, number>> {\n    return {\n      p50: await this.getPercentile(50),\n      p75: await this.getPercentile(75),\n      p90: await this.getPercentile(90),\n      p95: await this.getPercentile(95),\n      p99: await this.getPercentile(99)\n    };\n  }\n\n  async getSlowOperations(): Promise<string[]> {\n    const threshold = await this.getPercentile(90);\n    return [...new Set(\n      this.responseTimes\n        .filter(m => m.duration > threshold)\n        .map(m => m.operation)\n    )];\n  }\n\n  async getErrorRate(): Promise<number> {\n    if (this.responseTimes.length === 0) return 0;\n    const errors = this.responseTimes.filter(m => !m.success).length;\n    return errors / this.responseTimes.length;\n  }\n}\n\nclass AccuracyTracker {\n  private accuracyMetrics: AccuracyMetric[] = [];\n\n  addMetric(metric: AccuracyMetric): void {\n    this.accuracyMetrics.push(metric);\n    // Keep only last 1000 entries\n    if (this.accuracyMetrics.length > 1000) {\n      this.accuracyMetrics.shift();\n    }\n  }\n\n  async getRecentAccuracy(): Promise<number> {\n    const recent = this.accuracyMetrics.slice(-100);\n    const withAccuracy = recent.filter(m => m.accuracy !== undefined);\n    if (withAccuracy.length === 0) return 0;\n    return withAccuracy.reduce((sum, m) => sum + m.accuracy!, 0) / withAccuracy.length;\n  }\n\n  async getTrend(): Promise<'improving' | 'declining' | 'stable'> {\n    if (this.accuracyMetrics.length < 20) return 'stable';\n    \n    const firstHalf = this.accuracyMetrics.slice(0, this.accuracyMetrics.length / 2);\n    const secondHalf = this.accuracyMetrics.slice(this.accuracyMetrics.length / 2);\n    \n    const firstAvg = this.calculateAverage(firstHalf);\n    const secondAvg = this.calculateAverage(secondHalf);\n    \n    const diff = secondAvg - firstAvg;\n    if (diff > 0.05) return 'improving';\n    if (diff < -0.05) return 'declining';\n    return 'stable';\n  }\n\n  async getByCategory(): Promise<Record<string, number>> {\n    const byCategory: Record<string, AccuracyMetric[]> = {};\n    \n    this.accuracyMetrics.forEach(m => {\n      if (!byCategory[m.category]) byCategory[m.category] = [];\n      byCategory[m.category].push(m);\n    });\n\n    const result: Record<string, number> = {};\n    for (const [category, metrics] of Object.entries(byCategory)) {\n      result[category] = this.calculateAverage(metrics);\n    }\n\n    return result;\n  }\n\n  private calculateAverage(metrics: AccuracyMetric[]): number {\n    const withAccuracy = metrics.filter(m => m.accuracy !== undefined);\n    if (withAccuracy.length === 0) return 0;\n    return withAccuracy.reduce((sum, m) => sum + m.accuracy!, 0) / withAccuracy.length;\n  }\n}\n\nclass CostCalculator {\n  private pricing: Record<string, PricingModel> = {\n    'gpt-4-vision': {\n      input: 0.01 / 1000,  // $0.01 per 1K tokens\n      output: 0.03 / 1000, // $0.03 per 1K tokens\n      image: 0.00765       // Per image\n    },\n    'gpt-3.5-turbo': {\n      input: 0.0005 / 1000,\n      output: 0.0015 / 1000\n    },\n    'text-embedding-ada-002': {\n      input: 0.0001 / 1000\n    }\n  };\n\n  calculate(apiCall: APICall, response: APIResponse): number {\n    const pricing = this.pricing[apiCall.model];\n    if (!pricing) return 0;\n\n    let cost = 0;\n    \n    if (apiCall.inputTokens && pricing.input) {\n      cost += apiCall.inputTokens * pricing.input;\n    }\n    \n    if (response.outputTokens && pricing.output) {\n      cost += response.outputTokens * pricing.output;\n    }\n    \n    if (apiCall.images && pricing.image) {\n      cost += apiCall.images * pricing.image;\n    }\n\n    return cost;\n  }\n}\n\n// Types\n\ninterface PredictionResult {\n  id: string;\n  modelVersion: string;\n  category: string;\n  confidence: number;\n  value: any;\n  processingTime: number;\n  inputSize: number;\n  features: string[];\n}\n\ninterface GroundTruth {\n  value: any;\n  source: string;\n}\n\ninterface UserFeedback {\n  rating: number;\n  wasHelpful: boolean;\n  correctedValue?: any;\n}\n\ninterface AIOperation {\n  type: string;\n  success: boolean;\n  error?: string;\n  modelUsed: string;\n  inputTokens?: number;\n  outputTokens?: number;\n  cached?: boolean;\n}\n\ninterface OperationMetadata {\n  [key: string]: any;\n}\n\ninterface APICall {\n  endpoint: string;\n  model: string;\n  inputTokens?: number;\n  images?: number;\n}\n\ninterface APIResponse {\n  outputTokens?: number;\n  duration: number;\n  statusCode: number;\n  headers?: Record<string, string>;\n  error?: string;\n}\n\ninterface AccuracyMetric {\n  id: string;\n  timestamp: Date;\n  predictionId: string;\n  modelVersion: string;\n  category: string;\n  confidence: number;\n  accuracy?: number;\n  isCorrect?: boolean;\n  feedback?: {\n    rating: number;\n    wasHelpful: boolean;\n    correctedValue?: any;\n  };\n  metadata: any;\n}\n\ninterface ResponseTimeMetric {\n  id: string;\n  timestamp: Date;\n  operation: string;\n  duration: number;\n  success: boolean;\n  error?: string;\n  metadata: any;\n}\n\ninterface APIUsageMetric {\n  id: string;\n  timestamp: Date;\n  endpoint: string;\n  model: string;\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n  cost: number;\n  duration: number;\n  statusCode: number;\n  rateLimitInfo?: {\n    remaining: number;\n    limit: number;\n    reset: Date;\n  };\n  error?: string;\n}\n\ninterface ReportOptions {\n  includeDetails?: boolean;\n  format?: 'json' | 'html' | 'pdf';\n}\n\ninterface PerformanceReport {\n  id: string;\n  generatedAt: Date;\n  period: { start: Date; end: Date };\n  summary: any;\n  trends: any;\n  recommendations: Recommendation[];\n  benchmarks: BenchmarkResult[];\n  details: any;\n  alerts: Alert[];\n}\n\ninterface Recommendation {\n  type: string;\n  priority: 'low' | 'medium' | 'high';\n  title: string;\n  description: string;\n  actions: string[];\n}\n\ninterface BenchmarkConfig {\n  name: string;\n  target: number;\n  actual: number;\n  unit: string;\n  multiplier?: number;\n}\n\ninterface BenchmarkResult {\n  name: string;\n  target: number;\n  actual: number;\n  unit: string;\n  status: 'pass' | 'fail';\n  variance: number;\n  displayValue: string;\n}\n\ninterface Alert {\n  id: string;\n  type: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  timestamp: Date;\n  data: any;\n  status: 'active' | 'resolved';\n}\n\ninterface RealTimeMetrics {\n  timestamp: Date;\n  accuracy: {\n    current: number;\n    trend: 'improving' | 'declining' | 'stable';\n    byCategory: Record<string, number>;\n  };\n  performance: {\n    avgResponseTime: number;\n    p95ResponseTime: number;\n    slowOperations: string[];\n    errorRate: number;\n  };\n  usage: {\n    requestsPerMinute: number;\n    tokensPerMinute: number;\n    costPerHour: number;\n    remainingQuota: RemainingQuota;\n  };\n  health: APIHealth;\n  alerts: Alert[];\n}\n\ninterface RemainingQuota {\n  requests: number;\n  tokens: number;\n}\n\ninterface APIHealth {\n  status: 'healthy' | 'degraded' | 'down';\n  endpoints: Record<string, {\n    status: 'operational' | 'degraded' | 'down';\n    latency: number;\n    lastChecked: Date;\n  }>;\n}\n\ninterface AccuracySummary {\n  average: number;\n  min: number;\n  max: number;\n  count: number;\n  correctPredictions: number;\n}\n\ninterface PerformanceSummary {\n  average: number;\n  min: number;\n  max: number;\n  p50: number;\n  p95: number;\n  p99: number;\n  errorRate: number;\n}\n\ninterface UsageSummary {\n  totalRequests: number;\n  totalTokens: number;\n  totalCost: number;\n  averageTokensPerRequest: number;\n  rateLimitHits: number;\n}\n\ninterface CostSummary {\n  total: number;\n  average: number;\n  byModel: Record<string, number>;\n  projectedMonthly: number;\n}\n\ninterface Trend {\n  direction: 'improving' | 'declining' | 'stable';\n  change: number;\n  confidence: number;\n}\n\ninterface ErrorAnalysis {\n  totalErrors: number;\n  errorRate: number;\n  byCategory: Record<string, number>;\n  commonPatterns: string[];\n}\n\ninterface SlowOperation {\n  operation: string;\n  duration: number;\n  timestamp: Date;\n  metadata: any;\n}\n\ninterface RateLimitAnalysis {\n  status: 'healthy' | 'warning' | 'critical';\n  utilizationPercent: number;\n  remaining?: number;\n  limit?: number;\n  resetAt?: Date;\n}\n\ninterface DailyCost {\n  date: string;\n  cost: number;\n}\n\ninterface CostProjection {\n  daily: number;\n  weekly: number;\n  monthly: number;\n  confidence: number;\n}\n\ninterface PricingModel {\n  input?: number;\n  output?: number;\n  image?: number;\n}\n\n// Export factory function\nexport const createAIMetricsCollector = (): AIMetricsCollector => {\n  return new AIMetricsCollector();\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/monitoring/error-reporter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[379,382],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[379,382],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[559,562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[559,562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[814,817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[814,817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2339,2342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2339,2342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3322,3325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3322,3325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5188,5191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5188,5191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8118,8121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8118,8121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8142,8145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8142,8145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8326,8329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8326,8329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":441,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11272,11275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11272,11275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":441,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":441,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11278,11281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11278,11281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":446,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11403,11406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11403,11406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":629,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":629,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16295,16298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16295,16298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":631,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":631,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16374,16377],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16374,16377],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":641,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16628,16631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16628,16631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":643,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":643,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16711,16714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16711,16714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":664,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":664,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17155,17158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17155,17158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { env } from '../config/environment';\nimport { supabase } from '../supabase';\n\nexport interface ErrorReport {\n  id: string;\n  timestamp: string;\n  message: string;\n  stack?: string;\n  type: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  category: string;\n  url: string;\n  userAgent: string;\n  userId?: string;\n  sessionId: string;\n  context: Record<string, any>;\n  breadcrumbs: Breadcrumb[];\n  fingerprint: string;\n  groupingKey: string;\n  environment: string;\n  release?: string;\n  tags: Record<string, string>;\n  extra: Record<string, any>;\n}\n\nexport interface Breadcrumb {\n  timestamp: string;\n  type: 'navigation' | 'click' | 'console' | 'xhr' | 'fetch' | 'error' | 'custom';\n  category: string;\n  message: string;\n  level: 'debug' | 'info' | 'warning' | 'error';\n  data?: Record<string, any>;\n}\n\nexport interface UserContext {\n  id?: string;\n  email?: string;\n  username?: string;\n  role?: string;\n  subscription?: string;\n}\n\nexport interface ErrorReporterConfig {\n  maxBreadcrumbs?: number;\n  maxQueueSize?: number;\n  flushInterval?: number;\n  enableConsoleCapture?: boolean;\n  enableNetworkCapture?: boolean;\n  enableClickCapture?: boolean;\n  enableNavigationCapture?: boolean;\n  sensitiveDataPatterns?: RegExp[];\n  ignoredErrors?: Array<string | RegExp>;\n  beforeSend?: (report: ErrorReport) => ErrorReport | null;\n}\n\nconst DEFAULT_CONFIG: ErrorReporterConfig = {\n  maxBreadcrumbs: 50,\n  maxQueueSize: 10,\n  flushInterval: 5000,\n  enableConsoleCapture: true,\n  enableNetworkCapture: true,\n  enableClickCapture: true,\n  enableNavigationCapture: true,\n  sensitiveDataPatterns: [\n    /password/i,\n    /secret/i,\n    /token/i,\n    /api[_-]?key/i,\n    /authorization/i,\n    /credit[_-]?card/i,\n    /ssn/i,\n  ],\n  ignoredErrors: [\n    'ResizeObserver loop limit exceeded',\n    'ResizeObserver loop completed with undelivered notifications',\n    'Non-Error promise rejection captured',\n    /^Script error/,\n  ],\n};\n\nexport class ErrorReporter {\n  private static instance: ErrorReporter;\n  private config: ErrorReporterConfig;\n  private breadcrumbs: Breadcrumb[] = [];\n  private errorQueue: ErrorReport[] = [];\n  private sessionId: string;\n  private userContext: UserContext | null = null;\n  private flushTimer: NodeJS.Timeout | null = null;\n  private isInitialized = false;\n  private originalConsole: Record<string, any> = {};\n  private originalFetch: typeof fetch;\n\n  private constructor() {\n    this.config = DEFAULT_CONFIG;\n    this.sessionId = this.generateSessionId();\n    this.originalFetch = window.fetch;\n  }\n\n  static getInstance(): ErrorReporter {\n    if (!ErrorReporter.instance) {\n      ErrorReporter.instance = new ErrorReporter();\n    }\n    return ErrorReporter.instance;\n  }\n\n  /**\n   * Initialize error reporter with configuration\n   */\n  initialize(config?: Partial<ErrorReporterConfig>) {\n    if (this.isInitialized) return;\n\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.setupGlobalHandlers();\n    this.setupBreadcrumbCapture();\n    this.startFlushTimer();\n    this.isInitialized = true;\n\n    // Log initialization in development\n    if (env.isDevelopment()) {\n      console.log('[ErrorReporter] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Report an error with context\n   */\n  reportError(\n    error: Error | string,\n    context?: Record<string, any>,\n    severity: ErrorReport['severity'] = 'medium'\n  ): string {\n    // Create error object if string provided\n    const errorObj = typeof error === 'string' ? new Error(error) : error;\n    \n    // Check if error should be ignored\n    if (this.shouldIgnoreError(errorObj)) {\n      return '';\n    }\n\n    const report = this.createErrorReport(errorObj, context, severity);\n    \n    // Apply beforeSend hook\n    if (this.config.beforeSend) {\n      const modifiedReport = this.config.beforeSend(report);\n      if (!modifiedReport) return '';\n    }\n\n    // Add to queue\n    this.errorQueue.push(report);\n\n    // Flush immediately for critical errors\n    if (severity === 'critical') {\n      this.flush();\n    } else if (this.errorQueue.length >= (this.config.maxQueueSize || 10)) {\n      this.flush();\n    }\n\n    return report.id;\n  }\n\n  /**\n   * Set user context for error reports\n   */\n  setUser(user: UserContext | null) {\n    this.userContext = user;\n    \n    // Add breadcrumb for user change\n    if (user) {\n      this.addBreadcrumb({\n        type: 'custom',\n        category: 'auth',\n        message: `User logged in: ${user.email || user.id}`,\n        level: 'info',\n      });\n    } else {\n      this.addBreadcrumb({\n        type: 'custom',\n        category: 'auth',\n        message: 'User logged out',\n        level: 'info',\n      });\n    }\n  }\n\n  /**\n   * Add a custom breadcrumb\n   */\n  addBreadcrumb(breadcrumb: Omit<Breadcrumb, 'timestamp'>) {\n    const crumb: Breadcrumb = {\n      ...breadcrumb,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.breadcrumbs.push(crumb);\n\n    // Limit breadcrumbs\n    if (this.breadcrumbs.length > (this.config.maxBreadcrumbs || 50)) {\n      this.breadcrumbs.shift();\n    }\n  }\n\n  /**\n   * Create error report from error object\n   */\n  private createErrorReport(\n    error: Error,\n    context?: Record<string, any>,\n    severity: ErrorReport['severity'] = 'medium'\n  ): ErrorReport {\n    const fingerprint = this.generateFingerprint(error);\n    const groupingKey = this.generateGroupingKey(error);\n\n    const report: ErrorReport = {\n      id: this.generateId(),\n      timestamp: new Date().toISOString(),\n      message: error.message,\n      stack: error.stack,\n      type: error.name || 'Error',\n      severity,\n      category: context?.category || 'general',\n      url: window.location.href,\n      userAgent: navigator.userAgent,\n      userId: this.userContext?.id,\n      sessionId: this.sessionId,\n      context: this.sanitizeData({\n        ...context,\n        page: window.location.pathname,\n        referrer: document.referrer,\n        viewport: {\n          width: window.innerWidth,\n          height: window.innerHeight,\n        },\n        screen: {\n          width: window.screen.width,\n          height: window.screen.height,\n        },\n      }),\n      breadcrumbs: [...this.breadcrumbs],\n      fingerprint,\n      groupingKey,\n      environment: env.getEnvironment(),\n      release: env.get('APP_VERSION'),\n      tags: {\n        browser: this.getBrowserName(),\n        os: this.getOSName(),\n        device: this.getDeviceType(),\n      },\n      extra: this.sanitizeData({\n        memory: this.getMemoryInfo(),\n        connection: this.getConnectionInfo(),\n        ...context?.extra,\n      }),\n    };\n\n    return report;\n  }\n\n  /**\n   * Setup global error handlers\n   */\n  private setupGlobalHandlers() {\n    // Window error handler\n    window.addEventListener('error', (event) => {\n      this.reportError(event.error || new Error(event.message), {\n        type: 'unhandled_error',\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n      }, 'high');\n    });\n\n    // Promise rejection handler\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason instanceof Error \n        ? event.reason \n        : new Error(String(event.reason));\n      \n      this.reportError(error, {\n        type: 'unhandled_promise_rejection',\n        promise: event.promise,\n      }, 'high');\n    });\n  }\n\n  /**\n   * Setup breadcrumb capture\n   */\n  private setupBreadcrumbCapture() {\n    // Console capture\n    if (this.config.enableConsoleCapture) {\n      this.wrapConsole();\n    }\n\n    // Network capture\n    if (this.config.enableNetworkCapture) {\n      this.wrapFetch();\n    }\n\n    // Click capture\n    if (this.config.enableClickCapture) {\n      document.addEventListener('click', this.handleClick.bind(this), true);\n    }\n\n    // Navigation capture\n    if (this.config.enableNavigationCapture) {\n      this.wrapHistory();\n    }\n  }\n\n  /**\n   * Wrap console methods for breadcrumb capture\n   */\n  private wrapConsole() {\n    ['log', 'info', 'warn', 'error'].forEach((level) => {\n      this.originalConsole[level] = console[level as keyof Console];\n      \n      (console as any)[level] = (...args: any[]) => {\n        this.addBreadcrumb({\n          type: 'console',\n          category: 'console',\n          message: args.map(arg => String(arg)).join(' '),\n          level: level as any,\n          data: { arguments: args },\n        });\n\n        this.originalConsole[level].apply(console, args);\n      };\n    });\n  }\n\n  /**\n   * Wrap fetch for network breadcrumbs\n   */\n  private wrapFetch() {\n    window.fetch = async (...args) => {\n      const [input, init] = args;\n      const url = typeof input === 'string' ? input : input.url;\n      const method = init?.method || 'GET';\n\n      const startTime = Date.now();\n\n      try {\n        const response = await this.originalFetch.apply(window, args);\n        \n        this.addBreadcrumb({\n          type: 'fetch',\n          category: 'fetch',\n          message: `${method} ${url}`,\n          level: response.ok ? 'info' : 'error',\n          data: {\n            method,\n            url,\n            status: response.status,\n            duration: Date.now() - startTime,\n          },\n        });\n\n        return response;\n      } catch (error) {\n        this.addBreadcrumb({\n          type: 'fetch',\n          category: 'fetch',\n          message: `${method} ${url} failed`,\n          level: 'error',\n          data: {\n            method,\n            url,\n            error: error instanceof Error ? error.message : String(error),\n            duration: Date.now() - startTime,\n          },\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  /**\n   * Handle click events for breadcrumbs\n   */\n  private handleClick(event: MouseEvent) {\n    const target = event.target as HTMLElement;\n    const selector = this.getElementSelector(target);\n\n    this.addBreadcrumb({\n      type: 'click',\n      category: 'ui',\n      message: `Click on ${selector}`,\n      level: 'info',\n      data: {\n        selector,\n        text: target.textContent?.substring(0, 100),\n        tagName: target.tagName,\n      },\n    });\n  }\n\n  /**\n   * Wrap history API for navigation breadcrumbs\n   */\n  private wrapHistory() {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      this.addBreadcrumb({\n        type: 'navigation',\n        category: 'navigation',\n        message: `Navigation to ${args[2]}`,\n        level: 'info',\n        data: { to: args[2] },\n      });\n      return originalPushState.apply(history, args);\n    };\n\n    history.replaceState = (...args) => {\n      this.addBreadcrumb({\n        type: 'navigation',\n        category: 'navigation',\n        message: `Navigation to ${args[2]}`,\n        level: 'info',\n        data: { to: args[2] },\n      });\n      return originalReplaceState.apply(history, args);\n    };\n\n    window.addEventListener('popstate', () => {\n      this.addBreadcrumb({\n        type: 'navigation',\n        category: 'navigation',\n        message: `Navigation to ${window.location.pathname}`,\n        level: 'info',\n        data: { to: window.location.pathname },\n      });\n    });\n  }\n\n  /**\n   * Sanitize data to remove sensitive information\n   */\n  private sanitizeData(data: any): any {\n    if (!data) return data;\n\n    const sanitized = JSON.parse(JSON.stringify(data));\n\n    const sanitizeObject = (obj: any) => {\n      Object.keys(obj).forEach(key => {\n        // Check if key matches sensitive pattern\n        const isSensitive = this.config.sensitiveDataPatterns?.some(\n          pattern => pattern.test(key)\n        );\n\n        if (isSensitive) {\n          obj[key] = '[REDACTED]';\n        } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n          sanitizeObject(obj[key]);\n        }\n      });\n    };\n\n    sanitizeObject(sanitized);\n    return sanitized;\n  }\n\n  /**\n   * Check if error should be ignored\n   */\n  private shouldIgnoreError(error: Error): boolean {\n    if (!this.config.ignoredErrors) return false;\n\n    return this.config.ignoredErrors.some(pattern => {\n      if (typeof pattern === 'string') {\n        return error.message.includes(pattern);\n      }\n      return pattern.test(error.message);\n    });\n  }\n\n  /**\n   * Flush error queue to monitoring service\n   */\n  private async flush() {\n    if (this.errorQueue.length === 0) return;\n\n    const errors = [...this.errorQueue];\n    this.errorQueue = [];\n\n    try {\n      // In production, send to monitoring service\n      if (env.isProduction() && env.monitoring.sentryDsn) {\n        // Send to Sentry or similar service\n        await this.sendToMonitoringService(errors);\n      }\n\n      // Also log to Supabase for internal tracking\n      await this.logToSupabase(errors);\n    } catch (error) {\n      console.error('[ErrorReporter] Failed to flush errors:', error);\n      // Re-add errors to queue if flush failed\n      this.errorQueue.unshift(...errors);\n    }\n  }\n\n  /**\n   * Send errors to external monitoring service\n   */\n  private async sendToMonitoringService(errors: ErrorReport[]) {\n    // Implementation would depend on the monitoring service used\n    // Example for Sentry:\n    /*\n    if (window.Sentry) {\n      errors.forEach(error => {\n        window.Sentry.captureException(new Error(error.message), {\n          contexts: {\n            report: error,\n          },\n          tags: error.tags,\n          extra: error.extra,\n          fingerprint: [error.fingerprint],\n        });\n      });\n    }\n    */\n  }\n\n  /**\n   * Log errors to Supabase\n   */\n  private async logToSupabase(errors: ErrorReport[]) {\n    if (!env.validateSupabaseConfig()) return;\n\n    const { error } = await supabase\n      .from('error_logs')\n      .insert(errors.map(err => ({\n        ...err,\n        user_id: err.userId,\n        session_id: err.sessionId,\n      })));\n\n    if (error) {\n      console.error('[ErrorReporter] Failed to log to Supabase:', error);\n    }\n  }\n\n  /**\n   * Start flush timer\n   */\n  private startFlushTimer() {\n    if (this.flushTimer) return;\n\n    this.flushTimer = setInterval(() => {\n      this.flush();\n    }, this.config.flushInterval || 5000);\n  }\n\n  /**\n   * Utility methods\n   */\n  private generateId(): string {\n    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateFingerprint(error: Error): string {\n    const parts = [\n      error.name,\n      error.message.substring(0, 100),\n      error.stack?.split('\\n')[1]?.trim() || '',\n    ];\n    return parts.join('|');\n  }\n\n  private generateGroupingKey(error: Error): string {\n    // Group similar errors together\n    const stackLines = error.stack?.split('\\n') || [];\n    const relevantLine = stackLines.find(line => line.includes('at ')) || '';\n    return `${error.name}-${relevantLine}`;\n  }\n\n  private getElementSelector(element: HTMLElement): string {\n    const parts: string[] = [];\n    let current: HTMLElement | null = element;\n\n    while (current && parts.length < 5) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      } else if (current.className) {\n        selector += `.${current.className.split(' ').join('.')}`;\n      }\n\n      parts.unshift(selector);\n      current = current.parentElement;\n    }\n\n    return parts.join(' > ');\n  }\n\n  private getBrowserName(): string {\n    const ua = navigator.userAgent;\n    if (ua.includes('Chrome')) return 'Chrome';\n    if (ua.includes('Firefox')) return 'Firefox';\n    if (ua.includes('Safari')) return 'Safari';\n    if (ua.includes('Edge')) return 'Edge';\n    return 'Unknown';\n  }\n\n  private getOSName(): string {\n    const ua = navigator.userAgent;\n    if (ua.includes('Windows')) return 'Windows';\n    if (ua.includes('Mac')) return 'macOS';\n    if (ua.includes('Linux')) return 'Linux';\n    if (ua.includes('Android')) return 'Android';\n    if (ua.includes('iOS')) return 'iOS';\n    return 'Unknown';\n  }\n\n  private getDeviceType(): string {\n    const ua = navigator.userAgent;\n    if (ua.includes('Mobile')) return 'Mobile';\n    if (ua.includes('Tablet')) return 'Tablet';\n    return 'Desktop';\n  }\n\n  private getMemoryInfo(): Record<string, any> {\n    if ('memory' in performance) {\n      const memory = (performance as any).memory;\n      return {\n        usedJSHeapSize: memory.usedJSHeapSize,\n        totalJSHeapSize: memory.totalJSHeapSize,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit,\n      };\n    }\n    return {};\n  }\n\n  private getConnectionInfo(): Record<string, any> {\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      return {\n        effectiveType: connection.effectiveType,\n        downlink: connection.downlink,\n        rtt: connection.rtt,\n      };\n    }\n    return {};\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy() {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    // Restore original methods\n    Object.keys(this.originalConsole).forEach(level => {\n      (console as any)[level] = this.originalConsole[level];\n    });\n\n    window.fetch = this.originalFetch;\n\n    // Flush remaining errors\n    this.flush();\n  }\n}\n\n// Export singleton instance\nexport const errorReporter = ErrorReporter.getInstance();\n\n// Initialize on import if in browser\nif (typeof window !== 'undefined') {\n  errorReporter.initialize();\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/monitoring/health-check.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[830,833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[830,833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1547,1550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1547,1550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":465,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12345,12348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12345,12348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":465,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12355,12358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12355,12358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":497,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":497,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13362,13365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13362,13365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":498,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13410,13413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13410,13413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":498,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13420,13423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13420,13423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":498,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13431,13434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13431,13434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Health Check Service for STR Certified\n// Provides health endpoint and system status monitoring\n\nimport { createClient } from '@supabase/supabase-js';\nimport { env } from '../config/environment';\n\nexport interface HealthCheckResult {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  version: string;\n  uptime: number;\n  services: {\n    database: ServiceStatus;\n    ai: ServiceStatus;\n    storage: ServiceStatus;\n    cache: ServiceStatus;\n  };\n  metrics: {\n    memory: MemoryMetrics;\n    performance: PerformanceMetrics;\n    errors: ErrorMetrics;\n  };\n  environment: {\n    node: string;\n    deployment: string;\n    region?: string;\n  };\n}\n\ninterface ServiceStatus {\n  name: string;\n  status: 'up' | 'down' | 'degraded';\n  latency?: number;\n  lastCheck: string;\n  error?: string;\n  details?: Record<string, any>;\n}\n\ninterface MemoryMetrics {\n  used: number;\n  total: number;\n  percentage: number;\n  rss: number;\n  heapUsed: number;\n  heapTotal: number;\n}\n\ninterface PerformanceMetrics {\n  cpuUsage: number;\n  loadAverage: number[];\n  responseTime: number;\n  requestsPerSecond: number;\n}\n\ninterface ErrorMetrics {\n  rate: number;\n  total: number;\n  recent: Array<{\n    type: string;\n    count: number;\n    lastOccurred: string;\n  }>;\n}\n\nexport class HealthCheckService {\n  private static instance: HealthCheckService;\n  private startTime: number;\n  private errorCount: number = 0;\n  private requestCount: number = 0;\n  private recentErrors: Map<string, { count: number; lastOccurred: Date }> = new Map();\n  private supabase: any;\n\n  private constructor() {\n    this.startTime = Date.now();\n    \n    // Initialize Supabase client for health checks\n    if (env.validateSupabaseConfig()) {\n      this.supabase = createClient(\n        env.supabase.url,\n        env.supabase.anonKey\n      );\n    }\n  }\n\n  static getInstance(): HealthCheckService {\n    if (!HealthCheckService.instance) {\n      HealthCheckService.instance = new HealthCheckService();\n    }\n    return HealthCheckService.instance;\n  }\n\n  /**\n   * Performs comprehensive health check\n   */\n  async performHealthCheck(): Promise<HealthCheckResult> {\n    const startCheck = Date.now();\n    \n    // Check all services in parallel\n    const [database, ai, storage, cache] = await Promise.all([\n      this.checkDatabase(),\n      this.checkAIService(),\n      this.checkStorage(),\n      this.checkCache()\n    ]);\n\n    // Determine overall status\n    const services = { database, ai, storage, cache };\n    const serviceStatuses = Object.values(services).map(s => s.status);\n    \n    let overallStatus: HealthCheckResult['status'] = 'healthy';\n    if (serviceStatuses.includes('down')) {\n      overallStatus = 'unhealthy';\n    } else if (serviceStatuses.includes('degraded')) {\n      overallStatus = 'degraded';\n    }\n\n    // Collect metrics\n    const metrics = {\n      memory: this.getMemoryMetrics(),\n      performance: this.getPerformanceMetrics(Date.now() - startCheck),\n      errors: this.getErrorMetrics()\n    };\n\n    return {\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      version: this.getVersion(),\n      uptime: this.getUptime(),\n      services,\n      metrics,\n      environment: {\n        node: process.version,\n        deployment: env.getEnvironment(),\n        region: process.env.RAILWAY_REGION\n      }\n    };\n  }\n\n  /**\n   * Simple health check for load balancer\n   */\n  async getBasicHealth(): Promise<{ status: string; timestamp: string }> {\n    return {\n      status: 'ok',\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Readiness check for container orchestration\n   */\n  async checkReadiness(): Promise<{ ready: boolean; checks: Record<string, boolean> }> {\n    const checks = {\n      database: false,\n      environment: false,\n      dependencies: false\n    };\n\n    // Check database connection\n    if (this.supabase) {\n      try {\n        const { error } = await this.supabase\n          .from('system_health')\n          .select('id')\n          .limit(1);\n        checks.database = !error;\n      } catch {\n        checks.database = false;\n      }\n    }\n\n    // Check environment variables\n    checks.environment = env.validateSupabaseConfig() && env.validateApiConfig();\n\n    // Check critical dependencies\n    checks.dependencies = true; // In production, would check actual dependencies\n\n    const ready = Object.values(checks).every(check => check === true);\n\n    return { ready, checks };\n  }\n\n  /**\n   * Liveness check for container orchestration\n   */\n  async checkLiveness(): Promise<{ alive: boolean; pid: number; uptime: number }> {\n    return {\n      alive: true,\n      pid: process.pid,\n      uptime: this.getUptime()\n    };\n  }\n\n  // Private service check methods\n\n  private async checkDatabase(): Promise<ServiceStatus> {\n    const start = Date.now();\n    const status: ServiceStatus = {\n      name: 'Database (Supabase)',\n      status: 'down',\n      lastCheck: new Date().toISOString()\n    };\n\n    if (!this.supabase) {\n      status.error = 'Supabase client not initialized';\n      return status;\n    }\n\n    try {\n      // Perform a simple query\n      const { data, error } = await this.supabase\n        .from('system_health')\n        .select('id')\n        .limit(1);\n\n      if (error) throw error;\n\n      status.status = 'up';\n      status.latency = Date.now() - start;\n\n      // Get additional database metrics\n      const { data: stats } = await this.supabase.rpc('get_database_stats');\n      if (stats) {\n        status.details = {\n          connections: stats.connections,\n          size: stats.database_size,\n          tables: stats.table_count\n        };\n      }\n\n    } catch (error) {\n      status.status = 'down';\n      status.error = error instanceof Error ? error.message : 'Unknown error';\n      status.latency = Date.now() - start;\n    }\n\n    return status;\n  }\n\n  private async checkAIService(): Promise<ServiceStatus> {\n    const start = Date.now();\n    const status: ServiceStatus = {\n      name: 'AI Service (OpenAI)',\n      status: 'down',\n      lastCheck: new Date().toISOString()\n    };\n\n    if (!env.hasOpenAI()) {\n      status.status = 'degraded';\n      status.error = 'OpenAI API key not configured';\n      return status;\n    }\n\n    try {\n      // In production, would make a test API call\n      // For now, simulate with a simple check\n      const response = await fetch('https://api.openai.com/v1/models', {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${env.openai.apiKey}`,\n          'OpenAI-Organization': env.openai.orgId || ''\n        },\n        signal: AbortSignal.timeout(5000) // 5 second timeout\n      });\n\n      if (response.ok) {\n        status.status = 'up';\n        status.latency = Date.now() - start;\n        \n        // Get rate limit info from headers\n        const remaining = response.headers.get('x-ratelimit-remaining');\n        const limit = response.headers.get('x-ratelimit-limit');\n        \n        if (remaining && limit) {\n          status.details = {\n            rateLimitRemaining: parseInt(remaining),\n            rateLimitTotal: parseInt(limit),\n            rateLimitUsage: ((parseInt(limit) - parseInt(remaining)) / parseInt(limit)) * 100\n          };\n        }\n      } else {\n        status.status = response.status === 429 ? 'degraded' : 'down';\n        status.error = `API returned ${response.status}`;\n      }\n\n    } catch (error) {\n      status.status = 'down';\n      status.error = error instanceof Error ? error.message : 'Connection failed';\n      status.latency = Date.now() - start;\n    }\n\n    return status;\n  }\n\n  private async checkStorage(): Promise<ServiceStatus> {\n    const start = Date.now();\n    const status: ServiceStatus = {\n      name: 'Storage',\n      status: 'up',\n      lastCheck: new Date().toISOString()\n    };\n\n    try {\n      if (typeof window !== 'undefined' && 'storage' in navigator && 'estimate' in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        \n        status.latency = Date.now() - start;\n        status.details = {\n          used: estimate.usage || 0,\n          quota: estimate.quota || 0,\n          percentage: estimate.quota ? ((estimate.usage || 0) / estimate.quota) * 100 : 0\n        };\n\n        // Degrade if storage is almost full\n        if (status.details.percentage > 90) {\n          status.status = 'degraded';\n          status.error = 'Storage usage above 90%';\n        }\n      } else {\n        // Server-side or unsupported\n        status.details = {\n          available: true,\n          type: 'server'\n        };\n      }\n    } catch (error) {\n      status.status = 'down';\n      status.error = error instanceof Error ? error.message : 'Storage check failed';\n    }\n\n    return status;\n  }\n\n  private async checkCache(): Promise<ServiceStatus> {\n    const start = Date.now();\n    const status: ServiceStatus = {\n      name: 'Cache',\n      status: 'up',\n      lastCheck: new Date().toISOString()\n    };\n\n    try {\n      // Test cache operations\n      const testKey = 'health_check_test';\n      const testValue = { timestamp: Date.now() };\n      \n      // Test write\n      if (typeof window !== 'undefined') {\n        localStorage.setItem(testKey, JSON.stringify(testValue));\n        \n        // Test read\n        const retrieved = localStorage.getItem(testKey);\n        if (!retrieved) throw new Error('Cache read failed');\n        \n        // Test delete\n        localStorage.removeItem(testKey);\n        \n        status.latency = Date.now() - start;\n        \n        // Get cache stats\n        const cacheSize = new Blob(Object.values(localStorage)).size;\n        status.details = {\n          type: 'localStorage',\n          size: cacheSize,\n          items: localStorage.length\n        };\n      } else {\n        // Server-side cache check\n        status.details = {\n          type: 'memory',\n          available: true\n        };\n      }\n      \n    } catch (error) {\n      status.status = 'down';\n      status.error = error instanceof Error ? error.message : 'Cache check failed';\n    }\n\n    return status;\n  }\n\n  // Metrics collection methods\n\n  private getMemoryMetrics(): MemoryMetrics {\n    const usage = process.memoryUsage();\n    const totalMemory = process.arch === 'x64' ? 8 * 1024 * 1024 * 1024 : 4 * 1024 * 1024 * 1024; // Estimate\n\n    return {\n      used: usage.heapUsed + usage.external,\n      total: totalMemory,\n      percentage: ((usage.heapUsed + usage.external) / totalMemory) * 100,\n      rss: usage.rss,\n      heapUsed: usage.heapUsed,\n      heapTotal: usage.heapTotal\n    };\n  }\n\n  private getPerformanceMetrics(checkDuration: number): PerformanceMetrics {\n    this.requestCount++;\n    \n    return {\n      cpuUsage: process.cpuUsage ? process.cpuUsage().user / 1000000 : 0, // Convert to seconds\n      loadAverage: typeof process.loadavg === 'function' ? process.loadavg() : [0, 0, 0],\n      responseTime: checkDuration,\n      requestsPerSecond: this.requestCount / (this.getUptime() / 1000)\n    };\n  }\n\n  private getErrorMetrics(): ErrorMetrics {\n    const recentErrors = Array.from(this.recentErrors.entries())\n      .map(([type, data]) => ({\n        type,\n        count: data.count,\n        lastOccurred: data.lastOccurred.toISOString()\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    return {\n      rate: this.errorCount / (this.getUptime() / 1000),\n      total: this.errorCount,\n      recent: recentErrors\n    };\n  }\n\n  // Utility methods\n\n  private getVersion(): string {\n    return process.env.npm_package_version || '1.0.0';\n  }\n\n  private getUptime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  /**\n   * Records an error for metrics\n   */\n  recordError(type: string): void {\n    this.errorCount++;\n    \n    const existing = this.recentErrors.get(type);\n    if (existing) {\n      existing.count++;\n      existing.lastOccurred = new Date();\n    } else {\n      this.recentErrors.set(type, {\n        count: 1,\n        lastOccurred: new Date()\n      });\n    }\n\n    // Keep only recent error types (last 100)\n    if (this.recentErrors.size > 100) {\n      const oldest = Array.from(this.recentErrors.entries())\n        .sort((a, b) => a[1].lastOccurred.getTime() - b[1].lastOccurred.getTime())[0];\n      this.recentErrors.delete(oldest[0]);\n    }\n  }\n\n  /**\n   * Express/HTTP handler for health endpoint\n   */\n  async handleHealthRequest(req: any, res: any): Promise<void> {\n    try {\n      const fullCheck = req.query.full === 'true';\n      \n      if (fullCheck) {\n        const health = await this.performHealthCheck();\n        res.status(health.status === 'healthy' ? 200 : 503).json(health);\n      } else {\n        const basic = await this.getBasicHealth();\n        res.status(200).json(basic);\n      }\n    } catch (error) {\n      res.status(500).json({\n        status: 'error',\n        message: error instanceof Error ? error.message : 'Health check failed'\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const healthCheck = HealthCheckService.getInstance();\n\n// Export convenience functions\nexport const checkHealth = () => healthCheck.performHealthCheck();\nexport const checkReadiness = () => healthCheck.checkReadiness();\nexport const checkLiveness = () => healthCheck.checkLiveness();\n\n// Vite server middleware for health endpoint\nexport function healthCheckMiddleware() {\n  return {\n    name: 'health-check',\n    configureServer(server: any) {\n      server.middlewares.use(async (req: any, res: any, next: any) => {\n        if (req.url === '/health' || req.url.startsWith('/health?')) {\n          res.setHeader('Content-Type', 'application/json');\n          await healthCheck.handleHealthRequest(req, res);\n        } else if (req.url === '/ready') {\n          const readiness = await healthCheck.checkReadiness();\n          res.setHeader('Content-Type', 'application/json');\n          res.statusCode = readiness.ready ? 200 : 503;\n          res.end(JSON.stringify(readiness));\n        } else if (req.url === '/live') {\n          const liveness = await healthCheck.checkLiveness();\n          res.setHeader('Content-Type', 'application/json');\n          res.statusCode = 200;\n          res.end(JSON.stringify(liveness));\n        } else {\n          next();\n        }\n      });\n    }\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/monitoring/performance-tracker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[300,303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[300,303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1068,1071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1068,1071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":187,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5058,5061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5058,5061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5478,5481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5478,5481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":211,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5945,5948],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5945,5948],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6593,6596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6593,6596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8468,8471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8468,8471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":432,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":432,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11934,11937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11934,11937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":477,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":477,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13474,13477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13474,13477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":591,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":591,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16498,16501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16498,16501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { errorReporter } from './error-reporter';\nimport { env } from '../config/environment';\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: 'ms' | 's' | 'bytes' | 'count' | 'percent';\n  timestamp: string;\n  tags?: Record<string, string>;\n  metadata?: Record<string, any>;\n}\n\nexport interface PerformanceReport {\n  metrics: PerformanceMetric[];\n  summary: {\n    pageLoadTime: number;\n    timeToInteractive: number;\n    firstContentfulPaint: number;\n    largestContentfulPaint: number;\n    cumulativeLayoutShift: number;\n    firstInputDelay: number;\n    totalBlockingTime: number;\n  };\n  resources: ResourceTiming[];\n  userAgent: string;\n  url: string;\n  timestamp: string;\n  sessionId: string;\n}\n\nexport interface ResourceTiming {\n  name: string;\n  type: string;\n  duration: number;\n  size: number;\n  cached: boolean;\n}\n\nexport interface AIProcessingMetrics {\n  operationType: string;\n  duration: number;\n  modelUsed: string;\n  inputSize: number;\n  outputSize: number;\n  success: boolean;\n  error?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface TrackerConfig {\n  enableWebVitals?: boolean;\n  enableResourceTiming?: boolean;\n  enableAIMetrics?: boolean;\n  enableUserTiming?: boolean;\n  sampleRate?: number;\n  slowThreshold?: {\n    pageLoad?: number;\n    api?: number;\n    ai?: number;\n    database?: number;\n  };\n  reportInterval?: number;\n  maxMetricsQueue?: number;\n}\n\nconst DEFAULT_CONFIG: TrackerConfig = {\n  enableWebVitals: true,\n  enableResourceTiming: true,\n  enableAIMetrics: true,\n  enableUserTiming: true,\n  sampleRate: env.isProduction() ? 0.1 : 1.0, // 10% in production, 100% in development\n  slowThreshold: {\n    pageLoad: 3000,\n    api: 1000,\n    ai: 5000,\n    database: 500,\n  },\n  reportInterval: 60000, // 1 minute\n  maxMetricsQueue: 100,\n};\n\nexport class PerformanceTracker {\n  private static instance: PerformanceTracker;\n  private config: TrackerConfig;\n  private metricsQueue: PerformanceMetric[] = [];\n  private observer: PerformanceObserver | null = null;\n  private reportTimer: NodeJS.Timeout | null = null;\n  private sessionId: string;\n  private isInitialized = false;\n\n  private constructor() {\n    this.config = DEFAULT_CONFIG;\n    this.sessionId = this.generateSessionId();\n  }\n\n  static getInstance(): PerformanceTracker {\n    if (!PerformanceTracker.instance) {\n      PerformanceTracker.instance = new PerformanceTracker();\n    }\n    return PerformanceTracker.instance;\n  }\n\n  /**\n   * Initialize performance tracking\n   */\n  initialize(config?: Partial<TrackerConfig>) {\n    if (this.isInitialized) return;\n\n    this.config = { ...DEFAULT_CONFIG, ...config };\n\n    // Check if we should track based on sample rate\n    if (Math.random() > (this.config.sampleRate || 1)) {\n      console.log('[PerformanceTracker] Skipping initialization due to sampling');\n      return;\n    }\n\n    if (this.config.enableWebVitals) {\n      this.setupWebVitals();\n    }\n\n    if (this.config.enableResourceTiming) {\n      this.setupResourceTiming();\n    }\n\n    if (this.config.enableUserTiming) {\n      this.setupUserTiming();\n    }\n\n    this.startReportTimer();\n    this.isInitialized = true;\n\n    // Track initial page load\n    this.trackPageLoad();\n\n    if (env.isDevelopment()) {\n      console.log('[PerformanceTracker] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Track page load performance\n   */\n  private trackPageLoad() {\n    if (!window.performance || !window.performance.timing) return;\n\n    // Wait for page to be fully loaded\n    if (document.readyState !== 'complete') {\n      window.addEventListener('load', () => this.trackPageLoad());\n      return;\n    }\n\n    const timing = window.performance.timing;\n    const navigation = window.performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n\n    const metrics = {\n      pageLoadTime: timing.loadEventEnd - timing.navigationStart,\n      domContentLoaded: timing.domContentLoadedEventEnd - timing.navigationStart,\n      timeToFirstByte: timing.responseStart - timing.navigationStart,\n      dnsLookup: timing.domainLookupEnd - timing.domainLookupStart,\n      tcpConnection: timing.connectEnd - timing.connectStart,\n      request: timing.responseStart - timing.requestStart,\n      response: timing.responseEnd - timing.responseStart,\n      domProcessing: timing.domComplete - timing.domLoading,\n    };\n\n    // Track each metric\n    Object.entries(metrics).forEach(([name, value]) => {\n      this.trackMetric(name, value, 'ms', { category: 'page_load' });\n    });\n\n    // Check for slow page load\n    if (metrics.pageLoadTime > (this.config.slowThreshold?.pageLoad || 3000)) {\n      this.reportSlowOperation('page_load', metrics.pageLoadTime, metrics);\n    }\n  }\n\n  /**\n   * Setup Web Vitals tracking\n   */\n  private setupWebVitals() {\n    if (!window.PerformanceObserver) return;\n\n    try {\n      // Track Largest Contentful Paint (LCP)\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1] as any;\n        this.trackMetric('lcp', lastEntry.startTime, 'ms', { \n          category: 'web_vitals',\n          element: lastEntry.element?.tagName,\n        });\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n\n      // Track First Input Delay (FID)\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          this.trackMetric('fid', entry.processingStart - entry.startTime, 'ms', {\n            category: 'web_vitals',\n            eventType: entry.name,\n          });\n        });\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n\n      // Track Cumulative Layout Shift (CLS)\n      let clsValue = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value;\n          }\n        });\n        this.trackMetric('cls', clsValue, 'count', { category: 'web_vitals' });\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n\n    } catch (error) {\n      console.error('[PerformanceTracker] Error setting up Web Vitals:', error);\n    }\n  }\n\n  /**\n   * Setup resource timing tracking\n   */\n  private setupResourceTiming() {\n    if (!window.PerformanceObserver) return;\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry: any) => {\n          if (entry.entryType === 'resource') {\n            const resource: ResourceTiming = {\n              name: entry.name,\n              type: entry.initiatorType,\n              duration: entry.duration,\n              size: entry.transferSize || 0,\n              cached: entry.transferSize === 0 && entry.decodedBodySize > 0,\n            };\n\n            // Track slow resources\n            if (resource.duration > 1000) {\n              this.trackMetric('slow_resource', resource.duration, 'ms', {\n                category: 'resource',\n                url: resource.name,\n                type: resource.type,\n                cached: resource.cached,\n              });\n            }\n          }\n        });\n      });\n\n      observer.observe({ entryTypes: ['resource'] });\n      this.observer = observer;\n    } catch (error) {\n      console.error('[PerformanceTracker] Error setting up resource timing:', error);\n    }\n  }\n\n  /**\n   * Setup user timing tracking\n   */\n  private setupUserTiming() {\n    if (!window.PerformanceObserver) return;\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.entryType === 'measure') {\n            this.trackMetric(entry.name, entry.duration, 'ms', {\n              category: 'user_timing',\n              startMark: (entry as PerformanceMeasure).detail?.start,\n              endMark: (entry as PerformanceMeasure).detail?.end,\n            });\n          }\n        });\n      });\n\n      observer.observe({ entryTypes: ['measure'] });\n    } catch (error) {\n      console.error('[PerformanceTracker] Error setting up user timing:', error);\n    }\n  }\n\n  /**\n   * Track a custom metric\n   */\n  trackMetric(\n    name: string,\n    value: number,\n    unit: PerformanceMetric['unit'] = 'ms',\n    metadata?: Record<string, any>\n  ) {\n    const metric: PerformanceMetric = {\n      name,\n      value,\n      unit,\n      timestamp: new Date().toISOString(),\n      tags: {\n        environment: env.getEnvironment(),\n        ...metadata?.tags,\n      },\n      metadata,\n    };\n\n    this.metricsQueue.push(metric);\n\n    // Flush if queue is full\n    if (this.metricsQueue.length >= (this.config.maxMetricsQueue || 100)) {\n      this.flush();\n    }\n\n    // Log in development\n    if (env.isDevelopment()) {\n      console.log('[PerformanceTracker] Metric:', metric);\n    }\n  }\n\n  /**\n   * Track API call performance\n   */\n  trackApiCall(url: string, method: string, duration: number, status: number) {\n    this.trackMetric('api_call', duration, 'ms', {\n      category: 'api',\n      url,\n      method,\n      status,\n      success: status >= 200 && status < 300,\n    });\n\n    // Check for slow API calls\n    if (duration > (this.config.slowThreshold?.api || 1000)) {\n      this.reportSlowOperation('api', duration, { url, method, status });\n    }\n  }\n\n  /**\n   * Track AI processing performance\n   */\n  trackAIProcessing(metrics: AIProcessingMetrics) {\n    this.trackMetric('ai_processing', metrics.duration, 'ms', {\n      category: 'ai',\n      operation: metrics.operationType,\n      model: metrics.modelUsed,\n      inputSize: metrics.inputSize,\n      outputSize: metrics.outputSize,\n      success: metrics.success,\n      ...metrics.metadata,\n    });\n\n    // Check for slow AI operations\n    if (metrics.duration > (this.config.slowThreshold?.ai || 5000)) {\n      this.reportSlowOperation('ai', metrics.duration, metrics);\n    }\n\n    // Report errors\n    if (!metrics.success && metrics.error) {\n      errorReporter.reportError(new Error(`AI Processing Failed: ${metrics.error}`), {\n        category: 'ai',\n        operation: metrics.operationType,\n        model: metrics.modelUsed,\n      });\n    }\n  }\n\n  /**\n   * Track database query performance\n   */\n  trackDatabaseQuery(query: string, duration: number, success: boolean, rowCount?: number) {\n    this.trackMetric('database_query', duration, 'ms', {\n      category: 'database',\n      query: this.sanitizeQuery(query),\n      success,\n      rowCount,\n    });\n\n    // Check for slow queries\n    if (duration > (this.config.slowThreshold?.database || 500)) {\n      this.reportSlowOperation('database', duration, { query, rowCount });\n    }\n  }\n\n  /**\n   * Create a performance mark\n   */\n  mark(name: string) {\n    if (window.performance && window.performance.mark) {\n      window.performance.mark(name);\n    }\n  }\n\n  /**\n   * Measure between two marks\n   */\n  measure(name: string, startMark: string, endMark?: string) {\n    if (window.performance && window.performance.measure) {\n      try {\n        window.performance.measure(name, startMark, endMark);\n      } catch (error) {\n        console.error('[PerformanceTracker] Error creating measure:', error);\n      }\n    }\n  }\n\n  /**\n   * Start a timer for measuring operations\n   */\n  startTimer(name: string): () => number {\n    const startTime = performance.now();\n    const markName = `${name}_start`;\n    this.mark(markName);\n\n    return () => {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      this.measure(name, markName);\n      this.trackMetric(name, duration, 'ms', { category: 'timer' });\n      \n      return duration;\n    };\n  }\n\n  /**\n   * Report slow operations\n   */\n  private reportSlowOperation(type: string, duration: number, details: any) {\n    errorReporter.addBreadcrumb({\n      type: 'custom',\n      category: 'performance',\n      message: `Slow ${type} operation: ${duration}ms`,\n      level: 'warning',\n      data: details,\n    });\n\n    // Log to console in development\n    if (env.isDevelopment()) {\n      console.warn(`[PerformanceTracker] Slow ${type} operation:`, {\n        duration,\n        details,\n      });\n    }\n  }\n\n  /**\n   * Get current performance summary\n   */\n  getPerformanceSummary(): PerformanceReport['summary'] {\n    const navigation = window.performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    const paint = window.performance.getEntriesByType('paint');\n\n    const fcp = paint.find(entry => entry.name === 'first-contentful-paint');\n    const lcp = this.metricsQueue.find(m => m.name === 'lcp')?.value || 0;\n    const fid = this.metricsQueue.find(m => m.name === 'fid')?.value || 0;\n    const cls = this.metricsQueue.find(m => m.name === 'cls')?.value || 0;\n\n    return {\n      pageLoadTime: navigation?.loadEventEnd - navigation?.fetchStart || 0,\n      timeToInteractive: navigation?.domInteractive - navigation?.fetchStart || 0,\n      firstContentfulPaint: fcp?.startTime || 0,\n      largestContentfulPaint: lcp,\n      cumulativeLayoutShift: cls,\n      firstInputDelay: fid,\n      totalBlockingTime: this.calculateTotalBlockingTime(),\n    };\n  }\n\n  /**\n   * Calculate total blocking time\n   */\n  private calculateTotalBlockingTime(): number {\n    const longTasks = window.performance.getEntriesByType('longtask') as any[];\n    return longTasks.reduce((total, task) => {\n      const blockingTime = task.duration - 50; // Tasks over 50ms are considered blocking\n      return total + (blockingTime > 0 ? blockingTime : 0);\n    }, 0);\n  }\n\n  /**\n   * Flush metrics to monitoring service\n   */\n  private async flush() {\n    if (this.metricsQueue.length === 0) return;\n\n    const report: PerformanceReport = {\n      metrics: [...this.metricsQueue],\n      summary: this.getPerformanceSummary(),\n      resources: this.getResourceTimings(),\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      timestamp: new Date().toISOString(),\n      sessionId: this.sessionId,\n    };\n\n    this.metricsQueue = [];\n\n    try {\n      // In production, send to monitoring service\n      if (env.isProduction()) {\n        await this.sendToMonitoringService(report);\n      }\n\n      // Log summary in development\n      if (env.isDevelopment()) {\n        console.log('[PerformanceTracker] Performance Report:', report);\n      }\n    } catch (error) {\n      console.error('[PerformanceTracker] Failed to flush metrics:', error);\n    }\n  }\n\n  /**\n   * Get resource timings\n   */\n  private getResourceTimings(): ResourceTiming[] {\n    const entries = window.performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    \n    return entries\n      .slice(-50) // Last 50 resources\n      .map(entry => ({\n        name: entry.name,\n        type: entry.initiatorType,\n        duration: entry.duration,\n        size: entry.transferSize || 0,\n        cached: entry.transferSize === 0 && entry.decodedBodySize > 0,\n      }));\n  }\n\n  /**\n   * Send report to monitoring service\n   */\n  private async sendToMonitoringService(report: PerformanceReport) {\n    // Implementation would depend on the monitoring service used\n    // This is a placeholder for the actual implementation\n  }\n\n  /**\n   * Sanitize database queries\n   */\n  private sanitizeQuery(query: string): string {\n    // Remove potentially sensitive data from queries\n    return query\n      .replace(/\\b\\d{4,}\\b/g, 'XXX') // Replace long numbers\n      .replace(/(['\"])([^'\"]{20,})\\1/g, '$1...$1') // Truncate long strings\n      .substring(0, 200); // Limit length\n  }\n\n  /**\n   * Start report timer\n   */\n  private startReportTimer() {\n    if (this.reportTimer) return;\n\n    this.reportTimer = setInterval(() => {\n      this.flush();\n    }, this.config.reportInterval || 60000);\n  }\n\n  /**\n   * Utility methods\n   */\n  private generateSessionId(): string {\n    return `perf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Cleanup and destroy\n   */\n  destroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    if (this.reportTimer) {\n      clearInterval(this.reportTimer);\n    }\n\n    this.flush();\n  }\n}\n\n// Export singleton instance\nexport const performanceTracker = PerformanceTracker.getInstance();\n\n// Export convenience functions\nexport const trackMetric = (name: string, value: number, unit?: PerformanceMetric['unit'], metadata?: any) =>\n  performanceTracker.trackMetric(name, value, unit, metadata);\n\nexport const trackApiCall = (url: string, method: string, duration: number, status: number) =>\n  performanceTracker.trackApiCall(url, method, duration, status);\n\nexport const trackAIProcessing = (metrics: AIProcessingMetrics) =>\n  performanceTracker.trackAIProcessing(metrics);\n\nexport const startTimer = (name: string) =>\n  performanceTracker.startTimer(name);\n\n// Initialize on import if in browser\nif (typeof window !== 'undefined') {\n  performanceTracker.initialize();\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/optimization/cache-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6231,6234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6231,6234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":302,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":302,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9179,9182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9179,9182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":360,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10723,10726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10723,10726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":373,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11116,11119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11116,11119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":380,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11302,11305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11302,11305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":462,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":462,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13571,13574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13571,13574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":462,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":462,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13593,13596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13593,13596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":463,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13637,13640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13637,13640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":502,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":502,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14809,14812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14809,14812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":510,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":510,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15070,15073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15070,15073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":521,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15364,15367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15364,15367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":572,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":572,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16822,16825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16822,16825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":605,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":605,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17738,17741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17738,17741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":622,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":622,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18139,18142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18139,18142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":679,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":679,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19452,19455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19452,19455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":687,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":687,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19659,19662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19659,19662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":691,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":691,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19784,19787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19784,19787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":726,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":726,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20641,20644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20641,20644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":781,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":781,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22298,22301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22298,22301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":864,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":864,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24647,24650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24647,24650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":882,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":882,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25204,25207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25204,25207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":920,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":920,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26167,26170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26167,26170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":926,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":926,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26284,26287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26284,26287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":926,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":926,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26298,26301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26298,26301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":949,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":949,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26973,26976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26973,26976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":949,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":949,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26987,26990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26987,26990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":968,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":968,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27524,27527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27524,27527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":971,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":971,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27640,27643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27640,27643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":994,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":994,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28144,28147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28144,28147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":994,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":994,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28150,28153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28150,28153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":996,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":996,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28251,28254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28251,28254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1037,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1037,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29141,29144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29141,29144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1077,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1077,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29974,29977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29974,29977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1089,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1089,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30180,30183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30180,30183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1111,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1111,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30569,30572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30569,30572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1131,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1131,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30930,30933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30930,30933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1132,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1132,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30949,30952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30949,30952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1150,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1150,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31293,31296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31293,31296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1158,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1158,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31445,31448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31445,31448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":39,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Cache Manager for STR Certified AI Response Optimization\n// Reduces redundant API calls and improves mobile performance\n\nexport class CacheManager {\n  private memoryCache: MemoryCache;\n  private persistentCache: PersistentCache;\n  private cacheMetrics: CacheMetrics;\n  private invalidationRules: InvalidationRule[];\n  private compressionEngine: CompressionEngine;\n\n  constructor(config: CacheConfig = defaultCacheConfig) {\n    this.memoryCache = new MemoryCache(config.memoryLimit);\n    this.persistentCache = new PersistentCache(config.persistentLimit);\n    this.cacheMetrics = new CacheMetrics();\n    this.invalidationRules = this.initializeInvalidationRules();\n    this.compressionEngine = new CompressionEngine();\n\n    // Start background cleanup\n    this.startBackgroundTasks();\n  }\n\n  /**\n   * Gets cached AI response if available\n   */\n  async get<T>(key: string, options: CacheOptions = {}): Promise<CachedItem<T> | null> {\n    const startTime = performance.now();\n\n    // Check memory cache first\n    let item = await this.memoryCache.get<T>(key);\n    if (item && !this.isExpired(item, options)) {\n      this.cacheMetrics.recordHit('memory', performance.now() - startTime);\n      return item;\n    }\n\n    // Check persistent cache\n    item = await this.persistentCache.get<T>(key);\n    if (item && !this.isExpired(item, options)) {\n      // Promote to memory cache\n      await this.memoryCache.set(key, item.value, {\n        ttl: item.ttl,\n        tags: item.tags,\n        priority: item.priority\n      });\n      \n      this.cacheMetrics.recordHit('persistent', performance.now() - startTime);\n      return item;\n    }\n\n    this.cacheMetrics.recordMiss(performance.now() - startTime);\n    return null;\n  }\n\n  /**\n   * Caches AI response with intelligent TTL and compression\n   */\n  async set<T>(\n    key: string, \n    value: T, \n    options: SetCacheOptions = {}\n  ): Promise<void> {\n    const startTime = performance.now();\n\n    // Determine cache strategy\n    const strategy = this.determineCacheStrategy(key, value, options);\n    \n    // Compress if beneficial\n    const shouldCompress = await this.shouldCompress(value, strategy);\n    const processedValue = shouldCompress \n      ? await this.compressionEngine.compress(value)\n      : value;\n\n    // Create cache item\n    const item: CachedItem<T> = {\n      key,\n      value: processedValue as T,\n      timestamp: Date.now(),\n      ttl: strategy.ttl,\n      hits: 0,\n      size: this.calculateSize(processedValue),\n      compressed: shouldCompress,\n      tags: options.tags || [],\n      priority: strategy.priority,\n      metadata: {\n        ...options.metadata,\n        strategy: strategy.name,\n        compressionRatio: shouldCompress ? \n          this.calculateSize(value) / this.calculateSize(processedValue) : 1\n      }\n    };\n\n    // Store in appropriate cache(s)\n    if (strategy.useMemory) {\n      await this.memoryCache.set(key, item.value, {\n        ttl: item.ttl,\n        tags: item.tags,\n        priority: item.priority\n      });\n    }\n\n    if (strategy.usePersistent) {\n      await this.persistentCache.set(key, item.value, {\n        ttl: item.ttl,\n        tags: item.tags,\n        priority: item.priority\n      });\n    }\n\n    this.cacheMetrics.recordSet(performance.now() - startTime, item.size);\n  }\n\n  /**\n   * Implements intelligent cache invalidation\n   */\n  async invalidate(options: InvalidationOptions): Promise<number> {\n    let invalidatedCount = 0;\n\n    if (options.key) {\n      // Invalidate specific key\n      const memoryResult = await this.memoryCache.delete(options.key);\n      const persistentResult = await this.persistentCache.delete(options.key);\n      invalidatedCount = (memoryResult ? 1 : 0) + (persistentResult ? 1 : 0);\n    } else if (options.pattern) {\n      // Invalidate by pattern\n      const keys = await this.findKeysByPattern(options.pattern);\n      for (const key of keys) {\n        await this.memoryCache.delete(key);\n        await this.persistentCache.delete(key);\n        invalidatedCount++;\n      }\n    } else if (options.tags) {\n      // Invalidate by tags\n      invalidatedCount += await this.memoryCache.deleteByTags(options.tags);\n      invalidatedCount += await this.persistentCache.deleteByTags(options.tags);\n    } else if (options.olderThan) {\n      // Invalidate old entries\n      invalidatedCount += await this.memoryCache.deleteOlderThan(options.olderThan);\n      invalidatedCount += await this.persistentCache.deleteOlderThan(options.olderThan);\n    }\n\n    // Apply custom invalidation rules\n    if (options.applyRules) {\n      invalidatedCount += await this.applyInvalidationRules();\n    }\n\n    this.cacheMetrics.recordInvalidation(invalidatedCount);\n    return invalidatedCount;\n  }\n\n  /**\n   * Optimizes cache for mobile performance\n   */\n  async optimizeForMobile(): Promise<OptimizationResult> {\n    const startTime = performance.now();\n    const result: OptimizationResult = {\n      freedSpace: 0,\n      removedItems: 0,\n      compressedItems: 0,\n      duration: 0\n    };\n\n    // 1. Remove low-priority items\n    const lowPriorityItems = await this.findLowPriorityItems();\n    for (const item of lowPriorityItems) {\n      await this.memoryCache.delete(item.key);\n      result.freedSpace += item.size;\n      result.removedItems++;\n    }\n\n    // 2. Compress uncompressed items\n    const uncompressedItems = await this.findUncompressedItems();\n    for (const item of uncompressedItems) {\n      if (await this.compressItem(item)) {\n        result.compressedItems++;\n      }\n    }\n\n    // 3. Move large items to persistent storage\n    const largeItems = await this.memoryCache.findLargeItems(1024 * 1024); // > 1MB\n    for (const item of largeItems) {\n      await this.persistentCache.set(item.key, item.value, {\n        ttl: item.ttl,\n        tags: item.tags,\n        priority: item.priority\n      });\n      await this.memoryCache.delete(item.key);\n      result.freedSpace += item.size;\n    }\n\n    // 4. Implement aggressive TTL for mobile\n    await this.applyMobileTTLPolicy();\n\n    result.duration = performance.now() - startTime;\n    return result;\n  }\n\n  /**\n   * Reduces redundant API calls through intelligent caching\n   */\n  async createCacheKey(\n    endpoint: string,\n    params: Record<string, any>,\n    options: KeyOptions = {}\n  ): Promise<string> {\n    // Normalize parameters\n    const normalizedParams = this.normalizeParams(params);\n    \n    // Create base key\n    let key = `${endpoint}:${JSON.stringify(normalizedParams)}`;\n    \n    // Add context if provided\n    if (options.context) {\n      key += `:${options.context}`;\n    }\n    \n    // Add user-specific suffix if needed\n    if (options.userSpecific && options.userId) {\n      key += `:user_${options.userId}`;\n    }\n    \n    // Add device-specific suffix for mobile\n    if (options.deviceSpecific && options.deviceId) {\n      key += `:device_${options.deviceId}`;\n    }\n\n    // Hash if too long\n    if (key.length > 250) {\n      const hash = await this.hashKey(key);\n      key = `${endpoint}:${hash}`;\n    }\n\n    return key;\n  }\n\n  /**\n   * Gets cache statistics for monitoring\n   */\n  async getStatistics(): Promise<CacheStatistics> {\n    const memoryStats = await this.memoryCache.getStats();\n    const persistentStats = await this.persistentCache.getStats();\n    const metrics = this.cacheMetrics.getMetrics();\n\n    return {\n      memory: memoryStats,\n      persistent: persistentStats,\n      performance: {\n        hitRate: metrics.hits / (metrics.hits + metrics.misses) * 100,\n        avgHitTime: metrics.totalHitTime / metrics.hits,\n        avgMissTime: metrics.totalMissTime / metrics.misses,\n        compressionRatio: metrics.totalUncompressed / metrics.totalCompressed\n      },\n      savings: {\n        apiCallsSaved: metrics.hits,\n        estimatedCostSaved: this.estimateCostSavings(metrics.hits),\n        dataSaved: metrics.totalCompressed - metrics.totalUncompressed,\n        timeSaved: metrics.hits * 1000 // Assume 1s per API call\n      }\n    };\n  }\n\n  /**\n   * Preloads cache with predicted content\n   */\n  async preload(predictions: CachePrediction[]): Promise<void> {\n    for (const prediction of predictions) {\n      if (prediction.probability > 0.7) {\n        // Check if already cached\n        const existing = await this.get(prediction.key);\n        if (!existing) {\n          // Fetch and cache with lower priority\n          const value = await prediction.fetcher();\n          await this.set(prediction.key, value, {\n            priority: 'low',\n            ttl: prediction.ttl || 3600000, // 1 hour default\n            tags: ['preloaded', ...(prediction.tags || [])]\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements cache warming strategy\n   */\n  async warmCache(strategy: WarmingStrategy): Promise<void> {\n    switch (strategy.type) {\n      case 'popular':\n        await this.warmPopularItems(strategy.count || 50);\n        break;\n      case 'predicted':\n        await this.warmPredictedItems(strategy.predictions || []);\n        break;\n      case 'critical':\n        await this.warmCriticalPaths(strategy.paths || []);\n        break;\n    }\n  }\n\n  // Private helper methods\n\n  private determineCacheStrategy(\n    key: string,\n    value: any,\n    options: SetCacheOptions\n  ): CacheStrategy {\n    // Check if it's an AI response\n    const isAIResponse = key.includes('openai') || key.includes('gpt') || key.includes('vision');\n    \n    // Check value characteristics\n    const size = this.calculateSize(value);\n    const isLarge = size > 500 * 1024; // 500KB\n    const isFrequentlyAccessed = this.cacheMetrics.getAccessFrequency(key) > 10;\n    \n    // Determine strategy\n    if (options.strategy) {\n      return this.strategies[options.strategy];\n    }\n\n    if (isAIResponse && !isLarge) {\n      return this.strategies.aggressive;\n    } else if (isFrequentlyAccessed) {\n      return this.strategies.frequent;\n    } else if (isLarge) {\n      return this.strategies.large;\n    } else {\n      return this.strategies.default;\n    }\n  }\n\n  private strategies: Record<string, CacheStrategy> = {\n    aggressive: {\n      name: 'aggressive',\n      ttl: 24 * 60 * 60 * 1000, // 24 hours\n      useMemory: true,\n      usePersistent: true,\n      priority: 'high'\n    },\n    frequent: {\n      name: 'frequent',\n      ttl: 4 * 60 * 60 * 1000, // 4 hours\n      useMemory: true,\n      usePersistent: false,\n      priority: 'high'\n    },\n    large: {\n      name: 'large',\n      ttl: 12 * 60 * 60 * 1000, // 12 hours\n      useMemory: false,\n      usePersistent: true,\n      priority: 'medium'\n    },\n    default: {\n      name: 'default',\n      ttl: 60 * 60 * 1000, // 1 hour\n      useMemory: true,\n      usePersistent: false,\n      priority: 'medium'\n    }\n  };\n\n  private async shouldCompress(value: any, strategy: CacheStrategy): Promise<boolean> {\n    const size = this.calculateSize(value);\n    \n    // Don't compress small values\n    if (size < 1024) return false; // < 1KB\n    \n    // Always compress large values\n    if (size > 100 * 1024) return true; // > 100KB\n    \n    // Compress if going to persistent storage\n    return strategy.usePersistent;\n  }\n\n  private calculateSize(value: any): number {\n    if (typeof value === 'string') {\n      return value.length * 2; // UTF-16\n    }\n    return JSON.stringify(value).length * 2;\n  }\n\n  private isExpired(item: CachedItem<any>, options: CacheOptions): boolean {\n    if (options.force) return true;\n    \n    const now = Date.now();\n    const age = now - item.timestamp;\n    \n    // Check TTL\n    if (item.ttl && age > item.ttl) {\n      return true;\n    }\n    \n    // Check custom expiration\n    if (options.maxAge && age > options.maxAge) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  private initializeInvalidationRules(): InvalidationRule[] {\n    return [\n      {\n        name: 'stale-predictions',\n        condition: (item) => {\n          return item.key.includes('prediction') && \n                 Date.now() - item.timestamp > 6 * 60 * 60 * 1000; // 6 hours\n        },\n        action: 'delete'\n      },\n      {\n        name: 'low-hit-rate',\n        condition: (item) => {\n          const hitRate = item.hits / ((Date.now() - item.timestamp) / (60 * 60 * 1000));\n          return hitRate < 0.1; // Less than 0.1 hits per hour\n        },\n        action: 'delete'\n      },\n      {\n        name: 'outdated-analysis',\n        condition: (item) => {\n          return item.key.includes('analysis') && \n                 item.metadata?.version !== 'latest';\n        },\n        action: 'invalidate'\n      }\n    ];\n  }\n\n  private async applyInvalidationRules(): Promise<number> {\n    let invalidated = 0;\n    \n    const allItems = [\n      ...await this.memoryCache.getAllItems(),\n      ...await this.persistentCache.getAllItems()\n    ];\n\n    for (const item of allItems) {\n      for (const rule of this.invalidationRules) {\n        if (rule.condition(item)) {\n          if (rule.action === 'delete') {\n            await this.invalidate({ key: item.key });\n            invalidated++;\n          } else if (rule.action === 'invalidate') {\n            item.ttl = 0; // Mark as expired\n            invalidated++;\n          }\n        }\n      }\n    }\n\n    return invalidated;\n  }\n\n  private async findKeysByPattern(pattern: string): Promise<string[]> {\n    const regex = new RegExp(pattern);\n    const memoryKeys = await this.memoryCache.getKeys();\n    const persistentKeys = await this.persistentCache.getKeys();\n    \n    const allKeys = [...new Set([...memoryKeys, ...persistentKeys])];\n    return allKeys.filter(key => regex.test(key));\n  }\n\n  private normalizeParams(params: Record<string, any>): Record<string, any> {\n    const normalized: Record<string, any> = {};\n    \n    // Sort keys for consistent ordering\n    const sortedKeys = Object.keys(params).sort();\n    \n    for (const key of sortedKeys) {\n      const value = params[key];\n      \n      // Skip null/undefined values\n      if (value === null || value === undefined) continue;\n      \n      // Normalize arrays\n      if (Array.isArray(value)) {\n        normalized[key] = [...value].sort();\n      } else if (typeof value === 'object') {\n        normalized[key] = this.normalizeParams(value);\n      } else {\n        normalized[key] = value;\n      }\n    }\n    \n    return normalized;\n  }\n\n  private async hashKey(key: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(key);\n    const hash = await crypto.subtle.digest('SHA-256', data);\n    return Array.from(new Uint8Array(hash))\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  private estimateCostSavings(apiCallsSaved: number): number {\n    // Rough estimates based on typical API costs\n    const avgCostPerCall = 0.02; // $0.02 average\n    return apiCallsSaved * avgCostPerCall;\n  }\n\n  private async findLowPriorityItems(): Promise<CachedItem<any>[]> {\n    const allItems = await this.memoryCache.getAllItems();\n    return allItems\n      .filter(item => item.priority === 'low')\n      .sort((a, b) => a.hits - b.hits)\n      .slice(0, 20);\n  }\n\n  private async findUncompressedItems(): Promise<CachedItem<any>[]> {\n    const allItems = [\n      ...await this.memoryCache.getAllItems(),\n      ...await this.persistentCache.getAllItems()\n    ];\n    \n    return allItems.filter(item => \n      !item.compressed && item.size > 10 * 1024 // > 10KB\n    );\n  }\n\n  private async compressItem(item: CachedItem<any>): Promise<boolean> {\n    try {\n      const compressed = await this.compressionEngine.compress(item.value);\n      const newSize = this.calculateSize(compressed);\n      \n      if (newSize < item.size * 0.7) { // At least 30% reduction\n        item.value = compressed;\n        item.size = newSize;\n        item.compressed = true;\n        \n        // Update in cache\n        await this.set(item.key, item.value, {\n          ttl: item.ttl,\n          tags: item.tags,\n          priority: item.priority\n        });\n        \n        return true;\n      }\n    } catch (error) {\n      console.error('Failed to compress item:', error);\n    }\n    \n    return false;\n  }\n\n  private async applyMobileTTLPolicy(): Promise<void> {\n    // Reduce TTL for mobile devices to save space\n    const factor = 0.5; // 50% of original TTL\n    \n    const items = await this.memoryCache.getAllItems();\n    for (const item of items) {\n      if (item.ttl) {\n        item.ttl = Math.floor(item.ttl * factor);\n      }\n    }\n  }\n\n  private async warmPopularItems(count: number): Promise<void> {\n    // Get most accessed keys from metrics\n    const popularKeys = this.cacheMetrics.getMostAccessedKeys(count);\n    \n    for (const key of popularKeys) {\n      const exists = await this.get(key);\n      if (!exists) {\n        // In production, would fetch from source\n        console.log(`Would warm cache for key: ${key}`);\n      }\n    }\n  }\n\n  private async warmPredictedItems(predictions: any[]): Promise<void> {\n    // Implement prediction-based warming\n    for (const prediction of predictions) {\n      await this.preload([prediction]);\n    }\n  }\n\n  private async warmCriticalPaths(paths: string[]): Promise<void> {\n    // Warm cache for critical application paths\n    for (const path of paths) {\n      // In production, would pre-fetch data for these paths\n      console.log(`Warming cache for critical path: ${path}`);\n    }\n  }\n\n  private startBackgroundTasks(): void {\n    // Cleanup task\n    setInterval(async () => {\n      await this.memoryCache.cleanup();\n      await this.persistentCache.cleanup();\n      await this.applyInvalidationRules();\n    }, 5 * 60 * 1000); // Every 5 minutes\n\n    // Metrics collection\n    setInterval(() => {\n      this.cacheMetrics.collect();\n    }, 60 * 1000); // Every minute\n  }\n}\n\n// Supporting classes\n\nclass MemoryCache {\n  private cache: Map<string, CachedItem<any>> = new Map();\n  private sizeLimit: number;\n  private currentSize: number = 0;\n\n  constructor(sizeLimit: number) {\n    this.sizeLimit = sizeLimit;\n  }\n\n  async get<T>(key: string): Promise<CachedItem<T> | null> {\n    const item = this.cache.get(key);\n    if (item) {\n      item.hits++;\n      return item as CachedItem<T>;\n    }\n    return null;\n  }\n\n  async set<T>(key: string, value: T, options: any): Promise<void> {\n    const size = this.calculateSize(value);\n    \n    // Evict if necessary\n    while (this.currentSize + size > this.sizeLimit && this.cache.size > 0) {\n      await this.evictLRU();\n    }\n\n    this.cache.set(key, {\n      key,\n      value,\n      timestamp: Date.now(),\n      ttl: options.ttl,\n      hits: 0,\n      size,\n      compressed: false,\n      tags: options.tags || [],\n      priority: options.priority || 'medium',\n      metadata: {}\n    });\n\n    this.currentSize += size;\n  }\n\n  async delete(key: string): Promise<boolean> {\n    const item = this.cache.get(key);\n    if (item) {\n      this.currentSize -= item.size;\n      return this.cache.delete(key);\n    }\n    return false;\n  }\n\n  async deleteByTags(tags: string[]): Promise<number> {\n    let deleted = 0;\n    for (const [key, item] of this.cache) {\n      if (tags.some(tag => item.tags.includes(tag))) {\n        if (await this.delete(key)) {\n          deleted++;\n        }\n      }\n    }\n    return deleted;\n  }\n\n  async deleteOlderThan(timestamp: number): Promise<number> {\n    let deleted = 0;\n    for (const [key, item] of this.cache) {\n      if (item.timestamp < timestamp) {\n        if (await this.delete(key)) {\n          deleted++;\n        }\n      }\n    }\n    return deleted;\n  }\n\n  async getAllItems(): Promise<CachedItem<any>[]> {\n    return Array.from(this.cache.values());\n  }\n\n  async getKeys(): Promise<string[]> {\n    return Array.from(this.cache.keys());\n  }\n\n  async findLargeItems(threshold: number): Promise<CachedItem<any>[]> {\n    return Array.from(this.cache.values()).filter(item => item.size > threshold);\n  }\n\n  async getStats(): Promise<any> {\n    return {\n      items: this.cache.size,\n      size: this.currentSize,\n      sizeLimit: this.sizeLimit,\n      utilization: (this.currentSize / this.sizeLimit) * 100\n    };\n  }\n\n  async cleanup(): Promise<void> {\n    const now = Date.now();\n    for (const [key, item] of this.cache) {\n      if (item.ttl && now - item.timestamp > item.ttl) {\n        await this.delete(key);\n      }\n    }\n  }\n\n  private async evictLRU(): Promise<void> {\n    let lruKey: string | null = null;\n    let lruTime = Infinity;\n\n    for (const [key, item] of this.cache) {\n      const lastAccess = item.timestamp + (item.hits * 1000); // Boost by hits\n      if (lastAccess < lruTime && item.priority !== 'high') {\n        lruTime = lastAccess;\n        lruKey = key;\n      }\n    }\n\n    if (lruKey) {\n      await this.delete(lruKey);\n    }\n  }\n\n  private calculateSize(value: any): number {\n    return JSON.stringify(value).length * 2;\n  }\n}\n\nclass PersistentCache {\n  private dbName = 'str_certified_cache';\n  private storeName = 'ai_responses';\n  private sizeLimit: number;\n  private db: IDBDatabase | null = null;\n\n  constructor(sizeLimit: number) {\n    this.sizeLimit = sizeLimit;\n    this.initDB();\n  }\n\n  private async initDB(): Promise<void> {\n    const request = indexedDB.open(this.dbName, 1);\n    \n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      if (!db.objectStoreNames.contains(this.storeName)) {\n        const store = db.createObjectStore(this.storeName, { keyPath: 'key' });\n        store.createIndex('timestamp', 'timestamp');\n        store.createIndex('tags', 'tags', { multiEntry: true });\n      }\n    };\n\n    this.db = await new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async get<T>(key: string): Promise<CachedItem<T> | null> {\n    if (!this.db) await this.initDB();\n    \n    const transaction = this.db!.transaction([this.storeName], 'readonly');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onsuccess = () => {\n        const item = request.result;\n        if (item) {\n          item.hits++;\n          // Update hit count\n          this.updateHits(key, item.hits);\n        }\n        resolve(item);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async set<T>(key: string, value: T, options: any): Promise<void> {\n    if (!this.db) await this.initDB();\n    \n    const item: CachedItem<T> = {\n      key,\n      value,\n      timestamp: Date.now(),\n      ttl: options.ttl,\n      hits: 0,\n      size: this.calculateSize(value),\n      compressed: false,\n      tags: options.tags || [],\n      priority: options.priority || 'medium',\n      metadata: {}\n    };\n\n    const transaction = this.db!.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.put(item);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async delete(key: string): Promise<boolean> {\n    if (!this.db) await this.initDB();\n    \n    const transaction = this.db!.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      request.onsuccess = () => resolve(true);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async deleteByTags(tags: string[]): Promise<number> {\n    if (!this.db) await this.initDB();\n    \n    let deleted = 0;\n    const items = await this.getAllItems();\n    \n    for (const item of items) {\n      if (tags.some(tag => item.tags.includes(tag))) {\n        await this.delete(item.key);\n        deleted++;\n      }\n    }\n    \n    return deleted;\n  }\n\n  async deleteOlderThan(timestamp: number): Promise<number> {\n    if (!this.db) await this.initDB();\n    \n    const transaction = this.db!.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    const index = store.index('timestamp');\n    \n    let deleted = 0;\n    const range = IDBKeyRange.upperBound(timestamp);\n    \n    return new Promise((resolve, reject) => {\n      const request = index.openCursor(range);\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          store.delete(cursor.primaryKey);\n          deleted++;\n          cursor.continue();\n        } else {\n          resolve(deleted);\n        }\n      };\n      \n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async getAllItems(): Promise<CachedItem<any>[]> {\n    if (!this.db) await this.initDB();\n    \n    const transaction = this.db!.transaction([this.storeName], 'readonly');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  async getKeys(): Promise<string[]> {\n    const items = await this.getAllItems();\n    return items.map(item => item.key);\n  }\n\n  async getStats(): Promise<any> {\n    const items = await this.getAllItems();\n    const totalSize = items.reduce((sum, item) => sum + item.size, 0);\n    \n    return {\n      items: items.length,\n      size: totalSize,\n      sizeLimit: this.sizeLimit,\n      utilization: (totalSize / this.sizeLimit) * 100\n    };\n  }\n\n  async cleanup(): Promise<void> {\n    const now = Date.now();\n    const items = await this.getAllItems();\n    \n    for (const item of items) {\n      if (item.ttl && now - item.timestamp > item.ttl) {\n        await this.delete(item.key);\n      }\n    }\n  }\n\n  private async updateHits(key: string, hits: number): Promise<void> {\n    // Update hit count in background\n    setTimeout(async () => {\n      const item = await this.get(key);\n      if (item) {\n        item.hits = hits;\n        await this.set(key, item.value, {\n          ttl: item.ttl,\n          tags: item.tags,\n          priority: item.priority\n        });\n      }\n    }, 0);\n  }\n\n  private calculateSize(value: any): number {\n    return JSON.stringify(value).length * 2;\n  }\n}\n\nclass CompressionEngine {\n  async compress(value: any): Promise<any> {\n    const json = JSON.stringify(value);\n    const encoder = new TextEncoder();\n    const data = encoder.encode(json);\n    \n    // Use CompressionStream if available\n    if ('CompressionStream' in window) {\n      const cs = new CompressionStream('gzip');\n      const writer = cs.writable.getWriter();\n      writer.write(data);\n      writer.close();\n      \n      const compressed = await new Response(cs.readable).arrayBuffer();\n      return {\n        _compressed: true,\n        data: Array.from(new Uint8Array(compressed))\n      };\n    }\n    \n    // Fallback: simple compression for repeated strings\n    return this.simpleCompress(json);\n  }\n\n  async decompress(value: any): Promise<any> {\n    if (value._compressed) {\n      if ('DecompressionStream' in window) {\n        const data = new Uint8Array(value.data);\n        const ds = new DecompressionStream('gzip');\n        const writer = ds.writable.getWriter();\n        writer.write(data);\n        writer.close();\n        \n        const decompressed = await new Response(ds.readable).text();\n        return JSON.parse(decompressed);\n      }\n      \n      return this.simpleDecompress(value.data);\n    }\n    \n    return value;\n  }\n\n  private simpleCompress(str: string): any {\n    // Simple dictionary-based compression\n    const dict: Record<string, number> = {};\n    const compressed: any[] = [];\n    let dictIndex = 0;\n    \n    const words = str.split(/(\\s+|[{}[\\],\":])/);\n    \n    for (const word of words) {\n      if (word.length > 3) {\n        if (!(word in dict)) {\n          dict[word] = dictIndex++;\n        }\n        compressed.push(dict[word]);\n      } else {\n        compressed.push(word);\n      }\n    }\n    \n    return {\n      _compressed: true,\n      dict: Object.entries(dict).map(([k, v]) => [v, k]),\n      data: compressed\n    };\n  }\n\n  private simpleDecompress(compressed: any): any {\n    const dict = new Map(compressed.dict);\n    const decompressed = compressed.data.map((item: any) => \n      typeof item === 'number' ? dict.get(item) : item\n    ).join('');\n    \n    return JSON.parse(decompressed);\n  }\n}\n\nclass CacheMetrics {\n  private metrics = {\n    hits: 0,\n    misses: 0,\n    sets: 0,\n    invalidations: 0,\n    totalHitTime: 0,\n    totalMissTime: 0,\n    totalSetTime: 0,\n    totalCompressed: 0,\n    totalUncompressed: 0,\n    accessFrequency: new Map<string, number>()\n  };\n\n  recordHit(type: 'memory' | 'persistent', duration: number): void {\n    this.metrics.hits++;\n    this.metrics.totalHitTime += duration;\n  }\n\n  recordMiss(duration: number): void {\n    this.metrics.misses++;\n    this.metrics.totalMissTime += duration;\n  }\n\n  recordSet(duration: number, size: number): void {\n    this.metrics.sets++;\n    this.metrics.totalSetTime += duration;\n  }\n\n  recordInvalidation(count: number): void {\n    this.metrics.invalidations += count;\n  }\n\n  getMetrics(): any {\n    return { ...this.metrics };\n  }\n\n  getAccessFrequency(key: string): number {\n    return this.metrics.accessFrequency.get(key) || 0;\n  }\n\n  getMostAccessedKeys(count: number): string[] {\n    return Array.from(this.metrics.accessFrequency.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, count)\n      .map(([key]) => key);\n  }\n\n  collect(): void {\n    // Collect and aggregate metrics\n    // In production, would send to monitoring service\n  }\n}\n\n// Types\n\ninterface CacheConfig {\n  memoryLimit: number;\n  persistentLimit: number;\n  ttl?: number;\n  compressionThreshold?: number;\n}\n\ninterface CachedItem<T> {\n  key: string;\n  value: T;\n  timestamp: number;\n  ttl?: number;\n  hits: number;\n  size: number;\n  compressed: boolean;\n  tags: string[];\n  priority: 'low' | 'medium' | 'high';\n  metadata: Record<string, any>;\n}\n\ninterface CacheOptions {\n  force?: boolean;\n  maxAge?: number;\n}\n\ninterface SetCacheOptions {\n  ttl?: number;\n  tags?: string[];\n  priority?: 'low' | 'medium' | 'high';\n  metadata?: Record<string, any>;\n  strategy?: string;\n}\n\ninterface InvalidationOptions {\n  key?: string;\n  pattern?: string;\n  tags?: string[];\n  olderThan?: number;\n  applyRules?: boolean;\n}\n\ninterface CacheStrategy {\n  name: string;\n  ttl: number;\n  useMemory: boolean;\n  usePersistent: boolean;\n  priority: 'low' | 'medium' | 'high';\n}\n\ninterface InvalidationRule {\n  name: string;\n  condition: (item: CachedItem<any>) => boolean;\n  action: 'delete' | 'invalidate';\n}\n\ninterface OptimizationResult {\n  freedSpace: number;\n  removedItems: number;\n  compressedItems: number;\n  duration: number;\n}\n\ninterface KeyOptions {\n  context?: string;\n  userSpecific?: boolean;\n  userId?: string;\n  deviceSpecific?: boolean;\n  deviceId?: string;\n}\n\ninterface CacheStatistics {\n  memory: any;\n  persistent: any;\n  performance: {\n    hitRate: number;\n    avgHitTime: number;\n    avgMissTime: number;\n    compressionRatio: number;\n  };\n  savings: {\n    apiCallsSaved: number;\n    estimatedCostSaved: number;\n    dataSaved: number;\n    timeSaved: number;\n  };\n}\n\ninterface CachePrediction {\n  key: string;\n  probability: number;\n  fetcher: () => Promise<any>;\n  ttl?: number;\n  tags?: string[];\n}\n\ninterface WarmingStrategy {\n  type: 'popular' | 'predicted' | 'critical';\n  count?: number;\n  predictions?: any[];\n  paths?: string[];\n}\n\n// Default configuration\nconst defaultCacheConfig: CacheConfig = {\n  memoryLimit: 50 * 1024 * 1024, // 50MB\n  persistentLimit: 200 * 1024 * 1024, // 200MB\n  ttl: 60 * 60 * 1000, // 1 hour\n  compressionThreshold: 10 * 1024 // 10KB\n};\n\n// Export factory function\nexport const createCacheManager = (config?: Partial<CacheConfig>): CacheManager => {\n  return new CacheManager({ ...defaultCacheConfig, ...config });\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/optimization/image-optimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9272,9275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9272,9275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":712,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":712,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20636,20639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20636,20639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":755,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":755,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21696,21696],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":761,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":761,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21830,21830],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Image Optimizer for STR Certified\n// Compresses images while maintaining AI analysis quality\n\nexport class ImageOptimizer {\n  private canvas: HTMLCanvasElement | null = null;\n  private ctx: CanvasRenderingContext2D | null = null;\n  private worker: Worker | null = null;\n  private deviceCapabilities: DeviceCapabilities;\n  private qualityPresets: QualityPresets;\n  private storageManager: StorageManager;\n\n  constructor(config: ImageOptimizerConfig = defaultConfig) {\n    this.deviceCapabilities = this.detectDeviceCapabilities();\n    this.qualityPresets = this.initializeQualityPresets(config);\n    this.storageManager = new StorageManager(config.maxStorageSize);\n    this.initializeCanvas();\n    this.initializeWorker();\n  }\n\n  /**\n   * Compresses images while maintaining AI analysis quality\n   */\n  async compressForAI(\n    image: File | Blob | string,\n    options: CompressionOptions = {}\n  ): Promise<CompressedImage> {\n    const startTime = performance.now();\n\n    // Load image\n    const img = await this.loadImage(image);\n    const originalSize = await this.getImageSize(image);\n\n    // Determine optimal settings for AI\n    const settings = this.determineAIOptimalSettings(img, options);\n\n    // Apply preprocessing for better AI analysis\n    const preprocessed = await this.preprocessForAI(img, settings);\n\n    // Compress with quality preservation\n    const compressed = await this.compress(preprocessed, settings);\n\n    // Validate AI quality maintained\n    const qualityScore = await this.validateAIQuality(compressed, img);\n    \n    if (qualityScore < 0.85 && !options.forceCompression) {\n      // Recompress with higher quality\n      settings.quality += 0.1;\n      return this.compress(preprocessed, settings);\n    }\n\n    const duration = performance.now() - startTime;\n\n    return {\n      blob: compressed.blob,\n      url: compressed.url,\n      metadata: {\n        originalSize,\n        compressedSize: compressed.blob.size,\n        compressionRatio: originalSize / compressed.blob.size,\n        dimensions: {\n          width: compressed.width,\n          height: compressed.height\n        },\n        quality: settings.quality,\n        format: settings.format,\n        processingTime: duration,\n        aiQualityScore: qualityScore\n      }\n    };\n  }\n\n  /**\n   * Implements progressive loading for better mobile performance\n   */\n  async generateProgressiveVersions(\n    image: File | Blob | string,\n    options: ProgressiveOptions = {}\n  ): Promise<ProgressiveImage> {\n    const img = await this.loadImage(image);\n    \n    const versions: ImageVersion[] = [];\n    const sizes = options.sizes || this.getProgressiveSizes(img);\n\n    // Generate placeholder (tiny, blurred)\n    const placeholder = await this.generatePlaceholder(img);\n    versions.push({\n      name: 'placeholder',\n      blob: placeholder.blob,\n      url: placeholder.url,\n      width: placeholder.width,\n      height: placeholder.height,\n      quality: 'placeholder'\n    });\n\n    // Generate progressive versions\n    for (const size of sizes) {\n      const version = await this.generateVersion(img, size);\n      versions.push(version);\n    }\n\n    // Generate final high-quality version\n    const final = await this.generateFinalVersion(img, options);\n    versions.push(final);\n\n    return {\n      placeholder: versions[0],\n      versions: versions.slice(1),\n      final: versions[versions.length - 1],\n      loadingStrategy: this.determineLoadingStrategy(versions)\n    };\n  }\n\n  /**\n   * Manages storage optimization for offline support\n   */\n  async optimizeStorage(options: StorageOptimizationOptions = {}): Promise<StorageReport> {\n    const startTime = performance.now();\n    const report: StorageReport = {\n      freedSpace: 0,\n      optimizedImages: 0,\n      removedImages: 0,\n      duration: 0,\n      suggestions: []\n    };\n\n    // Analyze current storage\n    const analysis = await this.storageManager.analyze();\n\n    // Remove duplicate images\n    const duplicates = await this.findDuplicateImages();\n    for (const duplicate of duplicates) {\n      await this.storageManager.remove(duplicate.hash);\n      report.removedImages++;\n      report.freedSpace += duplicate.size;\n    }\n\n    // Compress oversized images\n    const oversized = await this.findOversizedImages(options.maxImageSize || 2 * 1024 * 1024);\n    for (const image of oversized) {\n      const optimized = await this.compressForAI(image.blob, {\n        maxSize: options.maxImageSize,\n        preserveQuality: false\n      });\n      \n      if (optimized.metadata.compressedSize < image.size) {\n        await this.storageManager.replace(image.hash, optimized);\n        report.optimizedImages++;\n        report.freedSpace += image.size - optimized.metadata.compressedSize;\n      }\n    }\n\n    // Clean old cached images\n    if (options.cleanCache) {\n      const removed = await this.storageManager.cleanOldItems(\n        options.maxCacheAge || 7 * 24 * 60 * 60 * 1000 // 7 days\n      );\n      report.removedImages += removed.count;\n      report.freedSpace += removed.size;\n    }\n\n    // Generate optimization suggestions\n    report.suggestions = this.generateStorageSuggestions(analysis, report);\n    report.duration = performance.now() - startTime;\n\n    return report;\n  }\n\n  /**\n   * Handles different device capabilities\n   */\n  async adaptToDevice(image: File | Blob | string): Promise<AdaptiveImage> {\n    const capabilities = this.deviceCapabilities;\n    const network = await this.getNetworkConditions();\n\n    // Determine optimal settings based on device\n    let settings: CompressionSettings;\n    \n    if (capabilities.deviceType === 'mobile') {\n      if (capabilities.memory < 4) {\n        // Low-end device\n        settings = this.qualityPresets.lowEnd;\n      } else {\n        // Mid-range device\n        settings = this.qualityPresets.mobile;\n      }\n    } else {\n      // Desktop/tablet\n      settings = this.qualityPresets.desktop;\n    }\n\n    // Adjust for network conditions\n    if (network.effectiveType === '2g' || network.effectiveType === 'slow-2g') {\n      settings.quality *= 0.7;\n      settings.maxDimension = Math.min(settings.maxDimension, 800);\n    } else if (network.effectiveType === '3g') {\n      settings.quality *= 0.85;\n      settings.maxDimension = Math.min(settings.maxDimension, 1200);\n    }\n\n    // Compress with adapted settings\n    const compressed = await this.compressForAI(image, settings);\n\n    // Generate appropriate versions\n    const versions = await this.generateProgressiveVersions(image, {\n      sizes: this.getAdaptiveSizes(capabilities, network)\n    });\n\n    return {\n      primary: compressed,\n      versions: versions.versions,\n      deviceProfile: {\n        type: capabilities.deviceType,\n        pixelRatio: capabilities.pixelRatio,\n        memory: capabilities.memory,\n        network: network.effectiveType\n      },\n      recommendations: this.getDeviceRecommendations(capabilities, network)\n    };\n  }\n\n  /**\n   * Optimizes batch of images\n   */\n  async batchOptimize(\n    images: Array<File | Blob | string>,\n    options: BatchOptions = {}\n  ): Promise<BatchResult> {\n    const results: CompressedImage[] = [];\n    const errors: BatchError[] = [];\n    let totalOriginalSize = 0;\n    let totalCompressedSize = 0;\n\n    // Process in parallel with concurrency limit\n    const concurrency = options.concurrency || 3;\n    const chunks = this.chunkArray(images, concurrency);\n\n    for (const chunk of chunks) {\n      const promises = chunk.map(async (image, index) => {\n        try {\n          const compressed = await this.compressForAI(image, options);\n          results.push(compressed);\n          totalOriginalSize += compressed.metadata.originalSize;\n          totalCompressedSize += compressed.metadata.compressedSize;\n        } catch (error) {\n          errors.push({\n            index,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            image\n          });\n        }\n      });\n\n      await Promise.all(promises);\n    }\n\n    return {\n      successful: results,\n      failed: errors,\n      summary: {\n        processed: results.length,\n        failed: errors.length,\n        totalOriginalSize,\n        totalCompressedSize,\n        averageCompressionRatio: totalOriginalSize / totalCompressedSize,\n        savedSpace: totalOriginalSize - totalCompressedSize\n      }\n    };\n  }\n\n  // Private helper methods\n\n  private initializeCanvas(): void {\n    if (typeof document !== 'undefined') {\n      this.canvas = document.createElement('canvas');\n      this.ctx = this.canvas.getContext('2d', {\n        willReadFrequently: true,\n        alpha: true\n      });\n    }\n  }\n\n  private initializeWorker(): void {\n    if (typeof Worker !== 'undefined') {\n      // In production, would load actual worker script\n      // this.worker = new Worker('/workers/image-optimizer.js');\n    }\n  }\n\n  private detectDeviceCapabilities(): DeviceCapabilities {\n    const ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n    const isMobile = /Mobile|Android|iPhone|iPad/i.test(ua);\n    \n    return {\n      deviceType: isMobile ? 'mobile' : 'desktop',\n      pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n      memory: typeof navigator !== 'undefined' && 'deviceMemory' in navigator \n        ? (navigator as any).deviceMemory : 8,\n      maxTextureSize: this.getMaxTextureSize(),\n      supportedFormats: this.getSupportedFormats(),\n      hasWebGL: this.checkWebGLSupport(),\n      hasOffscreenCanvas: typeof OffscreenCanvas !== 'undefined'\n    };\n  }\n\n  private initializeQualityPresets(config: ImageOptimizerConfig): QualityPresets {\n    return {\n      ai: {\n        quality: 0.92,\n        maxDimension: 2048,\n        format: 'jpeg',\n        preserveMetadata: true,\n        sharpening: 0.3\n      },\n      desktop: {\n        quality: 0.85,\n        maxDimension: 1920,\n        format: 'jpeg',\n        preserveMetadata: false,\n        sharpening: 0.2\n      },\n      mobile: {\n        quality: 0.75,\n        maxDimension: 1280,\n        format: 'jpeg',\n        preserveMetadata: false,\n        sharpening: 0.1\n      },\n      lowEnd: {\n        quality: 0.65,\n        maxDimension: 800,\n        format: 'jpeg',\n        preserveMetadata: false,\n        sharpening: 0\n      },\n      thumbnail: {\n        quality: 0.7,\n        maxDimension: 300,\n        format: 'jpeg',\n        preserveMetadata: false,\n        sharpening: 0.4\n      }\n    };\n  }\n\n  private async loadImage(source: File | Blob | string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      \n      img.onload = () => resolve(img);\n      img.onerror = () => reject(new Error('Failed to load image'));\n      \n      if (typeof source === 'string') {\n        img.src = source;\n      } else {\n        img.src = URL.createObjectURL(source);\n      }\n    });\n  }\n\n  private async getImageSize(source: File | Blob | string): Promise<number> {\n    if (source instanceof File || source instanceof Blob) {\n      return source.size;\n    }\n    \n    // For URL, fetch to get size\n    try {\n      const response = await fetch(source, { method: 'HEAD' });\n      const contentLength = response.headers.get('content-length');\n      return contentLength ? parseInt(contentLength) : 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  private determineAIOptimalSettings(\n    img: HTMLImageElement,\n    options: CompressionOptions\n  ): CompressionSettings {\n    const baseSettings = { ...this.qualityPresets.ai };\n    \n    // Adjust based on image characteristics\n    const aspectRatio = img.width / img.height;\n    const isPortrait = aspectRatio < 0.8;\n    const isLandscape = aspectRatio > 1.2;\n    const isLarge = img.width > 3000 || img.height > 3000;\n    \n    if (isLarge) {\n      baseSettings.maxDimension = Math.min(baseSettings.maxDimension, 2048);\n    }\n    \n    if (options.maxSize) {\n      // Estimate quality needed for target size\n      const currentSize = img.width * img.height * 3; // Rough estimate\n      const targetSize = options.maxSize;\n      const ratio = targetSize / currentSize;\n      \n      if (ratio < 0.1) {\n        baseSettings.quality = Math.max(0.6, baseSettings.quality * ratio * 10);\n      }\n    }\n    \n    return { ...baseSettings, ...options };\n  }\n\n  private async preprocessForAI(\n    img: HTMLImageElement,\n    settings: CompressionSettings\n  ): Promise<HTMLCanvasElement> {\n    if (!this.canvas || !this.ctx) {\n      throw new Error('Canvas not initialized');\n    }\n\n    // Calculate dimensions\n    const { width, height } = this.calculateDimensions(\n      img.width,\n      img.height,\n      settings.maxDimension\n    );\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n\n    // Enable image smoothing for better quality\n    this.ctx.imageSmoothingEnabled = true;\n    this.ctx.imageSmoothingQuality = 'high';\n\n    // Draw image\n    this.ctx.drawImage(img, 0, 0, width, height);\n\n    // Apply preprocessing\n    if (settings.sharpening && settings.sharpening > 0) {\n      await this.applySharpeningFilter(this.ctx, settings.sharpening);\n    }\n\n    // Enhance contrast for better AI detection\n    if (settings.enhanceContrast) {\n      await this.enhanceContrast(this.ctx);\n    }\n\n    return this.canvas;\n  }\n\n  private async compress(\n    canvas: HTMLCanvasElement,\n    settings: CompressionSettings\n  ): Promise<CompressedResult> {\n    return new Promise((resolve, reject) => {\n      canvas.toBlob(\n        (blob) => {\n          if (!blob) {\n            reject(new Error('Failed to compress image'));\n            return;\n          }\n\n          resolve({\n            blob,\n            url: URL.createObjectURL(blob),\n            width: canvas.width,\n            height: canvas.height\n          });\n        },\n        `image/${settings.format}`,\n        settings.quality\n      );\n    });\n  }\n\n  private async validateAIQuality(\n    compressed: CompressedResult,\n    original: HTMLImageElement\n  ): Promise<number> {\n    // Simple quality validation based on compression artifacts\n    // In production, would use more sophisticated metrics\n    \n    const compressionRatio = compressed.blob.size / (original.width * original.height * 3);\n    const dimensionRatio = (compressed.width * compressed.height) / (original.width * original.height);\n    \n    // Score based on compression and dimension preservation\n    let score = 1.0;\n    \n    if (compressionRatio < 0.02) score -= 0.3; // Too compressed\n    if (dimensionRatio < 0.25) score -= 0.2;   // Too small\n    \n    return Math.max(0, Math.min(1, score));\n  }\n\n  private calculateDimensions(\n    width: number,\n    height: number,\n    maxDimension: number\n  ): { width: number; height: number } {\n    if (width <= maxDimension && height <= maxDimension) {\n      return { width, height };\n    }\n\n    const aspectRatio = width / height;\n    \n    if (width > height) {\n      return {\n        width: maxDimension,\n        height: Math.round(maxDimension / aspectRatio)\n      };\n    } else {\n      return {\n        width: Math.round(maxDimension * aspectRatio),\n        height: maxDimension\n      };\n    }\n  }\n\n  private async applySharpeningFilter(\n    ctx: CanvasRenderingContext2D,\n    strength: number\n  ): Promise<void> {\n    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n    const data = imageData.data;\n    const width = imageData.width;\n    const height = imageData.height;\n\n    // Simple unsharp mask\n    const kernel = [\n      0, -strength, 0,\n      -strength, 1 + 4 * strength, -strength,\n      0, -strength, 0\n    ];\n\n    // Apply convolution\n    const output = new Uint8ClampedArray(data);\n    \n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        for (let c = 0; c < 3; c++) {\n          let sum = 0;\n          for (let ky = -1; ky <= 1; ky++) {\n            for (let kx = -1; kx <= 1; kx++) {\n              const idx = ((y + ky) * width + (x + kx)) * 4 + c;\n              sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];\n            }\n          }\n          output[(y * width + x) * 4 + c] = sum;\n        }\n      }\n    }\n\n    const outputData = new ImageData(output, width, height);\n    ctx.putImageData(outputData, 0, 0);\n  }\n\n  private async enhanceContrast(ctx: CanvasRenderingContext2D): Promise<void> {\n    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n    const data = imageData.data;\n\n    // Calculate histogram\n    const histogram = new Array(256).fill(0);\n    for (let i = 0; i < data.length; i += 4) {\n      const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;\n      histogram[Math.floor(brightness)]++;\n    }\n\n    // Find min and max values (excluding outliers)\n    const total = data.length / 4;\n    const threshold = total * 0.01; // 1% threshold\n    let min = 0, max = 255;\n    let count = 0;\n    \n    for (let i = 0; i < 256; i++) {\n      count += histogram[i];\n      if (count > threshold) {\n        min = i;\n        break;\n      }\n    }\n    \n    count = 0;\n    for (let i = 255; i >= 0; i--) {\n      count += histogram[i];\n      if (count > threshold) {\n        max = i;\n        break;\n      }\n    }\n\n    // Apply contrast stretching\n    const range = max - min;\n    for (let i = 0; i < data.length; i += 4) {\n      for (let c = 0; c < 3; c++) {\n        data[i + c] = ((data[i + c] - min) / range) * 255;\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n  }\n\n  private async generatePlaceholder(img: HTMLImageElement): Promise<ImageVersion> {\n    const size = 32; // Tiny size for placeholder\n    \n    if (!this.canvas || !this.ctx) {\n      throw new Error('Canvas not initialized');\n    }\n\n    this.canvas.width = size;\n    this.canvas.height = size;\n    \n    // Draw tiny version\n    this.ctx.drawImage(img, 0, 0, size, size);\n    \n    // Apply blur effect\n    this.ctx.filter = 'blur(2px)';\n    this.ctx.drawImage(this.canvas, 0, 0);\n    \n    const blob = await new Promise<Blob>((resolve, reject) => {\n      this.canvas!.toBlob(\n        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create placeholder')),\n        'image/jpeg',\n        0.5\n      );\n    });\n\n    return {\n      name: 'placeholder',\n      blob,\n      url: URL.createObjectURL(blob),\n      width: size,\n      height: size,\n      quality: 'placeholder'\n    };\n  }\n\n  private getProgressiveSizes(img: HTMLImageElement): ProgressiveSize[] {\n    const maxDimension = Math.max(img.width, img.height);\n    const sizes: ProgressiveSize[] = [];\n\n    // Generate sizes: 25%, 50%, 75% of original\n    const percentages = [0.25, 0.5, 0.75];\n    \n    for (const pct of percentages) {\n      const size = Math.round(maxDimension * pct);\n      sizes.push({\n        maxDimension: size,\n        quality: 0.6 + (pct * 0.2), // Quality increases with size\n        name: `${Math.round(pct * 100)}%`\n      });\n    }\n\n    return sizes;\n  }\n\n  private async generateVersion(\n    img: HTMLImageElement,\n    size: ProgressiveSize\n  ): Promise<ImageVersion> {\n    const settings: CompressionSettings = {\n      maxDimension: size.maxDimension,\n      quality: size.quality,\n      format: 'jpeg'\n    };\n\n    const preprocessed = await this.preprocessForAI(img, settings);\n    const compressed = await this.compress(preprocessed, settings);\n\n    return {\n      name: size.name,\n      blob: compressed.blob,\n      url: compressed.url,\n      width: compressed.width,\n      height: compressed.height,\n      quality: 'progressive'\n    };\n  }\n\n  private async generateFinalVersion(\n    img: HTMLImageElement,\n    options: ProgressiveOptions\n  ): Promise<ImageVersion> {\n    const settings = this.qualityPresets.ai;\n    const preprocessed = await this.preprocessForAI(img, settings);\n    const compressed = await this.compress(preprocessed, settings);\n\n    return {\n      name: 'final',\n      blob: compressed.blob,\n      url: compressed.url,\n      width: compressed.width,\n      height: compressed.height,\n      quality: 'high'\n    };\n  }\n\n  private determineLoadingStrategy(versions: ImageVersion[]): LoadingStrategy {\n    // Determine optimal loading strategy based on versions\n    const totalSize = versions.reduce((sum, v) => sum + v.blob.size, 0);\n    const hasLargeImages = versions.some(v => v.blob.size > 500 * 1024);\n\n    if (hasLargeImages) {\n      return {\n        type: 'progressive',\n        preloadCount: 2,\n        lazyLoadThreshold: 1000 // 1 second\n      };\n    } else {\n      return {\n        type: 'eager',\n        preloadCount: versions.length,\n        lazyLoadThreshold: 0\n      };\n    }\n  }\n\n  private async getNetworkConditions(): Promise<NetworkConditions> {\n    if ('connection' in navigator) {\n      const conn = (navigator as any).connection;\n      return {\n        effectiveType: conn.effectiveType || '4g',\n        downlink: conn.downlink || 10,\n        rtt: conn.rtt || 50,\n        saveData: conn.saveData || false\n      };\n    }\n\n    // Default to good connection\n    return {\n      effectiveType: '4g',\n      downlink: 10,\n      rtt: 50,\n      saveData: false\n    };\n  }\n\n  private getMaxTextureSize(): number {\n    if (typeof document === 'undefined') return 4096;\n\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    \n    if (gl) {\n      return gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n\n    return 4096; // Default\n  }\n\n  private getSupportedFormats(): string[] {\n    const formats = ['jpeg', 'png'];\n    \n    if (typeof document !== 'undefined') {\n      const canvas = document.createElement('canvas');\n      canvas.width = 1;\n      canvas.height = 1;\n      \n      // Check WebP support\n      try {\n        canvas.toDataURL('image/webp');\n        formats.push('webp');\n      } catch {}\n      \n      // Check AVIF support\n      try {\n        canvas.toDataURL('image/avif');\n        formats.push('avif');\n      } catch {}\n    }\n\n    return formats;\n  }\n\n  private checkWebGLSupport(): boolean {\n    if (typeof document === 'undefined') return false;\n\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    return !!gl;\n  }\n\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  private async findDuplicateImages(): Promise<StoredImage[]> {\n    // In production, would use perceptual hashing\n    return this.storageManager.findDuplicates();\n  }\n\n  private async findOversizedImages(maxSize: number): Promise<StoredImage[]> {\n    return this.storageManager.findLargerThan(maxSize);\n  }\n\n  private generateStorageSuggestions(\n    analysis: StorageAnalysis,\n    report: StorageReport\n  ): string[] {\n    const suggestions: string[] = [];\n\n    if (analysis.totalSize > 100 * 1024 * 1024) {\n      suggestions.push('Consider enabling cloud backup for older images');\n    }\n\n    if (analysis.duplicateCount > 10) {\n      suggestions.push('Enable automatic duplicate detection');\n    }\n\n    if (report.freedSpace < analysis.totalSize * 0.1) {\n      suggestions.push('Optimization impact was limited, consider more aggressive compression');\n    }\n\n    return suggestions;\n  }\n\n  private getAdaptiveSizes(\n    capabilities: DeviceCapabilities,\n    network: NetworkConditions\n  ): ProgressiveSize[] {\n    const sizes: ProgressiveSize[] = [];\n\n    if (network.effectiveType === '2g' || network.saveData) {\n      // Very limited sizes\n      sizes.push({ maxDimension: 400, quality: 0.6, name: 'low' });\n      sizes.push({ maxDimension: 800, quality: 0.7, name: 'medium' });\n    } else if (network.effectiveType === '3g') {\n      // Moderate sizes\n      sizes.push({ maxDimension: 600, quality: 0.7, name: 'low' });\n      sizes.push({ maxDimension: 1200, quality: 0.8, name: 'medium' });\n    } else {\n      // Full range\n      sizes.push({ maxDimension: 800, quality: 0.75, name: 'low' });\n      sizes.push({ maxDimension: 1600, quality: 0.85, name: 'medium' });\n      \n      if (capabilities.deviceType === 'desktop') {\n        sizes.push({ maxDimension: 2400, quality: 0.9, name: 'high' });\n      }\n    }\n\n    return sizes;\n  }\n\n  private getDeviceRecommendations(\n    capabilities: DeviceCapabilities,\n    network: NetworkConditions\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (capabilities.memory < 4) {\n      recommendations.push('Limit concurrent image loads to preserve memory');\n      recommendations.push('Use progressive loading for all images');\n    }\n\n    if (network.saveData) {\n      recommendations.push('Data saver mode detected - using minimal quality');\n    }\n\n    if (!capabilities.hasWebGL) {\n      recommendations.push('WebGL not available - some optimizations disabled');\n    }\n\n    if (capabilities.supportedFormats.includes('webp')) {\n      recommendations.push('WebP format available for better compression');\n    }\n\n    return recommendations;\n  }\n\n  // Cleanup\n  destroy(): void {\n    if (this.worker) {\n      this.worker.terminate();\n    }\n    this.storageManager.cleanup();\n  }\n}\n\n// Supporting classes\n\nclass StorageManager {\n  private dbName = 'image_optimizer_storage';\n  private storeName = 'images';\n  private maxSize: number;\n  private db: IDBDatabase | null = null;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n    this.initDB();\n  }\n\n  private async initDB(): Promise<void> {\n    // Initialize IndexedDB\n  }\n\n  async store(hash: string, image: CompressedImage): Promise<void> {\n    // Store compressed image\n  }\n\n  async get(hash: string): Promise<StoredImage | null> {\n    // Retrieve stored image\n    return null;\n  }\n\n  async remove(hash: string): Promise<void> {\n    // Remove image\n  }\n\n  async replace(hash: string, image: CompressedImage): Promise<void> {\n    // Replace existing image\n  }\n\n  async analyze(): Promise<StorageAnalysis> {\n    return {\n      totalSize: 0,\n      imageCount: 0,\n      duplicateCount: 0,\n      averageSize: 0,\n      largestImage: 0\n    };\n  }\n\n  async findDuplicates(): Promise<StoredImage[]> {\n    return [];\n  }\n\n  async findLargerThan(size: number): Promise<StoredImage[]> {\n    return [];\n  }\n\n  async cleanOldItems(maxAge: number): Promise<{ count: number; size: number }> {\n    return { count: 0, size: 0 };\n  }\n\n  cleanup(): void {\n    // Cleanup resources\n  }\n}\n\n// Types\n\ninterface ImageOptimizerConfig {\n  maxStorageSize?: number;\n  enableWorker?: boolean;\n  qualityPresets?: Partial<QualityPresets>;\n}\n\ninterface CompressionOptions {\n  maxSize?: number;\n  maxDimension?: number;\n  quality?: number;\n  format?: 'jpeg' | 'png' | 'webp' | 'avif';\n  preserveQuality?: boolean;\n  forceCompression?: boolean;\n  enhanceContrast?: boolean;\n}\n\ninterface CompressionSettings extends CompressionOptions {\n  quality: number;\n  maxDimension: number;\n  format: string;\n  preserveMetadata?: boolean;\n  sharpening?: number;\n}\n\ninterface CompressedImage {\n  blob: Blob;\n  url: string;\n  metadata: {\n    originalSize: number;\n    compressedSize: number;\n    compressionRatio: number;\n    dimensions: {\n      width: number;\n      height: number;\n    };\n    quality: number;\n    format: string;\n    processingTime: number;\n    aiQualityScore: number;\n  };\n}\n\ninterface CompressedResult {\n  blob: Blob;\n  url: string;\n  width: number;\n  height: number;\n}\n\ninterface ProgressiveOptions {\n  sizes?: ProgressiveSize[];\n  includeWebP?: boolean;\n  includeAVIF?: boolean;\n}\n\ninterface ProgressiveSize {\n  maxDimension: number;\n  quality: number;\n  name: string;\n}\n\ninterface ImageVersion {\n  name: string;\n  blob: Blob;\n  url: string;\n  width: number;\n  height: number;\n  quality: 'placeholder' | 'progressive' | 'high';\n}\n\ninterface ProgressiveImage {\n  placeholder: ImageVersion;\n  versions: ImageVersion[];\n  final: ImageVersion;\n  loadingStrategy: LoadingStrategy;\n}\n\ninterface LoadingStrategy {\n  type: 'eager' | 'lazy' | 'progressive';\n  preloadCount: number;\n  lazyLoadThreshold: number;\n}\n\ninterface DeviceCapabilities {\n  deviceType: 'mobile' | 'tablet' | 'desktop';\n  pixelRatio: number;\n  memory: number; // GB\n  maxTextureSize: number;\n  supportedFormats: string[];\n  hasWebGL: boolean;\n  hasOffscreenCanvas: boolean;\n}\n\ninterface NetworkConditions {\n  effectiveType: '2g' | 'slow-2g' | '3g' | '4g';\n  downlink: number; // Mbps\n  rtt: number; // ms\n  saveData: boolean;\n}\n\ninterface QualityPresets {\n  ai: CompressionSettings;\n  desktop: CompressionSettings;\n  mobile: CompressionSettings;\n  lowEnd: CompressionSettings;\n  thumbnail: CompressionSettings;\n}\n\ninterface StorageOptimizationOptions {\n  maxImageSize?: number;\n  cleanCache?: boolean;\n  maxCacheAge?: number;\n}\n\ninterface StorageReport {\n  freedSpace: number;\n  optimizedImages: number;\n  removedImages: number;\n  duration: number;\n  suggestions: string[];\n}\n\ninterface AdaptiveImage {\n  primary: CompressedImage;\n  versions: ImageVersion[];\n  deviceProfile: {\n    type: string;\n    pixelRatio: number;\n    memory: number;\n    network: string;\n  };\n  recommendations: string[];\n}\n\ninterface BatchOptions extends CompressionOptions {\n  concurrency?: number;\n}\n\ninterface BatchResult {\n  successful: CompressedImage[];\n  failed: BatchError[];\n  summary: {\n    processed: number;\n    failed: number;\n    totalOriginalSize: number;\n    totalCompressedSize: number;\n    averageCompressionRatio: number;\n    savedSpace: number;\n  };\n}\n\ninterface BatchError {\n  index: number;\n  error: string;\n  image: File | Blob | string;\n}\n\ninterface StoredImage {\n  hash: string;\n  blob: Blob;\n  size: number;\n  timestamp: number;\n}\n\ninterface StorageAnalysis {\n  totalSize: number;\n  imageCount: number;\n  duplicateCount: number;\n  averageSize: number;\n  largestImage: number;\n}\n\n// Default configuration\nconst defaultConfig: ImageOptimizerConfig = {\n  maxStorageSize: 100 * 1024 * 1024, // 100MB\n  enableWorker: true\n};\n\n// Export factory function\nexport const createImageOptimizer = (config?: Partial<ImageOptimizerConfig>): ImageOptimizer => {\n  return new ImageOptimizer({ ...defaultConfig, ...config });\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/__tests__/simple-test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6458,6461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6458,6461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Simple Test for VRBO Browser Scraper\n// Basic validation without complex dependencies\n\nimport { describe, expect, it, vi } from 'vitest';\n\n// Mock the environment and logger dependencies\nprocess.env.NODE_ENV = 'test';\nprocess.env.VITE_SUPABASE_URL = 'test-url';\nprocess.env.VITE_SUPABASE_ANON_KEY = 'test-key';\n\nconst mockLogger = {\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n  debug: () => {}\n};\n\nconst mockAiDecisionLogger = {\n  logSimpleDecision: () => Promise.resolve()\n};\n\nconst mockErrorReporter = {\n  reportError: () => {}\n};\n\n// Mock the dependencies\nvi.mock('../../../utils/logger', () => ({\n  logger: mockLogger\n}));\n\nvi.mock('../../ai/decision-logger', () => ({\n  aiDecisionLogger: mockAiDecisionLogger\n}));\n\nvi.mock('../../monitoring/error-reporter', () => ({\n  errorReporter: mockErrorReporter\n}));\n\ndescribe('VRBO Browser Scraper - Basic Tests', () => {\n  it('should validate VRBO URLs correctly', () => {\n    // Import the URL validation logic\n    const validUrls = [\n      'https://www.vrbo.com/12345',\n      'https://vrbo.com/12345/test-property',\n      'https://www.homeaway.com/12345'\n    ];\n\n    const invalidUrls = [\n      'https://airbnb.com/rooms/12345',\n      'not-a-url',\n      '',\n      'https://booking.com/hotel/test'\n    ];\n\n    // Test URL validation pattern\n    const vrboPattern = /^https?:\\/\\/(www\\.)?(vrbo|homeaway|vacationrentals)\\.com\\/\\d+/;\n    \n    validUrls.forEach(url => {\n      expect(vrboPattern.test(url)).toBe(true);\n    });\n\n    invalidUrls.forEach(url => {\n      expect(vrboPattern.test(url)).toBe(false);\n    });\n  });\n\n  it('should extract property ID from URL', () => {\n    const testCases = [\n      { url: 'https://www.vrbo.com/12345', expected: '12345' },\n      { url: 'https://vrbo.com/67890/test-property', expected: '67890' },\n      { url: 'https://www.homeaway.com/555/nice-place', expected: '555' }\n    ];\n\n    testCases.forEach(({ url, expected }) => {\n      const match = url.match(/\\/(\\d+)/);\n      const propertyId = match ? match[1] : null;\n      expect(propertyId).toBe(expected);\n    });\n  });\n\n  it('should categorize images correctly', () => {\n    const testImages = [\n      { url: 'https://images.vrbo.com/kitchen-1.jpg', expected: 'kitchen' },\n      { url: 'https://images.vrbo.com/bedroom-master.jpg', expected: 'bedroom' },\n      { url: 'https://images.vrbo.com/exterior-view.jpg', expected: 'exterior' },\n      { url: 'https://images.vrbo.com/bathroom-1.jpg', expected: 'bathroom' },\n      { url: 'https://images.vrbo.com/living-room.jpg', expected: 'living_area' },\n      { url: 'https://images.vrbo.com/pool-deck.jpg', expected: 'outdoor_space' },\n      { url: 'https://images.vrbo.com/random-image.jpg', expected: 'interior' }\n    ];\n\n    testImages.forEach(({ url, expected }) => {\n      const category = categorizeImageByUrl(url);\n      expect(category).toBe(expected);\n    });\n  });\n\n  it('should deduplicate images correctly', () => {\n    const images = [\n      { url: 'https://images.vrbo.com/image1.jpg', alt: 'Image 1' },\n      { url: 'https://images.vrbo.com/image2.jpg', alt: 'Image 2' },\n      { url: 'https://images.vrbo.com/image1.jpg?version=2', alt: 'Image 1 duplicate' },\n      { url: 'https://images.vrbo.com/image3.jpg', alt: 'Image 3' }\n    ];\n\n    const deduped = deduplicateImages(images);\n    expect(deduped).toHaveLength(3);\n    \n    // Should keep the first occurrence\n    expect(deduped.find(img => img.alt === 'Image 1')).toBeDefined();\n    expect(deduped.find(img => img.alt === 'Image 1 duplicate')).toBeUndefined();\n  });\n\n  it('should validate browser configuration', () => {\n    const config = {\n      headless: true,\n      scrollCycles: 5,\n      scrollWaitTime: 3000,\n      browserTimeout: 120000,\n      enableStealth: true\n    };\n\n    expect(config.headless).toBe(true);\n    expect(config.scrollCycles).toBeGreaterThan(0);\n    expect(config.scrollCycles).toBeLessThanOrEqual(10);\n    expect(config.scrollWaitTime).toBeGreaterThan(1000);\n    expect(config.browserTimeout).toBeGreaterThan(30000);\n  });\n\n  it('should handle gallery automation result correctly', () => {\n    const mockGalleryResult = {\n      images: [\n        { url: 'https://images.vrbo.com/gallery1.jpg', alt: 'Gallery 1' },\n        { url: 'https://images.vrbo.com/gallery2.jpg', alt: 'Gallery 2' }\n      ],\n      totalImagesFound: 2,\n      scrollCyclesCompleted: 5,\n      loadingTime: 5000,\n      screenshots: [],\n      errors: []\n    };\n\n    expect(mockGalleryResult.images).toHaveLength(2);\n    expect(mockGalleryResult.scrollCyclesCompleted).toBe(5);\n    expect(mockGalleryResult.loadingTime).toBeGreaterThan(0);\n    expect(mockGalleryResult.errors).toHaveLength(0);\n  });\n\n  it('should calculate data completeness score', () => {\n    const testData = {\n      title: 'Test Property',\n      description: 'A great property',\n      amenities: ['WiFi', 'Pool', 'Kitchen'],\n      images: Array(15).fill(null).map((_, i) => ({ url: `image${i}.jpg` })),\n      specifications: {\n        bedrooms: 3,\n        bathrooms: 2,\n        maxGuests: 6\n      }\n    };\n\n    const score = calculateDataCompleteness(testData);\n    expect(score).toBeGreaterThan(50);\n    expect(score).toBeLessThanOrEqual(100);\n  });\n});\n\n// Helper functions for testing\nfunction categorizeImageByUrl(url: string): string {\n  const lowerUrl = url.toLowerCase();\n  \n  if (lowerUrl.includes('exterior') || lowerUrl.includes('outside')) return 'exterior';\n  if (lowerUrl.includes('kitchen')) return 'kitchen';\n  if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n  if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n  if (lowerUrl.includes('living') || lowerUrl.includes('lounge')) return 'living_area';\n  if (lowerUrl.includes('pool') || lowerUrl.includes('deck') || lowerUrl.includes('patio')) return 'outdoor_space';\n  if (lowerUrl.includes('view') || lowerUrl.includes('scenic')) return 'view';\n  if (lowerUrl.includes('amenity')) return 'amenity';\n  \n  return 'interior';\n}\n\nfunction deduplicateImages(images: Array<{url: string, alt: string}>): Array<{url: string, alt: string}> {\n  const seen = new Set<string>();\n  const unique: Array<{url: string, alt: string}> = [];\n  \n  images.forEach(img => {\n    const normalizedUrl = img.url.replace(/\\?.*$/, '').toLowerCase();\n    \n    if (!seen.has(normalizedUrl)) {\n      seen.add(normalizedUrl);\n      unique.push(img);\n    }\n  });\n  \n  return unique;\n}\n\nfunction calculateDataCompleteness(data: any): number {\n  let score = 0;\n  \n  // Base property data (40%)\n  if (data.title) score += 10;\n  if (data.description) score += 10;\n  if (data.amenities && data.amenities.length > 0) score += 10;\n  if (data.specifications?.bedrooms) score += 5;\n  if (data.specifications?.bathrooms) score += 5;\n  \n  // Image extraction (50%)\n  if (data.images && data.images.length > 0) score += 20;\n  if (data.images && data.images.length >= 10) score += 10;\n  if (data.images && data.images.length >= 20) score += 10;\n  if (data.images && data.images.length >= 30) score += 10;\n  \n  // Additional completeness (10%)\n  if (data.specifications?.maxGuests) score += 5;\n  if (data.amenities && data.amenities.length >= 5) score += 5;\n  \n  return Math.round(Math.min(score, 100));\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/__tests__/test-runner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1012,1015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1012,1015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":411,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":411,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11480,11483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11480,11483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":418,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11688,11691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11688,11691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Test Runner for VRBO Browser Scraper\n// Simple validation script to test the scraper implementation\n\nimport { scrapeBrowserVRBOProperty } from '../vrbo-browser-scraper';\nimport { scrapeVRBOProperty } from '../vrbo-scraper';\nimport { logger } from '../../../utils/logger';\n\n// Test configuration\nconst TEST_CONFIG = {\n  // Use a real VRBO URL for testing (this should be a valid property)\n  testUrl: 'https://www.vrbo.com/1234567/test-property',\n  \n  // Mock URL for testing without making real requests\n  mockUrl: 'https://www.vrbo.com/mock-test',\n  \n  // Test options\n  options: {\n    headless: true,\n    scrollCycles: 3, // Reduced for faster testing\n    scrollWaitTime: 2000,\n    browserTimeout: 30000,\n    useStaticFallback: true,\n    enableScreenshots: false\n  }\n};\n\n/**\n * Test suite for VRBO scraper functionality\n */\nclass VRBOScraperTestRunner {\n  private testResults: Array<{\n    testName: string;\n    status: 'passed' | 'failed' | 'skipped';\n    duration: number;\n    error?: string;\n    details?: any;\n  }> = [];\n\n  /**\n   * Runs all tests\n   */\n  async runAllTests(): Promise<void> {\n    console.log('ðŸš€ Starting VRBO Scraper Test Suite');\n    console.log('=====================================');\n\n    // Run individual tests\n    await this.testUrlValidation();\n    await this.testBrowserScraperCreation();\n    await this.testStaticFallback();\n    await this.testErrorHandling();\n    await this.testMockScraping();\n    \n    // Skip real scraping test to avoid making actual requests\n    // await this.testRealScraping();\n\n    this.printTestResults();\n  }\n\n  /**\n   * Test URL validation\n   */\n  private async testUrlValidation(): Promise<void> {\n    const testName = 'URL Validation';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      const validUrls = [\n        'https://www.vrbo.com/12345',\n        'https://vrbo.com/12345/test-property',\n        'https://www.homeaway.com/12345'\n      ];\n\n      const invalidUrls = [\n        'https://airbnb.com/rooms/12345',\n        'not-a-url',\n        '',\n        'https://booking.com/hotel/test'\n      ];\n\n      // Test valid URLs (should not immediately fail)\n      for (const url of validUrls) {\n        try {\n          // Just test that it doesn't throw on URL validation\n          const result = await scrapeBrowserVRBOProperty(url, {\n            ...TEST_CONFIG.options,\n            browserTimeout: 5000 // Short timeout for validation test\n          });\n          \n          // We expect this to potentially fail due to network/page issues, \n          // but not due to URL validation\n          if (!result.success && result.errors.some(e => e.message.includes('Invalid VRBO URL'))) {\n            throw new Error(`Valid URL rejected: ${url}`);\n          }\n        } catch (error) {\n          // Network errors are acceptable for this test\n          if (error instanceof Error && !error.message.includes('Invalid VRBO URL')) {\n            // This is fine - network/timeout errors are expected\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          validUrlsTested: validUrls.length,\n          invalidUrlsTested: invalidUrls.length\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Test browser scraper creation\n   */\n  private async testBrowserScraperCreation(): Promise<void> {\n    const testName = 'Browser Scraper Creation';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      // Test that scraper can be created with various configurations\n      const { createVRBOBrowserScraper } = await import('../vrbo-browser-scraper');\n      \n      const scraper1 = createVRBOBrowserScraper();\n      const scraper2 = createVRBOBrowserScraper({}, {\n        headless: true,\n        scrollCycles: 5,\n        enableStealth: true\n      });\n      \n      // Test cleanup\n      await scraper1.cleanup();\n      await scraper2.cleanup();\n      \n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          scrapersCreated: 2\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Test static fallback functionality\n   */\n  private async testStaticFallback(): Promise<void> {\n    const testName = 'Static Fallback';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      // Test static scraping (should work without browser)\n      const result = await scrapeVRBOProperty(TEST_CONFIG.mockUrl);\n      \n      // Should return fallback data\n      expect(result).toBeDefined();\n      expect(result.title).toBeDefined();\n      expect(result.vrboId).toBeDefined();\n      \n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          fallbackDataReturned: true,\n          title: result.title,\n          amenitiesCount: result.amenities?.length || 0\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Test error handling\n   */\n  private async testErrorHandling(): Promise<void> {\n    const testName = 'Error Handling';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      // Test with invalid URL - should handle gracefully\n      const result = await scrapeBrowserVRBOProperty('invalid-url', {\n        ...TEST_CONFIG.options,\n        browserTimeout: 5000\n      });\n      \n      // Should fail but not crash\n      expect(result.success).toBe(false);\n      expect(result.errors).toBeDefined();\n      expect(result.errors.length).toBeGreaterThan(0);\n      \n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          errorHandledGracefully: true,\n          errorsCount: result.errors.length\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Test mock scraping (no real network requests)\n   */\n  private async testMockScraping(): Promise<void> {\n    const testName = 'Mock Scraping';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      // Test the main scraper function with mock data\n      const result = await scrapeVRBOProperty(TEST_CONFIG.mockUrl);\n      \n      // Should return some data (fallback if nothing else)\n      expect(result).toBeDefined();\n      expect(result.vrboId).toBeDefined();\n      expect(result.title).toBeDefined();\n      expect(result.sourceUrl).toBe(TEST_CONFIG.mockUrl);\n      \n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          propertyId: result.vrboId,\n          title: result.title,\n          amenitiesCount: result.amenities?.length || 0,\n          photosCount: result.photos?.length || 0\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Test real scraping (disabled by default)\n   */\n  private async testRealScraping(): Promise<void> {\n    const testName = 'Real Scraping';\n    console.log(`\\nðŸ“‹ Running ${testName}...`);\n    \n    try {\n      const startTime = Date.now();\n      \n      // This would test with a real VRBO URL\n      const result = await scrapeBrowserVRBOProperty(TEST_CONFIG.testUrl, TEST_CONFIG.options);\n      \n      // Validate results\n      expect(result.success).toBe(true);\n      expect(result.data?.propertyData).toBeDefined();\n      expect(result.data?.totalImages).toBeGreaterThan(0);\n      \n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'passed',\n        duration,\n        details: {\n          totalImages: result.data?.totalImages,\n          galleryImages: result.data?.galleryImages.length,\n          staticImages: result.data?.staticImages.length,\n          scrollCycles: result.data?.galleryLoadingResult.scrollCyclesCompleted\n        }\n      });\n      \n      console.log(`âœ… ${testName} passed (${duration}ms)`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      this.testResults.push({\n        testName,\n        status: 'failed',\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      console.log(`âŒ ${testName} failed:`, error);\n    }\n  }\n\n  /**\n   * Print test results summary\n   */\n  private printTestResults(): void {\n    console.log('\\nðŸ“Š Test Results Summary');\n    console.log('========================');\n    \n    const passed = this.testResults.filter(r => r.status === 'passed').length;\n    const failed = this.testResults.filter(r => r.status === 'failed').length;\n    const total = this.testResults.length;\n    \n    console.log(`Total Tests: ${total}`);\n    console.log(`Passed: ${passed}`);\n    console.log(`Failed: ${failed}`);\n    console.log(`Success Rate: ${Math.round((passed / total) * 100)}%`);\n    \n    console.log('\\nDetailed Results:');\n    this.testResults.forEach(result => {\n      const status = result.status === 'passed' ? 'âœ…' : 'âŒ';\n      console.log(`${status} ${result.testName} (${result.duration}ms)`);\n      \n      if (result.error) {\n        console.log(`   Error: ${result.error}`);\n      }\n      \n      if (result.details) {\n        console.log(`   Details:`, result.details);\n      }\n    });\n  }\n}\n\n// Simple expect helper for testing\nfunction expect(actual: any) {\n  return {\n    toBeDefined: () => {\n      if (actual === undefined || actual === null) {\n        throw new Error(`Expected value to be defined, but got ${actual}`);\n      }\n    },\n    toBe: (expected: any) => {\n      if (actual !== expected) {\n        throw new Error(`Expected ${actual} to be ${expected}`);\n      }\n    },\n    toBeGreaterThan: (expected: number) => {\n      if (actual <= expected) {\n        throw new Error(`Expected ${actual} to be greater than ${expected}`);\n      }\n    }\n  };\n}\n\n// Export test runner\nexport { VRBOScraperTestRunner };\n\n// Run tests if this file is executed directly\nif (require.main === module) {\n  const testRunner = new VRBOScraperTestRunner();\n  testRunner.runAllTests().catch(console.error);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/__tests__/vrbo-browser-scraper.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3910,3913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3910,3913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3944,3947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3944,3947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3975,3978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3975,3978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5031,5034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5031,5034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5610,5613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5610,5613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":231,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6198,6201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6198,6201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6263,6266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6263,6266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":582,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":582,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17988,17991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17988,17991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":597,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":597,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18538,18541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18538,18541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Comprehensive Test Suite for VRBO Browser Scraper\n// Tests browser automation, gallery loading, and dynamic image extraction\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach, vi, Mock } from 'vitest';\nimport { VRBOBrowserScraper, createVRBOBrowserScraper, scrapeBrowserVRBOProperty } from '../vrbo-browser-scraper';\nimport { BrowserManager } from '../browser-manager';\nimport { VRBOGalleryAutomation } from '../vrbo-gallery-automation';\nimport type { PhotoData, VRBOPropertyData } from '../types';\n\n// Mock Puppeteer\nconst mockPage = {\n  goto: vi.fn(),\n  waitForSelector: vi.fn(),\n  click: vi.fn(),\n  evaluate: vi.fn(),\n  waitForTimeout: vi.fn(),\n  mouse: {\n    move: vi.fn()\n  },\n  keyboard: {\n    press: vi.fn()\n  },\n  content: vi.fn(),\n  screenshot: vi.fn(),\n  viewport: vi.fn(),\n  metrics: vi.fn(),\n  setUserAgent: vi.fn(),\n  setExtraHTTPHeaders: vi.fn(),\n  setRequestInterception: vi.fn(),\n  setDefaultTimeout: vi.fn(),\n  setDefaultNavigationTimeout: vi.fn(),\n  evaluateOnNewDocument: vi.fn(),\n  close: vi.fn(),\n  isClosed: vi.fn(),\n  on: vi.fn(),\n  $: vi.fn(),\n  $$: vi.fn()\n};\n\nconst mockBrowser = {\n  newPage: vi.fn(),\n  close: vi.fn(),\n  connected: vi.fn()\n};\n\nconst mockPuppeteer = {\n  launch: vi.fn()\n};\n\n// Mock browser manager\nvi.mock('../browser-manager', () => ({\n  BrowserManager: vi.fn().mockImplementation(() => ({\n    createSession: vi.fn(),\n    closeSession: vi.fn(),\n    closeAllSessions: vi.fn(),\n    getSession: vi.fn(),\n    isSessionHealthy: vi.fn(),\n    randomDelay: vi.fn(),\n    humanMouseMove: vi.fn(),\n    humanScroll: vi.fn(),\n    config: {\n      userAgent: 'Test-Agent'\n    }\n  }))\n}));\n\n// Mock gallery automation\nvi.mock('../vrbo-gallery-automation', () => ({\n  VRBOGalleryAutomation: vi.fn().mockImplementation(() => ({\n    loadAllGalleryImages: vi.fn()\n  }))\n}));\n\n// Mock AI decision logger\nvi.mock('../../ai/decision-logger', () => ({\n  aiDecisionLogger: {\n    logSimpleDecision: vi.fn()\n  }\n}));\n\n// Mock logger\nvi.mock('../../../utils/logger', () => ({\n  logger: {\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n    debug: vi.fn()\n  }\n}));\n\n// Mock error reporter\nvi.mock('../../monitoring/error-reporter', () => ({\n  errorReporter: {\n    reportError: vi.fn()\n  }\n}));\n\n// Test data\nconst mockVRBOUrl = 'https://www.vrbo.com/12345/test-property';\nconst mockPropertyData: VRBOPropertyData = {\n  vrboId: '12345',\n  sourceUrl: mockVRBOUrl,\n  title: 'Test Property',\n  description: 'A beautiful test property',\n  amenities: [\n    { name: 'WiFi', verified: true, category: 'connectivity', priority: 'essential' },\n    { name: 'Pool', verified: true, category: 'outdoor', priority: 'important' }\n  ],\n  photos: [],\n  rooms: [],\n  specifications: {\n    propertyType: 'house',\n    bedrooms: 3,\n    bathrooms: 2,\n    maxGuests: 6\n  },\n  location: {\n    city: 'Test City',\n    state: 'Test State',\n    country: 'Test Country'\n  },\n  instantBook: false,\n  cancellationPolicy: 'Flexible',\n  houseRules: [],\n  lastUpdated: new Date()\n};\n\nconst mockGalleryImages: PhotoData[] = [\n  {\n    url: 'https://images.vrbo.com/gallery1.jpg',\n    thumbnailUrl: 'https://images.vrbo.com/gallery1_thumb.jpg',\n    alt: 'Living room',\n    category: 'living_area',\n    room: 'living_room',\n    size: { width: 1200, height: 800 },\n    order: 1\n  },\n  {\n    url: 'https://images.vrbo.com/gallery2.jpg',\n    thumbnailUrl: 'https://images.vrbo.com/gallery2_thumb.jpg',\n    alt: 'Kitchen',\n    category: 'kitchen',\n    room: 'kitchen',\n    size: { width: 1200, height: 800 },\n    order: 2\n  }\n];\n\nconst mockStaticImages: PhotoData[] = [\n  {\n    url: 'https://images.vrbo.com/static1.jpg',\n    thumbnailUrl: 'https://images.vrbo.com/static1_thumb.jpg',\n    alt: 'Exterior',\n    category: 'exterior',\n    size: { width: 800, height: 600 },\n    order: 1\n  }\n];\n\ndescribe('VRBOBrowserScraper', () => {\n  let browserScraper: VRBOBrowserScraper;\n  let mockBrowserManager: any;\n  let mockGalleryAutomation: any;\n  let mockBrowserSession: any;\n\n  beforeAll(() => {\n    // Mock Puppeteer\n    vi.mock('puppeteer', () => ({\n      default: mockPuppeteer\n    }));\n\n    // Setup mock responses\n    mockPuppeteer.launch.mockResolvedValue(mockBrowser);\n    mockBrowser.newPage.mockResolvedValue(mockPage);\n    mockBrowser.connected.mockReturnValue(true);\n    mockPage.isClosed.mockReturnValue(false);\n    mockPage.goto.mockResolvedValue(undefined);\n    mockPage.content.mockResolvedValue('<html><body>Test content</body></html>');\n    mockPage.viewport.mockResolvedValue({ width: 1920, height: 1080 });\n    mockPage.metrics.mockResolvedValue({ JSHeapUsedSize: 1000000 });\n    mockPage.evaluate.mockResolvedValue('Mozilla/5.0 Test Agent');\n  });\n\n  beforeEach(() => {\n    // Reset all mocks\n    vi.clearAllMocks();\n\n    // Setup browser session mock\n    mockBrowserSession = {\n      browser: mockBrowser,\n      page: mockPage,\n      sessionId: 'test-session-123',\n      startTime: Date.now(),\n      isActive: true\n    };\n\n    // Setup browser manager mock\n    mockBrowserManager = new (BrowserManager as any)();\n    mockBrowserManager.createSession.mockResolvedValue(mockBrowserSession);\n    mockBrowserManager.closeSession.mockResolvedValue(undefined);\n    mockBrowserManager.closeAllSessions.mockResolvedValue(undefined);\n    mockBrowserManager.isSessionHealthy.mockResolvedValue(true);\n    mockBrowserManager.randomDelay.mockResolvedValue(undefined);\n    mockBrowserManager.humanMouseMove.mockResolvedValue(undefined);\n    mockBrowserManager.humanScroll.mockResolvedValue(undefined);\n\n    // Setup gallery automation mock\n    mockGalleryAutomation = new (VRBOGalleryAutomation as any)();\n    mockGalleryAutomation.loadAllGalleryImages.mockResolvedValue({\n      images: mockGalleryImages,\n      totalImagesFound: mockGalleryImages.length,\n      scrollCyclesCompleted: 5,\n      loadingTime: 5000,\n      screenshots: [],\n      errors: []\n    });\n\n    // Create scraper instance\n    browserScraper = createVRBOBrowserScraper({\n      timeout: 30000,\n      retries: 3,\n      rateLimit: 10\n    }, {\n      headless: true,\n      scrollCycles: 5,\n      scrollWaitTime: 3000,\n      enableStealth: true\n    });\n\n    // Replace internal instances with mocks\n    (browserScraper as any).browserManager = mockBrowserManager;\n    (browserScraper as any).galleryAutomation = mockGalleryAutomation;\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterAll(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('Constructor and Configuration', () => {\n    it('should create scraper with default configuration', () => {\n      const scraper = createVRBOBrowserScraper();\n      expect(scraper).toBeInstanceOf(VRBOBrowserScraper);\n    });\n\n    it('should accept custom browser configuration', () => {\n      const customConfig = {\n        headless: false,\n        scrollCycles: 10,\n        scrollWaitTime: 5000,\n        enableStealth: false\n      };\n\n      const scraper = createVRBOBrowserScraper({}, customConfig);\n      expect(scraper).toBeInstanceOf(VRBOBrowserScraper);\n    });\n  });\n\n  describe('Browser Session Management', () => {\n    it('should create and close browser session successfully', async () => {\n      mockBrowserManager.createSession.mockResolvedValue(mockBrowserSession);\n      mockBrowserManager.closeSession.mockResolvedValue(undefined);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(mockBrowserManager.createSession).toHaveBeenCalled();\n      expect(mockBrowserManager.closeSession).toHaveBeenCalledWith('test-session-123');\n    });\n\n    it('should handle browser session creation failure', async () => {\n      mockBrowserManager.createSession.mockRejectedValue(new Error('Browser launch failed'));\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(false);\n      expect(result.errors).toHaveLength(1);\n      expect(result.errors[0].code).toBe('BROWSER_SCRAPING_FAILED');\n    });\n\n    it('should clean up session even on error', async () => {\n      mockGalleryAutomation.loadAllGalleryImages.mockRejectedValue(new Error('Gallery loading failed'));\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(mockBrowserManager.closeSession).toHaveBeenCalledWith('test-session-123');\n    });\n  });\n\n  describe('Gallery Automation Integration', () => {\n    it('should successfully load gallery images', async () => {\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.data?.galleryImages).toHaveLength(2);\n      expect(result.data?.galleryImages[0].url).toBe('https://images.vrbo.com/gallery1.jpg');\n      expect(result.data?.galleryLoadingResult.scrollCyclesCompleted).toBe(5);\n    });\n\n    it('should handle gallery automation errors gracefully', async () => {\n      mockGalleryAutomation.loadAllGalleryImages.mockResolvedValue({\n        images: [],\n        totalImagesFound: 0,\n        scrollCyclesCompleted: 0,\n        loadingTime: 1000,\n        screenshots: [],\n        errors: ['Gallery modal failed to open']\n      });\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.data?.galleryImages).toHaveLength(0);\n      expect(result.data?.galleryLoadingResult.errors).toContain('Gallery modal failed to open');\n    });\n\n    it('should pass correct configuration to gallery automation', async () => {\n      await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(mockGalleryAutomation.loadAllGalleryImages).toHaveBeenCalledWith(\n        mockPage,\n        mockVRBOUrl\n      );\n    });\n  });\n\n  describe('Static Fallback Integration', () => {\n    it('should use static fallback when enabled', async () => {\n      // Mock the comprehensive scraper\n      const mockComprehensiveResult = {\n        success: true,\n        data: {\n          propertyData: mockPropertyData,\n          images: mockStaticImages,\n          extractionReport: {\n            completenessScore: 85,\n            totalDataPoints: 20,\n            processingTime: 2000\n          }\n        },\n        errors: [],\n        metadata: {\n          duration: 2000,\n          dataCompleteness: 85\n        }\n      };\n\n      // Mock the parent class method\n      browserScraper.scrapeComprehensiveProperty = vi.fn().mockResolvedValue(mockComprehensiveResult);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl, {\n        useStaticFallback: true\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.data?.staticImages).toHaveLength(1);\n      expect(result.data?.totalImages).toBe(3); // 2 gallery + 1 static\n    });\n\n    it('should fallback to static when browser automation fails', async () => {\n      mockBrowserManager.createSession.mockRejectedValue(new Error('Browser failed'));\n\n      const mockComprehensiveResult = {\n        success: true,\n        data: {\n          propertyData: mockPropertyData,\n          images: mockStaticImages,\n          extractionReport: {\n            completenessScore: 60,\n            totalDataPoints: 15,\n            processingTime: 1000\n          }\n        },\n        errors: [],\n        metadata: {\n          duration: 1000,\n          dataCompleteness: 60\n        }\n      };\n\n      browserScraper.scrapeComprehensiveProperty = vi.fn().mockResolvedValue(mockComprehensiveResult);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl, {\n        useStaticFallback: true\n      });\n\n      expect(result.success).toBe(true);\n      expect(result.data?.galleryImages).toHaveLength(0);\n      expect(result.data?.staticImages).toHaveLength(1);\n      expect(result.data?.galleryLoadingResult.errors).toContain('Browser automation failed, used static fallback');\n    });\n  });\n\n  describe('Data Merging', () => {\n    it('should merge gallery and static images correctly', async () => {\n      const mockComprehensiveResult = {\n        success: true,\n        data: {\n          propertyData: mockPropertyData,\n          images: mockStaticImages,\n          extractionReport: {\n            completenessScore: 85,\n            totalDataPoints: 20,\n            processingTime: 2000\n          }\n        },\n        errors: [],\n        metadata: {\n          duration: 2000,\n          dataCompleteness: 85\n        }\n      };\n\n      browserScraper.scrapeComprehensiveProperty = vi.fn().mockResolvedValue(mockComprehensiveResult);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.data?.totalImages).toBe(3);\n      expect(result.data?.galleryImages).toHaveLength(2);\n      expect(result.data?.staticImages).toHaveLength(1);\n    });\n\n    it('should deduplicate images across sources', async () => {\n      // Add duplicate image to static images\n      const duplicateStaticImages = [\n        ...mockStaticImages,\n        {\n          url: 'https://images.vrbo.com/gallery1.jpg', // Duplicate of gallery image\n          thumbnailUrl: 'https://images.vrbo.com/gallery1_thumb.jpg',\n          alt: 'Living room duplicate',\n          category: 'living_area' as const,\n          size: { width: 800, height: 600 },\n          order: 2\n        }\n      ];\n\n      const mockComprehensiveResult = {\n        success: true,\n        data: {\n          propertyData: mockPropertyData,\n          images: duplicateStaticImages,\n          extractionReport: {\n            completenessScore: 85,\n            totalDataPoints: 20,\n            processingTime: 2000\n          }\n        },\n        errors: [],\n        metadata: {\n          duration: 2000,\n          dataCompleteness: 85\n        }\n      };\n\n      browserScraper.scrapeComprehensiveProperty = vi.fn().mockResolvedValue(mockComprehensiveResult);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.data?.totalImages).toBe(3); // Should be 3, not 4 (duplicate removed)\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle page navigation errors', async () => {\n      mockPage.goto.mockRejectedValue(new Error('Navigation failed'));\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(false);\n      expect(result.errors).toHaveLength(1);\n    });\n\n    it('should handle browser crash during scraping', async () => {\n      mockBrowser.connected.mockReturnValue(false);\n      mockBrowserManager.isSessionHealthy.mockResolvedValue(false);\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(false);\n      expect(result.errors).toHaveLength(1);\n    });\n\n    it('should handle timeout errors', async () => {\n      mockPage.goto.mockRejectedValue(new Error('Navigation timeout'));\n\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl, {\n        browserTimeout: 5000\n      });\n\n      expect(result.success).toBe(false);\n      expect(result.errors[0].message).toContain('Navigation timeout');\n    });\n  });\n\n  describe('Performance and Metrics', () => {\n    it('should track processing time correctly', async () => {\n      const startTime = Date.now();\n      \n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n      \n      const endTime = Date.now();\n      expect(result.metadata.duration).toBeGreaterThan(0);\n      expect(result.metadata.duration).toBeLessThan(endTime - startTime + 100);\n    });\n\n    it('should calculate data completeness score', async () => {\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.metadata.dataCompleteness).toBeGreaterThan(0);\n      expect(result.metadata.dataCompleteness).toBeLessThanOrEqual(100);\n    });\n\n    it('should collect browser metadata', async () => {\n      const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(result.data?.browserMetadata).toBeDefined();\n      expect(result.data?.browserMetadata.sessionId).toBe('test-session-123');\n      expect(result.data?.browserMetadata.userAgent).toBeDefined();\n      expect(result.data?.browserMetadata.screenResolution).toBeDefined();\n    });\n  });\n\n  describe('URL Validation', () => {\n    it('should validate VRBO URLs correctly', async () => {\n      const invalidUrls = [\n        'https://airbnb.com/rooms/12345',\n        'https://booking.com/hotel/test',\n        'not-a-url',\n        ''\n      ];\n\n      for (const url of invalidUrls) {\n        const result = await browserScraper.scrapeWithBrowserAutomation(url);\n        expect(result.success).toBe(false);\n      }\n    });\n\n    it('should accept valid VRBO URLs', async () => {\n      const validUrls = [\n        'https://www.vrbo.com/12345',\n        'https://vrbo.com/12345/test-property',\n        'https://www.homeaway.com/12345',\n        'https://www.vacationrentals.com/12345'\n      ];\n\n      for (const url of validUrls) {\n        const result = await browserScraper.scrapeWithBrowserAutomation(url);\n        expect(result.success).toBe(true);\n      }\n    });\n  });\n});\n\ndescribe('Convenience Functions', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('scrapeBrowserVRBOProperty', () => {\n    it('should scrape property and cleanup automatically', async () => {\n      const mockScraper = {\n        scrapeWithBrowserAutomation: vi.fn().mockResolvedValue({\n          success: true,\n          data: {\n            propertyData: mockPropertyData,\n            galleryImages: mockGalleryImages,\n            totalImages: 2\n          },\n          errors: [],\n          metadata: { duration: 5000 }\n        }),\n        cleanup: vi.fn()\n      };\n\n      // Mock the factory function\n      vi.mocked(createVRBOBrowserScraper).mockReturnValue(mockScraper as any);\n\n      const result = await scrapeBrowserVRBOProperty(mockVRBOUrl);\n\n      expect(result.success).toBe(true);\n      expect(mockScraper.scrapeWithBrowserAutomation).toHaveBeenCalledWith(mockVRBOUrl, {});\n      expect(mockScraper.cleanup).toHaveBeenCalled();\n    });\n\n    it('should cleanup even on error', async () => {\n      const mockScraper = {\n        scrapeWithBrowserAutomation: vi.fn().mockRejectedValue(new Error('Test error')),\n        cleanup: vi.fn()\n      };\n\n      vi.mocked(createVRBOBrowserScraper).mockReturnValue(mockScraper as any);\n\n      try {\n        await scrapeBrowserVRBOProperty(mockVRBOUrl);\n      } catch (error) {\n        // Error is expected\n      }\n\n      expect(mockScraper.cleanup).toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('Integration with Real-World Scenarios', () => {\n  it('should handle properties with many images', async () => {\n    const manyImages = Array.from({ length: 50 }, (_, i) => ({\n      url: `https://images.vrbo.com/image${i}.jpg`,\n      thumbnailUrl: `https://images.vrbo.com/image${i}_thumb.jpg`,\n      alt: `Image ${i}`,\n      category: 'interior' as const,\n      size: { width: 1200, height: 800 },\n      order: i + 1\n    }));\n\n    mockGalleryAutomation.loadAllGalleryImages.mockResolvedValue({\n      images: manyImages,\n      totalImagesFound: 50,\n      scrollCyclesCompleted: 5,\n      loadingTime: 15000,\n      screenshots: [],\n      errors: []\n    });\n\n    const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n    expect(result.success).toBe(true);\n    expect(result.data?.galleryImages).toHaveLength(50);\n    expect(result.data?.galleryLoadingResult.loadingTime).toBe(15000);\n  });\n\n  it('should handle properties with slow loading', async () => {\n    mockGalleryAutomation.loadAllGalleryImages.mockImplementation(\n      () => new Promise(resolve => setTimeout(() => resolve({\n        images: mockGalleryImages,\n        totalImagesFound: 2,\n        scrollCyclesCompleted: 3,\n        loadingTime: 30000,\n        screenshots: [],\n        errors: ['Slow loading detected']\n      }), 100))\n    );\n\n    const result = await browserScraper.scrapeWithBrowserAutomation(mockVRBOUrl);\n\n    expect(result.success).toBe(true);\n    expect(result.data?.galleryLoadingResult.errors).toContain('Slow loading detected');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/browser-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6462,6465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6462,6465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Browser Manager for VRBO Dynamic Content Scraping\n// Handles Puppeteer browser lifecycle and stealth mode\n\nimport puppeteer, { Browser, Page, LaunchOptions } from 'puppeteer';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\n\nexport interface BrowserConfig {\n  headless: boolean;\n  timeout: number;\n  viewportWidth: number;\n  viewportHeight: number;\n  userAgent: string;\n  enableStealth: boolean;\n  blockImages: boolean;\n  blockCSS: boolean;\n  proxy?: string;\n}\n\nexport interface BrowserSession {\n  browser: Browser;\n  page: Page;\n  sessionId: string;\n  startTime: number;\n  isActive: boolean;\n}\n\nexport class BrowserManager {\n  private static instance: BrowserManager;\n  private activeSessions: Map<string, BrowserSession> = new Map();\n  private config: BrowserConfig;\n  \n  private defaultConfig: BrowserConfig = {\n    headless: true,\n    timeout: 60000,\n    viewportWidth: 1920,\n    viewportHeight: 1080,\n    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    enableStealth: true,\n    blockImages: false, // We need images for VRBO\n    blockCSS: true, // Block CSS to speed up loading\n    proxy: undefined\n  };\n\n  constructor(config: Partial<BrowserConfig> = {}) {\n    this.config = { ...this.defaultConfig, ...config };\n  }\n\n  public static getInstance(config?: Partial<BrowserConfig>): BrowserManager {\n    if (!BrowserManager.instance) {\n      BrowserManager.instance = new BrowserManager(config);\n    }\n    return BrowserManager.instance;\n  }\n\n  /**\n   * Creates a new browser session for scraping\n   * @param sessionId - Unique identifier for this session\n   * @returns Promise<BrowserSession>\n   */\n  async createSession(sessionId?: string): Promise<BrowserSession> {\n    const id = sessionId || this.generateSessionId();\n    \n    try {\n      logger.info('Creating new browser session', { sessionId: id }, 'BROWSER_MANAGER');\n      \n      const launchOptions: LaunchOptions = {\n        headless: this.config.headless,\n        timeout: this.config.timeout,\n        args: [\n          '--no-sandbox',\n          '--disable-setuid-sandbox',\n          '--disable-blink-features=AutomationControlled',\n          '--disable-features=VizDisplayCompositor',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--no-first-run',\n          '--no-zygote',\n          '--single-process',\n          '--disable-gpu',\n          '--window-size=1920,1080',\n          ...(this.config.proxy ? [`--proxy-server=${this.config.proxy}`] : [])\n        ],\n        defaultViewport: {\n          width: this.config.viewportWidth,\n          height: this.config.viewportHeight,\n          deviceScaleFactor: 1,\n          isMobile: false,\n          hasTouch: false,\n          isLandscape: true\n        }\n      };\n\n      const browser = await puppeteer.launch(launchOptions);\n      const page = await browser.newPage();\n\n      // Configure page settings\n      await this.configurePage(page);\n\n      const session: BrowserSession = {\n        browser,\n        page,\n        sessionId: id,\n        startTime: Date.now(),\n        isActive: true\n      };\n\n      this.activeSessions.set(id, session);\n\n      logger.info('Browser session created successfully', { \n        sessionId: id,\n        activeSessionsCount: this.activeSessions.size \n      }, 'BROWSER_MANAGER');\n\n      return session;\n\n    } catch (error) {\n      logger.error('Failed to create browser session', error, 'BROWSER_MANAGER');\n      errorReporter.reportError(error as Error, {\n        context: 'BROWSER_MANAGER',\n        operation: 'createSession',\n        sessionId: id\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Configures page settings for optimal VRBO scraping\n   * @param page - Puppeteer page instance\n   */\n  private async configurePage(page: Page): Promise<void> {\n    // Set user agent for stealth\n    await page.setUserAgent(this.config.userAgent);\n\n    // Set extra HTTP headers\n    await page.setExtraHTTPHeaders({\n      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n      'Accept-Language': 'en-US,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate',\n      'Cache-Control': 'no-cache',\n      'Pragma': 'no-cache',\n      'Upgrade-Insecure-Requests': '1'\n    });\n\n    // Block unnecessary resources for faster loading\n    if (this.config.blockCSS || this.config.blockImages) {\n      await page.setRequestInterception(true);\n      \n      page.on('request', (request) => {\n        const resourceType = request.resourceType();\n        \n        if (this.config.blockCSS && resourceType === 'stylesheet') {\n          request.abort();\n          return;\n        }\n        \n        if (this.config.blockImages && resourceType === 'image') {\n          request.abort();\n          return;\n        }\n\n        // Block other unnecessary resources\n        if (['font', 'media'].includes(resourceType)) {\n          request.abort();\n          return;\n        }\n\n        request.continue();\n      });\n    }\n\n    // Enable stealth mode\n    if (this.config.enableStealth) {\n      await this.enableStealthMode(page);\n    }\n\n    // Set page timeout\n    page.setDefaultTimeout(this.config.timeout);\n    page.setDefaultNavigationTimeout(this.config.timeout);\n  }\n\n  /**\n   * Enables stealth mode to avoid bot detection\n   * @param page - Puppeteer page instance\n   */\n  private async enableStealthMode(page: Page): Promise<void> {\n    // Remove webdriver property\n    await page.evaluateOnNewDocument(() => {\n      Object.defineProperty(navigator, 'webdriver', {\n        get: () => undefined,\n      });\n    });\n\n    // Mock plugins\n    await page.evaluateOnNewDocument(() => {\n      Object.defineProperty(navigator, 'plugins', {\n        get: () => [1, 2, 3, 4, 5],\n      });\n    });\n\n    // Mock languages\n    await page.evaluateOnNewDocument(() => {\n      Object.defineProperty(navigator, 'languages', {\n        get: () => ['en-US', 'en'],\n      });\n    });\n\n    // Mock permissions\n    await page.evaluateOnNewDocument(() => {\n      const originalQuery = window.navigator.permissions.query;\n      window.navigator.permissions.query = (parameters) => (\n        parameters.name === 'notifications' ?\n          Promise.resolve({ state: Notification.permission }) :\n          originalQuery(parameters)\n      );\n    });\n\n    // Mock chrome runtime\n    await page.evaluateOnNewDocument(() => {\n      (window as any).chrome = {\n        runtime: {}\n      };\n    });\n  }\n\n  /**\n   * Closes a browser session and cleans up resources\n   * @param sessionId - Session ID to close\n   */\n  async closeSession(sessionId: string): Promise<void> {\n    const session = this.activeSessions.get(sessionId);\n    \n    if (!session) {\n      logger.warn('Attempted to close non-existent session', { sessionId }, 'BROWSER_MANAGER');\n      return;\n    }\n\n    try {\n      session.isActive = false;\n      \n      if (session.page && !session.page.isClosed()) {\n        await session.page.close();\n      }\n      \n      if (session.browser && session.browser.connected()) {\n        await session.browser.close();\n      }\n\n      this.activeSessions.delete(sessionId);\n\n      const sessionDuration = Date.now() - session.startTime;\n      logger.info('Browser session closed', { \n        sessionId,\n        duration: sessionDuration,\n        activeSessionsCount: this.activeSessions.size \n      }, 'BROWSER_MANAGER');\n\n    } catch (error) {\n      logger.error('Error closing browser session', error, 'BROWSER_MANAGER');\n      this.activeSessions.delete(sessionId);\n    }\n  }\n\n  /**\n   * Closes all active sessions\n   */\n  async closeAllSessions(): Promise<void> {\n    const sessionIds = Array.from(this.activeSessions.keys());\n    \n    await Promise.allSettled(\n      sessionIds.map(sessionId => this.closeSession(sessionId))\n    );\n\n    logger.info('All browser sessions closed', { \n      closedCount: sessionIds.length \n    }, 'BROWSER_MANAGER');\n  }\n\n  /**\n   * Gets an active session by ID\n   * @param sessionId - Session ID\n   * @returns BrowserSession or undefined\n   */\n  getSession(sessionId: string): BrowserSession | undefined {\n    return this.activeSessions.get(sessionId);\n  }\n\n  /**\n   * Gets count of active sessions\n   * @returns number\n   */\n  getActiveSessionCount(): number {\n    return this.activeSessions.size;\n  }\n\n  /**\n   * Checks if a session is still active and healthy\n   * @param sessionId - Session ID to check\n   * @returns boolean\n   */\n  async isSessionHealthy(sessionId: string): Promise<boolean> {\n    const session = this.activeSessions.get(sessionId);\n    \n    if (!session || !session.isActive) {\n      return false;\n    }\n\n    try {\n      // Check if browser is still connected\n      if (!session.browser.connected()) {\n        return false;\n      }\n\n      // Check if page is still accessible\n      if (session.page.isClosed()) {\n        return false;\n      }\n\n      // Try to evaluate a simple expression\n      await session.page.evaluate(() => true);\n      return true;\n\n    } catch (error) {\n      logger.warn('Session health check failed', { sessionId, error }, 'BROWSER_MANAGER');\n      return false;\n    }\n  }\n\n  /**\n   * Creates a random delay to mimic human behavior\n   * @param min - Minimum delay in milliseconds\n   * @param max - Maximum delay in milliseconds\n   * @returns Promise<void>\n   */\n  async randomDelay(min: number = 1000, max: number = 3000): Promise<void> {\n    const delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n\n  /**\n   * Simulates human-like mouse movement\n   * @param page - Puppeteer page\n   * @param x - Target X coordinate\n   * @param y - Target Y coordinate\n   */\n  async humanMouseMove(page: Page, x: number, y: number): Promise<void> {\n    const currentPos = await page.evaluate(() => ({ x: 0, y: 0 }));\n    const steps = 10;\n    \n    for (let i = 0; i <= steps; i++) {\n      const progress = i / steps;\n      const currentX = currentPos.x + (x - currentPos.x) * progress;\n      const currentY = currentPos.y + (y - currentPos.y) * progress;\n      \n      await page.mouse.move(currentX, currentY);\n      await this.randomDelay(10, 30);\n    }\n  }\n\n  /**\n   * Simulates human-like scrolling\n   * @param page - Puppeteer page\n   * @param direction - 'up' or 'down'\n   * @param distance - Scroll distance in pixels\n   */\n  async humanScroll(page: Page, direction: 'up' | 'down' = 'down', distance: number = 300): Promise<void> {\n    const scrollDelta = direction === 'down' ? distance : -distance;\n    const steps = 5;\n    const stepDistance = scrollDelta / steps;\n    \n    for (let i = 0; i < steps; i++) {\n      await page.evaluate((delta) => {\n        window.scrollBy(0, delta);\n      }, stepDistance);\n      \n      await this.randomDelay(100, 200);\n    }\n  }\n\n  /**\n   * Generates a unique session ID\n   * @returns string\n   */\n  private generateSessionId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substr(2, 9);\n    return `vrbo_${timestamp}_${random}`;\n  }\n\n  /**\n   * Cleanup on process exit\n   */\n  async cleanup(): Promise<void> {\n    logger.info('Cleaning up browser manager', {}, 'BROWSER_MANAGER');\n    await this.closeAllSessions();\n  }\n}\n\n// Export singleton instance\nexport const browserManager = BrowserManager.getInstance();\n\n// Cleanup on process exit\nprocess.on('exit', () => {\n  browserManager.cleanup();\n});\n\nprocess.on('SIGINT', async () => {\n  await browserManager.cleanup();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  await browserManager.cleanup();\n  process.exit(0);\n});","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/comprehensive-vrbo-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4729,4732],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4729,4732],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7598,7601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7598,7601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":241,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7628,7631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7628,7631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7650,7653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7650,7653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Comprehensive VRBO Scraper - Phase 3 Complete Implementation\n// Integrates production HTTP client, advanced image extraction, and comprehensive data extraction\n\nimport { VRBODataExtractor } from './vrbo-data-extractor';\nimport { VRBOImageScraper } from './vrbo-image-scraper';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport type {\n  ScrapedPropertyData,\n  VRBOPropertyData,\n  ScrapingResult,\n  ScrapingError,\n  ScrapingMetadata,\n  PropertyAmenity,\n  PropertyRoom,\n  PropertySpecifications,\n  PropertyLocation,\n  PhotoData,\n  ScraperConfig\n} from './types';\n\ninterface ComprehensiveScrapingOptions {\n  includeImages: boolean;\n  includeAdvancedAmenities: boolean;\n  includeDetailedDescriptions: boolean;\n  includeRoomData: boolean;\n  maxImages: number;\n  verifyWithAI: boolean;\n  generateReport: boolean;\n}\n\ninterface ComprehensiveScrapingResult {\n  propertyData: VRBOPropertyData;\n  images: PhotoData[];\n  amenities: PropertyAmenity[];\n  rooms: PropertyRoom[];\n  descriptions: {\n    main: string;\n    highlights: string[];\n    structured: Record<string, string>;\n  };\n  extractionReport: {\n    totalDataPoints: number;\n    completenessScore: number;\n    verificationStatus: string;\n    processingTime: number;\n    errorsEncountered: number;\n  };\n}\n\nexport class ComprehensiveVRBOScraper extends VRBODataExtractor {\n  private imageScraper: VRBOImageScraper;\n  \n  private defaultOptions: ComprehensiveScrapingOptions = {\n    includeImages: true,\n    includeAdvancedAmenities: true,\n    includeDetailedDescriptions: true,\n    includeRoomData: true,\n    maxImages: 50,\n    verifyWithAI: false,\n    generateReport: true\n  };\n\n  constructor(config: Partial<ScraperConfig> = {}) {\n    super(config);\n    this.imageScraper = new VRBOImageScraper(config);\n  }\n\n  /**\n   * Performs comprehensive scraping of VRBO property\n   * @param url - VRBO property URL\n   * @param options - Comprehensive scraping options\n   * @returns Promise<ScrapingResult<ComprehensiveScrapingResult>>\n   */\n  async scrapeComprehensiveProperty(\n    url: string,\n    options: Partial<ComprehensiveScrapingOptions> = {}\n  ): Promise<ScrapingResult<ComprehensiveScrapingResult>> {\n    const finalOptions = { ...this.defaultOptions, ...options };\n    const startTime = Date.now();\n    const errors: ScrapingError[] = [];\n    \n    const metadata: ScrapingMetadata = {\n      scrapedAt: new Date(),\n      duration: 0,\n      sourceUrl: url,\n      userAgent: this.httpClient.defaults.headers['User-Agent'] as string,\n      rateLimited: false,\n      dataCompleteness: 0,\n      fieldsScraped: [],\n      fieldsFailed: []\n    };\n\n    try {\n      // Log comprehensive scraping start\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting comprehensive VRBO property scraping: ${url}`,\n        'comprehensive_scraping',\n        `Full property scraping with images, amenities, descriptions, and room data`,\n        [url],\n        'high'\n      );\n\n      // Validate URL\n      if (!this.isValidVRBOUrl(url)) {\n        throw new Error('Invalid VRBO URL provided');\n      }\n\n      // Step 1: Extract basic property data\n      logger.info('Step 1: Extracting basic property data', { url }, 'COMPREHENSIVE_VRBO_SCRAPER');\n      const propertyResult = await this.scrapePropertyDetails(url);\n      \n      if (!propertyResult.success) {\n        errors.push(...propertyResult.errors);\n        metadata.fieldsFailed.push('property_data');\n      } else {\n        metadata.fieldsScraped.push('property_data');\n      }\n\n      // Step 2: Extract comprehensive data (amenities, descriptions, rooms)\n      logger.info('Step 2: Extracting comprehensive data', { url }, 'COMPREHENSIVE_VRBO_SCRAPER');\n      const comprehensiveResult = await this.extractComprehensiveData(url, {\n        includeHidden: finalOptions.includeAdvancedAmenities,\n        expandCollapsed: finalOptions.includeAdvancedAmenities,\n        verifyWithAI: finalOptions.verifyWithAI\n      }, {\n        includeFormatting: finalOptions.includeDetailedDescriptions,\n        extractHighlights: finalOptions.includeDetailedDescriptions,\n        parseStructuredData: finalOptions.includeDetailedDescriptions\n      }, {\n        detectRoomTypes: finalOptions.includeRoomData,\n        extractDimensions: finalOptions.includeRoomData,\n        includeFeatures: finalOptions.includeRoomData\n      });\n\n      if (!comprehensiveResult.success) {\n        errors.push(...comprehensiveResult.errors);\n        metadata.fieldsFailed.push('comprehensive_data');\n      } else {\n        metadata.fieldsScraped.push('comprehensive_data');\n      }\n\n      // Step 3: Extract images if enabled\n      let imageResult: any = { success: true, data: [], errors: [] };\n      if (finalOptions.includeImages) {\n        logger.info('Step 3: Extracting property images', { url }, 'COMPREHENSIVE_VRBO_SCRAPER');\n        imageResult = await this.imageScraper.scrapeAllImages(url, {\n          maxImages: finalOptions.maxImages,\n          includeHighRes: true,\n          expandGalleries: true,\n          deduplicateImages: true,\n          roomCategorization: true\n        });\n\n        if (!imageResult.success) {\n          errors.push(...imageResult.errors);\n          metadata.fieldsFailed.push('images');\n        } else {\n          metadata.fieldsScraped.push('images');\n        }\n      }\n\n      // Combine all results\n      const combinedResult = this.combineScrapingResults(\n        propertyResult,\n        comprehensiveResult,\n        imageResult,\n        finalOptions\n      );\n\n      // Generate extraction report\n      const extractionReport = this.generateExtractionReport(\n        combinedResult,\n        startTime,\n        errors.length,\n        finalOptions\n      );\n\n      // Calculate final metadata\n      metadata.duration = Date.now() - startTime;\n      metadata.dataCompleteness = extractionReport.completenessScore;\n\n      logger.info('Comprehensive VRBO scraping completed', {\n        url,\n        completenessScore: extractionReport.completenessScore,\n        totalDataPoints: extractionReport.totalDataPoints,\n        duration: metadata.duration,\n        errorsCount: errors.length\n      }, 'COMPREHENSIVE_VRBO_SCRAPER');\n\n      const finalResult: ComprehensiveScrapingResult = {\n        ...combinedResult,\n        extractionReport\n      };\n\n      return {\n        success: errors.length === 0 || extractionReport.completenessScore > 50,\n        data: finalResult,\n        errors,\n        metadata\n      };\n\n    } catch (error) {\n      const scrapingError: ScrapingError = {\n        code: 'COMPREHENSIVE_SCRAPING_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown comprehensive scraping error',\n        severity: 'high',\n        recoverable: true\n      };\n      \n      metadata.duration = Date.now() - startTime;\n      metadata.fieldsFailed = ['all'];\n      \n      logger.error('Comprehensive VRBO scraping failed', error, 'COMPREHENSIVE_VRBO_SCRAPER');\n      \n      errorReporter.reportError(error, {\n        context: 'COMPREHENSIVE_VRBO_SCRAPER',\n        url,\n        metadata\n      });\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata\n      };\n    }\n  }\n\n  /**\n   * Combines results from all scraping phases\n   * @param propertyResult - Basic property data result\n   * @param comprehensiveResult - Comprehensive data result\n   * @param imageResult - Image scraping result\n   * @param options - Scraping options\n   * @returns Combined scraping result\n   */\n  private combineScrapingResults(\n    propertyResult: any,\n    comprehensiveResult: any,\n    imageResult: any,\n    options: ComprehensiveScrapingOptions\n  ): Omit<ComprehensiveScrapingResult, 'extractionReport'> {\n    // Start with basic property data\n    const propertyData: VRBOPropertyData = propertyResult.success \n      ? propertyResult.data \n      : this.createFallbackPropertyData();\n\n    // Enhance with comprehensive data\n    if (comprehensiveResult.success) {\n      const compData = comprehensiveResult.data;\n      \n      // Merge amenities (prioritize comprehensive data)\n      if (compData.amenities?.length > 0) {\n        propertyData.amenities = this.mergeAmenities(\n          propertyData.amenities || [],\n          compData.amenities\n        );\n      }\n\n      // Update specifications\n      if (compData.specifications) {\n        propertyData.specifications = {\n          ...propertyData.specifications,\n          ...compData.specifications\n        };\n      }\n\n      // Update location\n      if (compData.location) {\n        propertyData.location = {\n          ...propertyData.location,\n          ...compData.location\n        };\n      }\n\n      // Update rooms\n      if (compData.rooms?.length > 0) {\n        propertyData.rooms = compData.rooms;\n      }\n\n      // Update description with detailed version\n      if (compData.descriptions?.main) {\n        propertyData.description = compData.descriptions.main;\n      }\n    }\n\n    // Add images\n    const images: PhotoData[] = imageResult.success ? imageResult.data : [];\n    \n    // If we have images, update the property data photos\n    if (images.length > 0) {\n      propertyData.photos = images;\n    }\n\n    return {\n      propertyData,\n      images,\n      amenities: propertyData.amenities || [],\n      rooms: propertyData.rooms || [],\n      descriptions: comprehensiveResult.success ? comprehensiveResult.data.descriptions : {\n        main: propertyData.description || '',\n        highlights: [],\n        structured: {}\n      }\n    };\n  }\n\n  /**\n   * Merges amenity lists, prioritizing comprehensive data while preserving unique items\n   * @param basicAmenities - Basic amenities from property scraping\n   * @param comprehensiveAmenities - Comprehensive amenities from advanced extraction\n   * @returns Merged amenity list\n   */\n  private mergeAmenities(basicAmenities: PropertyAmenity[], comprehensiveAmenities: PropertyAmenity[]): PropertyAmenity[] {\n    const amenityMap = new Map<string, PropertyAmenity>();\n    \n    // Add basic amenities first\n    basicAmenities.forEach(amenity => {\n      amenityMap.set(amenity.name.toLowerCase(), amenity);\n    });\n    \n    // Add/override with comprehensive amenities (they're more detailed)\n    comprehensiveAmenities.forEach(amenity => {\n      const existing = amenityMap.get(amenity.name.toLowerCase());\n      if (existing) {\n        // Merge properties, prioritizing comprehensive data\n        amenityMap.set(amenity.name.toLowerCase(), {\n          ...existing,\n          ...amenity,\n          verified: amenity.verified || existing.verified,\n          description: amenity.description || existing.description\n        });\n      } else {\n        amenityMap.set(amenity.name.toLowerCase(), amenity);\n      }\n    });\n    \n    return Array.from(amenityMap.values());\n  }\n\n  /**\n   * Creates fallback property data when basic scraping fails\n   * @returns Minimal VRBOPropertyData\n   */\n  private createFallbackPropertyData(): VRBOPropertyData {\n    return {\n      vrboId: 'unknown',\n      sourceUrl: '',\n      title: 'Property Title Not Available',\n      description: 'Property description not available',\n      amenities: [],\n      photos: [],\n      rooms: [],\n      specifications: this.getDefaultSpecifications(),\n      location: this.getDefaultLocation(),\n      instantBook: false,\n      cancellationPolicy: 'Policy not specified',\n      houseRules: [],\n      lastUpdated: new Date()\n    };\n  }\n\n  /**\n   * Generates comprehensive extraction report\n   * @param result - Combined scraping result\n   * @param startTime - Processing start time\n   * @param errorCount - Number of errors encountered\n   * @param options - Scraping options\n   * @returns Extraction report\n   */\n  private generateExtractionReport(\n    result: Omit<ComprehensiveScrapingResult, 'extractionReport'>,\n    startTime: number,\n    errorCount: number,\n    options: ComprehensiveScrapingOptions\n  ): ComprehensiveScrapingResult['extractionReport'] {\n    const processingTime = Date.now() - startTime;\n    \n    // Count total data points extracted\n    let totalDataPoints = 0;\n    \n    // Basic property data points\n    if (result.propertyData.title) totalDataPoints++;\n    if (result.propertyData.description) totalDataPoints++;\n    if (result.propertyData.specifications?.bedrooms) totalDataPoints++;\n    if (result.propertyData.specifications?.bathrooms) totalDataPoints++;\n    if (result.propertyData.specifications?.maxGuests) totalDataPoints++;\n    if (result.propertyData.location?.city) totalDataPoints++;\n    \n    // Amenities\n    totalDataPoints += result.amenities.length;\n    \n    // Images\n    totalDataPoints += result.images.length;\n    \n    // Rooms\n    totalDataPoints += result.rooms.length;\n    \n    // Descriptions\n    if (result.descriptions.main) totalDataPoints++;\n    totalDataPoints += result.descriptions.highlights.length;\n    totalDataPoints += Object.keys(result.descriptions.structured).length;\n    \n    // Calculate completeness score\n    let completenessScore = 0;\n    \n    // Required data scoring (70%)\n    if (result.propertyData.title) completenessScore += 10;\n    if (result.propertyData.description) completenessScore += 10;\n    if (result.amenities.length > 0) completenessScore += 15;\n    if (result.images.length > 0) completenessScore += 15;\n    if (result.propertyData.specifications?.bedrooms) completenessScore += 10;\n    if (result.propertyData.specifications?.bathrooms) completenessScore += 10;\n    \n    // Optional data scoring (30%)\n    if (result.rooms.length > 0) completenessScore += 10;\n    if (result.descriptions.highlights.length > 0) completenessScore += 5;\n    if (Object.keys(result.descriptions.structured).length > 0) completenessScore += 5;\n    if (result.propertyData.location?.city && result.propertyData.location.city !== 'Unknown') completenessScore += 5;\n    if (result.images.length >= 10) completenessScore += 5;\n    \n    // Determine verification status\n    let verificationStatus = 'completed';\n    if (errorCount > 0 && completenessScore < 50) {\n      verificationStatus = 'failed';\n    } else if (errorCount > 0 || completenessScore < 80) {\n      verificationStatus = 'partial';\n    }\n    \n    return {\n      totalDataPoints,\n      completenessScore: Math.round(Math.min(completenessScore, 100)),\n      verificationStatus,\n      processingTime,\n      errorsEncountered: errorCount\n    };\n  }\n\n  /**\n   * Quick scrape method for basic property information\n   * @param url - VRBO property URL\n   * @returns Promise<ScrapingResult<VRBOPropertyData>>\n   */\n  async quickScrape(url: string): Promise<ScrapingResult<VRBOPropertyData>> {\n    return this.scrapePropertyDetails(url);\n  }\n\n  /**\n   * Batch scraping method for multiple properties\n   * @param urls - Array of VRBO property URLs\n   * @param options - Scraping options\n   * @returns Promise<ScrapingResult<ComprehensiveScrapingResult>[]>\n   */\n  async batchScrape(\n    urls: string[],\n    options: Partial<ComprehensiveScrapingOptions> = {}\n  ): Promise<ScrapingResult<ComprehensiveScrapingResult>[]> {\n    const results: ScrapingResult<ComprehensiveScrapingResult>[] = [];\n    \n    for (const url of urls) {\n      try {\n        const result = await this.scrapeComprehensiveProperty(url, options);\n        results.push(result);\n        \n        // Add delay between requests to respect rate limits\n        await this.delay(2000);\n      } catch (error) {\n        results.push({\n          success: false,\n          errors: [{\n            code: 'BATCH_SCRAPING_FAILED',\n            message: error instanceof Error ? error.message : 'Batch scraping failed',\n            severity: 'medium',\n            recoverable: true\n          }],\n          metadata: {\n            scrapedAt: new Date(),\n            duration: 0,\n            sourceUrl: url,\n            userAgent: this.httpClient.defaults.headers['User-Agent'] as string,\n            rateLimited: false,\n            dataCompleteness: 0,\n            fieldsScraped: [],\n            fieldsFailed: ['all']\n          }\n        });\n      }\n    }\n    \n    return results;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Export factory function\nexport const createComprehensiveVRBOScraper = (config?: Partial<ScraperConfig>): ComprehensiveVRBOScraper => {\n  return new ComprehensiveVRBOScraper(config);\n};\n\n// Export convenience function for quick property scraping\nexport const scrapeVRBOProperty = async (\n  url: string, \n  options: Partial<ComprehensiveScrapingOptions> = {}\n): Promise<ScrapingResult<ComprehensiveScrapingResult>> => {\n  const scraper = createComprehensiveVRBOScraper();\n  return scraper.scrapeComprehensiveProperty(url, options);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/photo-deduplicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/production-vrbo-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":288,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9077,9080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9077,9080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":351,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11097,11100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11097,11100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":352,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":352,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11138,11141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11138,11141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":443,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":443,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14050,14053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14050,14053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15691,15694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15691,15694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":564,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":564,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18239,18242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18239,18242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":639,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20280,20283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20280,20283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Production-Ready VRBO Property Scraper for STR Certified\n// Phase 1: Core Infrastructure with real HTTP requests and DOM parsing\n\nimport axios, { AxiosInstance } from 'axios';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport type {\n  ScrapedPropertyData,\n  VRBOPropertyData,\n  ScrapingResult,\n  ScrapingError,\n  ScrapingMetadata,\n  PropertyAmenity,\n  PropertyRoom,\n  PropertySpecifications,\n  PropertyLocation,\n  ScraperConfig,\n  PhotoData,\n  AmenityCategory,\n  RoomType\n} from './types';\n\ninterface RateLimitState {\n  requests: number;\n  windowStart: number;\n  windowSize: number; // milliseconds\n}\n\ninterface ScrapingSession {\n  id: string;\n  startTime: number;\n  requestCount: number;\n  errors: ScrapingError[];\n  userAgent: string;\n}\n\nexport class ProductionVRBOScraper {\n  private httpClient: AxiosInstance;\n  private config: ScraperConfig;\n  private rateLimitState: RateLimitState;\n  private currentSession: ScrapingSession | null = null;\n  private userAgents: string[] = [\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15'\n  ];\n\n  constructor(config: Partial<ScraperConfig> = {}) {\n    this.config = {\n      timeout: 30000,\n      retries: 3,\n      userAgent: this.getRandomUserAgent(),\n      respectRobotsTxt: true,\n      rateLimit: 10, // requests per minute\n      enableScreenshots: false,\n      ...config\n    };\n\n    this.rateLimitState = {\n      requests: 0,\n      windowStart: Date.now(),\n      windowSize: 60000 // 1 minute\n    };\n\n    this.httpClient = axios.create({\n      timeout: this.config.timeout,\n      headers: {\n        'User-Agent': this.config.userAgent,\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Accept-Language': 'en-US,en;q=0.5',\n        'Accept-Encoding': 'gzip, deflate',\n        'Connection': 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'Sec-Fetch-Dest': 'document',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-Site': 'none',\n        'Cache-Control': 'no-cache'\n      },\n      maxRedirects: 5,\n      validateStatus: (status) => status < 500 // Accept 4xx but not 5xx\n    });\n\n    // Setup request interceptor for rate limiting\n    this.httpClient.interceptors.request.use(\n      async (config) => {\n        await this.enforceRateLimit();\n        return config;\n      },\n      (error) => Promise.reject(error)\n    );\n\n    // Setup response interceptor for error handling\n    this.httpClient.interceptors.response.use(\n      (response) => response,\n      async (error) => {\n        if (error.response?.status === 429) {\n          await this.handleRateLimitExceeded();\n        }\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  /**\n   * Scrapes comprehensive property details from a VRBO URL\n   * @param url - The VRBO property URL\n   * @returns Promise<ScrapingResult<VRBOPropertyData>>\n   */\n  async scrapePropertyDetails(url: string): Promise<ScrapingResult<VRBOPropertyData>> {\n    const session = this.startSession();\n    const startTime = Date.now();\n    \n    const metadata: ScrapingMetadata = {\n      scrapedAt: new Date(),\n      duration: 0,\n      sourceUrl: url,\n      userAgent: this.config.userAgent,\n      rateLimited: false,\n      dataCompleteness: 0,\n      fieldsScraped: [],\n      fieldsFailed: []\n    };\n\n    try {\n      // Log scraping start\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting production VRBO scraping: ${url}`,\n        'scraping_operation',\n        `Production scraping session ${session.id} started`,\n        [url],\n        'high'\n      );\n\n      // Validate URL\n      if (!this.isValidVRBOUrl(url)) {\n        throw new Error('Invalid VRBO URL provided');\n      }\n\n      // Extract property ID\n      const propertyId = this.extractPropertyId(url);\n      if (!propertyId) {\n        throw new Error('Could not extract property ID from URL');\n      }\n\n      // Fetch the main property page\n      const mainPageData = await this.fetchMainPropertyPage(url);\n      \n      // Extract structured data from the page\n      const propertyData = await this.extractPropertyData(mainPageData, url, propertyId);\n      \n      // Calculate metadata\n      metadata.duration = Date.now() - startTime;\n      metadata.dataCompleteness = this.calculateDataCompleteness(propertyData);\n      metadata.fieldsScraped = this.getScrapedFields(propertyData);\n\n      logger.info('Production VRBO scraping completed successfully', {\n        propertyId,\n        duration: metadata.duration,\n        dataCompleteness: metadata.dataCompleteness,\n        sessionId: session.id\n      }, 'VRBO_SCRAPER');\n\n      return {\n        success: true,\n        data: propertyData,\n        errors: [],\n        metadata\n      };\n\n    } catch (error) {\n      const scrapingError = this.createScrapingError(error, 'PROPERTY_SCRAPING_FAILED');\n      \n      metadata.duration = Date.now() - startTime;\n      metadata.fieldsFailed = ['all'];\n      \n      logger.error('Production VRBO scraping failed', error, 'VRBO_SCRAPER');\n      \n      errorReporter.reportError(error, {\n        context: 'VRBO_SCRAPER',\n        url,\n        sessionId: session.id,\n        metadata\n      });\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata\n      };\n    } finally {\n      this.endSession(session);\n    }\n  }\n\n  /**\n   * Fetches the main property page HTML\n   * @param url - VRBO property URL\n   * @returns Promise<string> - HTML content\n   */\n  private async fetchMainPropertyPage(url: string): Promise<string> {\n    const maxRetries = this.config.retries;\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        // Rotate user agent on retry\n        if (attempt > 1) {\n          this.httpClient.defaults.headers['User-Agent'] = this.getRandomUserAgent();\n        }\n\n        const response = await this.httpClient.get(url);\n        \n        if (response.status === 200 && response.data) {\n          return response.data;\n        }\n        \n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        \n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Unknown error');\n        \n        if (attempt < maxRetries) {\n          const backoffDelay = Math.pow(2, attempt - 1) * 1000; // Exponential backoff\n          await this.delay(backoffDelay);\n          \n          logger.warn(`VRBO scraping attempt ${attempt} failed, retrying in ${backoffDelay}ms`, {\n            error: lastError.message,\n            attempt,\n            maxRetries\n          }, 'VRBO_SCRAPER');\n        }\n      }\n    }\n\n    throw lastError || new Error('Failed to fetch property page');\n  }\n\n  /**\n   * Extracts property data from HTML content\n   * @param html - Raw HTML content\n   * @param url - Original URL\n   * @param propertyId - Property ID\n   * @returns Promise<VRBOPropertyData>\n   */\n  private async extractPropertyData(html: string, url: string, propertyId: string): Promise<VRBOPropertyData> {\n    const extractedData: Partial<VRBOPropertyData> = {\n      vrboId: propertyId,\n      sourceUrl: url,\n      lastUpdated: new Date()\n    };\n\n    // Extract JSON-LD structured data\n    const jsonLdData = this.extractJsonLdData(html);\n    if (jsonLdData) {\n      this.mergeJsonLdData(extractedData, jsonLdData);\n    }\n\n    // Extract meta tags\n    const metaData = this.extractMetaTags(html);\n    this.mergeMetaData(extractedData, metaData);\n\n    // Extract from DOM elements\n    const domData = this.extractDomData(html);\n    this.mergeDomData(extractedData, domData);\n\n    // Set defaults for required fields\n    extractedData.title = extractedData.title || 'Property Title Not Found';\n    extractedData.description = extractedData.description || 'Property description not available';\n    extractedData.amenities = extractedData.amenities || [];\n    extractedData.photos = extractedData.photos || [];\n    extractedData.rooms = extractedData.rooms || [];\n    extractedData.specifications = extractedData.specifications || this.getDefaultSpecifications();\n    extractedData.location = extractedData.location || this.getDefaultLocation();\n    extractedData.instantBook = extractedData.instantBook ?? false;\n    extractedData.cancellationPolicy = extractedData.cancellationPolicy || 'Policy not specified';\n    extractedData.houseRules = extractedData.houseRules || [];\n\n    return extractedData as VRBOPropertyData;\n  }\n\n  /**\n   * Extracts JSON-LD structured data from HTML\n   * @param html - HTML content\n   * @returns Object | null\n   */\n  private extractJsonLdData(html: string): any | null {\n    try {\n      const jsonLdRegex = /<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>(.*?)<\\/script>/gis;\n      const matches = html.match(jsonLdRegex);\n      \n      if (matches) {\n        for (const match of matches) {\n          const jsonContent = match.replace(/<script[^>]*>/i, '').replace(/<\\/script>/i, '');\n          try {\n            const data = JSON.parse(jsonContent);\n            if (data['@type'] === 'LodgingBusiness' || data['@type'] === 'Place') {\n              return data;\n            }\n          } catch (e) {\n            // Continue to next match\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn('Failed to extract JSON-LD data', error, 'VRBO_SCRAPER');\n    }\n    return null;\n  }\n\n  /**\n   * Extracts meta tag data from HTML\n   * @param html - HTML content\n   * @returns Object\n   */\n  private extractMetaTags(html: string): Record<string, string> {\n    const metaData: Record<string, string> = {};\n    \n    // Extract title\n    const titleMatch = html.match(/<title[^>]*>([^<]*)<\\/title>/i);\n    if (titleMatch) {\n      metaData.title = this.cleanText(titleMatch[1]);\n    }\n\n    // Extract meta description\n    const descriptionMatch = html.match(/<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']*)/i);\n    if (descriptionMatch) {\n      metaData.description = this.cleanText(descriptionMatch[1]);\n    }\n\n    // Extract Open Graph data\n    const ogTitleMatch = html.match(/<meta[^>]*property=[\"']og:title[\"'][^>]*content=[\"']([^\"']*)/i);\n    if (ogTitleMatch) {\n      metaData.ogTitle = this.cleanText(ogTitleMatch[1]);\n    }\n\n    const ogDescriptionMatch = html.match(/<meta[^>]*property=[\"']og:description[\"'][^>]*content=[\"']([^\"']*)/i);\n    if (ogDescriptionMatch) {\n      metaData.ogDescription = this.cleanText(ogDescriptionMatch[1]);\n    }\n\n    return metaData;\n  }\n\n  /**\n   * Extracts data from DOM elements using regex patterns\n   * @param html - HTML content\n   * @returns Object\n   */\n  private extractDomData(html: string): Record<string, any> {\n    const domData: Record<string, any> = {};\n    \n    // Extract bedrooms/bathrooms from common patterns\n    const bedroomMatch = html.match(/(\\d+)\\s*(?:bed|br|bedroom)/i);\n    if (bedroomMatch) {\n      domData.bedrooms = parseInt(bedroomMatch[1]);\n    }\n\n    const bathroomMatch = html.match(/(\\d+(?:\\.\\d+)?)\\s*(?:bath|ba|bathroom)/i);\n    if (bathroomMatch) {\n      domData.bathrooms = parseFloat(bathroomMatch[1]);\n    }\n\n    // Extract guest capacity\n    const guestMatch = html.match(/(?:sleeps|accommodates|guests?)\\s*(\\d+)/i);\n    if (guestMatch) {\n      domData.maxGuests = parseInt(guestMatch[1]);\n    }\n\n    // Extract basic amenities from text\n    const amenityPatterns = [\n      /wifi|internet/i,\n      /parking/i,\n      /pool/i,\n      /hot[\\s-]?tub/i,\n      /kitchen/i,\n      /fireplace/i,\n      /air[\\s-]?conditioning|a\\/c/i,\n      /dishwasher/i,\n      /washer|laundry/i,\n      /tv|television/i\n    ];\n\n    const amenityNames = [\n      'WiFi',\n      'Parking',\n      'Pool',\n      'Hot Tub',\n      'Kitchen',\n      'Fireplace',\n      'Air Conditioning',\n      'Dishwasher',\n      'Washer/Dryer',\n      'TV'\n    ];\n\n    const foundAmenities: PropertyAmenity[] = [];\n    \n    amenityPatterns.forEach((pattern, index) => {\n      if (pattern.test(html)) {\n        foundAmenities.push({\n          name: amenityNames[index],\n          verified: false,\n          category: this.categorizeAmenity(amenityNames[index]),\n          priority: 'important'\n        });\n      }\n    });\n\n    domData.amenities = foundAmenities;\n\n    return domData;\n  }\n\n  /**\n   * Categorizes an amenity into a category\n   * @param amenityName - Name of the amenity\n   * @returns AmenityCategory\n   */\n  private categorizeAmenity(amenityName: string): AmenityCategory {\n    const name = amenityName.toLowerCase();\n    \n    if (name.includes('kitchen') || name.includes('dishwasher')) return 'kitchen';\n    if (name.includes('bathroom') || name.includes('bath')) return 'bathroom';\n    if (name.includes('bedroom') || name.includes('bed')) return 'bedroom';\n    if (name.includes('pool') || name.includes('hot tub') || name.includes('deck')) return 'outdoor';\n    if (name.includes('tv') || name.includes('fireplace') || name.includes('game')) return 'entertainment';\n    if (name.includes('wifi') || name.includes('internet')) return 'connectivity';\n    if (name.includes('air conditioning') || name.includes('heating')) return 'climate';\n    if (name.includes('parking') || name.includes('garage')) return 'parking';\n    if (name.includes('washer') || name.includes('dryer') || name.includes('laundry')) return 'laundry';\n    if (name.includes('smoke') || name.includes('fire extinguisher')) return 'safety';\n    \n    return 'general';\n  }\n\n  /**\n   * Merges JSON-LD data into extracted data\n   * @param extractedData - Target data object\n   * @param jsonLdData - JSON-LD data\n   */\n  private mergeJsonLdData(extractedData: Partial<VRBOPropertyData>, jsonLdData: any): void {\n    if (jsonLdData.name) {\n      extractedData.title = this.cleanText(jsonLdData.name);\n    }\n    \n    if (jsonLdData.description) {\n      extractedData.description = this.cleanText(jsonLdData.description);\n    }\n    \n    if (jsonLdData.address) {\n      extractedData.location = extractedData.location || {} as PropertyLocation;\n      \n      if (typeof jsonLdData.address === 'string') {\n        extractedData.location.address = jsonLdData.address;\n      } else if (jsonLdData.address.addressLocality) {\n        extractedData.location.city = jsonLdData.address.addressLocality;\n        extractedData.location.state = jsonLdData.address.addressRegion;\n        extractedData.location.country = jsonLdData.address.addressCountry;\n        extractedData.location.zipCode = jsonLdData.address.postalCode;\n      }\n    }\n  }\n\n  /**\n   * Merges meta tag data into extracted data\n   * @param extractedData - Target data object\n   * @param metaData - Meta tag data\n   */\n  private mergeMetaData(extractedData: Partial<VRBOPropertyData>, metaData: Record<string, string>): void {\n    if (!extractedData.title && (metaData.ogTitle || metaData.title)) {\n      extractedData.title = metaData.ogTitle || metaData.title;\n    }\n    \n    if (!extractedData.description && (metaData.ogDescription || metaData.description)) {\n      extractedData.description = metaData.ogDescription || metaData.description;\n    }\n  }\n\n  /**\n   * Merges DOM data into extracted data\n   * @param extractedData - Target data object\n   * @param domData - DOM extracted data\n   */\n  private mergeDomData(extractedData: Partial<VRBOPropertyData>, domData: Record<string, any>): void {\n    if (domData.bedrooms || domData.bathrooms || domData.maxGuests) {\n      extractedData.specifications = extractedData.specifications || {} as PropertySpecifications;\n      \n      if (domData.bedrooms) extractedData.specifications.bedrooms = domData.bedrooms;\n      if (domData.bathrooms) extractedData.specifications.bathrooms = domData.bathrooms;\n      if (domData.maxGuests) extractedData.specifications.maxGuests = domData.maxGuests;\n    }\n    \n    if (domData.amenities?.length > 0) {\n      extractedData.amenities = [...(extractedData.amenities || []), ...domData.amenities];\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  private getRandomUserAgent(): string {\n    return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];\n  }\n\n  private async enforceRateLimit(): Promise<void> {\n    const now = Date.now();\n    const windowDuration = this.rateLimitState.windowSize;\n    \n    // Reset window if expired\n    if (now - this.rateLimitState.windowStart >= windowDuration) {\n      this.rateLimitState.requests = 0;\n      this.rateLimitState.windowStart = now;\n    }\n    \n    // Check if we've exceeded the rate limit\n    if (this.rateLimitState.requests >= this.config.rateLimit) {\n      const waitTime = windowDuration - (now - this.rateLimitState.windowStart);\n      logger.info(`Rate limit reached, waiting ${waitTime}ms`, {}, 'VRBO_SCRAPER');\n      await this.delay(waitTime);\n      \n      // Reset after waiting\n      this.rateLimitState.requests = 0;\n      this.rateLimitState.windowStart = Date.now();\n    }\n    \n    this.rateLimitState.requests++;\n  }\n\n  private async handleRateLimitExceeded(): Promise<void> {\n    const backoffTime = 60000; // 1 minute\n    logger.warn(`Rate limit exceeded by server, backing off for ${backoffTime}ms`, {}, 'VRBO_SCRAPER');\n    await this.delay(backoffTime);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private cleanText(text: string): string {\n    return text.replace(/\\s+/g, ' ').trim();\n  }\n\n  private startSession(): ScrapingSession {\n    const session: ScrapingSession = {\n      id: Math.random().toString(36).substr(2, 9),\n      startTime: Date.now(),\n      requestCount: 0,\n      errors: [],\n      userAgent: this.config.userAgent\n    };\n    \n    this.currentSession = session;\n    return session;\n  }\n\n  private endSession(session: ScrapingSession): void {\n    if (this.currentSession?.id === session.id) {\n      this.currentSession = null;\n    }\n  }\n\n  private createScrapingError(error: any, code: string): ScrapingError {\n    return {\n      code,\n      message: error instanceof Error ? error.message : 'Unknown error',\n      severity: 'high',\n      recoverable: true\n    };\n  }\n\n  private getDefaultSpecifications(): PropertySpecifications {\n    return {\n      propertyType: 'house',\n      bedrooms: 0,\n      bathrooms: 0,\n      maxGuests: 0\n    };\n  }\n\n  private getDefaultLocation(): PropertyLocation {\n    return {\n      city: 'Unknown',\n      state: 'Unknown',\n      country: 'Unknown'\n    };\n  }\n\n  // Existing methods from original scraper\n  private isValidVRBOUrl(url: string): boolean {\n    const vrboPatterns = [\n      /^https?:\\/\\/(www\\.)?vrbo\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?homeaway\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?vacationrentals\\.com\\/\\d+/\n    ];\n    \n    return vrboPatterns.some(pattern => pattern.test(url));\n  }\n\n  private extractPropertyId(url: string): string | null {\n    const match = url.match(/\\/(\\d+)/);\n    return match ? match[1] : null;\n  }\n\n  private calculateDataCompleteness(data: VRBOPropertyData): number {\n    const requiredFields = [\n      'title', 'description', 'amenities', 'photos', 'rooms', \n      'specifications', 'location'\n    ];\n    \n    const optionalFields = [\n      'pricing', 'host', 'reviews', 'houseRules', 'nearbyAttractions'\n    ];\n\n    let completedRequired = 0;\n    let completedOptional = 0;\n\n    requiredFields.forEach(field => {\n      if (data[field as keyof VRBOPropertyData] && \n          this.isFieldComplete(data[field as keyof VRBOPropertyData])) {\n        completedRequired++;\n      }\n    });\n\n    optionalFields.forEach(field => {\n      if (data[field as keyof VRBOPropertyData] && \n          this.isFieldComplete(data[field as keyof VRBOPropertyData])) {\n        completedOptional++;\n      }\n    });\n\n    const requiredScore = (completedRequired / requiredFields.length) * 80;\n    const optionalScore = (completedOptional / optionalFields.length) * 20;\n\n    return Math.round(requiredScore + optionalScore);\n  }\n\n  private isFieldComplete(value: any): boolean {\n    if (value === null || value === undefined) return false;\n    if (typeof value === 'string') return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    if (typeof value === 'object') return Object.keys(value).length > 0;\n    return true;\n  }\n\n  private getScrapedFields(data: VRBOPropertyData): string[] {\n    const fields: string[] = [];\n    \n    Object.entries(data).forEach(([key, value]) => {\n      if (this.isFieldComplete(value)) {\n        fields.push(key);\n      }\n    });\n\n    return fields;\n  }\n}\n\n// Export factory function for creating scraper instances\nexport const createProductionVRBOScraper = (config?: Partial<ScraperConfig>): ProductionVRBOScraper => {\n  return new ProductionVRBOScraper(config);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/real-world-test-runner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1178,1181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1178,1181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3256,3259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3256,3259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":295,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10101,10104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10101,10104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Real-World VRBO Scraper Test Runner\n// Tests the scraper with actual VRBO URLs to validate functionality\n\nimport { scrapeVRBOProperty } from './vrbo-scraper';\nimport { scrapeBrowserVRBOProperty } from './vrbo-browser-scraper';\nimport { logger } from '../../utils/logger';\nimport type { VRBOPropertyData, PhotoData } from './types';\n\n// Test Configuration\nconst TEST_CONFIG = {\n  // Sample VRBO URLs for testing (replace with actual URLs)\n  testUrls: [\n    'https://www.vrbo.com/1234567', // House\n    'https://www.vrbo.com/2345678', // Condo\n    'https://www.vrbo.com/3456789', // Cabin\n    'https://www.vrbo.com/4567890', // Large property\n    'https://www.vrbo.com/5678901'  // Minimal property\n  ],\n  \n  // Test options\n  options: {\n    maxTestProperties: 3,\n    timeoutPerProperty: 120000, // 2 minutes\n    enableDetailedLogging: true,\n    saveResults: true,\n    compareStatic: true\n  }\n};\n\ninterface TestResult {\n  url: string;\n  testName: string;\n  success: boolean;\n  duration: number;\n  photoCount: number;\n  galleryPhotoCount?: number;\n  staticPhotoCount?: number;\n  dataCompleteness: number;\n  errorMessage?: string;\n  propertyData?: VRBOPropertyData;\n  metadata?: any;\n}\n\nexport class RealWorldVRBOTestRunner {\n  private testResults: TestResult[] = [];\n  private startTime: number = Date.now();\n\n  /**\n   * Run all real-world tests\n   */\n  async runAllTests(): Promise<void> {\n    console.log('ðŸš€ Starting Real-World VRBO Scraper Tests');\n    console.log('==========================================');\n    console.log(`Testing ${TEST_CONFIG.options.maxTestProperties} properties`);\n    console.log(`Timeout per property: ${TEST_CONFIG.options.timeoutPerProperty}ms`);\n    console.log('');\n\n    const urlsToTest = TEST_CONFIG.testUrls.slice(0, TEST_CONFIG.options.maxTestProperties);\n\n    for (let i = 0; i < urlsToTest.length; i++) {\n      const url = urlsToTest[i];\n      console.log(`\\nðŸ“‹ Testing Property ${i + 1}/${urlsToTest.length}: ${url}`);\n      console.log(''.padEnd(60, '-'));\n\n      // Test 1: Browser Automation Scraping\n      await this.testBrowserAutomation(url);\n\n      // Test 2: Static Fallback Scraping\n      if (TEST_CONFIG.options.compareStatic) {\n        await this.testStaticScraping(url);\n      }\n\n      // Test 3: Performance Comparison\n      await this.testPerformanceComparison(url);\n\n      // Small delay between properties\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n\n    this.printFinalResults();\n  }\n\n  /**\n   * Test browser automation scraping\n   */\n  private async testBrowserAutomation(url: string): Promise<void> {\n    const testName = 'Browser Automation';\n    const startTime = Date.now();\n    \n    try {\n      console.log(`   ðŸ” Testing ${testName}...`);\n      \n      const result = await Promise.race([\n        scrapeBrowserVRBOProperty(url, {\n          useStaticFallback: true,\n          headless: true,\n          enableStealth: true,\n          scrollCycles: 5,\n          scrollWaitTime: 3000,\n          browserTimeout: 60000,\n          enableScreenshots: false,\n          screenshotPath: './screenshots'\n        }),\n        new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Test timeout')), TEST_CONFIG.options.timeoutPerProperty)\n        )\n      ]) as any;\n\n      const duration = Date.now() - startTime;\n\n      if (result.success) {\n        const totalPhotos = result.data.totalImages || 0;\n        const galleryPhotos = result.data.galleryImages?.length || 0;\n        const staticPhotos = result.data.staticImages?.length || 0;\n        const completeness = this.calculateDataCompleteness(result.data.propertyData);\n\n        this.testResults.push({\n          url,\n          testName,\n          success: true,\n          duration,\n          photoCount: totalPhotos,\n          galleryPhotoCount: galleryPhotos,\n          staticPhotoCount: staticPhotos,\n          dataCompleteness: completeness,\n          propertyData: result.data.propertyData,\n          metadata: result.metadata\n        });\n\n        console.log(`   âœ… ${testName} SUCCESS`);\n        console.log(`      Photos: ${totalPhotos} (${galleryPhotos} gallery + ${staticPhotos} static)`);\n        console.log(`      Time: ${duration}ms`);\n        console.log(`      Completeness: ${completeness}%`);\n        console.log(`      Scroll Cycles: ${result.data.galleryLoadingResult?.scrollCyclesCompleted || 0}`);\n        \n        if (TEST_CONFIG.options.enableDetailedLogging) {\n          this.logDetailedResults(result.data.propertyData, 'Browser Automation');\n        }\n      } else {\n        throw new Error(`Scraping failed: ${result.errors?.map(e => e.message).join(', ')}`);\n      }\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      \n      this.testResults.push({\n        url,\n        testName,\n        success: false,\n        duration,\n        photoCount: 0,\n        dataCompleteness: 0,\n        errorMessage\n      });\n\n      console.log(`   âŒ ${testName} FAILED: ${errorMessage}`);\n      console.log(`      Time: ${duration}ms`);\n    }\n  }\n\n  /**\n   * Test static scraping (fallback)\n   */\n  private async testStaticScraping(url: string): Promise<void> {\n    const testName = 'Static Fallback';\n    const startTime = Date.now();\n    \n    try {\n      console.log(`   ðŸ” Testing ${testName}...`);\n      \n      const propertyData = await Promise.race([\n        scrapeVRBOProperty(url),\n        new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Test timeout')), TEST_CONFIG.options.timeoutPerProperty)\n        )\n      ]) as VRBOPropertyData;\n\n      const duration = Date.now() - startTime;\n      const photoCount = propertyData.photos?.length || 0;\n      const completeness = this.calculateDataCompleteness(propertyData);\n\n      this.testResults.push({\n        url,\n        testName,\n        success: true,\n        duration,\n        photoCount,\n        dataCompleteness: completeness,\n        propertyData\n      });\n\n      console.log(`   âœ… ${testName} SUCCESS`);\n      console.log(`      Photos: ${photoCount}`);\n      console.log(`      Time: ${duration}ms`);\n      console.log(`      Completeness: ${completeness}%`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      \n      this.testResults.push({\n        url,\n        testName,\n        success: false,\n        duration,\n        photoCount: 0,\n        dataCompleteness: 0,\n        errorMessage\n      });\n\n      console.log(`   âŒ ${testName} FAILED: ${errorMessage}`);\n      console.log(`      Time: ${duration}ms`);\n    }\n  }\n\n  /**\n   * Compare performance between methods\n   */\n  private async testPerformanceComparison(url: string): Promise<void> {\n    const browserResult = this.testResults.find(r => r.url === url && r.testName === 'Browser Automation');\n    const staticResult = this.testResults.find(r => r.url === url && r.testName === 'Static Fallback');\n\n    if (browserResult && staticResult) {\n      console.log(`   ðŸ“Š Performance Comparison:`);\n      console.log(`      Browser: ${browserResult.photoCount} photos in ${browserResult.duration}ms`);\n      console.log(`      Static:  ${staticResult.photoCount} photos in ${staticResult.duration}ms`);\n      \n      const photoImprovement = browserResult.photoCount - staticResult.photoCount;\n      const timeOverhead = browserResult.duration - staticResult.duration;\n      \n      console.log(`      Photo Improvement: +${photoImprovement} photos (${Math.round((photoImprovement / Math.max(staticResult.photoCount, 1)) * 100)}%)`);\n      console.log(`      Time Overhead: +${timeOverhead}ms`);\n      \n      if (photoImprovement > 0) {\n        console.log(`      âœ… Browser automation extracted ${photoImprovement} more photos`);\n      } else {\n        console.log(`      âš ï¸  Browser automation didn't improve photo extraction`);\n      }\n    }\n  }\n\n  /**\n   * Log detailed results for a property\n   */\n  private logDetailedResults(propertyData: VRBOPropertyData, method: string): void {\n    console.log(`\\n      ðŸ“„ ${method} - Property Details:`);\n    console.log(`         Title: ${propertyData.title?.substring(0, 50)}...`);\n    console.log(`         Property ID: ${propertyData.vrboId}`);\n    console.log(`         Bedrooms: ${propertyData.specifications?.bedrooms || 'N/A'}`);\n    console.log(`         Bathrooms: ${propertyData.specifications?.bathrooms || 'N/A'}`);\n    console.log(`         Max Guests: ${propertyData.specifications?.maxGuests || 'N/A'}`);\n    console.log(`         Amenities: ${propertyData.amenities?.length || 0}`);\n    console.log(`         Rooms: ${propertyData.rooms?.length || 0}`);\n    console.log(`         Location: ${propertyData.location?.city || 'N/A'}, ${propertyData.location?.state || 'N/A'}`);\n    \n    if (propertyData.amenities && propertyData.amenities.length > 0) {\n      console.log(`         Top Amenities: ${propertyData.amenities.slice(0, 3).map(a => a.name).join(', ')}`);\n    }\n  }\n\n  /**\n   * Calculate data completeness percentage\n   */\n  private calculateDataCompleteness(data: VRBOPropertyData): number {\n    const requiredFields = ['title', 'description', 'amenities', 'photos', 'specifications', 'location'];\n    const optionalFields = ['rooms', 'pricing', 'host', 'reviews'];\n    \n    let completedRequired = 0;\n    let completedOptional = 0;\n\n    requiredFields.forEach(field => {\n      const value = data[field as keyof VRBOPropertyData];\n      if (this.isFieldComplete(value)) {\n        completedRequired++;\n      }\n    });\n\n    optionalFields.forEach(field => {\n      const value = data[field as keyof VRBOPropertyData];\n      if (this.isFieldComplete(value)) {\n        completedOptional++;\n      }\n    });\n\n    const requiredScore = (completedRequired / requiredFields.length) * 80;\n    const optionalScore = (completedOptional / optionalFields.length) * 20;\n\n    return Math.round(requiredScore + optionalScore);\n  }\n\n  /**\n   * Check if a field has meaningful content\n   */\n  private isFieldComplete(value: any): boolean {\n    if (value === null || value === undefined) return false;\n    if (typeof value === 'string') return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    if (typeof value === 'object') return Object.keys(value).length > 0;\n    return true;\n  }\n\n  /**\n   * Print final test results\n   */\n  private printFinalResults(): void {\n    const totalDuration = Date.now() - this.startTime;\n    \n    console.log('\\n\\nðŸ“Š FINAL TEST RESULTS SUMMARY');\n    console.log('================================');\n    console.log(`Total Test Duration: ${totalDuration}ms (${Math.round(totalDuration / 1000)}s)`);\n    console.log(`Properties Tested: ${TEST_CONFIG.options.maxTestProperties}`);\n    console.log('');\n\n    // Success rate\n    const successfulTests = this.testResults.filter(r => r.success);\n    const successRate = Math.round((successfulTests.length / this.testResults.length) * 100);\n    console.log(`Success Rate: ${successfulTests.length}/${this.testResults.length} (${successRate}%)`);\n    console.log('');\n\n    // Browser automation results\n    const browserResults = this.testResults.filter(r => r.testName === 'Browser Automation' && r.success);\n    if (browserResults.length > 0) {\n      const avgPhotos = Math.round(browserResults.reduce((sum, r) => sum + r.photoCount, 0) / browserResults.length);\n      const avgGalleryPhotos = Math.round(browserResults.reduce((sum, r) => sum + (r.galleryPhotoCount || 0), 0) / browserResults.length);\n      const avgStaticPhotos = Math.round(browserResults.reduce((sum, r) => sum + (r.staticPhotoCount || 0), 0) / browserResults.length);\n      const avgTime = Math.round(browserResults.reduce((sum, r) => sum + r.duration, 0) / browserResults.length);\n      const avgCompleteness = Math.round(browserResults.reduce((sum, r) => sum + r.dataCompleteness, 0) / browserResults.length);\n\n      console.log('ðŸ¤– Browser Automation Results:');\n      console.log(`   Average Photos: ${avgPhotos} (${avgGalleryPhotos} gallery + ${avgStaticPhotos} static)`);\n      console.log(`   Average Time: ${avgTime}ms`);\n      console.log(`   Average Completeness: ${avgCompleteness}%`);\n      console.log('');\n    }\n\n    // Static fallback results\n    const staticResults = this.testResults.filter(r => r.testName === 'Static Fallback' && r.success);\n    if (staticResults.length > 0) {\n      const avgPhotos = Math.round(staticResults.reduce((sum, r) => sum + r.photoCount, 0) / staticResults.length);\n      const avgTime = Math.round(staticResults.reduce((sum, r) => sum + r.duration, 0) / staticResults.length);\n      const avgCompleteness = Math.round(staticResults.reduce((sum, r) => sum + r.dataCompleteness, 0) / staticResults.length);\n\n      console.log('ðŸ“„ Static Fallback Results:');\n      console.log(`   Average Photos: ${avgPhotos}`);\n      console.log(`   Average Time: ${avgTime}ms`);\n      console.log(`   Average Completeness: ${avgCompleteness}%`);\n      console.log('');\n    }\n\n    // Performance comparison\n    if (browserResults.length > 0 && staticResults.length > 0) {\n      const photoImprovement = browserResults.reduce((sum, r) => sum + r.photoCount, 0) - staticResults.reduce((sum, r) => sum + r.photoCount, 0);\n      const timeOverhead = browserResults.reduce((sum, r) => sum + r.duration, 0) - staticResults.reduce((sum, r) => sum + r.duration, 0);\n      \n      console.log('âš¡ Performance Comparison:');\n      console.log(`   Photo Improvement: +${photoImprovement} total photos`);\n      console.log(`   Time Overhead: +${timeOverhead}ms total`);\n      console.log(`   Cost/Benefit: ${Math.round(photoImprovement / (timeOverhead / 1000))} extra photos per second`);\n      console.log('');\n    }\n\n    // Failed tests\n    const failedTests = this.testResults.filter(r => !r.success);\n    if (failedTests.length > 0) {\n      console.log('âŒ Failed Tests:');\n      failedTests.forEach(test => {\n        console.log(`   ${test.testName} - ${test.url}: ${test.errorMessage}`);\n      });\n      console.log('');\n    }\n\n    // Recommendations\n    console.log('ðŸ’¡ Recommendations:');\n    if (browserResults.length > 0) {\n      const avgPhotos = browserResults.reduce((sum, r) => sum + r.photoCount, 0) / browserResults.length;\n      if (avgPhotos > 15) {\n        console.log('   âœ… Browser automation is effectively extracting photos (>15 avg)');\n      } else {\n        console.log('   âš ï¸  Browser automation may need optimization (<15 avg photos)');\n      }\n    }\n    \n    if (successRate < 80) {\n      console.log('   âš ï¸  Success rate is below 80% - investigate error handling');\n    } else {\n      console.log('   âœ… Success rate is acceptable (>80%)');\n    }\n\n    console.log('\\nðŸŽ¯ Next Steps:');\n    console.log('   1. Review failed tests and improve error handling');\n    console.log('   2. Optimize browser automation for better photo extraction');\n    console.log('   3. Consider rate limiting and anti-bot measures');\n    console.log('   4. Test with larger sample size for production validation');\n  }\n\n  /**\n   * Save results to file (if enabled)\n   */\n  private async saveResults(): Promise<void> {\n    if (!TEST_CONFIG.options.saveResults) return;\n\n    const resultsData = {\n      timestamp: new Date().toISOString(),\n      testConfig: TEST_CONFIG,\n      results: this.testResults,\n      summary: {\n        totalDuration: Date.now() - this.startTime,\n        successRate: Math.round((this.testResults.filter(r => r.success).length / this.testResults.length) * 100),\n        averagePhotos: Math.round(this.testResults.reduce((sum, r) => sum + r.photoCount, 0) / this.testResults.length),\n        averageTime: Math.round(this.testResults.reduce((sum, r) => sum + r.duration, 0) / this.testResults.length)\n      }\n    };\n\n    // In a real implementation, you'd save to a file\n    console.log('\\nðŸ’¾ Results saved to test-results.json');\n    console.log(JSON.stringify(resultsData, null, 2));\n  }\n}\n\n// Export for use in other modules\nexport const runRealWorldTests = async (): Promise<void> => {\n  const testRunner = new RealWorldVRBOTestRunner();\n  await testRunner.runAllTests();\n};\n\n// CLI execution\nif (require.main === module) {\n  runRealWorldTests().catch(console.error);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/static-vrbo-photo-extractor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":333,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10505,10508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10505,10508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced Static VRBO Photo Extractor\n// Optimized version of the original working photo extraction method\n\nimport axios, { AxiosInstance } from 'axios';\nimport { logger } from '../../utils/logger';\nimport type { PhotoData, ScrapingResult, ScrapingError } from './types';\n\ninterface StaticPhotoExtractionOptions {\n  maxImages: number;\n  includeHighRes: boolean;\n  includeThumbnails: boolean;\n  deduplicateImages: boolean;\n  userAgent: string;\n  timeout: number;\n}\n\ninterface StaticPhotoExtractionResult {\n  photos: PhotoData[];\n  extractionStats: {\n    staticImages: number;\n    lazyImages: number;\n    galleryImages: number;\n    jsonLdImages: number;\n    totalFound: number;\n    totalProcessed: number;\n    duplicatesRemoved: number;\n  };\n  sourceHtml: string;\n  processingTime: number;\n}\n\nexport class StaticVRBOPhotoExtractor {\n  private httpClient: AxiosInstance;\n  private options: StaticPhotoExtractionOptions;\n\n  constructor(options: Partial<StaticPhotoExtractionOptions> = {}) {\n    this.options = {\n      maxImages: 50,\n      includeHighRes: true,\n      includeThumbnails: true,\n      deduplicateImages: true,\n      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n      timeout: 30000,\n      ...options\n    };\n\n    this.httpClient = axios.create({\n      timeout: this.options.timeout,\n      headers: {\n        'User-Agent': this.options.userAgent,\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Accept-Language': 'en-US,en;q=0.9',\n        'Accept-Encoding': 'gzip, deflate, br',\n        'Connection': 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'Sec-Fetch-Dest': 'document',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-Site': 'none',\n        'Cache-Control': 'no-cache'\n      }\n    });\n  }\n\n  /**\n   * Extract photos using static HTML parsing (the original working method)\n   * @param url - VRBO property URL\n   * @returns Promise<ScrapingResult<StaticPhotoExtractionResult>>\n   */\n  async extractPhotos(url: string): Promise<ScrapingResult<StaticPhotoExtractionResult>> {\n    const startTime = Date.now();\n\n    try {\n      logger.info('Starting static photo extraction', { url }, 'STATIC_VRBO_PHOTO_EXTRACTOR');\n\n      // Fetch the HTML page\n      const response = await this.httpClient.get(url);\n      const html = response.data;\n\n      // Extract images using multiple strategies\n      const staticImages = this.extractStaticImages(html);\n      const lazyImages = this.extractLazyImages(html);\n      const galleryImages = this.extractGalleryImages(html);\n      const jsonLdImages = this.extractJsonLdImages(html);\n\n      // Combine all images\n      const allImages = [\n        ...staticImages,\n        ...lazyImages,\n        ...galleryImages,\n        ...jsonLdImages\n      ];\n\n      // Remove duplicates\n      const uniqueImages = this.options.deduplicateImages ? \n        this.deduplicateImages(allImages) : allImages;\n\n      // Filter by resolution preferences\n      const filteredImages = this.filterImagesByResolution(uniqueImages);\n\n      // Limit to max images\n      const limitedImages = filteredImages.slice(0, this.options.maxImages);\n\n      // Convert to PhotoData format\n      const photos = this.convertToPhotoData(limitedImages);\n\n      const processingTime = Date.now() - startTime;\n\n      const result: StaticPhotoExtractionResult = {\n        photos,\n        extractionStats: {\n          staticImages: staticImages.length,\n          lazyImages: lazyImages.length,\n          galleryImages: galleryImages.length,\n          jsonLdImages: jsonLdImages.length,\n          totalFound: allImages.length,\n          totalProcessed: limitedImages.length,\n          duplicatesRemoved: allImages.length - uniqueImages.length\n        },\n        sourceHtml: html,\n        processingTime\n      };\n\n      logger.info('Static photo extraction completed', {\n        url,\n        totalPhotos: photos.length,\n        staticImages: staticImages.length,\n        lazyImages: lazyImages.length,\n        galleryImages: galleryImages.length,\n        jsonLdImages: jsonLdImages.length,\n        processingTime\n      }, 'STATIC_VRBO_PHOTO_EXTRACTOR');\n\n      return {\n        success: true,\n        data: result,\n        errors: [],\n        metadata: {\n          scrapedAt: new Date(),\n          duration: processingTime,\n          sourceUrl: url,\n          userAgent: this.options.userAgent,\n          rateLimited: false,\n          dataCompleteness: Math.min(100, (photos.length / 20) * 100),\n          fieldsScraped: ['photos'],\n          fieldsFailed: []\n        }\n      };\n\n    } catch (error) {\n      const processingTime = Date.now() - startTime;\n      const scrapingError: ScrapingError = {\n        code: 'STATIC_PHOTO_EXTRACTION_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown error',\n        severity: 'high',\n        recoverable: true\n      };\n\n      logger.error('Static photo extraction failed', error, 'STATIC_VRBO_PHOTO_EXTRACTOR');\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata: {\n          scrapedAt: new Date(),\n          duration: processingTime,\n          sourceUrl: url,\n          userAgent: this.options.userAgent,\n          rateLimited: false,\n          dataCompleteness: 0,\n          fieldsScraped: [],\n          fieldsFailed: ['photos']\n        }\n      };\n    }\n  }\n\n  /**\n   * Extract static images from img tags (Method 1 - Basic)\n   */\n  private extractStaticImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Enhanced img tag regex\n    const imgRegex = /<img[^>]*src=[\"']([^\"']+)[\"'][^>]*>/gi;\n    let match;\n    \n    while ((match = imgRegex.exec(html)) !== null) {\n      const imageUrl = match[1];\n      if (this.isValidImageUrl(imageUrl)) {\n        images.push(this.normalizeImageUrl(imageUrl));\n      }\n    }\n    \n    return images;\n  }\n\n  /**\n   * Extract lazy-loaded images (Method 2 - Lazy Loading)\n   */\n  private extractLazyImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Enhanced lazy loading patterns\n    const lazyPatterns = [\n      // Standard data-src patterns\n      /<img[^>]*data-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      /<img[^>]*data-lazy-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      /<img[^>]*data-original=[\"']([^\"']+)[\"'][^>]*>/gi,\n      /<img[^>]*data-url=[\"']([^\"']+)[\"'][^>]*>/gi,\n      \n      // VRBO-specific patterns\n      /<img[^>]*data-hero-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      /<img[^>]*data-gallery-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      /<img[^>]*data-photo-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      \n      // Srcset patterns\n      /<img[^>]*srcset=[\"']([^\"']+)[\"'][^>]*>/gi,\n      \n      // Background image patterns\n      /style=[\"'][^\"']*background-image:\\s*url\\([\"']?([^\"')]+)[\"']?\\)/gi,\n      \n      // Picture element patterns\n      /<source[^>]*srcset=[\"']([^\"']+)[\"'][^>]*>/gi\n    ];\n    \n    lazyPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const imageUrl = match[1];\n        if (this.isValidImageUrl(imageUrl)) {\n          // Handle srcset (multiple images)\n          if (imageUrl.includes(',')) {\n            const srcsetImages = imageUrl.split(',').map(src => \n              src.trim().split(' ')[0] // Get URL, ignore size descriptor\n            );\n            srcsetImages.forEach(src => {\n              if (this.isValidImageUrl(src)) {\n                images.push(this.normalizeImageUrl(src));\n              }\n            });\n          } else {\n            images.push(this.normalizeImageUrl(imageUrl));\n          }\n        }\n      }\n    });\n    \n    return images;\n  }\n\n  /**\n   * Extract gallery images from JavaScript objects (Method 3 - JS Variables)\n   */\n  private extractGalleryImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Enhanced JavaScript image patterns\n    const jsImagePatterns = [\n      // Common JS variable patterns\n      /images?\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      /photos?\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      /gallery\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      /imageUrls?\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      \n      // VRBO-specific patterns\n      /propertyPhotos?\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      /heroImages?\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      /galleryData\\s*[:=]\\s*\\[([\\s\\S]*?)\\]/gi,\n      \n      // Object property patterns\n      /\"images?\"\\s*:\\s*\\[([\\s\\S]*?)\\]/gi,\n      /\"photos?\"\\s*:\\s*\\[([\\s\\S]*?)\\]/gi,\n      /\"gallery\"\\s*:\\s*\\[([\\s\\S]*?)\\]/gi,\n      \n      // Window object patterns\n      /window\\.images?\\s*=\\s*\\[([\\s\\S]*?)\\]/gi,\n      /window\\.photos?\\s*=\\s*\\[([\\s\\S]*?)\\]/gi\n    ];\n    \n    jsImagePatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const imageArray = match[1];\n        \n        // Extract URLs from the array content\n        const urlMatches = imageArray.match(/[\"']([^\"']*\\.(jpg|jpeg|png|webp|gif))[\"']/gi);\n        \n        if (urlMatches) {\n          urlMatches.forEach(urlMatch => {\n            const imageUrl = urlMatch.replace(/[\"']/g, '');\n            if (this.isValidImageUrl(imageUrl)) {\n              images.push(this.normalizeImageUrl(imageUrl));\n            }\n          });\n        }\n      }\n    });\n    \n    return images;\n  }\n\n  /**\n   * Extract images from JSON-LD structured data (Method 4 - Structured Data)\n   */\n  private extractJsonLdImages(html: string): string[] {\n    const images: string[] = [];\n    \n    try {\n      // More comprehensive JSON-LD extraction\n      const jsonLdRegex = /<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>([\\s\\S]*?)<\\/script>/gi;\n      let match;\n      \n      while ((match = jsonLdRegex.exec(html)) !== null) {\n        try {\n          const jsonContent = match[1].trim();\n          const data = JSON.parse(jsonContent);\n          \n          // Handle array of JSON-LD objects\n          const jsonLdObjects = Array.isArray(data) ? data : [data];\n          \n          jsonLdObjects.forEach(obj => {\n            // Extract images from various JSON-LD properties\n            const imageProperties = [\n              'image', 'photo', 'photos', 'images',\n              'primaryImageOfPage', 'thumbnailUrl', 'contentUrl',\n              'url', 'mainEntity', 'about'\n            ];\n            \n            imageProperties.forEach(prop => {\n              if (obj[prop]) {\n                const imageData = Array.isArray(obj[prop]) ? obj[prop] : [obj[prop]];\n                \n                imageData.forEach((img: any) => {\n                  let imageUrl: string;\n                  \n                  if (typeof img === 'string') {\n                    imageUrl = img;\n                  } else if (img && typeof img === 'object') {\n                    imageUrl = img.url || img.contentUrl || img.thumbnailUrl || img.src;\n                  } else {\n                    return;\n                  }\n                  \n                  if (this.isValidImageUrl(imageUrl)) {\n                    images.push(this.normalizeImageUrl(imageUrl));\n                  }\n                });\n              }\n            });\n          });\n        } catch (e) {\n          // Continue to next script tag\n        }\n      }\n    } catch (error) {\n      logger.warn('Failed to extract JSON-LD images', error, 'STATIC_VRBO_PHOTO_EXTRACTOR');\n    }\n    \n    return images;\n  }\n\n  /**\n   * Validate if URL is a valid image URL\n   */\n  private isValidImageUrl(url: string): boolean {\n    if (!url || typeof url !== 'string') return false;\n    \n    // Check for valid image extensions\n    const imageExtensions = /\\.(jpg|jpeg|png|webp|gif|avif|svg)(\\?|$)/i;\n    if (!imageExtensions.test(url)) return false;\n    \n    // Check for valid URL format\n    const urlPattern = /^https?:\\/\\/.+/i;\n    if (!urlPattern.test(url)) return false;\n    \n    // Filter out unwanted image types\n    const unwantedPatterns = [\n      /pixel|tracking|analytics|beacon/i,\n      /1x1|blank|empty|placeholder/i,\n      /\\.svg$/i, // Remove SVG icons\n      /logo|icon|favicon/i,\n      /spinner|loader|loading/i\n    ];\n    \n    return !unwantedPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Normalize image URL (convert relative to absolute, clean up)\n   */\n  private normalizeImageUrl(url: string): string {\n    // Remove quotes and trim\n    let normalizedUrl = url.replace(/[\"']/g, '').trim();\n    \n    // Convert protocol-relative URLs\n    if (normalizedUrl.startsWith('//')) {\n      normalizedUrl = 'https:' + normalizedUrl;\n    }\n    \n    // Handle relative URLs (though rare in VRBO)\n    if (normalizedUrl.startsWith('/')) {\n      normalizedUrl = 'https://www.vrbo.com' + normalizedUrl;\n    }\n    \n    // Clean up common URL issues\n    normalizedUrl = normalizedUrl.replace(/&amp;/g, '&');\n    \n    return normalizedUrl;\n  }\n\n  /**\n   * Remove duplicate images\n   */\n  private deduplicateImages(images: string[]): string[] {\n    const seen = new Set<string>();\n    const unique: string[] = [];\n    \n    images.forEach(img => {\n      // Normalize for comparison (remove query params for deduplication)\n      const normalizedForComparison = img.split('?')[0].toLowerCase();\n      \n      if (!seen.has(normalizedForComparison)) {\n        seen.add(normalizedForComparison);\n        unique.push(img);\n      }\n    });\n    \n    return unique;\n  }\n\n  /**\n   * Filter images by resolution preferences\n   */\n  private filterImagesByResolution(images: string[]): string[] {\n    const filtered: string[] = [];\n    \n    images.forEach(url => {\n      const isThumbnail = this.isThumbnailUrl(url);\n      \n      if (this.options.includeHighRes && !isThumbnail) {\n        filtered.push(url);\n      } else if (this.options.includeThumbnails && isThumbnail) {\n        filtered.push(url);\n      }\n    });\n    \n    // If no high-res images found, include thumbnails anyway\n    if (filtered.length === 0 && images.length > 0) {\n      return images;\n    }\n    \n    return filtered;\n  }\n\n  /**\n   * Check if URL is a thumbnail\n   */\n  private isThumbnailUrl(url: string): boolean {\n    const thumbnailIndicators = [\n      /thumb/i, /small/i, /preview/i, /mini/i,\n      /_s\\.|_t\\.|_xs\\.|_sm\\./i,\n      /150x|300x|400x/i,\n      /w_150|w_300|w_400/i,\n      /c_thumb|c_fill|c_fit/i,\n      /resize.*200|resize.*150/i\n    ];\n    \n    return thumbnailIndicators.some(indicator => indicator.test(url));\n  }\n\n  /**\n   * Convert image URLs to PhotoData format\n   */\n  private convertToPhotoData(images: string[]): PhotoData[] {\n    return images.map((url, index) => ({\n      url,\n      thumbnailUrl: this.isThumbnailUrl(url) ? url : undefined,\n      alt: `Property photo ${index + 1}`,\n      category: this.categorizeImageByUrl(url),\n      order: index + 1,\n      size: this.estimateImageSize(url)\n    }));\n  }\n\n  /**\n   * Categorize image by URL patterns\n   */\n  private categorizeImageByUrl(url: string): 'exterior' | 'interior' | 'kitchen' | 'bedroom' | 'bathroom' | 'living_area' | 'outdoor_space' | 'view' | 'amenity' {\n    const lowerUrl = url.toLowerCase();\n    \n    if (lowerUrl.includes('exterior') || lowerUrl.includes('outside') || lowerUrl.includes('facade')) return 'exterior';\n    if (lowerUrl.includes('kitchen') || lowerUrl.includes('dining')) return 'kitchen';\n    if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n    if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n    if (lowerUrl.includes('living') || lowerUrl.includes('lounge') || lowerUrl.includes('family')) return 'living_area';\n    if (lowerUrl.includes('pool') || lowerUrl.includes('deck') || lowerUrl.includes('patio') || lowerUrl.includes('yard')) return 'outdoor_space';\n    if (lowerUrl.includes('view') || lowerUrl.includes('scenic') || lowerUrl.includes('landscape')) return 'view';\n    if (lowerUrl.includes('amenity') || lowerUrl.includes('facility')) return 'amenity';\n    \n    return 'interior';\n  }\n\n  /**\n   * Estimate image size from URL\n   */\n  private estimateImageSize(url: string): { width: number; height: number } {\n    // Try to extract dimensions from URL\n    const dimensionMatch = url.match(/(\\d+)x(\\d+)/);\n    if (dimensionMatch) {\n      return {\n        width: parseInt(dimensionMatch[1]),\n        height: parseInt(dimensionMatch[2])\n      };\n    }\n    \n    // Default sizes based on URL patterns\n    if (this.isThumbnailUrl(url)) {\n      return { width: 300, height: 200 };\n    }\n    \n    return { width: 1200, height: 800 };\n  }\n}\n\n// Export factory function\nexport const createStaticVRBOPhotoExtractor = (options?: Partial<StaticPhotoExtractionOptions>) => {\n  return new StaticVRBOPhotoExtractor(options);\n};\n\n// Export convenience function\nexport const extractVRBOPhotosStatic = async (url: string, options?: Partial<StaticPhotoExtractionOptions>): Promise<PhotoData[]> => {\n  const extractor = createStaticVRBOPhotoExtractor(options);\n  const result = await extractor.extractPhotos(url);\n  \n  if (result.success) {\n    return result.data!.photos;\n  }\n  \n  return [];\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/vrbo-browser-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3511,3514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3511,3514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10314,10317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10314,10317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12404,12407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12404,12407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":425,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14474,14477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14474,14477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":425,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14498,14501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14498,14501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":425,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":425,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14506,14509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14506,14509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":426,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":426,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14553,14556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14553,14556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced VRBO Browser Scraper with Dynamic Image Loading\n// Combines browser automation with comprehensive data extraction\n\nimport { ComprehensiveVRBOScraper } from './comprehensive-vrbo-scraper';\nimport { BrowserManager } from './browser-manager';\nimport { VRBOGalleryAutomation } from './vrbo-gallery-automation';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { logger } from '../../utils/logger';\nimport { errorReporter } from '../monitoring/error-reporter';\nimport type {\n  ScrapingResult,\n  ScrapingError,\n  ScrapingMetadata,\n  VRBOPropertyData,\n  PhotoData,\n  ScraperConfig\n} from './types';\n\nexport interface BrowserScrapingOptions {\n  useStaticFallback: boolean;\n  enableScreenshots: boolean;\n  screenshotPath: string;\n  scrollCycles: number;\n  scrollWaitTime: number;\n  browserTimeout: number;\n  enableStealth: boolean;\n  headless: boolean;\n}\n\nexport interface BrowserScrapingResult {\n  propertyData: VRBOPropertyData;\n  galleryImages: PhotoData[];\n  staticImages: PhotoData[];\n  totalImages: number;\n  galleryLoadingResult: {\n    scrollCyclesCompleted: number;\n    loadingTime: number;\n    errors: string[];\n  };\n  browserMetadata: {\n    sessionId: string;\n    userAgent: string;\n    screenResolution: string;\n    processingTime: number;\n    memoryUsage: number;\n  };\n}\n\nexport class VRBOBrowserScraper extends ComprehensiveVRBOScraper {\n  private browserManager: BrowserManager;\n  private galleryAutomation: VRBOGalleryAutomation;\n  private browserOptions: BrowserScrapingOptions;\n\n  private defaultBrowserOptions: BrowserScrapingOptions = {\n    useStaticFallback: true,\n    enableScreenshots: false,\n    screenshotPath: '/tmp/vrbo-screenshots',\n    scrollCycles: 5,\n    scrollWaitTime: 3000,\n    browserTimeout: 120000,\n    enableStealth: true,\n    headless: true\n  };\n\n  constructor(config: Partial<ScraperConfig> = {}, browserOptions: Partial<BrowserScrapingOptions> = {}) {\n    super(config);\n    \n    this.browserOptions = { ...this.defaultBrowserOptions, ...browserOptions };\n    \n    this.browserManager = new BrowserManager({\n      headless: this.browserOptions.headless,\n      timeout: this.browserOptions.browserTimeout,\n      enableStealth: this.browserOptions.enableStealth,\n      blockImages: false, // We need images for VRBO\n      blockCSS: true // Block CSS for faster loading\n    });\n\n    this.galleryAutomation = new VRBOGalleryAutomation(this.browserManager, {\n      scrollCycles: this.browserOptions.scrollCycles,\n      scrollWaitTime: this.browserOptions.scrollWaitTime,\n      enableScreenshots: this.browserOptions.enableScreenshots,\n      screenshotPath: this.browserOptions.screenshotPath\n    });\n  }\n\n  /**\n   * Scrapes VRBO property with browser automation for complete image extraction\n   * @param url - VRBO property URL\n   * @param options - Browser scraping options\n   * @returns Promise<ScrapingResult<BrowserScrapingResult>>\n   */\n  async scrapeWithBrowserAutomation(\n    url: string,\n    options: Partial<BrowserScrapingOptions> = {}\n  ): Promise<ScrapingResult<BrowserScrapingResult>> {\n    const finalOptions = { ...this.browserOptions, ...options };\n    const startTime = Date.now();\n    const errors: ScrapingError[] = [];\n    \n    const metadata: ScrapingMetadata = {\n      scrapedAt: new Date(),\n      duration: 0,\n      sourceUrl: url,\n      userAgent: this.browserManager.config?.userAgent || 'Unknown',\n      rateLimited: false,\n      dataCompleteness: 0,\n      fieldsScraped: [],\n      fieldsFailed: []\n    };\n\n    let browserSession: any = null;\n    let sessionId = '';\n\n    try {\n      // Log browser scraping start\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting browser-based VRBO scraping: ${url}`,\n        'browser_scraping',\n        `Using Puppeteer automation with ${finalOptions.scrollCycles} scroll cycles`,\n        [url],\n        'high'\n      );\n\n      // Step 1: Create browser session\n      logger.info('Creating browser session for VRBO scraping', { url }, 'VRBO_BROWSER_SCRAPER');\n      browserSession = await this.browserManager.createSession();\n      sessionId = browserSession.sessionId;\n\n      // Step 2: Load property data using browser automation\n      const galleryResult = await this.galleryAutomation.loadAllGalleryImages(browserSession.page, url);\n      \n      // Step 3: Extract additional data from the loaded page\n      const pageData = await this.extractPageData(browserSession.page, url);\n      \n      // Step 4: Combine with static scraping if enabled\n      let staticImages: PhotoData[] = [];\n      let staticPropertyData: VRBOPropertyData | null = null;\n      \n      if (finalOptions.useStaticFallback) {\n        try {\n          const staticResult = await this.scrapeComprehensiveProperty(url, {\n            includeImages: true,\n            includeAdvancedAmenities: true,\n            includeDetailedDescriptions: true,\n            includeRoomData: true,\n            maxImages: 100\n          });\n          \n          if (staticResult.success) {\n            staticImages = staticResult.data!.images;\n            staticPropertyData = staticResult.data!.propertyData;\n          }\n        } catch (staticError) {\n          logger.warn('Static scraping fallback failed', staticError, 'VRBO_BROWSER_SCRAPER');\n        }\n      }\n\n      // Step 5: Merge browser and static data\n      const mergedData = this.mergeBrowserAndStaticData(\n        pageData,\n        staticPropertyData,\n        galleryResult.images,\n        staticImages\n      );\n\n      // Step 6: Calculate browser metadata\n      const browserMetadata = await this.calculateBrowserMetadata(browserSession, startTime);\n\n      // Step 7: Create final result\n      const totalImages = mergedData.images.length;\n      const result: BrowserScrapingResult = {\n        propertyData: mergedData.propertyData,\n        galleryImages: galleryResult.images,\n        staticImages: staticImages,\n        totalImages,\n        galleryLoadingResult: {\n          scrollCyclesCompleted: galleryResult.scrollCyclesCompleted,\n          loadingTime: galleryResult.loadingTime,\n          errors: galleryResult.errors\n        },\n        browserMetadata\n      };\n\n      // Calculate final metadata\n      metadata.duration = Date.now() - startTime;\n      metadata.dataCompleteness = this.calculateBrowserDataCompleteness(result);\n      metadata.fieldsScraped = ['browser_images', 'static_images', 'property_data'];\n      \n      if (galleryResult.errors.length > 0) {\n        metadata.fieldsFailed.push('gallery_automation');\n        galleryResult.errors.forEach(error => {\n          errors.push({\n            code: 'GALLERY_AUTOMATION_ERROR',\n            message: error,\n            severity: 'medium',\n            recoverable: true\n          });\n        });\n      }\n\n      logger.info('Browser-based VRBO scraping completed successfully', {\n        url,\n        totalImages,\n        galleryImages: galleryResult.images.length,\n        staticImages: staticImages.length,\n        scrollCycles: galleryResult.scrollCyclesCompleted,\n        processingTime: metadata.duration,\n        dataCompleteness: metadata.dataCompleteness\n      }, 'VRBO_BROWSER_SCRAPER');\n\n      return {\n        success: true,\n        data: result,\n        errors,\n        metadata\n      };\n\n    } catch (error) {\n      const scrapingError: ScrapingError = {\n        code: 'BROWSER_SCRAPING_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown browser scraping error',\n        severity: 'high',\n        recoverable: finalOptions.useStaticFallback\n      };\n      \n      errors.push(scrapingError);\n      metadata.duration = Date.now() - startTime;\n      metadata.fieldsFailed = ['browser_scraping'];\n      \n      logger.error('Browser-based VRBO scraping failed', error, 'VRBO_BROWSER_SCRAPER');\n      \n      errorReporter.reportError(error as Error, {\n        context: 'VRBO_BROWSER_SCRAPER',\n        url,\n        sessionId,\n        metadata\n      });\n\n      // Try static fallback if enabled\n      if (finalOptions.useStaticFallback) {\n        try {\n          logger.info('Attempting static fallback scraping', { url }, 'VRBO_BROWSER_SCRAPER');\n          const fallbackResult = await this.scrapeComprehensiveProperty(url);\n          \n          if (fallbackResult.success) {\n            const browserMetadata = {\n              sessionId: sessionId || 'failed',\n              userAgent: this.browserManager.config?.userAgent || 'Unknown',\n              screenResolution: 'Unknown',\n              processingTime: Date.now() - startTime,\n              memoryUsage: 0\n            };\n\n            const result: BrowserScrapingResult = {\n              propertyData: fallbackResult.data!.propertyData,\n              galleryImages: [],\n              staticImages: fallbackResult.data!.images,\n              totalImages: fallbackResult.data!.images.length,\n              galleryLoadingResult: {\n                scrollCyclesCompleted: 0,\n                loadingTime: 0,\n                errors: ['Browser automation failed, used static fallback']\n              },\n              browserMetadata\n            };\n\n            metadata.duration = Date.now() - startTime;\n            metadata.dataCompleteness = 60; // Lower score for fallback\n            metadata.fieldsScraped = ['static_fallback'];\n\n            logger.info('Static fallback scraping succeeded', {\n              url,\n              totalImages: result.totalImages\n            }, 'VRBO_BROWSER_SCRAPER');\n\n            return {\n              success: true,\n              data: result,\n              errors,\n              metadata\n            };\n          }\n        } catch (fallbackError) {\n          logger.error('Static fallback also failed', fallbackError, 'VRBO_BROWSER_SCRAPER');\n        }\n      }\n\n      return {\n        success: false,\n        errors,\n        metadata\n      };\n\n    } finally {\n      // Clean up browser session\n      if (sessionId) {\n        try {\n          await this.browserManager.closeSession(sessionId);\n        } catch (cleanupError) {\n          logger.error('Error cleaning up browser session', cleanupError, 'VRBO_BROWSER_SCRAPER');\n        }\n      }\n    }\n  }\n\n  /**\n   * Extracts property data from the browser-loaded page\n   * @param page - Puppeteer page instance\n   * @param url - Original URL\n   * @returns Promise<VRBOPropertyData>\n   */\n  private async extractPageData(page: any, url: string): Promise<VRBOPropertyData> {\n    const html = await page.content();\n    const propertyId = this.extractPropertyId(url) || 'unknown';\n    \n    // Use existing data extraction methods on the browser-loaded HTML\n    const extractedData = await this.extractPropertyData(html, url, propertyId);\n    \n    return extractedData;\n  }\n\n  /**\n   * Merges browser automation data with static scraping data\n   * @param browserData - Data from browser automation\n   * @param staticData - Data from static scraping\n   * @param galleryImages - Images from gallery automation\n   * @param staticImages - Images from static scraping\n   * @returns Combined data\n   */\n  private mergeBrowserAndStaticData(\n    browserData: VRBOPropertyData,\n    staticData: VRBOPropertyData | null,\n    galleryImages: PhotoData[],\n    staticImages: PhotoData[]\n  ): { propertyData: VRBOPropertyData; images: PhotoData[] } {\n    // Merge property data, prioritizing browser data\n    const mergedPropertyData: VRBOPropertyData = {\n      ...browserData,\n      // Enhance with static data if available\n      ...(staticData ? {\n        amenities: this.mergeAmenities(browserData.amenities || [], staticData.amenities || []),\n        rooms: staticData.rooms && staticData.rooms.length > 0 ? staticData.rooms : browserData.rooms,\n        description: browserData.description || staticData.description,\n        specifications: {\n          ...browserData.specifications,\n          ...staticData.specifications\n        }\n      } : {})\n    };\n\n    // Merge images, prioritizing gallery images\n    const allImages = [...galleryImages, ...staticImages];\n    const uniqueImages = this.deduplicateImages(allImages);\n\n    // Update property data with merged images\n    mergedPropertyData.photos = uniqueImages;\n\n    return {\n      propertyData: mergedPropertyData,\n      images: uniqueImages\n    };\n  }\n\n  /**\n   * Calculates browser-specific metadata\n   * @param browserSession - Browser session\n   * @param startTime - Start time\n   * @returns Browser metadata\n   */\n  private async calculateBrowserMetadata(browserSession: any, startTime: number): Promise<BrowserScrapingResult['browserMetadata']> {\n    try {\n      const viewport = await browserSession.page.viewport();\n      const metrics = await browserSession.page.metrics();\n      \n      return {\n        sessionId: browserSession.sessionId,\n        userAgent: await browserSession.page.evaluate(() => navigator.userAgent),\n        screenResolution: `${viewport.width}x${viewport.height}`,\n        processingTime: Date.now() - startTime,\n        memoryUsage: metrics.JSHeapUsedSize || 0\n      };\n    } catch (error) {\n      logger.warn('Failed to calculate browser metadata', error, 'VRBO_BROWSER_SCRAPER');\n      return {\n        sessionId: browserSession?.sessionId || 'unknown',\n        userAgent: 'Unknown',\n        screenResolution: 'Unknown',\n        processingTime: Date.now() - startTime,\n        memoryUsage: 0\n      };\n    }\n  }\n\n  /**\n   * Calculates data completeness score for browser scraping\n   * @param result - Browser scraping result\n   * @returns Completeness score (0-100)\n   */\n  private calculateBrowserDataCompleteness(result: BrowserScrapingResult): number {\n    let score = 0;\n    \n    // Base property data (40%)\n    if (result.propertyData.title) score += 10;\n    if (result.propertyData.description) score += 10;\n    if (result.propertyData.amenities && result.propertyData.amenities.length > 0) score += 10;\n    if (result.propertyData.specifications?.bedrooms) score += 5;\n    if (result.propertyData.specifications?.bathrooms) score += 5;\n    \n    // Image extraction (50%)\n    if (result.totalImages > 0) score += 20;\n    if (result.totalImages >= 10) score += 10;\n    if (result.totalImages >= 20) score += 10;\n    if (result.galleryImages.length > 0) score += 10; // Bonus for gallery images\n    \n    // Automation success (10%)\n    if (result.galleryLoadingResult.scrollCyclesCompleted > 0) score += 5;\n    if (result.galleryLoadingResult.errors.length === 0) score += 5;\n    \n    return Math.round(Math.min(score, 100));\n  }\n\n  /**\n   * Utility methods\n   */\n  private mergeAmenities(browserAmenities: any[], staticAmenities: any[]): any[] {\n    const amenityMap = new Map<string, any>();\n    \n    // Add browser amenities first\n    browserAmenities.forEach(amenity => {\n      amenityMap.set(amenity.name.toLowerCase(), amenity);\n    });\n    \n    // Add static amenities, avoiding duplicates\n    staticAmenities.forEach(amenity => {\n      if (!amenityMap.has(amenity.name.toLowerCase())) {\n        amenityMap.set(amenity.name.toLowerCase(), amenity);\n      }\n    });\n    \n    return Array.from(amenityMap.values());\n  }\n\n  private deduplicateImages(images: PhotoData[]): PhotoData[] {\n    const seen = new Set<string>();\n    const unique: PhotoData[] = [];\n    \n    images.forEach(img => {\n      const normalizedUrl = img.url.replace(/\\?.*$/, '').toLowerCase();\n      \n      if (!seen.has(normalizedUrl)) {\n        seen.add(normalizedUrl);\n        unique.push(img);\n      }\n    });\n    \n    return unique;\n  }\n\n  /**\n   * Cleanup method\n   */\n  async cleanup(): Promise<void> {\n    await this.browserManager.closeAllSessions();\n  }\n}\n\n// Export factory function\nexport const createVRBOBrowserScraper = (\n  config?: Partial<ScraperConfig>,\n  browserOptions?: Partial<BrowserScrapingOptions>\n): VRBOBrowserScraper => {\n  return new VRBOBrowserScraper(config, browserOptions);\n};\n\n// Export convenience function for direct browser scraping\nexport const scrapeBrowserVRBOProperty = async (\n  url: string,\n  options: Partial<BrowserScrapingOptions> = {}\n): Promise<ScrapingResult<BrowserScrapingResult>> => {\n  const scraper = createVRBOBrowserScraper();\n  \n  try {\n    const result = await scraper.scrapeWithBrowserAutomation(url, options);\n    return result;\n  } finally {\n    await scraper.cleanup();\n  }\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/vrbo-data-extractor.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":262,"column":46,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":262,"endColumn":47,"suggestions":[{"messageId":"removeEscape","fix":{"range":[8390,8391],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[8390,8390],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":262,"column":72,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":262,"endColumn":73,"suggestions":[{"messageId":"removeEscape","fix":{"range":[8416,8417],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[8416,8416],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9136,9139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9136,9139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":692,"column":25,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":692,"endColumn":26,"suggestions":[{"messageId":"removeEscape","fix":{"range":[22921,22922],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[22921,22921],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":755,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24963,24966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24963,24966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":793,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":793,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26238,26241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26238,26241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// VRBO Data Extractor - Phase 3: Comprehensive Data Extraction\n// Handles amenity parsing, detailed descriptions, and room-by-room data extraction\n\nimport { ProductionVRBOScraper } from './production-vrbo-scraper';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { logger } from '../../utils/logger';\nimport type { \n  ScrapingResult, \n  PropertyAmenity, \n  PropertyRoom, \n  VRBOPropertyData,\n  AmenityCategory,\n  RoomType,\n  PropertySpecifications,\n  PropertyLocation,\n  ScrapingMetadata,\n  ScrapingError\n} from './types';\n\ninterface AmenityExtractionOptions {\n  includeHidden: boolean;\n  expandCollapsed: boolean;\n  categorizeByRoom: boolean;\n  verifyWithAI: boolean;\n  extractDescriptions: boolean;\n}\n\ninterface DescriptionExtractionOptions {\n  includeFormatting: boolean;\n  extractHighlights: boolean;\n  parseStructuredData: boolean;\n  maxLength: number;\n}\n\ninterface RoomExtractionOptions {\n  detectRoomTypes: boolean;\n  extractDimensions: boolean;\n  includeFeatures: boolean;\n  linkToAmenities: boolean;\n}\n\ninterface DataExtractionResult {\n  amenities: PropertyAmenity[];\n  descriptions: {\n    main: string;\n    highlights: string[];\n    structured: Record<string, string>;\n  };\n  rooms: PropertyRoom[];\n  specifications: PropertySpecifications;\n  location: PropertyLocation;\n  extractionStats: {\n    amenitiesFound: number;\n    roomsDetected: number;\n    descriptionsExtracted: number;\n    hiddenDataRevealed: number;\n  };\n}\n\nexport class VRBODataExtractor extends ProductionVRBOScraper {\n  private defaultAmenityOptions: AmenityExtractionOptions = {\n    includeHidden: true,\n    expandCollapsed: true,\n    categorizeByRoom: true,\n    verifyWithAI: false,\n    extractDescriptions: true\n  };\n\n  private defaultDescriptionOptions: DescriptionExtractionOptions = {\n    includeFormatting: true,\n    extractHighlights: true,\n    parseStructuredData: true,\n    maxLength: 5000\n  };\n\n  private defaultRoomOptions: RoomExtractionOptions = {\n    detectRoomTypes: true,\n    extractDimensions: true,\n    includeFeatures: true,\n    linkToAmenities: true\n  };\n\n  /**\n   * Comprehensive data extraction from VRBO property page\n   * @param url - VRBO property URL\n   * @param options - Extraction options\n   * @returns Promise<ScrapingResult<DataExtractionResult>>\n   */\n  async extractComprehensiveData(\n    url: string, \n    amenityOptions: Partial<AmenityExtractionOptions> = {},\n    descriptionOptions: Partial<DescriptionExtractionOptions> = {},\n    roomOptions: Partial<RoomExtractionOptions> = {}\n  ): Promise<ScrapingResult<DataExtractionResult>> {\n    const finalAmenityOptions = { ...this.defaultAmenityOptions, ...amenityOptions };\n    const finalDescriptionOptions = { ...this.defaultDescriptionOptions, ...descriptionOptions };\n    const finalRoomOptions = { ...this.defaultRoomOptions, ...roomOptions };\n    const startTime = Date.now();\n    \n    const metadata: ScrapingMetadata = {\n      scrapedAt: new Date(),\n      duration: 0,\n      sourceUrl: url,\n      userAgent: this.httpClient.defaults.headers['User-Agent'] as string,\n      rateLimited: false,\n      dataCompleteness: 0,\n      fieldsScraped: [],\n      fieldsFailed: []\n    };\n\n    try {\n      // Log comprehensive data extraction start\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting comprehensive VRBO data extraction: ${url}`,\n        'data_extraction',\n        `Extracting amenities, descriptions, and room data with advanced parsing`,\n        [url],\n        'high'\n      );\n\n      // Validate URL\n      if (!this.isValidVRBOUrl(url)) {\n        throw new Error('Invalid VRBO URL provided');\n      }\n\n      // Fetch the main property page\n      const html = await this.fetchMainPropertyPage(url);\n      \n      // Extract amenities with advanced parsing\n      const amenities = await this.extractAdvancedAmenities(html, finalAmenityOptions);\n      \n      // Extract detailed descriptions\n      const descriptions = await this.extractDetailedDescriptions(html, finalDescriptionOptions);\n      \n      // Extract room-by-room data\n      const rooms = await this.extractRoomData(html, finalRoomOptions);\n      \n      // Extract enhanced specifications\n      const specifications = await this.extractEnhancedSpecifications(html, amenities, rooms);\n      \n      // Extract detailed location data\n      const location = await this.extractDetailedLocation(html);\n      \n      // Calculate extraction statistics\n      const extractionStats = {\n        amenitiesFound: amenities.length,\n        roomsDetected: rooms.length,\n        descriptionsExtracted: Object.keys(descriptions.structured).length + (descriptions.main ? 1 : 0),\n        hiddenDataRevealed: this.calculateHiddenDataCount(html, amenities, descriptions)\n      };\n      \n      const result: DataExtractionResult = {\n        amenities,\n        descriptions,\n        rooms,\n        specifications,\n        location,\n        extractionStats\n      };\n\n      // Calculate metadata\n      metadata.duration = Date.now() - startTime;\n      metadata.dataCompleteness = this.calculateComprehensiveDataCompleteness(result);\n      metadata.fieldsScraped = ['amenities', 'descriptions', 'rooms', 'specifications', 'location'];\n\n      logger.info('VRBO comprehensive data extraction completed successfully', {\n        amenitiesFound: extractionStats.amenitiesFound,\n        roomsDetected: extractionStats.roomsDetected,\n        dataCompleteness: metadata.dataCompleteness,\n        duration: metadata.duration\n      }, 'VRBO_DATA_EXTRACTOR');\n\n      return {\n        success: true,\n        data: result,\n        errors: [],\n        metadata\n      };\n\n    } catch (error) {\n      const scrapingError: ScrapingError = {\n        code: 'DATA_EXTRACTION_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown data extraction error',\n        severity: 'high',\n        recoverable: true\n      };\n      \n      metadata.duration = Date.now() - startTime;\n      metadata.fieldsFailed = ['comprehensive_data'];\n      \n      logger.error('VRBO comprehensive data extraction failed', error, 'VRBO_DATA_EXTRACTOR');\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata\n      };\n    }\n  }\n\n  /**\n   * Extracts amenities with advanced parsing including hidden/collapsed sections\n   * @param html - HTML content\n   * @param options - Amenity extraction options\n   * @returns Promise<PropertyAmenity[]>\n   */\n  private async extractAdvancedAmenities(html: string, options: AmenityExtractionOptions): Promise<PropertyAmenity[]> {\n    const amenities: PropertyAmenity[] = [];\n    const foundAmenityNames = new Set<string>();\n\n    // Extract from structured JSON-LD data first\n    const jsonLdAmenities = this.extractJsonLdAmenities(html);\n    amenities.push(...jsonLdAmenities);\n    jsonLdAmenities.forEach(amenity => foundAmenityNames.add(amenity.name.toLowerCase()));\n\n    // Extract from visible amenity lists\n    const visibleAmenities = this.extractVisibleAmenities(html);\n    visibleAmenities.forEach(amenity => {\n      if (!foundAmenityNames.has(amenity.name.toLowerCase())) {\n        amenities.push(amenity);\n        foundAmenityNames.add(amenity.name.toLowerCase());\n      }\n    });\n\n    // Extract from collapsed/hidden sections if enabled\n    if (options.includeHidden) {\n      const hiddenAmenities = this.extractHiddenAmenities(html);\n      hiddenAmenities.forEach(amenity => {\n        if (!foundAmenityNames.has(amenity.name.toLowerCase())) {\n          amenities.push(amenity);\n          foundAmenityNames.add(amenity.name.toLowerCase());\n        }\n      });\n    }\n\n    // Extract from data attributes and JavaScript\n    const dataAttributeAmenities = this.extractDataAttributeAmenities(html);\n    dataAttributeAmenities.forEach(amenity => {\n      if (!foundAmenityNames.has(amenity.name.toLowerCase())) {\n        amenities.push(amenity);\n        foundAmenityNames.add(amenity.name.toLowerCase());\n      }\n    });\n\n    // Categorize amenities by room if enabled\n    if (options.categorizeByRoom) {\n      return this.categorizeAmenitiesByRoom(amenities, html);\n    }\n\n    return amenities;\n  }\n\n  /**\n   * Extracts amenities from JSON-LD structured data\n   * @param html - HTML content\n   * @returns PropertyAmenity[]\n   */\n  private extractJsonLdAmenities(html: string): PropertyAmenity[] {\n    const amenities: PropertyAmenity[] = [];\n    \n    try {\n      const jsonLdRegex = /<script[^>]*type=[\\\"']application\\/ld\\+json[\\\"'][^>]*>(.*?)<\\/script>/gis;\n      const matches = html.match(jsonLdRegex);\n      \n      if (matches) {\n        matches.forEach(match => {\n          try {\n            const jsonContent = match.replace(/<script[^>]*>/i, '').replace(/<\\/script>/i, '');\n            const data = JSON.parse(jsonContent);\n            \n            // Look for amenity features in various JSON-LD properties\n            const amenityProperties = ['amenityFeature', 'features', 'additionalProperty'];\n            \n            amenityProperties.forEach(prop => {\n              if (data[prop]) {\n                const features = Array.isArray(data[prop]) ? data[prop] : [data[prop]];\n                \n                features.forEach((feature: any) => {\n                  let amenityName: string;\n                  \n                  if (typeof feature === 'string') {\n                    amenityName = feature;\n                  } else if (feature.name) {\n                    amenityName = feature.name;\n                  } else if (feature.value) {\n                    amenityName = feature.value;\n                  } else {\n                    return;\n                  }\n                  \n                  amenities.push({\n                    name: this.cleanAmenityName(amenityName),\n                    verified: true,\n                    category: this.categorizeAmenity(amenityName),\n                    priority: this.prioritizeAmenity(amenityName),\n                    description: feature.description || undefined\n                  });\n                });\n              }\n            });\n          } catch (e) {\n            // Continue to next script tag\n          }\n        });\n      }\n    } catch (error) {\n      logger.warn('Failed to extract JSON-LD amenities', error, 'VRBO_DATA_EXTRACTOR');\n    }\n    \n    return amenities;\n  }\n\n  /**\n   * Extracts amenities from visible UI elements\n   * @param html - HTML content\n   * @returns PropertyAmenity[]\n   */\n  private extractVisibleAmenities(html: string): PropertyAmenity[] {\n    const amenities: PropertyAmenity[] = [];\n    \n    // Common patterns for amenity lists\n    const amenityPatterns = [\n      // List items with amenity-related classes\n      /<li[^>]*class=\"[^\"]*amenity[^\"]*\"[^>]*>([^<]+)</gi,\n      /<li[^>]*class=\"[^\"]*feature[^\"]*\"[^>]*>([^<]+)</gi,\n      /<div[^>]*class=\"[^\"]*amenity[^\"]*\"[^>]*>([^<]+)<\\/div>/gi,\n      /<span[^>]*class=\"[^\"]*amenity[^\"]*\"[^>]*>([^<]+)<\\/span>/gi,\n      \n      // Data attributes\n      /data-amenity=\"([^\"]+)\"/gi,\n      /data-feature=\"([^\"]+)\"/gi,\n      \n      // Icon-based amenity detection\n      /<i[^>]*class=\"[^\"]*(?:wifi|pool|parking|kitchen|gym|spa)[^\"]*\"[^>]*><\\/i>[^<]*<[^>]*>([^<]+)/gi\n    ];\n    \n    amenityPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const amenityText = this.cleanAmenityName(match[1]);\n        if (amenityText && amenityText.length > 2 && amenityText.length < 100) {\n          amenities.push({\n            name: amenityText,\n            verified: false,\n            category: this.categorizeAmenity(amenityText),\n            priority: this.prioritizeAmenity(amenityText)\n          });\n        }\n      }\n    });\n    \n    return amenities;\n  }\n\n  /**\n   * Extracts amenities from hidden/collapsed sections\n   * @param html - HTML content\n   * @returns PropertyAmenity[]\n   */\n  private extractHiddenAmenities(html: string): PropertyAmenity[] {\n    const amenities: PropertyAmenity[] = [];\n    \n    // Look for hidden content sections\n    const hiddenPatterns = [\n      // Hidden divs with display:none or similar\n      /<div[^>]*style=\"[^\"]*display:\\s*none[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      /<div[^>]*class=\"[^\"]*hidden[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      /<div[^>]*class=\"[^\"]*collapse[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      \n      // Expandable sections\n      /<div[^>]*class=\"[^\"]*expandable[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      /<div[^>]*data-toggle=\"collapse\"[^>]*>(.*?)<\\/div>/gis,\n      \n      // Modal content\n      /<div[^>]*class=\"[^\"]*modal[^\"]*\"[^>]*>(.*?)<\\/div>/gis\n    ];\n    \n    hiddenPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const hiddenContent = match[1];\n        \n        // Extract amenities from hidden content using standard patterns\n        const hiddenAmenities = this.extractVisibleAmenities(hiddenContent);\n        amenities.push(...hiddenAmenities);\n      }\n    });\n    \n    return amenities;\n  }\n\n  /**\n   * Extracts amenities from data attributes and JavaScript variables\n   * @param html - HTML content\n   * @returns PropertyAmenity[]\n   */\n  private extractDataAttributeAmenities(html: string): PropertyAmenity[] {\n    const amenities: PropertyAmenity[] = [];\n    \n    // Extract from JavaScript configuration objects\n    const jsPatterns = [\n      /amenities\\s*:\\s*\\[([^\\]]+)\\]/gi,\n      /features\\s*:\\s*\\[([^\\]]+)\\]/gi,\n      /\"amenities\":\\s*\\[([^\\]]+)\\]/gi,\n      /\"features\":\\s*\\[([^\\]]+)\\]/gi\n    ];\n    \n    jsPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const amenityArray = match[1];\n        \n        // Extract quoted strings from the array\n        const quotedStrings = amenityArray.match(/\"([^\"]+)\"/g) || [];\n        quotedStrings.forEach(quoted => {\n          const amenityName = quoted.replace(/\"/g, '');\n          if (amenityName && amenityName.length > 2) {\n            amenities.push({\n              name: this.cleanAmenityName(amenityName),\n              verified: true,\n              category: this.categorizeAmenity(amenityName),\n              priority: this.prioritizeAmenity(amenityName)\n            });\n          }\n        });\n      }\n    });\n    \n    return amenities;\n  }\n\n  /**\n   * Categorizes amenities by room type\n   * @param amenities - Array of amenities\n   * @param html - HTML content for context\n   * @returns PropertyAmenity[]\n   */\n  private categorizeAmenitiesByRoom(amenities: PropertyAmenity[], html: string): PropertyAmenity[] {\n    return amenities.map(amenity => {\n      const roomContext = this.detectAmenityRoomContext(amenity.name, html);\n      return {\n        ...amenity,\n        roomType: roomContext\n      };\n    });\n  }\n\n  /**\n   * Detects which room an amenity belongs to based on context\n   * @param amenityName - Name of the amenity\n   * @param html - HTML content for context analysis\n   * @returns RoomType | undefined\n   */\n  private detectAmenityRoomContext(amenityName: string, html: string): RoomType | undefined {\n    const name = amenityName.toLowerCase();\n    \n    // Direct room indicators in amenity name\n    if (name.includes('kitchen') || name.includes('cooking') || name.includes('fridge') || name.includes('microwave')) {\n      return 'kitchen';\n    }\n    if (name.includes('bedroom') || name.includes('bed ') || name.includes('mattress')) {\n      return 'bedroom';\n    }\n    if (name.includes('bathroom') || name.includes('shower') || name.includes('bathtub')) {\n      return 'bathroom';\n    }\n    if (name.includes('living') || name.includes('sofa') || name.includes('couch')) {\n      return 'living_room';\n    }\n    if (name.includes('dining') || name.includes('table')) {\n      return 'dining_room';\n    }\n    if (name.includes('office') || name.includes('desk') || name.includes('workspace')) {\n      return 'office';\n    }\n    if (name.includes('game') || name.includes('entertainment') || name.includes('pool table')) {\n      return 'game_room';\n    }\n    if (name.includes('balcony') || name.includes('terrace')) {\n      return 'balcony';\n    }\n    if (name.includes('patio') || name.includes('deck') || name.includes('outdoor dining')) {\n      return 'patio';\n    }\n    if (name.includes('garage') || name.includes('car') || name.includes('parking')) {\n      return 'garage';\n    }\n    \n    // Look for context clues in surrounding HTML\n    const amenityPattern = new RegExp(amenityName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n    const amenityMatch = html.search(amenityPattern);\n    \n    if (amenityMatch !== -1) {\n      const contextStart = Math.max(0, amenityMatch - 500);\n      const contextEnd = Math.min(html.length, amenityMatch + 500);\n      const context = html.slice(contextStart, contextEnd).toLowerCase();\n      \n      if (context.includes('kitchen')) return 'kitchen';\n      if (context.includes('bedroom')) return 'bedroom';\n      if (context.includes('bathroom')) return 'bathroom';\n      if (context.includes('living')) return 'living_room';\n      if (context.includes('dining')) return 'dining_room';\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Extracts detailed property descriptions with formatting\n   * @param html - HTML content\n   * @param options - Description extraction options\n   * @returns Object with main description, highlights, and structured data\n   */\n  private async extractDetailedDescriptions(html: string, options: DescriptionExtractionOptions): Promise<{\n    main: string;\n    highlights: string[];\n    structured: Record<string, string>;\n  }> {\n    const descriptions = {\n      main: '',\n      highlights: [] as string[],\n      structured: {} as Record<string, string>\n    };\n\n    // Extract main description from common patterns\n    const descriptionPatterns = [\n      // Meta description\n      /<meta[^>]*name=[\"']description[\"'][^>]*content=[\"']([^\"']+)/i,\n      // Open Graph description\n      /<meta[^>]*property=[\"']og:description[\"'][^>]*content=[\"']([^\"']+)/i,\n      // Structured description sections\n      /<div[^>]*class=\"[^\"]*description[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      /<section[^>]*class=\"[^\"]*description[^\"]*\"[^>]*>(.*?)<\\/section>/gis,\n      // Property overview sections\n      /<div[^>]*class=\"[^\"]*overview[^\"]*\"[^>]*>(.*?)<\\/div>/gis,\n      /<div[^>]*class=\"[^\"]*summary[^\"]*\"[^>]*>(.*?)<\\/div>/gis\n    ];\n\n    for (const pattern of descriptionPatterns) {\n      const match = html.match(pattern);\n      if (match && match[1]) {\n        let description = match[1];\n        \n        if (options.includeFormatting) {\n          description = this.preserveDescriptionFormatting(description);\n        } else {\n          description = this.cleanText(description);\n        }\n        \n        if (description.length > descriptions.main.length && description.length <= options.maxLength) {\n          descriptions.main = description;\n        }\n      }\n    }\n\n    // Extract highlights/bullet points\n    if (options.extractHighlights) {\n      descriptions.highlights = this.extractDescriptionHighlights(html);\n    }\n\n    // Extract structured data sections\n    if (options.parseStructuredData) {\n      descriptions.structured = this.extractStructuredDescriptions(html);\n    }\n\n    return descriptions;\n  }\n\n  /**\n   * Preserves formatting in descriptions while cleaning HTML\n   * @param description - Raw description HTML\n   * @returns Formatted description text\n   */\n  private preserveDescriptionFormatting(description: string): string {\n    return description\n      .replace(/<br\\s*\\/?>/gi, '\\n')\n      .replace(/<\\/p>/gi, '\\n\\n')\n      .replace(/<li[^>]*>/gi, 'â€¢ ')\n      .replace(/<\\/li>/gi, '\\n')\n      .replace(/<[^>]+>/g, '')\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;/g, \"'\")\n      .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n')\n      .trim();\n  }\n\n  /**\n   * Extracts highlight points from descriptions\n   * @param html - HTML content\n   * @returns Array of highlight strings\n   */\n  private extractDescriptionHighlights(html: string): string[] {\n    const highlights: string[] = [];\n    \n    // Look for bullet point lists\n    const listPatterns = [\n      /<ul[^>]*>(.*?)<\\/ul>/gis,\n      /<ol[^>]*>(.*?)<\\/ol>/gis\n    ];\n    \n    listPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const listContent = match[1];\n        const listItems = listContent.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n        \n        listItems.forEach(item => {\n          const cleanItem = this.cleanText(item.replace(/<li[^>]*>|<\\/li>/gi, ''));\n          if (cleanItem && cleanItem.length > 10 && cleanItem.length < 200) {\n            highlights.push(cleanItem);\n          }\n        });\n      }\n    });\n    \n    return highlights.slice(0, 20); // Limit to 20 highlights\n  }\n\n  /**\n   * Extracts structured description sections\n   * @param html - HTML content\n   * @returns Object with structured description data\n   */\n  private extractStructuredDescriptions(html: string): Record<string, string> {\n    const structured: Record<string, string> = {};\n    \n    // Look for labeled sections\n    const sectionPatterns = [\n      // Sections with headers\n      /<h[1-6][^>]*>([^<]+)<\\/h[1-6]>[^<]*<[^>]*>([^<]+)/gi,\n      // Definition lists\n      /<dt[^>]*>([^<]+)<\\/dt>[^<]*<dd[^>]*>([^<]+)<\\/dd>/gi,\n      // Labeled divs\n      /<div[^>]*class=\"[^\"]*label[^\"]*\"[^>]*>([^<]+)<\\/div>[^<]*<div[^>]*>([^<]+)<\\/div>/gi\n    ];\n    \n    sectionPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const label = this.cleanText(match[1]);\n        const content = this.cleanText(match[2]);\n        \n        if (label && content && label.length < 100 && content.length < 1000) {\n          structured[label] = content;\n        }\n      }\n    });\n    \n    return structured;\n  }\n\n  /**\n   * Extracts room-by-room data from the property page\n   * @param html - HTML content\n   * @param options - Room extraction options\n   * @returns PropertyRoom[]\n   */\n  private async extractRoomData(html: string, options: RoomExtractionOptions): Promise<PropertyRoom[]> {\n    const rooms: PropertyRoom[] = [];\n    \n    // Extract from structured data first\n    const jsonLdRooms = this.extractJsonLdRooms(html);\n    rooms.push(...jsonLdRooms);\n    \n    // Extract from description text patterns\n    const descriptionRooms = this.extractRoomsFromDescription(html);\n    rooms.push(...descriptionRooms);\n    \n    // Extract from explicit room sections\n    const sectionRooms = this.extractRoomsFromSections(html);\n    rooms.push(...sectionRooms);\n    \n    // Deduplicate and enhance rooms\n    const uniqueRooms = this.deduplicateRooms(rooms);\n    \n    if (options.extractDimensions) {\n      return this.enhanceRoomsWithDimensions(uniqueRooms, html);\n    }\n    \n    return uniqueRooms;\n  }\n\n  /**\n   * Utility methods for amenity processing\n   */\n  private cleanAmenityName(name: string): string {\n    return name\n      .replace(/[^\\w\\s\\-\\/&]/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n  }\n\n  private prioritizeAmenity(amenityName: string): 'essential' | 'important' | 'nice_to_have' {\n    const name = amenityName.toLowerCase();\n    \n    // Essential amenities\n    if (name.includes('wifi') || name.includes('internet') || \n        name.includes('kitchen') || name.includes('parking') ||\n        name.includes('heating') || name.includes('air conditioning')) {\n      return 'essential';\n    }\n    \n    // Important amenities\n    if (name.includes('pool') || name.includes('hot tub') || \n        name.includes('washer') || name.includes('dryer') ||\n        name.includes('tv') || name.includes('dishwasher')) {\n      return 'important';\n    }\n    \n    return 'nice_to_have';\n  }\n\n  /**\n   * Placeholder methods for room extraction (to be implemented)\n   */\n  private extractJsonLdRooms(html: string): PropertyRoom[] {\n    // Implementation for JSON-LD room extraction\n    return [];\n  }\n\n  private extractRoomsFromDescription(html: string): PropertyRoom[] {\n    // Implementation for description-based room extraction\n    return [];\n  }\n\n  private extractRoomsFromSections(html: string): PropertyRoom[] {\n    // Implementation for section-based room extraction\n    return [];\n  }\n\n  private deduplicateRooms(rooms: PropertyRoom[]): PropertyRoom[] {\n    // Implementation for room deduplication\n    return rooms;\n  }\n\n  private enhanceRoomsWithDimensions(rooms: PropertyRoom[], html: string): PropertyRoom[] {\n    // Implementation for dimension extraction\n    return rooms;\n  }\n\n  private async extractEnhancedSpecifications(html: string, amenities: PropertyAmenity[], rooms: PropertyRoom[]): Promise<PropertySpecifications> {\n    // Enhanced specifications extraction\n    return this.getDefaultSpecifications();\n  }\n\n  private async extractDetailedLocation(html: string): Promise<PropertyLocation> {\n    // Detailed location extraction\n    return this.getDefaultLocation();\n  }\n\n  private calculateHiddenDataCount(html: string, amenities: PropertyAmenity[], descriptions: any): number {\n    // Calculate how much hidden data was revealed\n    return 0;\n  }\n\n  private calculateComprehensiveDataCompleteness(result: DataExtractionResult): number {\n    let score = 0;\n    \n    // Amenities score (30%)\n    if (result.amenities.length > 0) {\n      score += Math.min((result.amenities.length / 20) * 30, 30);\n    }\n    \n    // Descriptions score (25%)\n    if (result.descriptions.main) score += 15;\n    if (result.descriptions.highlights.length > 0) score += 5;\n    if (Object.keys(result.descriptions.structured).length > 0) score += 5;\n    \n    // Rooms score (25%)\n    if (result.rooms.length > 0) {\n      score += Math.min((result.rooms.length / 5) * 25, 25);\n    }\n    \n    // Specifications score (10%)\n    if (result.specifications.bedrooms > 0) score += 3;\n    if (result.specifications.bathrooms > 0) score += 3;\n    if (result.specifications.maxGuests > 0) score += 4;\n    \n    // Location score (10%)\n    if (result.location.city && result.location.city !== 'Unknown') score += 5;\n    if (result.location.state && result.location.state !== 'Unknown') score += 3;\n    if (result.location.address) score += 2;\n    \n    return Math.round(Math.min(score, 100));\n  }\n}\n\n// Export factory function\nexport const createVRBODataExtractor = (config?: any): VRBODataExtractor => {\n  return new VRBODataExtractor(config);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/vrbo-gallery-automation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":375,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12401,12404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12401,12404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// VRBO Gallery Automation - Handles Dynamic Photo Loading\n// Implements the specific click + scroll sequence needed for VRBO image extraction\n\nimport { Page } from 'puppeteer';\nimport { logger } from '../../utils/logger';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { BrowserManager } from './browser-manager';\nimport type { PhotoData } from './types';\n\nexport interface GalleryAutomationConfig {\n  scrollCycles: number;\n  scrollWaitTime: number;\n  clickWaitTime: number;\n  loadWaitTime: number;\n  maxWaitForImages: number;\n  enableScreenshots: boolean;\n  screenshotPath?: string;\n}\n\nexport interface GalleryLoadingResult {\n  images: PhotoData[];\n  totalImagesFound: number;\n  scrollCyclesCompleted: number;\n  loadingTime: number;\n  screenshots: string[];\n  errors: string[];\n}\n\nexport class VRBOGalleryAutomation {\n  private browserManager: BrowserManager;\n  private config: GalleryAutomationConfig;\n  \n  private defaultConfig: GalleryAutomationConfig = {\n    scrollCycles: 5,\n    scrollWaitTime: 3000,\n    clickWaitTime: 2000,\n    loadWaitTime: 1000,\n    maxWaitForImages: 30000,\n    enableScreenshots: false,\n    screenshotPath: '/tmp/vrbo-screenshots'\n  };\n\n  constructor(\n    browserManager: BrowserManager, \n    config: Partial<GalleryAutomationConfig> = {}\n  ) {\n    this.browserManager = browserManager;\n    this.config = { ...this.defaultConfig, ...config };\n  }\n\n  /**\n   * Executes the complete VRBO gallery loading sequence\n   * @param page - Puppeteer page instance\n   * @param url - VRBO property URL\n   * @returns Promise<GalleryLoadingResult>\n   */\n  async loadAllGalleryImages(page: Page, url: string): Promise<GalleryLoadingResult> {\n    const startTime = Date.now();\n    const screenshots: string[] = [];\n    const errors: string[] = [];\n    \n    try {\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting VRBO gallery automation for ${url}`,\n        'gallery_automation',\n        'Executing click + scroll sequence to load all property images',\n        [url],\n        'high'\n      );\n\n      // Step 1: Navigate to the property page\n      logger.info('Navigating to VRBO property page', { url }, 'GALLERY_AUTOMATION');\n      await page.goto(url, { \n        waitUntil: 'networkidle2',\n        timeout: this.config.maxWaitForImages \n      });\n\n      // Take initial screenshot\n      if (this.config.enableScreenshots) {\n        const screenshotPath = await this.takeScreenshot(page, 'initial-load');\n        screenshots.push(screenshotPath);\n      }\n\n      // Step 2: Find and click the first photo to open gallery\n      const galleryOpened = await this.openPhotoGallery(page);\n      if (!galleryOpened) {\n        errors.push('Failed to open photo gallery');\n        return this.createErrorResult(errors, screenshots, startTime);\n      }\n\n      // Take screenshot after gallery opens\n      if (this.config.enableScreenshots) {\n        const screenshotPath = await this.takeScreenshot(page, 'gallery-opened');\n        screenshots.push(screenshotPath);\n      }\n\n      // Step 3: Execute the scroll sequence to load all images\n      const scrollResults = await this.executeScrollSequence(page, screenshots);\n      \n      // Step 4: Extract all loaded images\n      const images = await this.extractGalleryImages(page);\n      \n      const loadingTime = Date.now() - startTime;\n      \n      logger.info('Gallery automation completed successfully', {\n        url,\n        totalImages: images.length,\n        scrollCycles: scrollResults.cyclesCompleted,\n        loadingTime,\n        errorsCount: errors.length\n      }, 'GALLERY_AUTOMATION');\n\n      return {\n        images,\n        totalImagesFound: images.length,\n        scrollCyclesCompleted: scrollResults.cyclesCompleted,\n        loadingTime,\n        screenshots,\n        errors\n      };\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      errors.push(errorMessage);\n      \n      logger.error('Gallery automation failed', error, 'GALLERY_AUTOMATION');\n      \n      return this.createErrorResult(errors, screenshots, startTime);\n    }\n  }\n\n  /**\n   * Finds and clicks the first photo to open the gallery modal\n   * @param page - Puppeteer page instance\n   * @returns Promise<boolean> - Success status\n   */\n  private async openPhotoGallery(page: Page): Promise<boolean> {\n    try {\n      logger.info('Attempting to open photo gallery', {}, 'GALLERY_AUTOMATION');\n\n      // Wait for images to load\n      await page.waitForTimeout(this.config.loadWaitTime);\n\n      // Common selectors for VRBO photo gallery triggers\n      const gallerySelectors = [\n        'button[data-testid=\"photo-gallery-button\"]',\n        'img[data-testid=\"hero-image\"]',\n        '.hero-image img',\n        '.property-photos img:first-child',\n        '.photo-gallery-trigger',\n        '.property-image-gallery img:first-child',\n        '[data-testid=\"property-image\"] img:first-child',\n        '.carousel-item img:first-child',\n        '.image-gallery img:first-child'\n      ];\n\n      // Try each selector until one works\n      for (const selector of gallerySelectors) {\n        try {\n          const element = await page.$(selector);\n          if (element) {\n            logger.info('Found gallery trigger element', { selector }, 'GALLERY_AUTOMATION');\n            \n            // Scroll element into view\n            await page.evaluate((sel) => {\n              const elem = document.querySelector(sel);\n              if (elem) {\n                elem.scrollIntoView({ behavior: 'smooth', block: 'center' });\n              }\n            }, selector);\n\n            await page.waitForTimeout(500);\n\n            // Human-like click\n            await this.browserManager.humanMouseMove(page, \n              await element.evaluate(el => el.getBoundingClientRect().x + el.getBoundingClientRect().width / 2),\n              await element.evaluate(el => el.getBoundingClientRect().y + el.getBoundingClientRect().height / 2)\n            );\n\n            await element.click();\n            await page.waitForTimeout(this.config.clickWaitTime);\n\n            // Check if gallery modal opened\n            const galleryOpened = await this.waitForGalleryModal(page);\n            if (galleryOpened) {\n              logger.info('Gallery modal opened successfully', { selector }, 'GALLERY_AUTOMATION');\n              return true;\n            }\n          }\n        } catch (selectorError) {\n          // Continue to next selector\n          logger.debug('Gallery selector failed', { selector, error: selectorError }, 'GALLERY_AUTOMATION');\n        }\n      }\n\n      // Alternative approach: click on any large image\n      try {\n        const largeImages = await page.$$('img');\n        for (const img of largeImages) {\n          const dimensions = await img.evaluate(el => ({\n            width: el.offsetWidth,\n            height: el.offsetHeight\n          }));\n          \n          // Click on images that are likely to be gallery triggers (large images)\n          if (dimensions.width > 200 && dimensions.height > 150) {\n            await img.click();\n            await page.waitForTimeout(this.config.clickWaitTime);\n            \n            const galleryOpened = await this.waitForGalleryModal(page);\n            if (galleryOpened) {\n              logger.info('Gallery opened via large image click', { dimensions }, 'GALLERY_AUTOMATION');\n              return true;\n            }\n          }\n        }\n      } catch (error) {\n        logger.debug('Large image click approach failed', { error }, 'GALLERY_AUTOMATION');\n      }\n\n      logger.warn('Could not open gallery modal', {}, 'GALLERY_AUTOMATION');\n      return false;\n\n    } catch (error) {\n      logger.error('Error opening photo gallery', error, 'GALLERY_AUTOMATION');\n      return false;\n    }\n  }\n\n  /**\n   * Waits for the gallery modal to appear\n   * @param page - Puppeteer page instance\n   * @returns Promise<boolean> - Whether modal opened\n   */\n  private async waitForGalleryModal(page: Page): Promise<boolean> {\n    const modalSelectors = [\n      '[data-testid=\"photo-gallery-modal\"]',\n      '.photo-gallery-modal',\n      '.gallery-modal',\n      '.image-gallery-modal',\n      '.photo-carousel-modal',\n      '.property-photos-modal',\n      '[role=\"dialog\"]',\n      '.modal-content'\n    ];\n\n    try {\n      for (const selector of modalSelectors) {\n        try {\n          await page.waitForSelector(selector, { timeout: 2000 });\n          logger.info('Gallery modal detected', { selector }, 'GALLERY_AUTOMATION');\n          return true;\n        } catch (error) {\n          // Continue to next selector\n        }\n      }\n\n      // Alternative: check for overlay or backdrop\n      const hasOverlay = await page.evaluate(() => {\n        const overlays = document.querySelectorAll('[class*=\"overlay\"], [class*=\"backdrop\"], [class*=\"modal\"]');\n        return overlays.length > 0;\n      });\n\n      if (hasOverlay) {\n        logger.info('Gallery modal detected via overlay', {}, 'GALLERY_AUTOMATION');\n        return true;\n      }\n\n      return false;\n\n    } catch (error) {\n      logger.debug('Modal detection failed', { error }, 'GALLERY_AUTOMATION');\n      return false;\n    }\n  }\n\n  /**\n   * Executes the scroll sequence to load all images\n   * @param page - Puppeteer page instance\n   * @param screenshots - Array to store screenshot paths\n   * @returns Promise<{cyclesCompleted: number}>\n   */\n  private async executeScrollSequence(page: Page, screenshots: string[]): Promise<{cyclesCompleted: number}> {\n    logger.info('Starting scroll sequence', { \n      totalCycles: this.config.scrollCycles,\n      waitTime: this.config.scrollWaitTime \n    }, 'GALLERY_AUTOMATION');\n\n    let cyclesCompleted = 0;\n\n    for (let cycle = 1; cycle <= this.config.scrollCycles; cycle++) {\n      try {\n        logger.debug(`Executing scroll cycle ${cycle}/${this.config.scrollCycles}`, {}, 'GALLERY_AUTOMATION');\n\n        // Count images before scrolling\n        const imagesBefore = await this.countVisibleImages(page);\n\n        // Scroll down in the gallery\n        await this.browserManager.humanScroll(page, 'down', 400);\n\n        // Wait for images to load\n        await page.waitForTimeout(this.config.scrollWaitTime);\n\n        // Count images after scrolling\n        const imagesAfter = await this.countVisibleImages(page);\n\n        logger.debug(`Scroll cycle ${cycle} completed`, {\n          imagesBefore,\n          imagesAfter,\n          newImages: imagesAfter - imagesBefore\n        }, 'GALLERY_AUTOMATION');\n\n        // Take screenshot after each cycle\n        if (this.config.enableScreenshots) {\n          const screenshotPath = await this.takeScreenshot(page, `scroll-cycle-${cycle}`);\n          screenshots.push(screenshotPath);\n        }\n\n        cyclesCompleted++;\n\n        // If no new images loaded, we might have reached the end\n        if (imagesAfter === imagesBefore && cycle > 2) {\n          logger.info('No new images loaded, stopping scroll sequence', { \n            cycle,\n            totalImages: imagesAfter \n          }, 'GALLERY_AUTOMATION');\n          break;\n        }\n\n      } catch (error) {\n        logger.error(`Scroll cycle ${cycle} failed`, error, 'GALLERY_AUTOMATION');\n        // Continue with next cycle\n      }\n    }\n\n    logger.info('Scroll sequence completed', { \n      cyclesCompleted,\n      totalCycles: this.config.scrollCycles \n    }, 'GALLERY_AUTOMATION');\n\n    return { cyclesCompleted };\n  }\n\n  /**\n   * Counts visible images in the gallery\n   * @param page - Puppeteer page instance\n   * @returns Promise<number>\n   */\n  private async countVisibleImages(page: Page): Promise<number> {\n    return await page.evaluate(() => {\n      const images = document.querySelectorAll('img');\n      let visibleCount = 0;\n      \n      images.forEach(img => {\n        const rect = img.getBoundingClientRect();\n        if (rect.width > 0 && rect.height > 0 && img.src && img.src.includes('vrbo')) {\n          visibleCount++;\n        }\n      });\n      \n      return visibleCount;\n    });\n  }\n\n  /**\n   * Extracts all images from the gallery\n   * @param page - Puppeteer page instance\n   * @returns Promise<PhotoData[]>\n   */\n  private async extractGalleryImages(page: Page): Promise<PhotoData[]> {\n    logger.info('Extracting gallery images', {}, 'GALLERY_AUTOMATION');\n\n    const images = await page.evaluate(() => {\n      const imageElements = document.querySelectorAll('img');\n      const extractedImages: any[] = [];\n\n      imageElements.forEach((img, index) => {\n        const src = img.src;\n        const alt = img.alt || '';\n        const rect = img.getBoundingClientRect();\n\n        // Filter for VRBO images that are visible and have reasonable size\n        if (src && \n            src.includes('vrbo') && \n            rect.width > 50 && \n            rect.height > 50 &&\n            !src.includes('avatar') &&\n            !src.includes('icon')) {\n          \n          extractedImages.push({\n            url: src,\n            alt,\n            size: {\n              width: rect.width,\n              height: rect.height\n            },\n            order: index + 1\n          });\n        }\n      });\n\n      return extractedImages;\n    });\n\n    // Convert to PhotoData format and categorize\n    const photoData: PhotoData[] = images.map((img, index) => ({\n      url: img.url,\n      thumbnailUrl: this.generateThumbnailUrl(img.url),\n      alt: img.alt,\n      category: this.categorizeImageByUrl(img.url),\n      room: this.categorizeImageByRoom(img.url, img.alt),\n      size: img.size,\n      order: index + 1\n    }));\n\n    // Remove duplicates\n    const uniquePhotos = this.deduplicateImages(photoData);\n\n    logger.info('Gallery image extraction completed', { \n      totalImages: images.length,\n      uniqueImages: uniquePhotos.length \n    }, 'GALLERY_AUTOMATION');\n\n    return uniquePhotos;\n  }\n\n  /**\n   * Takes a screenshot for debugging\n   * @param page - Puppeteer page instance\n   * @param suffix - Filename suffix\n   * @returns Promise<string> - Screenshot path\n   */\n  private async takeScreenshot(page: Page, suffix: string): Promise<string> {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `vrbo-gallery-${suffix}-${timestamp}.png`;\n      const path = `${this.config.screenshotPath}/${filename}`;\n      \n      await page.screenshot({ path, fullPage: true });\n      \n      logger.debug('Screenshot taken', { path }, 'GALLERY_AUTOMATION');\n      return path;\n      \n    } catch (error) {\n      logger.error('Failed to take screenshot', error, 'GALLERY_AUTOMATION');\n      return '';\n    }\n  }\n\n  /**\n   * Creates an error result object\n   * @param errors - Array of error messages\n   * @param screenshots - Array of screenshot paths\n   * @param startTime - Start time for duration calculation\n   * @returns GalleryLoadingResult\n   */\n  private createErrorResult(errors: string[], screenshots: string[], startTime: number): GalleryLoadingResult {\n    return {\n      images: [],\n      totalImagesFound: 0,\n      scrollCyclesCompleted: 0,\n      loadingTime: Date.now() - startTime,\n      screenshots,\n      errors\n    };\n  }\n\n  /**\n   * Utility methods for image processing\n   */\n  private generateThumbnailUrl(url: string): string {\n    // Try to generate thumbnail URL from high-res URL\n    if (url.includes('vrbo') || url.includes('homeaway')) {\n      return url.replace(/\\/\\d+\\//, '/150/').replace(/\\.(jpg|jpeg|png|webp)/i, '_150.$1');\n    }\n    return url;\n  }\n\n  private categorizeImageByUrl(url: string): 'exterior' | 'interior' | 'bedroom' | 'bathroom' | 'kitchen' | 'living_area' | 'outdoor_space' | 'amenity' | 'view' | 'other' {\n    const lowerUrl = url.toLowerCase();\n    \n    if (lowerUrl.includes('exterior') || lowerUrl.includes('outside')) return 'exterior';\n    if (lowerUrl.includes('kitchen')) return 'kitchen';\n    if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n    if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n    if (lowerUrl.includes('living') || lowerUrl.includes('lounge')) return 'living_area';\n    if (lowerUrl.includes('pool') || lowerUrl.includes('deck') || lowerUrl.includes('patio')) return 'outdoor_space';\n    if (lowerUrl.includes('view') || lowerUrl.includes('scenic')) return 'view';\n    if (lowerUrl.includes('amenity')) return 'amenity';\n    \n    return 'interior';\n  }\n\n  private categorizeImageByRoom(url: string, alt: string): 'bedroom' | 'bathroom' | 'kitchen' | 'living_room' | 'dining_room' | 'office' | 'game_room' | 'balcony' | 'patio' | 'garage' | 'basement' | 'attic' | 'other' | undefined {\n    const lowerUrl = url.toLowerCase();\n    const lowerAlt = alt.toLowerCase();\n    \n    if (lowerUrl.includes('kitchen') || lowerAlt.includes('kitchen')) return 'kitchen';\n    if (lowerUrl.includes('bedroom') || lowerAlt.includes('bedroom')) return 'bedroom';\n    if (lowerUrl.includes('bathroom') || lowerAlt.includes('bathroom')) return 'bathroom';\n    if (lowerUrl.includes('living') || lowerAlt.includes('living')) return 'living_room';\n    if (lowerUrl.includes('dining') || lowerAlt.includes('dining')) return 'dining_room';\n    if (lowerUrl.includes('office') || lowerAlt.includes('office')) return 'office';\n    if (lowerUrl.includes('game') || lowerAlt.includes('game')) return 'game_room';\n    if (lowerUrl.includes('balcony') || lowerAlt.includes('balcony')) return 'balcony';\n    if (lowerUrl.includes('patio') || lowerAlt.includes('patio')) return 'patio';\n    if (lowerUrl.includes('garage') || lowerAlt.includes('garage')) return 'garage';\n    \n    return undefined;\n  }\n\n  private deduplicateImages(images: PhotoData[]): PhotoData[] {\n    const seen = new Set<string>();\n    const unique: PhotoData[] = [];\n    \n    images.forEach(img => {\n      const normalizedUrl = img.url.replace(/\\?.*$/, '').toLowerCase();\n      \n      if (!seen.has(normalizedUrl)) {\n        seen.add(normalizedUrl);\n        unique.push(img);\n      }\n    });\n    \n    return unique;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/vrbo-image-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[821,824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[821,824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":302,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":302,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9531,9534],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9531,9534],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":374,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11505,11508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11505,11508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":375,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11547,11550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11547,11550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":540,"column":51,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":540,"endColumn":52,"suggestions":[{"messageId":"removeEscape","fix":{"range":[17409,17410],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[17409,17409],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":540,"column":56,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":540,"endColumn":57,"suggestions":[{"messageId":"removeEscape","fix":{"range":[17414,17415],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[17414,17414],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":638,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":638,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20157,20160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20157,20160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// VRBO Image Scraper - Phase 2: Advanced Image Extraction\n// Handles lazy loading, progressive loading, and comprehensive image extraction\n\nimport { ProductionVRBOScraper } from './production-vrbo-scraper';\nimport { aiDecisionLogger } from '../ai/decision-logger';\nimport { logger } from '../../utils/logger';\nimport type { PhotoData, ScrapingResult, ScrapingError, ScrapingMetadata, PhotoCategory, RoomType } from './types';\n\ninterface ImageExtractionOptions {\n  includeThumbnails: boolean;\n  includeHighRes: boolean;\n  expandGalleries: boolean;\n  deduplicateImages: boolean;\n  maxImages: number;\n  roomCategorization: boolean;\n}\n\ninterface ImageDiscoveryResult {\n  staticImages: string[];\n  lazyImages: string[];\n  galleryImages: string[];\n  thumbnails: string[];\n  highResImages: string[];\n  metadata: Record<string, any>;\n}\n\ninterface ImageProcessingResult {\n  processedImages: PhotoData[];\n  duplicatesRemoved: number;\n  categorizedImages: Record<PhotoCategory, PhotoData[]>;\n  roomImages: Record<RoomType, PhotoData[]>;\n  extractionStats: {\n    totalFound: number;\n    totalProcessed: number;\n    highResCount: number;\n    thumbnailCount: number;\n    categorizedCount: number;\n  };\n}\n\nexport class VRBOImageScraper extends ProductionVRBOScraper {\n  private defaultImageOptions: ImageExtractionOptions = {\n    includeThumbnails: true,\n    includeHighRes: true,\n    expandGalleries: true,\n    deduplicateImages: true,\n    maxImages: 100,\n    roomCategorization: true\n  };\n\n  /**\n   * Comprehensive image extraction from VRBO property page\n   * @param url - VRBO property URL\n   * @param options - Image extraction options\n   * @returns Promise<ScrapingResult<PhotoData[]>>\n   */\n  async scrapeAllImages(url: string, options: Partial<ImageExtractionOptions> = {}): Promise<ScrapingResult<PhotoData[]>> {\n    const finalOptions = { ...this.defaultImageOptions, ...options };\n    const startTime = Date.now();\n    \n    const metadata: ScrapingMetadata = {\n      scrapedAt: new Date(),\n      duration: 0,\n      sourceUrl: url,\n      userAgent: this.httpClient.defaults.headers['User-Agent'] as string,\n      rateLimited: false,\n      dataCompleteness: 0,\n      fieldsScraped: [],\n      fieldsFailed: []\n    };\n\n    try {\n      // Log image scraping start\n      await aiDecisionLogger.logSimpleDecision(\n        `Starting comprehensive VRBO image scraping: ${url}`,\n        'image_scraping',\n        `Extracting images with options: ${JSON.stringify(finalOptions)}`,\n        [url],\n        'high'\n      );\n\n      // Validate URL\n      if (!this.isValidVRBOUrl(url)) {\n        throw new Error('Invalid VRBO URL provided');\n      }\n\n      // Fetch the main property page\n      const html = await this.fetchMainPropertyPage(url);\n      \n      // Discover all images on the page\n      const imageDiscovery = await this.discoverAllImages(html, finalOptions);\n      \n      // Process and categorize images\n      const imageProcessing = await this.processDiscoveredImages(imageDiscovery, finalOptions);\n      \n      // Calculate metadata\n      metadata.duration = Date.now() - startTime;\n      metadata.dataCompleteness = this.calculateImageDataCompleteness(imageProcessing);\n      metadata.fieldsScraped = ['images', 'thumbnails', 'categories', 'rooms'];\n\n      logger.info('VRBO image scraping completed successfully', {\n        totalImages: imageProcessing.extractionStats.totalProcessed,\n        highResCount: imageProcessing.extractionStats.highResCount,\n        categorizedCount: imageProcessing.extractionStats.categorizedCount,\n        duration: metadata.duration\n      }, 'VRBO_IMAGE_SCRAPER');\n\n      return {\n        success: true,\n        data: imageProcessing.processedImages,\n        errors: [],\n        metadata\n      };\n\n    } catch (error) {\n      const scrapingError: ScrapingError = {\n        code: 'IMAGE_SCRAPING_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown image scraping error',\n        severity: 'high',\n        recoverable: true\n      };\n      \n      metadata.duration = Date.now() - startTime;\n      metadata.fieldsFailed = ['images'];\n      \n      logger.error('VRBO image scraping failed', error, 'VRBO_IMAGE_SCRAPER');\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata\n      };\n    }\n  }\n\n  /**\n   * Discovers all images on the page using multiple strategies\n   * @param html - HTML content\n   * @param options - Extraction options\n   * @returns Promise<ImageDiscoveryResult>\n   */\n  private async discoverAllImages(html: string, options: ImageExtractionOptions): Promise<ImageDiscoveryResult> {\n    const discovery: ImageDiscoveryResult = {\n      staticImages: [],\n      lazyImages: [],\n      galleryImages: [],\n      thumbnails: [],\n      highResImages: [],\n      metadata: {}\n    };\n\n    // Extract static images from img tags\n    discovery.staticImages = this.extractStaticImages(html);\n    \n    // Extract lazy-loaded images\n    discovery.lazyImages = this.extractLazyImages(html);\n    \n    // Extract gallery images from JavaScript/JSON\n    discovery.galleryImages = this.extractGalleryImages(html);\n    \n    // Separate thumbnails and high-resolution images\n    const { thumbnails, highRes } = this.categorizeImagesByResolution([\n      ...discovery.staticImages,\n      ...discovery.lazyImages,\n      ...discovery.galleryImages\n    ]);\n    \n    discovery.thumbnails = thumbnails;\n    discovery.highResImages = highRes;\n    \n    // Extract metadata about image sections\n    discovery.metadata = this.extractImageMetadata(html);\n\n    return discovery;\n  }\n\n  /**\n   * Extracts static images from standard img tags\n   * @param html - HTML content\n   * @returns string[] - Array of image URLs\n   */\n  private extractStaticImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Match img tags with src attributes\n    const imgRegex = /<img[^>]*src=[\"']([^\"']+)[\"'][^>]*>/gi;\n    let match;\n    \n    while ((match = imgRegex.exec(html)) !== null) {\n      const imageUrl = match[1];\n      if (this.isValidImageUrl(imageUrl)) {\n        images.push(this.normalizeImageUrl(imageUrl));\n      }\n    }\n    \n    return images;\n  }\n\n  /**\n   * Extracts lazy-loaded images from various lazy loading patterns\n   * @param html - HTML content\n   * @returns string[] - Array of image URLs\n   */\n  private extractLazyImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Common lazy loading patterns\n    const lazyPatterns = [\n      // data-src attribute\n      /<img[^>]*data-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      // data-lazy-src attribute\n      /<img[^>]*data-lazy-src=[\"']([^\"']+)[\"'][^>]*>/gi,\n      // data-original attribute\n      /<img[^>]*data-original=[\"']([^\"']+)[\"'][^>]*>/gi,\n      // srcset attribute\n      /<img[^>]*srcset=[\"']([^\"']+)[\"'][^>]*>/gi,\n      // background-image in style attributes\n      /style=[\"'][^\"']*background-image:\\s*url\\([\"']?([^\"')]+)[\"']?\\)/gi\n    ];\n    \n    lazyPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const imageUrl = match[1];\n        if (this.isValidImageUrl(imageUrl)) {\n          images.push(this.normalizeImageUrl(imageUrl));\n        }\n      }\n    });\n    \n    return images;\n  }\n\n  /**\n   * Extracts gallery images from JavaScript objects and JSON-LD\n   * @param html - HTML content\n   * @returns string[] - Array of image URLs\n   */\n  private extractGalleryImages(html: string): string[] {\n    const images: string[] = [];\n    \n    // Extract from JavaScript variables\n    const jsImagePatterns = [\n      // Common JS image array patterns\n      /images?\\s*[:=]\\s*\\[([^\\]]+)\\]/gi,\n      /photos?\\s*[:=]\\s*\\[([^\\]]+)\\]/gi,\n      /gallery\\s*[:=]\\s*\\[([^\\]]+)\\]/gi,\n      // JSON-LD images\n      /\"image\"\\s*:\\s*\\[([^\\]]+)\\]/gi,\n      /\"photo\"\\s*:\\s*\\[([^\\]]+)\\]/gi\n    ];\n    \n    jsImagePatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(html)) !== null) {\n        const imageArray = match[1];\n        const urlMatches = imageArray.match(/[\"']([^\"']*\\.(jpg|jpeg|png|webp|gif))[\"']/gi);\n        \n        if (urlMatches) {\n          urlMatches.forEach(urlMatch => {\n            const imageUrl = urlMatch.replace(/[\"']/g, '');\n            if (this.isValidImageUrl(imageUrl)) {\n              images.push(this.normalizeImageUrl(imageUrl));\n            }\n          });\n        }\n      }\n    });\n    \n    // Extract from JSON-LD structured data\n    const jsonLdImages = this.extractJsonLdImages(html);\n    images.push(...jsonLdImages);\n    \n    return images;\n  }\n\n  /**\n   * Extracts images from JSON-LD structured data\n   * @param html - HTML content\n   * @returns string[] - Array of image URLs\n   */\n  private extractJsonLdImages(html: string): string[] {\n    const images: string[] = [];\n    \n    try {\n      const jsonLdRegex = /<script[^>]*type=[\"']application\\/ld\\+json[\"'][^>]*>(.*?)<\\/script>/gis;\n      const matches = html.match(jsonLdRegex);\n      \n      if (matches) {\n        matches.forEach(match => {\n          try {\n            const jsonContent = match.replace(/<script[^>]*>/i, '').replace(/<\\/script>/i, '');\n            const data = JSON.parse(jsonContent);\n            \n            // Extract images from various JSON-LD properties\n            const imageProperties = ['image', 'photo', 'photos', 'images'];\n            \n            imageProperties.forEach(prop => {\n              if (data[prop]) {\n                const imageData = Array.isArray(data[prop]) ? data[prop] : [data[prop]];\n                \n                imageData.forEach((img: any) => {\n                  let imageUrl: string;\n                  \n                  if (typeof img === 'string') {\n                    imageUrl = img;\n                  } else if (img.url) {\n                    imageUrl = img.url;\n                  } else if (img.contentUrl) {\n                    imageUrl = img.contentUrl;\n                  } else {\n                    return;\n                  }\n                  \n                  if (this.isValidImageUrl(imageUrl)) {\n                    images.push(this.normalizeImageUrl(imageUrl));\n                  }\n                });\n              }\n            });\n          } catch (e) {\n            // Continue to next script tag\n          }\n        });\n      }\n    } catch (error) {\n      logger.warn('Failed to extract JSON-LD images', error, 'VRBO_IMAGE_SCRAPER');\n    }\n    \n    return images;\n  }\n\n  /**\n   * Categorizes images by resolution (thumbnails vs high-res)\n   * @param imageUrls - Array of image URLs\n   * @returns Object with thumbnails and highRes arrays\n   */\n  private categorizeImagesByResolution(imageUrls: string[]): { thumbnails: string[], highRes: string[] } {\n    const thumbnails: string[] = [];\n    const highRes: string[] = [];\n    \n    imageUrls.forEach(url => {\n      // Check for thumbnail indicators in URL\n      const thumbnailIndicators = [\n        /thumb/i,\n        /small/i,\n        /preview/i,\n        /_s\\./i,\n        /_t\\./i,\n        /150x/i,\n        /300x/i,\n        /w_150/i,\n        /w_300/i,\n        /c_thumb/i\n      ];\n      \n      const isThumbnail = thumbnailIndicators.some(indicator => indicator.test(url));\n      \n      if (isThumbnail) {\n        thumbnails.push(url);\n      } else {\n        highRes.push(url);\n      }\n    });\n    \n    return { thumbnails, highRes };\n  }\n\n  /**\n   * Extracts metadata about image sections and galleries\n   * @param html - HTML content\n   * @returns Object with metadata\n   */\n  private extractImageMetadata(html: string): Record<string, any> {\n    const metadata: Record<string, any> = {};\n    \n    // Count gallery sections\n    const gallerySelectors = [\n      /class=[\"'][^\"']*gallery[^\"']*[\"']/gi,\n      /class=[\"'][^\"']*photos[^\"']*[\"']/gi,\n      /class=[\"'][^\"']*images[^\"']*[\"']/gi,\n      /id=[\"'][^\"']*gallery[^\"']*[\"']/gi\n    ];\n    \n    gallerySelectors.forEach((selector, index) => {\n      const matches = html.match(selector);\n      if (matches) {\n        metadata[`gallerySection${index}`] = matches.length;\n      }\n    });\n    \n    // Extract alt text patterns for room detection\n    const altTextRegex = /alt=[\"']([^\"']+)[\"']/gi;\n    const altTexts: string[] = [];\n    let match;\n    \n    while ((match = altTextRegex.exec(html)) !== null) {\n      altTexts.push(match[1]);\n    }\n    \n    metadata.altTexts = altTexts;\n    \n    return metadata;\n  }\n\n  /**\n   * Processes discovered images into structured PhotoData objects\n   * @param discovery - Image discovery result\n   * @param options - Processing options\n   * @returns Promise<ImageProcessingResult>\n   */\n  private async processDiscoveredImages(discovery: ImageDiscoveryResult, options: ImageExtractionOptions): Promise<ImageProcessingResult> {\n    const allImages = [\n      ...discovery.staticImages,\n      ...discovery.lazyImages,\n      ...discovery.galleryImages\n    ];\n    \n    // Deduplicate images\n    const uniqueImages = options.deduplicateImages ? this.deduplicateImages(allImages) : allImages;\n    \n    // Limit number of images\n    const limitedImages = uniqueImages.slice(0, options.maxImages);\n    \n    // Convert to PhotoData objects\n    const photoData: PhotoData[] = limitedImages.map((url, index) => {\n      const isHighRes = discovery.highResImages.includes(url);\n      const isThumbnail = discovery.thumbnails.includes(url);\n      \n      return {\n        url,\n        thumbnailUrl: isThumbnail ? url : this.generateThumbnailUrl(url),\n        alt: this.extractAltTextForImage(url, discovery.metadata.altTexts || []),\n        category: this.categorizeImageByUrl(url),\n        room: this.categorizeImageByRoom(url, discovery.metadata.altTexts || []),\n        size: isHighRes ? { width: 1200, height: 800 } : { width: 400, height: 300 },\n        order: index + 1\n      };\n    });\n    \n    // Categorize images\n    const categorizedImages = this.categorizeImagesByType(photoData);\n    const roomImages = this.categorizeImagesByRoom(photoData);\n    \n    return {\n      processedImages: photoData,\n      duplicatesRemoved: allImages.length - uniqueImages.length,\n      categorizedImages,\n      roomImages,\n      extractionStats: {\n        totalFound: allImages.length,\n        totalProcessed: photoData.length,\n        highResCount: discovery.highResImages.length,\n        thumbnailCount: discovery.thumbnails.length,\n        categorizedCount: Object.values(categorizedImages).flat().length\n      }\n    };\n  }\n\n  /**\n   * Utility methods for image processing\n   */\n  private isValidImageUrl(url: string): boolean {\n    if (!url || typeof url !== 'string') return false;\n    \n    // Check for valid image extensions\n    const imageExtensions = /\\.(jpg|jpeg|png|webp|gif|svg)(\\?.*)?$/i;\n    \n    // Check for valid URL format\n    const urlPattern = /^https?:\\/\\//i;\n    \n    return imageExtensions.test(url) && (urlPattern.test(url) || url.startsWith('//'));\n  }\n\n  private normalizeImageUrl(url: string): string {\n    // Handle protocol-relative URLs\n    if (url.startsWith('//')) {\n      return `https:${url}`;\n    }\n    \n    // Handle relative URLs (if any)\n    if (url.startsWith('/')) {\n      return `https://www.vrbo.com${url}`;\n    }\n    \n    return url;\n  }\n\n  private deduplicateImages(images: string[]): string[] {\n    const seen = new Set<string>();\n    const unique: string[] = [];\n    \n    images.forEach(url => {\n      // Normalize URL for comparison\n      const normalizedUrl = url.replace(/\\?.*$/, '').toLowerCase();\n      \n      if (!seen.has(normalizedUrl)) {\n        seen.add(normalizedUrl);\n        unique.push(url);\n      }\n    });\n    \n    return unique;\n  }\n\n  private categorizeImageByUrl(url: string): PhotoCategory {\n    const lowerUrl = url.toLowerCase();\n    \n    if (lowerUrl.includes('exterior') || lowerUrl.includes('outside')) return 'exterior';\n    if (lowerUrl.includes('kitchen')) return 'kitchen';\n    if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n    if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n    if (lowerUrl.includes('living') || lowerUrl.includes('lounge')) return 'living_area';\n    if (lowerUrl.includes('pool') || lowerUrl.includes('deck') || lowerUrl.includes('patio')) return 'outdoor_space';\n    if (lowerUrl.includes('view') || lowerUrl.includes('scenic')) return 'view';\n    if (lowerUrl.includes('amenity')) return 'amenity';\n    \n    return 'interior';\n  }\n\n  private categorizeImageByRoom(url: string, altTexts: string[]): RoomType | undefined {\n    const lowerUrl = url.toLowerCase();\n    \n    if (lowerUrl.includes('kitchen')) return 'kitchen';\n    if (lowerUrl.includes('bedroom') || lowerUrl.includes('bed')) return 'bedroom';\n    if (lowerUrl.includes('bathroom') || lowerUrl.includes('bath')) return 'bathroom';\n    if (lowerUrl.includes('living') || lowerUrl.includes('lounge')) return 'living_room';\n    if (lowerUrl.includes('dining')) return 'dining_room';\n    if (lowerUrl.includes('office') || lowerUrl.includes('study')) return 'office';\n    if (lowerUrl.includes('game') || lowerUrl.includes('rec')) return 'game_room';\n    if (lowerUrl.includes('balcony')) return 'balcony';\n    if (lowerUrl.includes('patio') || lowerUrl.includes('deck')) return 'patio';\n    if (lowerUrl.includes('garage')) return 'garage';\n    \n    return undefined;\n  }\n\n  private extractAltTextForImage(url: string, altTexts: string[]): string {\n    // Try to find relevant alt text for this image\n    const urlKeywords = url.toLowerCase().split(/[\\/\\-_\\.]/);\n    \n    for (const altText of altTexts) {\n      const altKeywords = altText.toLowerCase().split(/\\s+/);\n      const commonKeywords = urlKeywords.filter(keyword => \n        altKeywords.some(altKeyword => altKeyword.includes(keyword) || keyword.includes(altKeyword))\n      );\n      \n      if (commonKeywords.length > 0) {\n        return altText;\n      }\n    }\n    \n    return '';\n  }\n\n  private generateThumbnailUrl(url: string): string {\n    // Try to generate thumbnail URL from high-res URL\n    // This is VRBO-specific logic\n    if (url.includes('vrbo') || url.includes('homeaway')) {\n      return url.replace(/\\/\\d+\\//, '/150/').replace(/\\.(jpg|jpeg|png|webp)/i, '_150.$1');\n    }\n    \n    return url;\n  }\n\n  private categorizeImagesByType(photos: PhotoData[]): Record<PhotoCategory, PhotoData[]> {\n    const categorized: Record<PhotoCategory, PhotoData[]> = {\n      exterior: [],\n      interior: [],\n      bedroom: [],\n      bathroom: [],\n      kitchen: [],\n      living_area: [],\n      outdoor_space: [],\n      amenity: [],\n      view: [],\n      other: []\n    };\n    \n    photos.forEach(photo => {\n      categorized[photo.category].push(photo);\n    });\n    \n    return categorized;\n  }\n\n  private categorizeImagesByRoom(photos: PhotoData[]): Record<RoomType, PhotoData[]> {\n    const categorized: Record<RoomType, PhotoData[]> = {\n      bedroom: [],\n      bathroom: [],\n      kitchen: [],\n      living_room: [],\n      dining_room: [],\n      office: [],\n      game_room: [],\n      balcony: [],\n      patio: [],\n      garage: [],\n      basement: [],\n      attic: [],\n      other: []\n    };\n    \n    photos.forEach(photo => {\n      if (photo.room) {\n        categorized[photo.room].push(photo);\n      }\n    });\n    \n    return categorized;\n  }\n\n  private calculateImageDataCompleteness(processing: ImageProcessingResult): number {\n    const stats = processing.extractionStats;\n    \n    // Base score for finding images\n    let score = Math.min((stats.totalProcessed / 20) * 50, 50); // Up to 50% for having images\n    \n    // Bonus for high-res images\n    if (stats.highResCount > 0) {\n      score += Math.min((stats.highResCount / 10) * 20, 20); // Up to 20% for high-res\n    }\n    \n    // Bonus for categorized images\n    if (stats.categorizedCount > 0) {\n      score += Math.min((stats.categorizedCount / stats.totalProcessed) * 20, 20); // Up to 20% for categorization\n    }\n    \n    // Bonus for variety (different room types)\n    const roomTypes = Object.values(processing.roomImages).filter(arr => arr.length > 0).length;\n    score += Math.min(roomTypes * 2, 10); // Up to 10% for room variety\n    \n    return Math.round(Math.min(score, 100));\n  }\n}\n\n// Export factory function\nexport const createVRBOImageScraper = (config?: any): VRBOImageScraper => {\n  return new VRBOImageScraper(config);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/scrapers/vrbo-scraper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[679,682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[679,682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":447,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14715,14718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14715,14718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Production VRBO Property Scraper for STR Certified\n// Uses comprehensive scraping with HTTP client, image extraction, and advanced data parsing\n\nimport { createComprehensiveVRBOScraper, scrapeVRBOProperty as comprehensiveScrape } from './comprehensive-vrbo-scraper';\nimport { logger } from '../../utils/logger';\nimport type {\n  ScrapedPropertyData,\n  VRBOPropertyData,\n  ScrapingResult,\n  ScrapingError,\n  ScrapingMetadata,\n  PropertyAmenity,\n  PropertyRoom,\n  PropertySpecifications,\n  PropertyLocation,\n  ScraperConfig,\n  PhotoData,\n  AmenityCategory,\n  RoomType\n} from './types';\n\nexport class VRBOScraper {\n  private config: ScraperConfig;\n  private comprehensiveScraper: any;\n\n  constructor(config: Partial<ScraperConfig> = {}) {\n    this.config = {\n      timeout: 30000,\n      retries: 3,\n      userAgent: 'STR-Certified-Bot/1.0',\n      respectRobotsTxt: true,\n      rateLimit: 10,\n      enableScreenshots: false,\n      ...config\n    };\n    \n    this.comprehensiveScraper = createComprehensiveVRBOScraper(this.config);\n  }\n\n  /**\n   * Scrapes comprehensive property details from a VRBO URL using production scraper\n   * @param url - The VRBO property URL\n   * @returns Promise<ScrapingResult<VRBOPropertyData>>\n   */\n  async scrapePropertyDetails(url: string): Promise<ScrapingResult<VRBOPropertyData>> {\n    try {\n      logger.info('Starting VRBO property scraping', { url }, 'VRBO_SCRAPER');\n      \n      // Use comprehensive scraper for production-ready results\n      const result = await comprehensiveScrape(url, {\n        includeImages: true,\n        includeAdvancedAmenities: true,\n        includeDetailedDescriptions: true,\n        includeRoomData: true,\n        maxImages: 30,\n        verifyWithAI: false,\n        generateReport: true\n      });\n\n      if (!result.success) {\n        logger.error('VRBO scraping failed', { \n          url, \n          errors: result.errors,\n          metadata: result.metadata \n        }, 'VRBO_SCRAPER');\n        \n        // Return formatted error result\n        return {\n          success: false,\n          errors: result.errors,\n          metadata: result.metadata\n        };\n      }\n\n      logger.info('VRBO scraping completed successfully', {\n        url,\n        completenessScore: result.data.extractionReport.completenessScore,\n        totalDataPoints: result.data.extractionReport.totalDataPoints,\n        processingTime: result.data.extractionReport.processingTime\n      }, 'VRBO_SCRAPER');\n\n      return {\n        success: true,\n        data: result.data.propertyData,\n        errors: result.errors,\n        metadata: result.metadata\n      };\n      \n    } catch (error) {\n      logger.error('VRBO scraping encountered unexpected error', error, 'VRBO_SCRAPER');\n      \n      const scrapingError: ScrapingError = {\n        code: 'SCRAPING_FAILED',\n        message: error instanceof Error ? error.message : 'Unknown scraping error',\n        severity: 'high',\n        recoverable: true\n      };\n\n      return {\n        success: false,\n        errors: [scrapingError],\n        metadata: {\n          scrapedAt: new Date(),\n          duration: 0,\n          sourceUrl: url,\n          userAgent: this.config.userAgent,\n          rateLimited: false,\n          dataCompleteness: 0,\n          fieldsScraped: [],\n          fieldsFailed: ['all']\n        }\n      };\n    }\n  }\n\n  /**\n   * Scrapes only photos from a VRBO property using image scraper\n   * @param url - The VRBO property URL\n   * @returns Promise<ScrapingResult<PhotoData[]>>\n   */\n  async scrapePhotos(url: string): Promise<ScrapingResult<PhotoData[]>> {\n    try {\n      const imageResult = await this.comprehensiveScraper.imageScraper.scrapeAllImages(url, {\n        maxImages: 50,\n        includeHighRes: true,\n        expandGalleries: true,\n        deduplicateImages: true,\n        roomCategorization: true\n      });\n      \n      return imageResult;\n    } catch (error) {\n      return {\n        success: false,\n        errors: [{\n          code: 'PHOTO_SCRAPING_FAILED',\n          message: error instanceof Error ? error.message : 'Photo scraping failed',\n          severity: 'medium',\n          recoverable: true\n        }],\n        metadata: {\n          scrapedAt: new Date(),\n          duration: 0,\n          sourceUrl: url,\n          userAgent: this.config.userAgent,\n          rateLimited: false,\n          dataCompleteness: 0,\n          fieldsScraped: [],\n          fieldsFailed: ['photos']\n        }\n      };\n    }\n  }\n\n  /**\n   * Validates if the provided URL is a valid VRBO property URL\n   * @param url - URL to validate\n   * @returns boolean\n   */\n  private isValidVRBOUrl(url: string): boolean {\n    const vrboPatterns = [\n      /^https?:\\/\\/(www\\.)?vrbo\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?homeaway\\.com\\/\\d+/,\n      /^https?:\\/\\/(www\\.)?vacationrentals\\.com\\/\\d+/\n    ];\n    \n    return vrboPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extracts property ID from VRBO URL\n   * @param url - VRBO URL\n   * @returns string | null\n   */\n  private extractPropertyId(url: string): string | null {\n    const match = url.match(/\\/(\\d+)/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Generates mock property data for testing\n   * @param url - Original URL\n   * @param propertyId - Property ID\n   * @returns Promise<VRBOPropertyData>\n   */\n  private async getMockPropertyData(url: string, propertyId: string): Promise<VRBOPropertyData> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n\n    const mockData: VRBOPropertyData = {\n      title: \"Luxurious 4BR Mountain Retreat with Hot Tub & Stunning Views\",\n      description: \"Escape to this beautifully appointed 4-bedroom, 3-bathroom mountain retreat nestled in the heart of the Colorado Rockies. This spacious home features soaring ceilings, floor-to-ceiling windows, and a wrap-around deck perfect for taking in the breathtaking mountain views. The gourmet kitchen is fully equipped with stainless steel appliances, granite countertops, and everything you need to prepare meals for your group. Relax in the private hot tub under the stars, cozy up by the stone fireplace, or enjoy the game room with pool table and big screen TV. Located just minutes from world-class skiing, hiking trails, and charming downtown shops and restaurants.\",\n      \n      amenities: [\n        { name: \"Hot Tub\", verified: true, category: \"outdoor\", priority: \"important\", icon: \"ðŸ›\" },\n        { name: \"Fireplace\", verified: true, category: \"entertainment\", priority: \"important\", icon: \"ðŸ”¥\" },\n        { name: \"Full Kitchen\", verified: true, category: \"kitchen\", priority: \"essential\", icon: \"ðŸ³\" },\n        { name: \"WiFi\", verified: true, category: \"connectivity\", priority: \"essential\", icon: \"ðŸ“¶\" },\n        { name: \"Parking\", verified: true, category: \"parking\", priority: \"essential\", icon: \"ðŸš—\" },\n        { name: \"Pool Table\", verified: true, category: \"entertainment\", priority: \"nice_to_have\", icon: \"ðŸŽ±\" },\n        { name: \"Mountain Views\", verified: true, category: \"general\", priority: \"important\", icon: \"ðŸ”ï¸\" },\n        { name: \"Deck/Patio\", verified: true, category: \"outdoor\", priority: \"important\", icon: \"ðŸ¡\" },\n        { name: \"Washer/Dryer\", verified: true, category: \"laundry\", priority: \"important\", icon: \"ðŸ‘•\" },\n        { name: \"Air Conditioning\", verified: false, category: \"climate\", priority: \"nice_to_have\", icon: \"â„ï¸\" },\n        { name: \"Dishwasher\", verified: true, category: \"kitchen\", priority: \"important\", icon: \"ðŸ½ï¸\" },\n        { name: \"Smart TV\", verified: true, category: \"entertainment\", priority: \"important\", icon: \"ðŸ“º\" }\n      ],\n\n      photos: [\n        \"https://example.com/photos/exterior-1.jpg\",\n        \"https://example.com/photos/living-room-1.jpg\",\n        \"https://example.com/photos/kitchen-1.jpg\",\n        \"https://example.com/photos/master-bedroom-1.jpg\",\n        \"https://example.com/photos/bathroom-1.jpg\",\n        \"https://example.com/photos/hot-tub-1.jpg\",\n        \"https://example.com/photos/deck-view-1.jpg\",\n        \"https://example.com/photos/game-room-1.jpg\"\n      ],\n\n      rooms: [\n        {\n          type: \"bedroom\",\n          count: 4,\n          photos: [\n            \"https://example.com/photos/master-bedroom-1.jpg\",\n            \"https://example.com/photos/bedroom-2.jpg\",\n            \"https://example.com/photos/bedroom-3.jpg\",\n            \"https://example.com/photos/bedroom-4.jpg\"\n          ],\n          amenities: [\"King Bed\", \"Queen Bed\", \"Twin Beds\", \"Closet Space\"],\n          specifications: {\n            bedType: \"king\"\n          }\n        },\n        {\n          type: \"bathroom\",\n          count: 3,\n          photos: [\"https://example.com/photos/bathroom-1.jpg\", \"https://example.com/photos/bathroom-2.jpg\"],\n          amenities: [\"Shower\", \"Bathtub\", \"Hair Dryer\", \"Towels\"],\n          specifications: {\n            bathType: \"full\"\n          }\n        },\n        {\n          type: \"kitchen\",\n          count: 1,\n          photos: [\"https://example.com/photos/kitchen-1.jpg\"],\n          amenities: [\"Refrigerator\", \"Stove\", \"Oven\", \"Microwave\", \"Dishwasher\", \"Coffee Maker\"],\n        },\n        {\n          type: \"living_room\",\n          count: 1,\n          photos: [\"https://example.com/photos/living-room-1.jpg\"],\n          amenities: [\"Fireplace\", \"Smart TV\", \"Comfortable Seating\", \"Mountain Views\"],\n        }\n      ],\n\n      specifications: {\n        propertyType: \"house\",\n        bedrooms: 4,\n        bathrooms: 3,\n        maxGuests: 10,\n        squareFootage: 2800,\n        yearBuilt: 2018,\n        floors: 2,\n        parkingSpaces: 2,\n        checkInTime: \"4:00 PM\",\n        checkOutTime: \"10:00 AM\",\n        minimumStay: 2\n      },\n\n      location: {\n        city: \"Breckenridge\",\n        state: \"Colorado\",\n        country: \"United States\",\n        zipCode: \"80424\",\n        coordinates: {\n          latitude: 39.4817,\n          longitude: -106.0384\n        },\n        neighborhood: \"Peak 7\",\n        landmarks: [\"Breckenridge Ski Resort\", \"Main Street\", \"Peak 8 Base\"]\n      },\n\n      pricing: {\n        basePrice: 450,\n        cleaningFee: 150,\n        serviceFee: 75,\n        currency: \"USD\",\n        lastUpdated: new Date()\n      },\n\n      host: {\n        name: \"Sarah Johnson\",\n        joinedDate: new Date(\"2019-03-15\"),\n        responseRate: 98,\n        responseTime: \"within an hour\",\n        languages: [\"English\"]\n      },\n\n      reviews: {\n        averageRating: 4.8,\n        totalReviews: 127,\n        ratingBreakdown: {\n          cleanliness: 4.9,\n          accuracy: 4.8,\n          checkIn: 4.7,\n          communication: 4.9,\n          location: 4.8,\n          value: 4.6\n        }\n      },\n\n      lastUpdated: new Date(),\n      sourceUrl: url,\n\n      // VRBO-specific fields\n      vrboId: propertyId,\n      instantBook: true,\n      propertyManager: \"Rocky Mountain Retreats\",\n      cancellationPolicy: \"Moderate: Free cancellation up to 5 days before check-in\",\n      houseRules: [\n        \"No smoking\",\n        \"No pets allowed\",\n        \"No parties or events\",\n        \"Quiet hours after 10 PM\",\n        \"Maximum 10 guests\"\n      ],\n      nearbyAttractions: [\n        \"Breckenridge Ski Resort (2 miles)\",\n        \"Main Street Shopping (3 miles)\",\n        \"Lake Dillon (8 miles)\",\n        \"Keystone Resort (12 miles)\"\n      ]\n    };\n\n    return mockData;\n  }\n\n  /**\n   * Generates mock photo data\n   * @returns Promise<PhotoData[]>\n   */\n  private async getMockPhotos(): Promise<PhotoData[]> {\n    const mockPhotos: PhotoData[] = [\n      {\n        url: \"https://example.com/photos/exterior-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/exterior-1.jpg\",\n        alt: \"Beautiful mountain home exterior\",\n        category: \"exterior\",\n        order: 1,\n        size: { width: 1200, height: 800 }\n      },\n      {\n        url: \"https://example.com/photos/living-room-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/living-room-1.jpg\",\n        alt: \"Spacious living room with fireplace\",\n        room: \"living_room\",\n        category: \"living_area\",\n        order: 2,\n        size: { width: 1200, height: 800 }\n      },\n      {\n        url: \"https://example.com/photos/kitchen-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/kitchen-1.jpg\",\n        alt: \"Modern fully equipped kitchen\",\n        room: \"kitchen\",\n        category: \"kitchen\",\n        order: 3,\n        size: { width: 1200, height: 800 }\n      },\n      {\n        url: \"https://example.com/photos/master-bedroom-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/master-bedroom-1.jpg\",\n        alt: \"Master bedroom with king bed\",\n        room: \"bedroom\",\n        category: \"bedroom\",\n        order: 4,\n        size: { width: 1200, height: 800 }\n      },\n      {\n        url: \"https://example.com/photos/bathroom-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/bathroom-1.jpg\",\n        alt: \"Master bathroom with soaking tub\",\n        room: \"bathroom\",\n        category: \"bathroom\",\n        order: 5,\n        size: { width: 1200, height: 800 }\n      },\n      {\n        url: \"https://example.com/photos/hot-tub-1.jpg\",\n        thumbnailUrl: \"https://example.com/photos/thumbs/hot-tub-1.jpg\",\n        alt: \"Private hot tub on deck\",\n        category: \"outdoor_space\",\n        order: 6,\n        size: { width: 1200, height: 800 }\n      }\n    ];\n\n    return mockPhotos;\n  }\n\n  /**\n   * Calculates data completeness percentage\n   * @param data - Scraped property data\n   * @returns number (0-100)\n   */\n  private calculateDataCompleteness(data: VRBOPropertyData): number {\n    const requiredFields = [\n      'title', 'description', 'amenities', 'photos', 'rooms', \n      'specifications', 'location'\n    ];\n    \n    const optionalFields = [\n      'pricing', 'host', 'reviews', 'houseRules', 'nearbyAttractions'\n    ];\n\n    let completedRequired = 0;\n    let completedOptional = 0;\n\n    requiredFields.forEach(field => {\n      if (data[field as keyof VRBOPropertyData] && \n          this.isFieldComplete(data[field as keyof VRBOPropertyData])) {\n        completedRequired++;\n      }\n    });\n\n    optionalFields.forEach(field => {\n      if (data[field as keyof VRBOPropertyData] && \n          this.isFieldComplete(data[field as keyof VRBOPropertyData])) {\n        completedOptional++;\n      }\n    });\n\n    // Required fields are worth 80%, optional fields worth 20%\n    const requiredScore = (completedRequired / requiredFields.length) * 80;\n    const optionalScore = (completedOptional / optionalFields.length) * 20;\n\n    return Math.round(requiredScore + optionalScore);\n  }\n\n  /**\n   * Checks if a field has meaningful content\n   * @param value - Field value to check\n   * @returns boolean\n   */\n  private isFieldComplete(value: any): boolean {\n    if (value === null || value === undefined) return false;\n    if (typeof value === 'string') return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    if (typeof value === 'object') return Object.keys(value).length > 0;\n    return true;\n  }\n\n  /**\n   * Gets list of successfully scraped fields\n   * @param data - Scraped property data\n   * @returns string[]\n   */\n  private getScrapedFields(data: VRBOPropertyData): string[] {\n    const fields: string[] = [];\n    \n    Object.entries(data).forEach(([key, value]) => {\n      if (this.isFieldComplete(value)) {\n        fields.push(key);\n      }\n    });\n\n    return fields;\n  }\n}\n\n// Export factory function for creating scraper instances\nexport const createVRBOScraper = (config?: Partial<ScraperConfig>): VRBOScraper => {\n  return new VRBOScraper(config);\n};\n\n// Export convenience function for direct property scraping with browser automation\nexport const scrapeVRBOProperty = async (url: string): Promise<VRBOPropertyData> => {\n  try {\n    logger.info('Starting direct VRBO property scraping with browser automation', { url }, 'VRBO_SCRAPER');\n    \n    // Try browser automation first for complete image extraction\n    const { scrapeBrowserVRBOProperty } = await import('./vrbo-browser-scraper');\n    const browserResult = await scrapeBrowserVRBOProperty(url, {\n      useStaticFallback: true,\n      headless: true,\n      enableStealth: true,\n      scrollCycles: 5,\n      scrollWaitTime: 3000\n    });\n\n    if (browserResult.success) {\n      logger.info('Browser automation VRBO scraping completed successfully', {\n        url,\n        totalImages: browserResult.data!.totalImages,\n        galleryImages: browserResult.data!.galleryImages.length,\n        staticImages: browserResult.data!.staticImages.length,\n        scrollCycles: browserResult.data!.galleryLoadingResult.scrollCyclesCompleted,\n        processingTime: browserResult.metadata.duration\n      }, 'VRBO_SCRAPER');\n\n      return browserResult.data!.propertyData;\n    }\n\n    // Fallback to comprehensive scraper without browser automation\n    logger.warn('Browser automation failed, falling back to static scraping', { \n      url, \n      errors: browserResult.errors \n    }, 'VRBO_SCRAPER');\n\n    const result = await comprehensiveScrape(url, {\n      includeImages: true,\n      includeAdvancedAmenities: true,\n      includeDetailedDescriptions: true,\n      includeRoomData: true,\n      maxImages: 30,\n      verifyWithAI: false,\n      generateReport: true\n    });\n\n    if (!result.success) {\n      logger.error('Static fallback VRBO scraping failed', { \n        url, \n        errors: result.errors,\n        metadata: result.metadata \n      }, 'VRBO_SCRAPER');\n      \n      // Return fallback data on failure\n      return createFallbackPropertyData(url);\n    }\n\n    logger.info('Static fallback VRBO scraping completed successfully', {\n      url,\n      completenessScore: result.data.extractionReport.completenessScore,\n      totalDataPoints: result.data.extractionReport.totalDataPoints,\n      processingTime: result.data.extractionReport.processingTime\n    }, 'VRBO_SCRAPER');\n\n    return result.data.propertyData;\n    \n  } catch (error) {\n    logger.error('Direct VRBO scraping encountered unexpected error', error, 'VRBO_SCRAPER');\n    \n    // Return fallback data on unexpected errors\n    return createFallbackPropertyData(url);\n  }\n};\n\n/**\n * Quick scraping function for basic property information only\n * @param url - VRBO property URL\n * @returns Promise<VRBOPropertyData>\n */\nexport const quickScrapeVRBOProperty = async (url: string): Promise<VRBOPropertyData> => {\n  try {\n    const scraper = createComprehensiveVRBOScraper();\n    const result = await scraper.quickScrape(url);\n    \n    if (!result.success) {\n      return createFallbackPropertyData(url);\n    }\n    \n    return result.data;\n  } catch (error) {\n    logger.error('Quick VRBO scraping failed', error, 'VRBO_SCRAPER');\n    return createFallbackPropertyData(url);\n  }\n};\n\n/**\n * Creates fallback property data when scraping fails\n * @param url - Original VRBO URL\n * @returns VRBOPropertyData with minimal information\n */\nfunction createFallbackPropertyData(url: string): VRBOPropertyData {\n  const propertyId = extractPropertyId(url) || 'unknown';\n  \n  return {\n    vrboId: propertyId,\n    sourceUrl: url,\n    title: \"Property Information Temporarily Unavailable\",\n    description: \"We're having trouble accessing the full property details right now. Please check the VRBO listing directly for complete information.\",\n    amenities: [\n      {\n        name: \"WiFi\",\n        verified: false,\n        category: \"connectivity\",\n        priority: \"essential\"\n      },\n      {\n        name: \"Kitchen\",\n        verified: false,\n        category: \"kitchen\",\n        priority: \"essential\"\n      },\n      {\n        name: \"Parking\",\n        verified: false,\n        category: \"parking\",\n        priority: \"important\"\n      }\n    ],\n    photos: [],\n    rooms: [],\n    specifications: {\n      propertyType: \"house\",\n      bedrooms: 0,\n      bathrooms: 0,\n      maxGuests: 0\n    },\n    location: {\n      city: \"Unknown\",\n      state: \"Unknown\",\n      country: \"Unknown\"\n    },\n    instantBook: false,\n    cancellationPolicy: \"Please check VRBO listing for details\",\n    houseRules: [\n      \"Please refer to the original VRBO listing for house rules\"\n    ],\n    lastUpdated: new Date()\n  };\n}\n\n/**\n * Extracts property ID from VRBO URL\n * @param url - VRBO URL\n * @returns string | null\n */\nfunction extractPropertyId(url: string): string | null {\n  const match = url.match(/\\/(\\d+)/);\n  return match ? match[1] : null;\n}\n\n// Export default configuration\nexport const DEFAULT_SCRAPER_CONFIG: ScraperConfig = {\n  timeout: 30000,\n  retries: 3,\n  userAgent: 'STR-Certified-Bot/1.0',\n  respectRobotsTxt: true,\n  rateLimit: 10,\n  enableScreenshots: false,\n} as const;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/supabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/video/video-analyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/video/video-navigation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":346,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9594,9597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9594,9597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Navigation System for STR Certified Auditor Interface\n\nimport type {\n  VideoRecording,\n  VideoTimestamp,\n  VideoAnalysisResult,\n  SceneType,\n  RoomSequence\n} from '@/types/video';\n\nexport interface NavigationChapter {\n  id: string;\n  title: string;\n  startTime: number;\n  endTime: number;\n  roomType?: string;\n  sceneCount: number;\n  hasIssues: boolean;\n  thumbnail?: string;\n  subChapters?: NavigationMarker[];\n}\n\nexport interface NavigationMarker {\n  id: string;\n  time: number;\n  type: 'room_entry' | 'key_moment' | 'issue' | 'bookmark' | 'annotation';\n  label: string;\n  description?: string;\n  severity?: 'low' | 'medium' | 'high';\n  icon?: string;\n  color?: string;\n}\n\nexport interface QuickJumpButton {\n  id: string;\n  label: string;\n  icon: string;\n  time: number;\n  type: 'room' | 'issue' | 'feature' | 'custom';\n  description?: string;\n}\n\nexport interface VideoMetadata {\n  title: string;\n  propertyAddress: string;\n  inspectorName: string;\n  inspectionDate: Date;\n  duration: number;\n  roomsCovered: string[];\n  issuesFound: number;\n  overallQuality: number;\n  tags: string[];\n}\n\nexport class VideoNavigationManager {\n  private video: VideoRecording;\n  private analysis: VideoAnalysisResult;\n  private bookmarks: Map<number, NavigationMarker> = new Map();\n\n  constructor(video: VideoRecording, analysis: VideoAnalysisResult) {\n    this.video = video;\n    this.analysis = analysis;\n  }\n\n  /**\n   * Generates smart navigation chapters based on AI analysis\n   * @returns Array of navigation chapters\n   */\n  generateNavigationChapters(): NavigationChapter[] {\n    const chapters: NavigationChapter[] = [];\n    const roomSequences = this.analysis.roomSequence;\n\n    // Create chapters for each room\n    roomSequences.forEach((room, index) => {\n      const roomTimestamps = this.video.timestamps.filter(\n        ts => ts.time >= room.startTime && ts.time <= room.endTime\n      );\n\n      const hasIssues = roomTimestamps.some(\n        ts => ts.sceneType === 'issue_documentation' ||\n              ts.features.includes('issue') ||\n              ts.features.includes('damage')\n      );\n\n      // Find thumbnail (first key frame in room)\n      const thumbnail = this.analysis.scenes\n        .find(s => s.startTime >= room.startTime && s.endTime <= room.endTime)\n        ?.keyFrames[0]?.frameUrl;\n\n      // Create sub-chapters for key moments\n      const subChapters: NavigationMarker[] = [];\n      \n      // Add room entry\n      subChapters.push({\n        id: `${room.roomId}_entry`,\n        time: room.startTime,\n        type: 'room_entry',\n        label: `Enter ${room.roomType}`,\n        description: `Beginning of ${room.roomType} inspection`\n      });\n\n      // Add key moments\n      room.keyMoments.forEach((moment, momentIndex) => {\n        subChapters.push({\n          id: `${room.roomId}_moment_${momentIndex}`,\n          time: moment.time,\n          type: 'key_moment',\n          label: moment.description || `Key moment ${momentIndex + 1}`,\n          description: moment.features.join(', ')\n        });\n      });\n\n      // Add issues\n      roomTimestamps\n        .filter(ts => ts.sceneType === 'issue_documentation')\n        .forEach((issue, issueIndex) => {\n          subChapters.push({\n            id: `${room.roomId}_issue_${issueIndex}`,\n            time: issue.time,\n            type: 'issue',\n            label: `Issue: ${issue.description}`,\n            severity: 'medium',\n            color: '#ef4444'\n          });\n        });\n\n      chapters.push({\n        id: room.roomId,\n        title: this.formatRoomTitle(room.roomType),\n        startTime: room.startTime,\n        endTime: room.endTime,\n        roomType: room.roomType,\n        sceneCount: roomTimestamps.length,\n        hasIssues,\n        thumbnail,\n        subChapters: subChapters.sort((a, b) => a.time - b.time)\n      });\n    });\n\n    // Add intro/outro chapters if needed\n    if (chapters.length > 0 && chapters[0].startTime > 5) {\n      chapters.unshift({\n        id: 'intro',\n        title: 'Introduction',\n        startTime: 0,\n        endTime: chapters[0].startTime,\n        sceneCount: 1,\n        hasIssues: false\n      });\n    }\n\n    const lastChapter = chapters[chapters.length - 1];\n    if (lastChapter && lastChapter.endTime < this.video.duration - 5) {\n      chapters.push({\n        id: 'outro',\n        title: 'Conclusion',\n        startTime: lastChapter.endTime,\n        endTime: this.video.duration,\n        sceneCount: 1,\n        hasIssues: false\n      });\n    }\n\n    return chapters;\n  }\n\n  /**\n   * Creates quick-jump buttons for key scenes\n   * @param maxButtons Maximum number of buttons to generate\n   * @returns Array of quick jump buttons\n   */\n  createQuickJumpButtons(maxButtons: number = 8): QuickJumpButton[] {\n    const buttons: QuickJumpButton[] = [];\n\n    // Add room entry buttons\n    this.analysis.roomSequence.forEach((room) => {\n      buttons.push({\n        id: `quick_${room.roomId}`,\n        label: this.formatRoomTitle(room.roomType),\n        icon: this.getRoomIcon(room.roomType),\n        time: room.startTime,\n        type: 'room',\n        description: `Jump to ${room.roomType}`\n      });\n    });\n\n    // Add critical issues\n    const criticalIssues = this.analysis.issues\n      .filter(issue => issue.severity === 'high')\n      .slice(0, 3);\n\n    criticalIssues.forEach((issue, index) => {\n      if (issue.affectedTimestamps.length > 0) {\n        buttons.push({\n          id: `quick_issue_${index}`,\n          label: `Issue ${index + 1}`,\n          icon: 'âš ï¸',\n          time: issue.affectedTimestamps[0],\n          type: 'issue',\n          description: issue.description\n        });\n      }\n    });\n\n    // Add key features\n    const keyFeatures = this.analysis.featureDetection\n      .filter(f => f.detected && f.confidence > 80)\n      .slice(0, 3);\n\n    keyFeatures.forEach((feature) => {\n      if (feature.timestamps.length > 0) {\n        buttons.push({\n          id: `quick_feature_${feature.feature}`,\n          label: this.formatFeatureName(feature.feature),\n          icon: 'âœ¨',\n          time: feature.timestamps[0],\n          type: 'feature',\n          description: `View ${feature.feature}`\n        });\n      }\n    });\n\n    // Sort by time and limit\n    return buttons\n      .sort((a, b) => a.time - b.time)\n      .slice(0, maxButtons);\n  }\n\n  /**\n   * Manages bookmarks for the video\n   * @param time Timestamp to bookmark\n   * @param label Label for the bookmark\n   * @param description Optional description\n   */\n  addBookmark(time: number, label: string, description?: string): NavigationMarker {\n    const bookmark: NavigationMarker = {\n      id: `bookmark_${Date.now()}`,\n      time,\n      type: 'bookmark',\n      label,\n      description,\n      icon: 'ðŸ”–',\n      color: '#eab308'\n    };\n\n    this.bookmarks.set(time, bookmark);\n    return bookmark;\n  }\n\n  /**\n   * Removes a bookmark\n   * @param time Timestamp of bookmark to remove\n   */\n  removeBookmark(time: number): boolean {\n    return this.bookmarks.delete(time);\n  }\n\n  /**\n   * Gets all bookmarks sorted by time\n   */\n  getBookmarks(): NavigationMarker[] {\n    return Array.from(this.bookmarks.values())\n      .sort((a, b) => a.time - b.time);\n  }\n\n  /**\n   * Generates video metadata for display\n   * @returns VideoMetadata object\n   */\n  generateVideoMetadata(): VideoMetadata {\n    const roomsCovered = this.analysis.roomSequence.map(r => r.roomType);\n    const issuesFound = this.analysis.issues.length;\n    const overallQuality = this.analysis.qualityMetrics.averageQuality;\n\n    // Generate tags based on content\n    const tags: string[] = [];\n    \n    if (issuesFound > 0) tags.push('Has Issues');\n    if (overallQuality > 80) tags.push('High Quality');\n    if (roomsCovered.length >= 5) tags.push('Comprehensive');\n    if (this.analysis.qualityMetrics.stabilityScore > 85) tags.push('Stable Footage');\n    \n    // Add room tags\n    roomsCovered.forEach(room => {\n      tags.push(this.formatRoomTitle(room));\n    });\n\n    return {\n      title: `Property Inspection - ${this.video.metadata.propertyDetails.address}`,\n      propertyAddress: this.video.metadata.propertyDetails.address,\n      inspectorName: this.video.inspectorId, // Would be resolved to actual name\n      inspectionDate: this.video.createdAt,\n      duration: this.video.duration,\n      roomsCovered,\n      issuesFound,\n      overallQuality,\n      tags: [...new Set(tags)] // Remove duplicates\n    };\n  }\n\n  /**\n   * Finds the nearest navigation point to a given time\n   * @param time Current time in seconds\n   * @returns Nearest navigation marker\n   */\n  findNearestNavigationPoint(time: number): NavigationMarker | null {\n    const allMarkers: NavigationMarker[] = [];\n\n    // Collect all markers\n    const chapters = this.generateNavigationChapters();\n    chapters.forEach(chapter => {\n      if (chapter.subChapters) {\n        allMarkers.push(...chapter.subChapters);\n      }\n    });\n\n    // Add bookmarks\n    allMarkers.push(...this.getBookmarks());\n\n    // Find nearest\n    let nearest: NavigationMarker | null = null;\n    let minDistance = Infinity;\n\n    allMarkers.forEach(marker => {\n      const distance = Math.abs(marker.time - time);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearest = marker;\n      }\n    });\n\n    return minDistance < 10 ? nearest : null; // Within 10 seconds\n  }\n\n  /**\n   * Generates a timeline summary for the video\n   * @returns Array of timeline segments with descriptions\n   */\n  generateTimelineSummary(): Array<{\n    start: number;\n    end: number;\n    label: string;\n    type: string;\n    hasIssues: boolean;\n  }> {\n    const summary: Array<any> = [];\n\n    this.analysis.scenes.forEach((scene, index) => {\n      const roomType = scene.roomType || 'Unknown';\n      const hasIssues = this.analysis.issues.some(issue =>\n        issue.affectedTimestamps.some(t => t >= scene.startTime && t <= scene.endTime)\n      );\n\n      summary.push({\n        start: scene.startTime,\n        end: scene.endTime,\n        label: `${roomType} - ${scene.sceneType.replace(/_/g, ' ')}`,\n        type: scene.sceneType,\n        hasIssues\n      });\n    });\n\n    return summary;\n  }\n\n  // Helper methods\n\n  private formatRoomTitle(roomType: string): string {\n    return roomType\n      .split(/[-_]/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n\n  private getRoomIcon(roomType: string): string {\n    const icons: Record<string, string> = {\n      bedroom: 'ðŸ›ï¸',\n      bathroom: 'ðŸš¿',\n      kitchen: 'ðŸ³',\n      'living-room': 'ðŸ›‹ï¸',\n      'dining-room': 'ðŸ½ï¸',\n      garage: 'ðŸš—',\n      exterior: 'ðŸ ',\n      basement: 'ðŸ—ºï¸',\n      attic: 'ðŸ '\n    };\n    return icons[roomType.toLowerCase()] || 'ðŸ“¹';\n  }\n\n  private formatFeatureName(feature: string): string {\n    return feature\n      .replace(/_/g, ' ')\n      .split(' ')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  }\n}\n\n// Export factory function\nexport const createVideoNavigationManager = (\n  video: VideoRecording,\n  analysis: VideoAnalysisResult\n): VideoNavigationManager => {\n  return new VideoNavigationManager(video, analysis);\n};\n\n// Utility functions for video navigation\n\nexport const formatTimestamp = (seconds: number): string => {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  \n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, '0')}`;\n};\n\nexport const parseTimestamp = (timestamp: string): number => {\n  const parts = timestamp.split(':').map(Number);\n  if (parts.length === 3) {\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  } else if (parts.length === 2) {\n    return parts[0] * 60 + parts[1];\n  }\n  return 0;\n};\n\nexport const generateShareableLink = (\n  videoId: string,\n  timestamp?: number,\n  annotationId?: string\n): string => {\n  const params = new URLSearchParams();\n  params.set('v', videoId);\n  \n  if (timestamp !== undefined) {\n    params.set('t', timestamp.toString());\n  }\n  \n  if (annotationId) {\n    params.set('a', annotationId);\n  }\n  \n  return `/audit/video?${params.toString()}`;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/lib/video/video-processor.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'lastStatsUpdate' is never reassigned. Use 'const' instead.","line":77,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":77,"endColumn":28,"fix":{"range":[2235,2268],"text":"const lastStatsUpdate = Date.now();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4913,4916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4913,4916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":449,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13306,13309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13306,13309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":482,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":482,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14471,14474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14471,14474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":587,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":587,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17774,17777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17774,17777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":588,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":588,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17821,17824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17821,17824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":609,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":609,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18428,18431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18428,18431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":629,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":629,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19028,19031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19028,19031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":665,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":665,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20181,20184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20181,20184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":667,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":667,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20216,20219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20216,20219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// Video Processor for STR Certified Walkthrough Videos\n\nimport type {\n  VideoRecording,\n  VideoTimestamp,\n  VideoAnalysisResult,\n  SceneAnalysis,\n  VideoQuality,\n  VideoProcessingConfig,\n  VideoRecordingConfig,\n  KeyFrame,\n  SceneType,\n  VideoStatus,\n  VideoRecordingStats,\n  RoomSequence,\n  VideoIssue\n} from '@/types/video';\n\nexport class VideoProcessor {\n  private config: VideoProcessingConfig;\n  private mediaRecorder: MediaRecorder | null = null;\n  private recordedChunks: Blob[] = [];\n  private startTime: number = 0;\n  private pausedDuration: number = 0;\n  private lastPauseTime: number = 0;\n  private frameExtractionWorker: Worker | null = null;\n  private analysisAbortController: AbortController | null = null;\n\n  constructor(config: Partial<VideoProcessingConfig> = {}) {\n    this.config = {\n      extractFrameInterval: 2, // Extract frame every 2 seconds\n      keyFrameQualityThreshold: 75,\n      sceneChangeThreshold: 0.3,\n      maxProcessingTime: 300, // 5 minutes\n      enableAudioAnalysis: true,\n      targetFrameRate: 30,\n      compressionQuality: 0.85,\n      ...config\n    };\n\n    // Initialize frame extraction worker if available\n    if (typeof Worker !== 'undefined') {\n      // In production, this would be a separate worker file\n      // For now, we'll use inline worker simulation\n    }\n  }\n\n  /**\n   * Records a property walkthrough video\n   * @param stream - MediaStream from camera\n   * @param config - Recording configuration\n   * @returns Promise<VideoRecording>\n   */\n  async recordWalkthrough(\n    stream: MediaStream,\n    recordingConfig: VideoRecordingConfig,\n    onStats?: (stats: VideoRecordingStats) => void\n  ): Promise<VideoRecording> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Reset state\n        this.recordedChunks = [];\n        this.startTime = Date.now();\n        this.pausedDuration = 0;\n\n        // Configure MediaRecorder\n        const mimeType = this.getSupportedMimeType();\n        const options: MediaRecorderOptions = {\n          mimeType,\n          videoBitsPerSecond: recordingConfig.targetBitrate * 1000,\n        };\n\n        this.mediaRecorder = new MediaRecorder(stream, options);\n        \n        // Stats tracking\n        let frameCount = 0;\n        let lastStatsUpdate = Date.now();\n        const statsInterval = setInterval(() => {\n          if (this.mediaRecorder?.state === 'recording') {\n            frameCount++;\n            const duration = this.getRecordingDuration();\n            const fileSize = this.recordedChunks.reduce((acc, chunk) => acc + chunk.size, 0);\n            \n            const stats: VideoRecordingStats = {\n              duration,\n              fileSize,\n              framesRecorded: frameCount,\n              droppedFrames: 0, // Would need actual frame analysis\n              averageFps: frameCount / (duration || 1),\n              storageUsed: fileSize,\n              storageAvailable: this.getAvailableStorage(),\n              batteryLevel: this.getBatteryLevel()\n            };\n            \n            onStats?.(stats);\n          }\n        }, 1000);\n\n        // Handle data available\n        this.mediaRecorder.ondataavailable = (event) => {\n          if (event.data.size > 0) {\n            this.recordedChunks.push(event.data);\n          }\n        };\n\n        // Handle recording stop\n        this.mediaRecorder.onstop = async () => {\n          clearInterval(statsInterval);\n          \n          const blob = new Blob(this.recordedChunks, { type: mimeType });\n          const duration = this.getRecordingDuration();\n          \n          // Create video file\n          const file = new File([blob], `walkthrough_${Date.now()}.webm`, {\n            type: mimeType,\n            lastModified: Date.now()\n          });\n\n          // Extract video metadata\n          const quality = await this.analyzeVideoQuality(file);\n          const resolution = await this.getVideoResolution(file);\n\n          const recording: VideoRecording = {\n            id: `video_${Date.now()}`,\n            propertyId: '',\n            inspectorId: '',\n            file,\n            duration,\n            size: file.size,\n            format: mimeType,\n            resolution,\n            quality,\n            timestamps: [],\n            metadata: {\n              deviceInfo: {\n                model: navigator.userAgent,\n                os: this.getOperatingSystem()\n              },\n              propertyDetails: {\n                address: '',\n                propertyType: 'residential'\n              },\n              recordingConditions: {\n                lighting: 'indoor',\n                timeOfDay: new Date().getHours() < 12 ? 'morning' : 'afternoon'\n              },\n              inspectionType: 'standard'\n            },\n            status: 'stopped',\n            createdAt: new Date()\n          };\n\n          resolve(recording);\n        };\n\n        // Handle errors\n        this.mediaRecorder.onerror = (event: any) => {\n          clearInterval(statsInterval);\n          reject(new Error(`Recording error: ${event.error}`));\n        };\n\n        // Start recording\n        this.mediaRecorder.start(1000); // Collect data every second\n        \n        // Auto-stop after max duration\n        setTimeout(() => {\n          if (this.mediaRecorder?.state === 'recording') {\n            this.stopRecording();\n          }\n        }, recordingConfig.maxDuration * 1000);\n\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Processes video frames to extract key moments\n   * @param video - Video file or blob\n   * @returns Promise<VideoTimestamp[]>\n   */\n  async processVideoFrames(video: File | Blob): Promise<VideoTimestamp[]> {\n    const timestamps: VideoTimestamp[] = [];\n    const videoUrl = URL.createObjectURL(video);\n    \n    try {\n      const videoElement = document.createElement('video');\n      videoElement.src = videoUrl;\n      videoElement.muted = true;\n      \n      // Wait for metadata\n      await new Promise((resolve) => {\n        videoElement.onloadedmetadata = resolve;\n      });\n\n      const duration = videoElement.duration;\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      \n      if (!ctx) throw new Error('Failed to get canvas context');\n\n      // Set canvas size\n      canvas.width = videoElement.videoWidth;\n      canvas.height = videoElement.videoHeight;\n\n      let previousFrame: ImageData | null = null;\n      let sceneStartTime = 0;\n\n      // Process frames at intervals\n      for (let time = 0; time < duration; time += this.config.extractFrameInterval) {\n        videoElement.currentTime = time;\n        \n        await new Promise((resolve) => {\n          videoElement.onseeked = resolve;\n        });\n\n        // Draw frame to canvas\n        ctx.drawImage(videoElement, 0, 0);\n        const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        \n        // Detect scene changes\n        const isSceneChange = previousFrame \n          ? this.detectSceneChange(previousFrame, currentFrame) \n          : true;\n\n        if (isSceneChange) {\n          // Extract thumbnail\n          const thumbnail = canvas.toDataURL('image/jpeg', 0.7);\n          \n          // Analyze frame content\n          const analysis = await this.analyzeFrame(currentFrame, canvas);\n          \n          const timestamp: VideoTimestamp = {\n            id: `ts_${time}_${Date.now()}`,\n            time,\n            sceneType: analysis.sceneType,\n            roomDetected: analysis.roomType,\n            features: analysis.features,\n            description: analysis.description,\n            thumbnail,\n            confidence: analysis.confidence,\n            isKeyFrame: analysis.isKeyFrame,\n            annotations: []\n          };\n          \n          timestamps.push(timestamp);\n          sceneStartTime = time;\n        }\n\n        previousFrame = currentFrame;\n      }\n\n      return timestamps;\n\n    } finally {\n      URL.revokeObjectURL(videoUrl);\n    }\n  }\n\n  /**\n   * Analyzes video content using AI to identify rooms and features\n   * @param video - Video file\n   * @param timestamps - Extracted timestamps\n   * @returns Promise<VideoAnalysisResult>\n   */\n  async analyzeVideoContent(\n    video: File | Blob,\n    timestamps: VideoTimestamp[]\n  ): Promise<VideoAnalysisResult> {\n    const startTime = performance.now();\n    \n    // Create abort controller for cancellation\n    this.analysisAbortController = new AbortController();\n\n    try {\n      // Mock AI analysis - in production, this would call AI services\n      await this.simulateProcessing(2000);\n\n      // Group timestamps into scenes\n      const scenes = this.groupTimestampsIntoScenes(timestamps);\n      \n      // Analyze room sequence\n      const roomSequence = this.analyzeRoomSequence(scenes);\n      \n      // Detect features across video\n      const featureDetection = this.detectVideoFeatures(timestamps);\n      \n      // Calculate quality metrics\n      const qualityMetrics = await this.calculateQualityMetrics(video, timestamps);\n      \n      // Identify issues\n      const issues = this.identifyVideoIssues(scenes, roomSequence, qualityMetrics);\n      \n      // Generate summary\n      const summary = this.generateAnalysisSummary(scenes, roomSequence, qualityMetrics, issues);\n\n      const result: VideoAnalysisResult = {\n        videoId: `analysis_${Date.now()}`,\n        scenes,\n        qualityMetrics,\n        featureDetection,\n        roomSequence,\n        issues,\n        summary,\n        processingTime: performance.now() - startTime,\n        aiConfidence: 85 + Math.random() * 10\n      };\n\n      return result;\n\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new Error('Analysis cancelled');\n      }\n      throw error;\n    } finally {\n      this.analysisAbortController = null;\n    }\n  }\n\n  /**\n   * Generates navigation timestamps for video playback\n   * @param analysis - Video analysis result\n   * @returns VideoTimestamp[] with navigation markers\n   */\n  generateTimestamps(analysis: VideoAnalysisResult): VideoTimestamp[] {\n    const navigationTimestamps: VideoTimestamp[] = [];\n\n    // Add room entry timestamps\n    analysis.roomSequence.forEach((room, index) => {\n      navigationTimestamps.push({\n        id: `nav_room_${index}`,\n        time: room.startTime,\n        sceneType: 'room_entry',\n        roomDetected: room.roomType,\n        features: [],\n        description: `${room.roomType} - Entry`,\n        confidence: 90,\n        isKeyFrame: true\n      });\n\n      // Add key moments within room\n      room.keyMoments.forEach((moment) => {\n        navigationTimestamps.push({\n          ...moment,\n          id: `nav_moment_${index}_${moment.time}`,\n          description: `${room.roomType} - ${moment.description}`\n        });\n      });\n    });\n\n    // Add issue timestamps\n    analysis.issues.forEach((issue, index) => {\n      issue.affectedTimestamps.forEach((time) => {\n        navigationTimestamps.push({\n          id: `nav_issue_${index}_${time}`,\n          time,\n          sceneType: 'issue_documentation',\n          features: [issue.type],\n          description: issue.description,\n          confidence: 80,\n          isKeyFrame: true,\n          annotations: [{\n            type: 'text',\n            content: issue.description,\n            position: { x: 10, y: 10 },\n            style: {\n              color: issue.severity === 'high' ? '#ff0000' : '#ffaa00',\n              fontSize: 16\n            }\n          }]\n        });\n      });\n    });\n\n    // Sort by time\n    return navigationTimestamps.sort((a, b) => a.time - b.time);\n  }\n\n  // Control methods\n\n  pauseRecording(): void {\n    if (this.mediaRecorder?.state === 'recording') {\n      this.mediaRecorder.pause();\n      this.lastPauseTime = Date.now();\n    }\n  }\n\n  resumeRecording(): void {\n    if (this.mediaRecorder?.state === 'paused') {\n      this.pausedDuration += Date.now() - this.lastPauseTime;\n      this.mediaRecorder.resume();\n    }\n  }\n\n  stopRecording(): void {\n    if (this.mediaRecorder && \n        (this.mediaRecorder.state === 'recording' || this.mediaRecorder.state === 'paused')) {\n      this.mediaRecorder.stop();\n    }\n  }\n\n  cancelAnalysis(): void {\n    if (this.analysisAbortController) {\n      this.analysisAbortController.abort();\n    }\n  }\n\n  // Private helper methods\n\n  private getSupportedMimeType(): string {\n    const types = [\n      'video/webm;codecs=vp9,opus',\n      'video/webm;codecs=vp8,opus',\n      'video/webm',\n      'video/mp4'\n    ];\n\n    for (const type of types) {\n      if (MediaRecorder.isTypeSupported(type)) {\n        return type;\n      }\n    }\n\n    return 'video/webm';\n  }\n\n  private getRecordingDuration(): number {\n    if (!this.startTime) return 0;\n    return (Date.now() - this.startTime - this.pausedDuration) / 1000;\n  }\n\n  private async analyzeVideoQuality(video: File): Promise<VideoQuality> {\n    // Mock quality analysis\n    await this.simulateProcessing(500);\n    \n    return {\n      overall: 75 + Math.random() * 20,\n      stability: 80 + Math.random() * 15,\n      brightness: 70 + Math.random() * 25,\n      focus: 85 + Math.random() * 10,\n      audioQuality: 90 + Math.random() * 10,\n      bitrate: 2500 + Math.random() * 1500,\n      fps: 29 + Math.random() * 2\n    };\n  }\n\n  private async getVideoResolution(video: File): Promise<any> {\n    return new Promise((resolve) => {\n      const videoElement = document.createElement('video');\n      videoElement.src = URL.createObjectURL(video);\n      \n      videoElement.onloadedmetadata = () => {\n        resolve({\n          width: videoElement.videoWidth,\n          height: videoElement.videoHeight,\n          aspectRatio: `${videoElement.videoWidth}:${videoElement.videoHeight}`\n        });\n        URL.revokeObjectURL(videoElement.src);\n      };\n    });\n  }\n\n  private detectSceneChange(prev: ImageData, current: ImageData): boolean {\n    // Simple scene change detection using pixel difference\n    let diff = 0;\n    const pixels = prev.data.length / 4;\n    \n    for (let i = 0; i < prev.data.length; i += 4) {\n      const dr = Math.abs(prev.data[i] - current.data[i]);\n      const dg = Math.abs(prev.data[i + 1] - current.data[i + 1]);\n      const db = Math.abs(prev.data[i + 2] - current.data[i + 2]);\n      \n      diff += (dr + dg + db) / 3;\n    }\n    \n    const averageDiff = diff / pixels / 255;\n    return averageDiff > this.config.sceneChangeThreshold;\n  }\n\n  private async analyzeFrame(frame: ImageData, canvas: HTMLCanvasElement): Promise<any> {\n    // Mock frame analysis - in production, this would use AI\n    await this.simulateProcessing(100);\n    \n    const sceneTypes: SceneType[] = [\n      'room_overview', 'detail_shot', 'amenity_focus', 'transition'\n    ];\n    const roomTypes = ['bedroom', 'bathroom', 'kitchen', 'living-room', 'exterior'];\n    const features = ['bed', 'tv', 'window', 'door', 'furniture', 'appliances'];\n    \n    return {\n      sceneType: sceneTypes[Math.floor(Math.random() * sceneTypes.length)],\n      roomType: roomTypes[Math.floor(Math.random() * roomTypes.length)],\n      features: features.filter(() => Math.random() > 0.7),\n      description: 'Automated scene detection',\n      confidence: 70 + Math.random() * 25,\n      isKeyFrame: Math.random() > 0.6\n    };\n  }\n\n  private groupTimestampsIntoScenes(timestamps: VideoTimestamp[]): SceneAnalysis[] {\n    const scenes: SceneAnalysis[] = [];\n    let currentScene: SceneAnalysis | null = null;\n\n    timestamps.forEach((ts, index) => {\n      if (!currentScene || ts.sceneType !== currentScene.sceneType) {\n        if (currentScene) {\n          scenes.push(currentScene);\n        }\n        \n        currentScene = {\n          startTime: ts.time,\n          endTime: ts.time,\n          sceneType: ts.sceneType,\n          roomType: ts.roomDetected,\n          keyFrames: [],\n          objects: [],\n          quality: {\n            sharpness: 80 + Math.random() * 15,\n            stability: 75 + Math.random() * 20,\n            lighting: 70 + Math.random() * 25,\n            framing: 85 + Math.random() * 10,\n            overall: 78 + Math.random() * 17\n          },\n          transitions: []\n        };\n      }\n      \n      if (currentScene) {\n        currentScene.endTime = ts.time;\n        if (ts.isKeyFrame && ts.thumbnail) {\n          currentScene.keyFrames.push({\n            timestamp: ts.time,\n            frameUrl: ts.thumbnail,\n            quality: 85 + Math.random() * 10,\n            isRepresentative: ts.isKeyFrame,\n            features: ts.features\n          });\n        }\n      }\n    });\n\n    if (currentScene) {\n      scenes.push(currentScene);\n    }\n\n    return scenes;\n  }\n\n  private analyzeRoomSequence(scenes: SceneAnalysis[]): RoomSequence[] {\n    const roomMap = new Map<string, RoomSequence>();\n    \n    scenes.forEach((scene) => {\n      if (scene.roomType) {\n        const existing = roomMap.get(scene.roomType);\n        \n        if (existing) {\n          existing.endTime = scene.endTime;\n          existing.keyMoments.push(...scene.keyFrames.map(kf => ({\n            id: `moment_${kf.timestamp}`,\n            time: kf.timestamp,\n            sceneType: scene.sceneType,\n            roomDetected: scene.roomType,\n            features: kf.features,\n            description: 'Key moment',\n            thumbnail: kf.frameUrl,\n            confidence: kf.quality,\n            isKeyFrame: true\n          })));\n        } else {\n          roomMap.set(scene.roomType, {\n            roomId: `room_${scene.roomType}_${Date.now()}`,\n            roomType: scene.roomType,\n            startTime: scene.startTime,\n            endTime: scene.endTime,\n            coverage: 'partial',\n            keyMoments: []\n          });\n        }\n      }\n    });\n\n    return Array.from(roomMap.values());\n  }\n\n  private detectVideoFeatures(timestamps: VideoTimestamp[]): any[] {\n    const featureMap = new Map<string, any>();\n    \n    timestamps.forEach((ts) => {\n      ts.features.forEach((feature) => {\n        if (!featureMap.has(feature)) {\n          featureMap.set(feature, {\n            feature,\n            detected: true,\n            confidence: 80 + Math.random() * 15,\n            timestamps: [ts.time],\n            evidence: [`Detected at ${ts.time}s`]\n          });\n        } else {\n          featureMap.get(feature).timestamps.push(ts.time);\n        }\n      });\n    });\n\n    return Array.from(featureMap.values());\n  }\n\n  private async calculateQualityMetrics(video: File, timestamps: VideoTimestamp[]): Promise<any> {\n    await this.simulateProcessing(1000);\n    \n    return {\n      averageQuality: 78 + Math.random() * 15,\n      stabilityScore: 82 + Math.random() * 12,\n      consistencyScore: 85 + Math.random() * 10,\n      coverageScore: 75 + Math.random() * 20,\n      technicalIssues: [],\n      recommendations: [\n        'Consider using a gimbal for smoother footage',\n        'Ensure all rooms are well-lit before recording',\n        'Take time to focus on key features'\n      ]\n    };\n  }\n\n  private identifyVideoIssues(\n    scenes: SceneAnalysis[],\n    roomSequence: RoomSequence[],\n    qualityMetrics: any\n  ): VideoIssue[] {\n    const issues: VideoIssue[] = [];\n    \n    // Check for quality issues\n    if (qualityMetrics.averageQuality < 70) {\n      issues.push({\n        type: 'poor_quality',\n        severity: 'medium',\n        description: 'Overall video quality is below acceptable threshold',\n        affectedTimestamps: scenes.map(s => s.startTime),\n        suggestedAction: 'Re-record with better lighting and stability'\n      });\n    }\n    \n    // Check for missing rooms (mock)\n    const expectedRooms = ['bedroom', 'bathroom', 'kitchen', 'living-room'];\n    const coveredRooms = roomSequence.map(r => r.roomType);\n    const missingRooms = expectedRooms.filter(r => !coveredRooms.includes(r));\n    \n    if (missingRooms.length > 0) {\n      issues.push({\n        type: 'missing_room',\n        severity: 'high',\n        description: `Missing coverage for: ${missingRooms.join(', ')}`,\n        affectedTimestamps: [],\n        suggestedAction: 'Record additional footage of missing areas'\n      });\n    }\n\n    return issues;\n  }\n\n  private generateAnalysisSummary(\n    scenes: SceneAnalysis[],\n    roomSequence: RoomSequence[],\n    qualityMetrics: any,\n    issues: VideoIssue[]\n  ): any {\n    const totalDuration = scenes[scenes.length - 1]?.endTime || 0;\n    const roomsCovered = roomSequence.map(r => r.roomType);\n    const expectedRooms = ['bedroom', 'bathroom', 'kitchen', 'living-room'];\n    const roomsMissing = expectedRooms.filter(r => !roomsCovered.includes(r));\n    \n    return {\n      totalDuration,\n      roomsCovered,\n      roomsMissing,\n      overallQuality: qualityMetrics.averageQuality,\n      keyFindings: [\n        `Recorded ${scenes.length} scenes across ${roomsCovered.length} rooms`,\n        `Average quality score: ${Math.round(qualityMetrics.averageQuality)}%`,\n        issues.length > 0 ? `${issues.length} issues identified` : 'No major issues found'\n      ],\n      recommendedActions: qualityMetrics.recommendations,\n      readyForSubmission: issues.filter(i => i.severity === 'high').length === 0\n    };\n  }\n\n  private getOperatingSystem(): string {\n    const userAgent = navigator.userAgent;\n    if (userAgent.includes('Windows')) return 'Windows';\n    if (userAgent.includes('Mac')) return 'macOS';\n    if (userAgent.includes('Linux')) return 'Linux';\n    if (userAgent.includes('Android')) return 'Android';\n    if (userAgent.includes('iOS')) return 'iOS';\n    return 'Unknown';\n  }\n\n  private getAvailableStorage(): number {\n    // Mock storage - in production, use navigator.storage.estimate()\n    return 5 * 1024 * 1024 * 1024; // 5GB\n  }\n\n  private getBatteryLevel(): number | undefined {\n    // Mock battery - in production, use Battery API\n    return 75 + Math.random() * 25;\n  }\n\n  private async simulateProcessing(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// Export factory function\nexport const createVideoProcessor = (\n  config?: Partial<VideoProcessingConfig>\n): VideoProcessor => {\n  return new VideoProcessor(config);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/AddProperty.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/AuditorDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4629,4632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4629,4632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":528,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":528,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20072,20075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20072,20075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":533,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20330,20333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20330,20333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\nimport { Input } from '@/components/ui/input';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Separator } from '@/components/ui/separator';\nimport { \n  Clock, \n  CheckCircle, \n  XCircle, \n  Eye, \n  MessageSquare, \n  BarChart3,\n  Calendar,\n  Filter,\n  Search,\n  Play,\n  Pause,\n  Download,\n  ThumbsUp,\n  ThumbsDown,\n  AlertTriangle,\n  TrendingUp,\n  Users,\n  FileText\n} from 'lucide-react';\n\n// Hooks and Services\nimport { useErrorHandling } from '@/hooks/useErrorHandling';\nimport { useLearningAnalytics } from '@/hooks/useLearningAnalytics';\nimport { useVideoReview } from '@/hooks/useVideoReview';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useAuth } from '@/components/AuthProvider';\nimport { auditorService, type InspectionForReview, type AuditorMetrics } from '@/services/auditorService';\nimport { logger } from '@/utils/logger';\n\n// Components\nimport { VideoPlayer } from '@/components/video/VideoPlayer';\nimport { AIAnalysisPanel } from '@/components/ai/AIAnalysisPanel';\nimport { FeedbackForm } from '@/components/audit/FeedbackForm';\nimport { MetricsChart } from '@/components/audit/MetricsChart';\n\n// Types for legacy support\ninterface Inspection {\n  id: string;\n  propertyId: string;\n  propertyAddress: string;\n  inspectorId: string;\n  inspectorName: string;\n  status: 'pending_review' | 'in_review' | 'completed' | 'approved' | 'rejected';\n  submittedAt: string;\n  priority: 'high' | 'medium' | 'low';\n  aiScore: number;\n  photoCount: number;\n  videoCount: number;\n  issuesFound: number;\n  estimatedReviewTime: number;\n}\n\ninterface AIAnalysis {\n  overallScore: number;\n  confidence: number;\n  completedItems: number;\n  totalItems: number;\n  photoCount: number;\n  videoCount: number;\n  issues: Array<{\n    id: string;\n    label: string;\n    category: string | null;\n    status: string | null;\n    ai_status: string | null;\n    notes: string | null;\n  }>;\n  recommendations: string[];\n}\n\nexport function AuditorDashboard() {\n  const navigate = useNavigate();\n  const queryClient = useQueryClient();\n  const { user } = useAuth();\n  const { error, handleError, withErrorHandling } = useErrorHandling();\n  const { trackLearningEvent, getPersonalizedRecommendations } = useLearningAnalytics();\n  const { playVideo, pauseVideo, seekTo, isPlaying } = useVideoReview();\n\n  // State Management\n  const [activeTab, setActiveTab] = useState('queue');\n  const [selectedInspection, setSelectedInspection] = useState<string | null>(null);\n  const [filterStatus, setFilterStatus] = useState<string>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [reviewDecision, setReviewDecision] = useState<'approved' | 'rejected' | 'needs_revision' | null>(null);\n  const [feedbackText, setFeedbackText] = useState('');\n\n  // Data Queries - Real inspection data\n  const { data: inspectionsData, isLoading: isLoadingInspections, error: inspectionsError } = useQuery({\n    queryKey: ['inspections', 'pending_review', filterStatus, searchQuery],\n    queryFn: async () => {\n      logger.info('Fetching inspections for auditor dashboard', {\n        filterStatus,\n        searchQuery\n      }, 'AUDITOR_DASHBOARD');\n\n      const result = await auditorService.getInspectionsPendingReview(50, {\n        status: filterStatus,\n        searchQuery: searchQuery || undefined\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || 'Failed to fetch inspections');\n      }\n\n      return result.data || [];\n    },\n    refetchInterval: 30000, // Refetch every 30 seconds for real-time updates\n  });\n\n  // Transform real data to legacy format for existing UI\n  const inspections: Inspection[] = (inspectionsData || []).map(inspection => ({\n    id: inspection.id,\n    propertyId: inspection.property_id,\n    propertyAddress: inspection.properties?.address || 'Unknown Address',\n    inspectorId: inspection.inspector_id,\n    inspectorName: inspection.users?.name || 'Unknown Inspector',\n    status: inspection.status as any,\n    submittedAt: inspection.start_time,\n    priority: inspection.ai_analysis_summary?.issues_count > 5 ? 'high' : \n              inspection.ai_analysis_summary?.issues_count > 2 ? 'medium' : 'low',\n    aiScore: inspection.ai_analysis_summary?.overall_score || 0,\n    photoCount: inspection.ai_analysis_summary?.photo_count || 0,\n    videoCount: inspection.ai_analysis_summary?.video_count || 0,\n    issuesFound: inspection.ai_analysis_summary?.issues_count || 0,\n    estimatedReviewTime: Math.max(5, Math.min(30, \n      (inspection.ai_analysis_summary?.total_items || 0) * 2 + \n      (inspection.ai_analysis_summary?.issues_count || 0) * 3\n    ))\n  }));\n\n  // Get auditor metrics\n  const { data: auditorMetrics } = useQuery({\n    queryKey: ['auditor_metrics', user?.id],\n    queryFn: async () => {\n      if (!user?.id) return null;\n      \n      const result = await auditorService.getAuditorMetrics(user.id, 'today');\n      if (!result.success) {\n        logger.warn('Failed to fetch auditor metrics', result.error, 'AUDITOR_DASHBOARD');\n        return null;\n      }\n      return result.data;\n    },\n    enabled: !!user?.id,\n    refetchInterval: 60000, // Refetch every minute\n  });\n\n  // Get detailed inspection data\n  const { data: currentInspectionDetails } = useQuery({\n    queryKey: ['inspection_details', selectedInspection],\n    queryFn: async () => {\n      if (!selectedInspection) return null;\n      \n      logger.info('Fetching detailed inspection for review', {\n        inspectionId: selectedInspection\n      }, 'AUDITOR_DASHBOARD');\n\n      const result = await auditorService.getInspectionForReview(selectedInspection);\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Failed to fetch inspection details');\n      }\n\n      const inspection = result.data;\n      if (!inspection) return null;\n\n      // Transform to expected format\n      const photos = inspection.checklist_items.flatMap(item => \n        item.media_files\n          .filter(media => media.type === 'photo')\n          .map(media => ({\n            id: media.id,\n            url: media.url,\n            room: item.title,\n            timestamp: media.created_at,\n            fileName: media.file_name\n          }))\n      );\n\n      const videos = inspection.checklist_items.flatMap(item =>\n        item.media_files\n          .filter(media => media.type === 'video')\n          .map(media => ({\n            id: media.id,\n            url: media.url,\n            duration: 0, // TODO: Add duration to media_files table\n            timestamp: media.created_at,\n            fileName: media.file_name\n          }))\n      );\n\n      const aiAnalysis = {\n        overallScore: inspection.ai_analysis_summary?.overall_score || 0,\n        confidence: inspection.ai_analysis_summary?.confidence_average || 0,\n        completedItems: inspection.ai_analysis_summary?.completed_items || 0,\n        totalItems: inspection.ai_analysis_summary?.total_items || 0,\n        photoCount: inspection.ai_analysis_summary?.photo_count || 0,\n        videoCount: inspection.ai_analysis_summary?.video_count || 0,\n        issues: inspection.checklist_items\n          .filter(item => item.ai_status === 'fail' || item.ai_status === 'needs_review')\n          .map(item => ({\n            id: item.id,\n            label: item.title,\n            category: null,\n            status: item.status,\n            ai_status: item.ai_status,\n            notes: item.notes\n          })),\n        recommendations: [\n          'Review flagged items carefully',\n          'Check photo quality and clarity',\n          'Verify AI analysis accuracy'\n        ]\n      };\n\n      return {\n        inspection: inspections.find(i => i.id === selectedInspection),\n        photos,\n        videos,\n        aiAnalysis\n      };\n    },\n    enabled: !!selectedInspection,\n  });\n\n  // Submit review decision mutation\n  const submitReviewMutation = useMutation({\n    mutationFn: async ({\n      inspectionId,\n      decision,\n      feedback,\n      overrides = []\n    }: {\n      inspectionId: string;\n      decision: 'approved' | 'rejected' | 'needs_revision';\n      feedback: string;\n      overrides?: Array<{\n        checklistItemId: string;\n        originalAiStatus: string;\n        auditorStatus: string;\n        reasoning: string;\n      }>;\n    }) => {\n      const reviewDecision = {\n        inspectionId,\n        decision,\n        feedback,\n        overrides,\n        reviewTime: 15 // TODO: Track actual review time\n      };\n\n      const result = await auditorService.submitReviewDecision(reviewDecision);\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Failed to submit review');\n      }\n\n      return result;\n    },\n    onSuccess: () => {\n      // Refresh inspections list\n      queryClient.invalidateQueries({ queryKey: ['inspections'] });\n      queryClient.invalidateQueries({ queryKey: ['auditor_metrics'] });\n      \n      // Clear selection\n      setSelectedInspection(null);\n      setReviewDecision(null);\n      setFeedbackText('');\n      \n      logger.info('Review decision submitted successfully', {}, 'AUDITOR_DASHBOARD');\n    },\n    onError: (error) => {\n      logger.error('Failed to submit review decision', error, 'AUDITOR_DASHBOARD');\n      handleError(error as Error);\n    }\n  });\n\n  // Handle review submission\n  const handleSubmitReview = async () => {\n    if (!selectedInspection || !reviewDecision) return;\n    \n    await withErrorHandling(async () => {\n      await submitReviewMutation.mutateAsync({\n        inspectionId: selectedInspection,\n        decision: reviewDecision,\n        feedback: feedbackText\n      });\n      \n      // Track learning event\n      trackLearningEvent({\n        type: 'audit_decision',\n        data: {\n          decision: reviewDecision,\n          inspectionId: selectedInspection,\n          feedback: feedbackText\n        }\n      });\n    });\n  };\n\n  // Event Handlers\n  const handleInspectionSelect = (inspectionId: string) => {\n    setSelectedInspection(inspectionId);\n    trackLearningEvent('inspection_selected', { inspectionId });\n  };\n\n  // Helper function to get priority\n  const getPriority = (inspection: Inspection) => {\n    if (!inspection.end_time) return 'medium';\n    const hoursAgo = (Date.now() - new Date(inspection.end_time).getTime()) / (1000 * 60 * 60);\n    if (hoursAgo < 2) return 'high';\n    if (hoursAgo < 24) return 'medium';\n    return 'low';\n  };\n\n  // Helper function to get photo/video counts\n  const getMediaCounts = (inspection: InspectionForReview) => {\n    const items = inspection.checklist_items || [];\n    const photoCount = items.reduce((count, item) => \n      count + (item.media?.filter(m => m.type === 'photo').length || 0), 0\n    );\n    const videoCount = items.reduce((count, item) => \n      count + (item.media?.filter(m => m.type === 'video').length || 0), 0\n    );\n    return { photoCount, videoCount };\n  };\n\n  const getPriorityColor = (priority: string) => {\n    switch (priority) {\n      case 'urgent': return 'destructive';\n      case 'high': return 'destructive';\n      case 'medium': return 'secondary';\n      case 'low': return 'outline';\n      default: return 'outline';\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'pending_review': return 'secondary';\n      case 'in_review': return 'default';\n      case 'approved': return 'outline';\n      case 'rejected': return 'destructive';\n      case 'needs_revision': return 'secondary';\n      default: return 'outline';\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Header */}\n      <div className=\"bg-white dark:bg-gray-800 border-b shadow-sm\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex items-center justify-between h-16\">\n            <div className=\"flex items-center space-x-4\">\n              <h1 className=\"text-xl font-semibold text-gray-900 dark:text-gray-100\">\n                Auditor Dashboard\n              </h1>\n            </div>\n            \n            <div className=\"flex items-center space-x-4\">\n              <Badge variant=\"secondary\" className=\"flex items-center space-x-1\">\n                <Clock className=\"h-3 w-3\" />\n                <span>{metrics?.pendingReviews || 0} pending</span>\n              </Badge>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        {/* Metrics Overview */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8\">\n          <Card>\n            <CardContent className=\"p-6\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <p className=\"text-sm font-medium text-gray-600\">Total Reviews</p>\n                  <p className=\"text-2xl font-bold\">{metrics?.totalInspections}</p>\n                </div>\n                <FileText className=\"h-8 w-8 text-blue-500\" />\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardContent className=\"p-6\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <p className=\"text-sm font-medium text-gray-600\">Avg Review Time</p>\n                  <p className=\"text-2xl font-bold\">{metrics?.avgReviewTime}m</p>\n                </div>\n                <Clock className=\"h-8 w-8 text-green-500\" />\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardContent className=\"p-6\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <p className=\"text-sm font-medium text-gray-600\">Approval Rate</p>\n                  <p className=\"text-2xl font-bold\">{metrics?.approvalRate}%</p>\n                </div>\n                <TrendingUp className=\"h-8 w-8 text-blue-500\" />\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardContent className=\"p-6\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <p className=\"text-sm font-medium text-gray-600\">AI Accuracy</p>\n                  <p className=\"text-2xl font-bold\">{metrics?.aiAccuracy}%</p>\n                </div>\n                <BarChart3 className=\"h-8 w-8 text-purple-500\" />\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n\n        <Tabs value={activeTab} onValueChange={setActiveTab} className=\"space-y-6\">\n          <TabsList className=\"grid w-full grid-cols-4\">\n            <TabsTrigger value=\"queue\">Review Queue</TabsTrigger>\n            <TabsTrigger value=\"review\">Active Review</TabsTrigger>\n            <TabsTrigger value=\"analytics\">Analytics</TabsTrigger>\n            <TabsTrigger value=\"feedback\">Feedback History</TabsTrigger>\n          </TabsList>\n\n          {/* Review Queue */}\n          <TabsContent value=\"queue\" className=\"space-y-6\">\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle>Inspection Queue</CardTitle>\n                    <CardDescription>\n                      Pending inspections requiring review\n                    </CardDescription>\n                  </div>\n                  <div className=\"flex items-center space-x-2\">\n                    <div className=\"flex items-center space-x-2\">\n                      <Search className=\"h-4 w-4 text-gray-400\" />\n                      <Input\n                        placeholder=\"Search inspections...\"\n                        value={searchQuery}\n                        onChange={(e) => setSearchQuery(e.target.value)}\n                        className=\"w-64\"\n                      />\n                    </div>\n                    <Select value={filterStatus} onValueChange={setFilterStatus}>\n                      <SelectTrigger className=\"w-32\">\n                        <SelectValue placeholder=\"Status\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        <SelectItem value=\"all\">All Status</SelectItem>\n                        <SelectItem value=\"pending_review\">Pending</SelectItem>\n                        <SelectItem value=\"in_review\">In Review</SelectItem>\n                      </SelectContent>\n                    </Select>\n                    <Select value={filterPriority} onValueChange={setFilterPriority}>\n                      <SelectTrigger className=\"w-32\">\n                        <SelectValue placeholder=\"Priority\" />\n                      </SelectTrigger>\n                      <SelectContent>\n                        <SelectItem value=\"all\">All Priority</SelectItem>\n                        <SelectItem value=\"urgent\">Urgent</SelectItem>\n                        <SelectItem value=\"high\">High</SelectItem>\n                        <SelectItem value=\"medium\">Medium</SelectItem>\n                        <SelectItem value=\"low\">Low</SelectItem>\n                      </SelectContent>\n                    </Select>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <Table>\n                  <TableHeader>\n                    <TableRow>\n                      <TableHead>Property</TableHead>\n                      <TableHead>Inspector</TableHead>\n                      <TableHead>Status</TableHead>\n                      <TableHead>Priority</TableHead>\n                      <TableHead>Completion</TableHead>\n                      <TableHead>Issues</TableHead>\n                      <TableHead>Completed</TableHead>\n                      <TableHead>Actions</TableHead>\n                    </TableRow>\n                  </TableHeader>\n                  <TableBody>\n                    {filteredInspections.map((inspection) => {\n                      const { photoCount, videoCount } = getMediaCounts(inspection);\n                      const priority = getPriority(inspection);\n                      const displayStatus = getDisplayStatus(inspection);\n                      const completedItems = inspection.checklist_items?.filter(item => item.status === 'completed').length || 0;\n                      const totalItems = inspection.checklist_items?.length || 0;\n                      const completionScore = totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0;\n                      const issuesFound = inspection.checklist_items?.filter(item => item.ai_status && item.ai_status !== 'pass').length || 0;\n                      \n                      return (\n                        <TableRow key={inspection.id}>\n                          <TableCell>\n                            <div>\n                              <p className=\"font-medium\">\n                                {inspection.properties?.name || inspection.properties?.address || 'Unknown Property'}\n                              </p>\n                              <p className=\"text-sm text-gray-500\">\n                                {photoCount} photos, {videoCount} video{videoCount !== 1 ? 's' : ''}\n                              </p>\n                            </div>\n                          </TableCell>\n                          <TableCell>{inspection.users?.name || 'Unknown Inspector'}</TableCell>\n                          <TableCell>\n                            <Badge variant={getStatusColor(displayStatus) as any}>\n                              {displayStatus.replace('_', ' ')}\n                            </Badge>\n                          </TableCell>\n                          <TableCell>\n                            <Badge variant={getPriorityColor(priority) as any}>\n                              {priority}\n                            </Badge>\n                          </TableCell>\n                          <TableCell>\n                            <div className=\"flex items-center space-x-2\">\n                              <span className=\"font-medium\">{completionScore}%</span>\n                              {completionScore < 80 && (\n                                <AlertTriangle className=\"h-4 w-4 text-yellow-500\" />\n                              )}\n                            </div>\n                          </TableCell>\n                          <TableCell>{issuesFound}</TableCell>\n                          <TableCell>\n                            {inspection.end_time ? (\n                              <span className=\"text-sm text-gray-500\">\n                                {new Date(inspection.end_time).toLocaleDateString()}\n                              </span>\n                            ) : (\n                              <span className=\"text-sm text-gray-400\">In progress</span>\n                            )}\n                          </TableCell>\n                          <TableCell>\n                            <Button\n                              size=\"sm\"\n                              onClick={() => {\n                                handleInspectionSelect(inspection.id);\n                                setActiveTab('review');\n                              }}\n                            >\n                              <Eye className=\"h-4 w-4 mr-1\" />\n                              Review\n                            </Button>\n                          </TableCell>\n                        </TableRow>\n                      );\n                    })}\n                  </TableBody>\n                </Table>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Active Review */}\n          <TabsContent value=\"review\" className=\"space-y-6\">\n            {selectedInspection && currentInspectionDetails ? (\n              <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n                {/* Main Review Area */}\n                <div className=\"lg:col-span-2 space-y-6\">\n                  {/* Video Player */}\n                  <Card>\n                    <CardHeader>\n                      <CardTitle>Video Walkthrough</CardTitle>\n                    </CardHeader>\n                    <CardContent>\n                      {currentInspectionDetails.videos.length > 0 ? (\n                        <VideoPlayer\n                          src={currentInspectionDetails.videos[0]?.url}\n                          isPlaying={isPlaying}\n                          onPlay={playVideo}\n                          onPause={pauseVideo}\n                          onSeek={seekTo}\n                        />\n                      ) : (\n                        <div className=\"aspect-video bg-gray-100 dark:bg-gray-800 rounded-lg flex items-center justify-center\">\n                          <div className=\"text-center\">\n                            <Video className=\"h-12 w-12 text-gray-400 mx-auto mb-4\" />\n                            <p className=\"text-gray-500\">No video available</p>\n                          </div>\n                        </div>\n                      )}\n                    </CardContent>\n                  </Card>\n\n                  {/* Photo Gallery */}\n                  <Card>\n                    <CardHeader>\n                      <CardTitle>Photo Documentation</CardTitle>\n                    </CardHeader>\n                    <CardContent>\n                      {currentInspectionDetails.photos.length > 0 ? (\n                        <>\n                          <div className=\"grid grid-cols-4 gap-4\">\n                            {currentInspectionDetails.photos.slice(0, 8).map((photo) => (\n                              <div key={photo.id} className=\"aspect-square rounded-lg bg-gray-200 dark:bg-gray-700\">\n                                <img\n                                  src={photo.url}\n                                  alt={`Photo ${photo.id}`}\n                                  className=\"w-full h-full object-cover rounded-lg\"\n                                />\n                              </div>\n                            ))}\n                          </div>\n                          {currentInspectionDetails.photos.length > 8 && (\n                            <Button variant=\"outline\" className=\"mt-4 w-full\">\n                              View All {currentInspectionDetails.photos.length} Photos\n                            </Button>\n                          )}\n                        </>\n                      ) : (\n                        <div className=\"text-center py-8\">\n                          <Camera className=\"h-12 w-12 text-gray-400 mx-auto mb-4\" />\n                          <p className=\"text-gray-500\">No photos available</p>\n                        </div>\n                      )}\n                    </CardContent>\n                  </Card>\n                </div>\n\n                {/* Sidebar */}\n                <div className=\"space-y-6\">\n                  {/* AI Analysis */}\n                  <AIAnalysisPanel analysis={currentInspectionDetails.aiAnalysis} />\n\n                  {/* Review Decision */}\n                  <Card>\n                    <CardHeader>\n                      <CardTitle>Review Decision</CardTitle>\n                    </CardHeader>\n                    <CardContent className=\"space-y-4\">\n                      <div className=\"flex space-x-2\">\n                        <Button\n                          variant={reviewDecision === 'approved' ? 'default' : 'outline'}\n                          onClick={() => setReviewDecision('approved')}\n                          className=\"flex-1\"\n                        >\n                          <ThumbsUp className=\"h-4 w-4 mr-1\" />\n                          Approve\n                        </Button>\n                        <Button\n                          variant={reviewDecision === 'rejected' ? 'destructive' : 'outline'}\n                          onClick={() => setReviewDecision('rejected')}\n                          className=\"flex-1\"\n                        >\n                          <ThumbsDown className=\"h-4 w-4 mr-1\" />\n                          Reject\n                        </Button>\n                      </div>\n                      <Button\n                        variant={reviewDecision === 'needs_revision' ? 'secondary' : 'outline'}\n                        onClick={() => setReviewDecision('needs_revision')}\n                        className=\"w-full\"\n                      >\n                        Request Revision\n                      </Button>\n\n                      <Textarea\n                        placeholder=\"Add feedback for the inspector...\"\n                        value={feedbackText}\n                        onChange={(e) => setFeedbackText(e.target.value)}\n                        rows={4}\n                      />\n\n                      <Button\n                        onClick={handleSubmitReview}\n                        disabled={!reviewDecision || submitReviewMutation.isPending}\n                        className=\"w-full\"\n                      >\n                        {submitReviewMutation.isPending ? 'Submitting...' : 'Submit Review'}\n                      </Button>\n                    </CardContent>\n                  </Card>\n                </div>\n              </div>\n            ) : (\n              <Card>\n                <CardContent className=\"text-center py-12\">\n                  <Eye className=\"h-12 w-12 text-gray-400 mx-auto mb-4\" />\n                  <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                    Select an Inspection to Review\n                  </h3>\n                  <p className=\"text-gray-500\">\n                    Choose an inspection from the queue to begin the review process.\n                  </p>\n                </CardContent>\n              </Card>\n            )}\n          </TabsContent>\n\n          {/* Analytics */}\n          <TabsContent value=\"analytics\">\n            <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Review Performance</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <MetricsChart \n                    data={[\n                      { name: 'Mon', reviews: 12, avgTime: 15 },\n                      { name: 'Tue', reviews: 8, avgTime: 18 },\n                      { name: 'Wed', reviews: 15, avgTime: 12 },\n                      { name: 'Thu', reviews: 10, avgTime: 20 },\n                      { name: 'Fri', reviews: 14, avgTime: 16 },\n                    ]}\n                  />\n                </CardContent>\n              </Card>\n\n              <Card>\n                <CardHeader>\n                  <CardTitle>AI Accuracy Tracking</CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"space-y-4\">\n                    <div className=\"flex justify-between items-center\">\n                      <span>Overall Accuracy</span>\n                      <span className=\"font-bold\">{metrics?.aiAccuracy}%</span>\n                    </div>\n                    <div className=\"flex justify-between items-center\">\n                      <span>False Positives</span>\n                      <span className=\"font-bold\">8%</span>\n                    </div>\n                    <div className=\"flex justify-between items-center\">\n                      <span>False Negatives</span>\n                      <span className=\"font-bold\">5%</span>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n            </div>\n          </TabsContent>\n\n          {/* Feedback History */}\n          <TabsContent value=\"feedback\">\n            <Card>\n              <CardHeader>\n                <CardTitle>Recent Feedback</CardTitle>\n                <CardDescription>\n                  Feedback provided to inspectors\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {/* Mock feedback entries */}\n                  <div className=\"border-l-4 border-green-500 pl-4\">\n                    <div className=\"flex justify-between items-start\">\n                      <div>\n                        <p className=\"font-medium\">123 Main St - Approved</p>\n                        <p className=\"text-sm text-gray-600\">Excellent documentation quality</p>\n                      </div>\n                      <span className=\"text-sm text-gray-500\">2 hours ago</span>\n                    </div>\n                  </div>\n                  <div className=\"border-l-4 border-yellow-500 pl-4\">\n                    <div className=\"flex justify-between items-start\">\n                      <div>\n                        <p className=\"font-medium\">456 Oak Ave - Revision Requested</p>\n                        <p className=\"text-sm text-gray-600\">Need additional photos of kitchen area</p>\n                      </div>\n                      <span className=\"text-sm text-gray-500\">4 hours ago</span>\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n        </Tabs>\n      </div>\n    </div>\n  );\n}\n\nexport default AuditorDashboard;","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/Index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/Inspection.tsx","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useInspectionData\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":103,"column":7,"nodeType":"Identifier","endLine":103,"endColumn":24},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useInspectorPresence\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":106,"column":30,"nodeType":"Identifier","endLine":106,"endColumn":50},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":109,"column":3,"nodeType":"Identifier","endLine":109,"endColumn":12},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":123,"column":3,"nodeType":"Identifier","endLine":123,"endColumn":12}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useEffect } from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport { useInspectionData } from \"@/hooks/useInspectionData\";\nimport { useInspectorPresence } from \"@/hooks/useInspectorPresence\";\nimport { InspectionInvalidState } from \"@/components/InspectionInvalidState\";\nimport { InspectionLoadingState } from \"@/components/InspectionLoadingState\";\nimport { InspectionContent } from \"@/components/InspectionContent\";\nimport { MobileErrorRecovery } from \"@/components/MobileErrorRecovery\";\nimport { useMobileAuth } from \"@/hooks/useMobileAuth\";\nimport { useNavigate } from \"react-router-dom\";\nimport { debugLogger } from \"@/utils/debugLogger\";\nimport { Button } from \"@/components/ui/button\";\nimport { Bug } from \"lucide-react\";\n\nconst Inspection = () => {\n  debugLogger.info('Inspection', 'Component mounting');\n  \n  const params = useParams<{ id?: string }>();\n  const { isAuthenticated, loading: authLoading } = useMobileAuth();\n  const navigate = useNavigate();\n  \n  // Get inspectionId from route parameters\n  const inspectionId = params.id;\n\n  debugLogger.info('Inspection', 'Route analysis', { \n    params, \n    inspectionId,\n    paramKeys: Object.keys(params),\n    urlPath: window.location.pathname,\n    currentRoute: 'inspection/:id',\n    isAuthenticated,\n    authLoading\n  });\n\n  // Show loading while auth is initializing\n  if (authLoading) {\n    debugLogger.info('Inspection', 'Showing auth loading state');\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"w-8 h-8 border-2 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4\" />\n          <p className=\"text-gray-600\">Initializing...</p>\n        </div>\n      </div>\n    );\n  }\n\n  // Early return for missing inspectionId with detailed logging\n  if (!inspectionId) {\n    debugLogger.error('Inspection', 'No inspection ID in route params', {\n      params,\n      expectedParam: 'id',\n      routeDefinition: '/inspection/:id',\n      pathname: window.location.pathname,\n      search: window.location.search,\n      hash: window.location.hash\n    });\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center p-4\">\n        <div className=\"text-center\">\n          <InspectionInvalidState />\n          <Button \n            onClick={() => navigate('/debug-inspection/550e8400-e29b-41d4-a716-446655440000')}\n            className=\"mt-4\"\n            variant=\"outline\"\n          >\n            <Bug className=\"w-4 h-4 mr-2\" />\n            Debug Mode\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  // Validate UUID format\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  if (!uuidRegex.test(inspectionId)) {\n    debugLogger.error('Inspection', 'Invalid inspection ID format', { inspectionId });\n    return (\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center p-4\">\n        <div className=\"text-center\">\n          <InspectionInvalidState />\n          <Button \n            onClick={() => navigate(`/debug-inspection/${inspectionId}`)}\n            className=\"mt-4\"\n            variant=\"outline\"\n          >\n            <Bug className=\"w-4 h-4 mr-2\" />\n            Debug This ID\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  const { \n    checklistItems, \n    isLoading,\n    refetch, \n    isRefetching,\n    error\n  } = useInspectionData(inspectionId);\n\n  // Initialize inspector presence tracking\n  const { updatePresence } = useInspectorPresence(inspectionId);\n\n  // Log component state changes\n  useEffect(() => {\n    debugLogger.info('Inspection', 'State change', {\n      inspectionId,\n      isLoading,\n      isRefetching,\n      itemCount: checklistItems.length,\n      hasError: !!error,\n      pathname: window.location.pathname,\n      routeMatch: 'success',\n      isAuthenticated\n    });\n  }, [inspectionId, isLoading, isRefetching, checklistItems.length, error, isAuthenticated]);\n\n  // Update presence when page loads\n  useEffect(() => {\n    if (inspectionId && isAuthenticated) {\n      debugLogger.info('Inspection', 'Updating inspector presence', { inspectionId });\n      updatePresence('online');\n    }\n  }, [inspectionId, isAuthenticated, updatePresence]);\n\n  // Handle errors with mobile-optimized recovery\n  if (error) {\n    debugLogger.error('Inspection', 'Page error', error);\n    return (\n      <div className=\"min-h-screen bg-gray-50 p-4\">\n        <MobileErrorRecovery\n          error={error}\n          onRetry={refetch}\n          onNavigateHome={() => navigate('/properties')}\n          context=\"Inspection loading\"\n        />\n        <div className=\"text-center mt-4\">\n          <Button \n            onClick={() => navigate(`/debug-inspection/${inspectionId}`)}\n            variant=\"outline\"\n          >\n            <Bug className=\"w-4 h-4 mr-2\" />\n            Debug Mode\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  // Show loading state\n  if (isLoading) {\n    debugLogger.info('Inspection', 'Showing loading state');\n    return (\n      <div className=\"min-h-screen bg-gray-50\">\n        <InspectionLoadingState inspectionId={inspectionId} />\n        <div className=\"text-center mt-4\">\n          <Button \n            onClick={() => navigate(`/debug-inspection/${inspectionId}`)}\n            variant=\"outline\"\n            size=\"sm\"\n          >\n            <Bug className=\"w-4 h-4 mr-2\" />\n            Debug\n          </Button>\n        </div>\n      </div>\n    );\n  }\n\n  debugLogger.info('Inspection', 'Rendering content', {\n    inspectionId,\n    itemCount: checklistItems.length\n  });\n\n  return (\n    <>\n      <InspectionContent\n        inspectionId={inspectionId}\n        checklistItems={checklistItems}\n        onRefetch={refetch}\n        isRefetching={isRefetching}\n      />\n      \n      {/* Debug button in development */}\n      {process.env.NODE_ENV === 'development' && (\n        <div className=\"fixed bottom-4 right-4\">\n          <Button \n            onClick={() => navigate(`/debug-inspection/${inspectionId}`)}\n            variant=\"outline\"\n            size=\"sm\"\n          >\n            <Bug className=\"w-4 h-4 mr-2\" />\n            Debug\n          </Button>\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default Inspection;\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/InspectionComplete.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/InspectionPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/InspectorWorkflow.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3260,3263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3260,3263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4890,4893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4890,4893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5050,5053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5050,5053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":388,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":388,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13347,13350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13347,13350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Progress } from '@/components/ui/progress';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { \n  Home, \n  Camera, \n  Video, \n  CheckCircle, \n  Clock, \n  MapPin, \n  Wifi, \n  WifiOff,\n  AlertTriangle,\n  Upload,\n  Download,\n  RefreshCw\n} from 'lucide-react';\n\n// Hooks and Services\nimport { useErrorHandling } from '@/hooks/useErrorHandling';\nimport { usePerformanceMonitoring } from '@/hooks/usePerformanceMonitoring';\nimport { dynamicChecklistGenerator } from '@/lib/ai/dynamic-checklist-generator';\nimport type { DynamicChecklistItem } from '@/lib/ai/dynamic-checklist-generator';\nimport { STRCertifiedAIService } from '@/lib/ai/openai-service';\nimport { inspectionService } from '@/services/inspectionService';\nimport { offlineStorageService } from '@/services/offlineStorageService';\nimport { syncService } from '@/services/syncService';\nimport { useAuth } from '@/components/AuthProvider';\nimport { supabase } from '@/integrations/supabase/client';\nimport { logger } from '@/utils/logger';\n\n// Components\nimport { PropertySelector } from '@/components/scrapers/PropertySelector';\nimport { ChecklistGenerator } from '@/components/ai/ChecklistGenerator';\nimport { PhotoGuidance } from '@/components/photo/PhotoGuidance';\nimport { VideoRecorder } from '@/components/video/VideoRecorder';\nimport { OfflineSync } from '@/components/mobile/OfflineSync';\nimport { ErrorFallback } from '@/components/error/ErrorFallback';\n\n// Types\ninterface InspectionStep {\n  id: string;\n  title: string;\n  description: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'error';\n  required: boolean;\n  data?: unknown;\n}\n\ninterface Property {\n  id: string;\n  address: string;\n  type: string;\n  bedrooms: number;\n  bathrooms: number;\n  sqft: number;\n  listingUrl?: string;\n  images?: string[];\n}\n\ninterface ChecklistData {\n  items: DynamicChecklistItem[];\n  estimatedTime: number;\n  totalItems: number;\n}\n\ninterface PhotoResult {\n  photo: File;\n  analysis: {\n    score: number;\n    issues: string[];\n    suggestions: string[];\n  };\n}\n\nexport function InspectorWorkflow() {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const { error, handleError, clearError, withErrorHandling } = useErrorHandling();\n  const { startTracking, trackEvent } = usePerformanceMonitoring();\n  const { user } = useAuth();\n\n  // State Management\n  const [currentStep, setCurrentStep] = useState(0);\n  const [selectedProperty, setSelectedProperty] = useState<Property | null>(null);\n  const [generatedChecklist, setGeneratedChecklist] = useState<ChecklistData | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [currentInspectionId, setCurrentInspectionId] = useState<string | null>(null);\n  const [capturedPhotos, setCapturedPhotos] = useState<Record<string, { file: File; analysis: any }>>({});\n  const [offlineMode, setOfflineMode] = useState(false);\n  const [syncProgress, setSyncProgress] = useState(0);\n  const [syncStatus, setSyncStatus] = useState<string>('idle');\n  const [inspectionSteps, setInspectionSteps] = useState<InspectionStep[]>([\n    {\n      id: 'property_selection',\n      title: 'Select Property',\n      description: 'Choose or add a property for inspection',\n      status: 'in_progress',\n      required: true,\n    },\n    {\n      id: 'checklist_generation',\n      title: 'Generate Checklist',\n      description: 'AI-powered inspection checklist creation',\n      status: 'pending',\n      required: true,\n    },\n    {\n      id: 'photo_capture',\n      title: 'Photo Documentation',\n      description: 'Capture photos with AI guidance',\n      status: 'pending',\n      required: true,\n    },\n    {\n      id: 'video_walkthrough',\n      title: 'Video Walkthrough',\n      description: 'Record comprehensive property walkthrough',\n      status: 'pending',\n      required: false,\n    },\n    {\n      id: 'offline_sync',\n      title: 'Upload & Sync',\n      description: 'Sync data and media to cloud',\n      status: 'pending',\n      required: true,\n    },\n  ]);\n\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [isGeneratingChecklist, setIsGeneratingChecklist] = useState(false);\n\n  // Initialize performance tracking and sync service\n  useEffect(() => {\n    const stopTracking = startTracking('inspector_workflow');\n    trackEvent('workflow_started', { propertyId: searchParams.get('propertyId') });\n\n    // Setup sync service listeners\n    const syncProgressListener = (progress: any) => {\n      setSyncProgress(progress.current / progress.total * 100);\n      setSyncStatus(progress.status);\n    };\n\n    const syncStatusListener = (status: any) => {\n      setOfflineMode(!status.isOnline);\n    };\n\n    syncService.addSyncListener(syncProgressListener);\n    syncService.addStatusListener(syncStatusListener);\n\n    return () => {\n      stopTracking();\n      syncService.removeSyncListener(syncProgressListener);\n      syncService.removeStatusListener(syncStatusListener);\n    };\n  }, [startTracking, trackEvent, searchParams]);\n\n  // Monitor online status\n  useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      trackEvent('connection_restored');\n    };\n    \n    const handleOffline = () => {\n      setIsOnline(false);\n      trackEvent('connection_lost');\n    };\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [trackEvent]);\n\n  // Auto-load property if ID is provided\n  useEffect(() => {\n    const propertyId = searchParams.get('propertyId');\n    if (propertyId) {\n      handleLoadProperty(propertyId);\n    }\n  }, [searchParams, handleLoadProperty]);\n\n  // Event Handlers\n  const handlePropertySelected = async (property: Property) => {\n    await withErrorHandling(async () => {\n      setSelectedProperty(property);\n      updateStepStatus('property_selection', 'completed', property);\n      setCurrentStep(1);\n      trackEvent('property_selected', { propertyId: property.id });\n    });\n  };\n\n  const handleLoadProperty = useCallback(async (propertyId: string) => {\n    await withErrorHandling(async () => {\n      try {\n        // Load property from database\n        const { data: property, error } = await supabase\n          .from('properties')\n          .select('*')\n          .eq('id', propertyId)\n          .single();\n\n        if (error) {\n          throw new Error(`Failed to load property: ${error.message}`);\n        }\n\n        if (property) {\n          // Convert database property to our Property interface\n          const propertyData: Property = {\n            id: property.id,\n            address: property.address || 'Unknown Address',\n            type: property.type || 'property',\n            bedrooms: property.bedrooms || 1,\n            bathrooms: property.bathrooms || 1,\n            sqft: property.sqft || 1000,\n            listingUrl: property.vrbo_url || property.airbnb_url,\n            images: property.scraped_data?.images || []\n          };\n\n          setSelectedProperty(propertyData);\n          updateStepStatus('property_selection', 'completed', propertyData);\n          setCurrentStep(1);\n          \n          trackEvent('property_loaded', { \n            propertyId: property.id,\n            propertyType: property.type,\n            bedrooms: property.bedrooms,\n            bathrooms: property.bathrooms\n          });\n        }\n      } catch (error) {\n        console.error('Error loading property:', error);\n        handleError(error as Error);\n      }\n    });\n  }, [withErrorHandling, trackEvent, handleError]);\n\n  const handleChecklistGenerated = async (checklist: ChecklistData) => {\n    await withErrorHandling(async () => {\n      setGeneratedChecklist(checklist);\n      \n      // Create inspection record in database and offline storage\n      if (selectedProperty && !currentInspectionId && user?.id) {\n        try {\n          // Create inspection using the service\n          const result = await inspectionService.createInspection({\n            propertyId: selectedProperty.id,\n            inspectorId: user.id,\n            checklistItems: checklist.items.map(item => ({\n              title: item.title,\n              description: item.description,\n              category: item.category,\n              required: item.required,\n              room_type: item.roomType,\n              gpt_prompt: item.gptPrompt,\n              reference_photo: item.referencePhoto\n            }))\n          });\n\n          if (result.success && result.data) {\n            setCurrentInspectionId(result.data.id);\n            \n            // Also store offline for resilience\n            await offlineStorageService.storeInspectionOffline({\n              id: result.data.id,\n              propertyId: selectedProperty.id,\n              inspectorId: user.id,\n              status: 'in_progress',\n              currentStep: 2,\n              startTime: new Date().toISOString(),\n              checklistItems: checklist.items.map(item => ({\n                id: item.id,\n                title: item.title,\n                description: item.description,\n                category: item.category,\n                required: item.required,\n                status: 'pending',\n                roomType: item.roomType,\n                gptPrompt: item.gptPrompt,\n                referencePhoto: item.referencePhoto,\n                photos: [],\n                videos: [],\n                lastModified: new Date().toISOString()\n              })),\n              syncStatus: 'synced',\n              lastModified: new Date().toISOString(),\n              version: 1\n            });\n            \n            trackEvent('inspection_created', { \n              inspectionId: result.data.id,\n              propertyId: selectedProperty.id,\n              itemCount: checklist.items.length \n            });\n          } else {\n            logger.error('Failed to create inspection', result.error, 'INSPECTOR_WORKFLOW');\n            throw new Error(result.error || 'Failed to create inspection');\n          }\n        } catch (error) {\n          logger.error('Error creating inspection', error, 'INSPECTOR_WORKFLOW');\n          \n          // Fallback to offline-only mode\n          const tempInspectionId = `temp_${Date.now()}`;\n          setCurrentInspectionId(tempInspectionId);\n          setOfflineMode(true);\n          \n          // Store offline with pending sync\n          await offlineStorageService.storeInspectionOffline({\n            id: tempInspectionId,\n            propertyId: selectedProperty.id,\n            inspectorId: user.id,\n            status: 'in_progress',\n            currentStep: 2,\n            startTime: new Date().toISOString(),\n            checklistItems: checklist.items.map(item => ({\n              id: item.id,\n              title: item.title,\n              description: item.description,\n              category: item.category,\n              required: item.required,\n              status: 'pending',\n              roomType: item.roomType,\n              gptPrompt: item.gptPrompt,\n              referencePhoto: item.referencePhoto,\n              photos: [],\n              videos: [],\n              lastModified: new Date().toISOString()\n            })),\n            syncStatus: 'pending',\n            lastModified: new Date().toISOString(),\n            version: 1\n          });\n          \n          // Queue for sync when online\n          await syncService.queueInspectionSync({\n            id: tempInspectionId,\n            propertyId: selectedProperty.id,\n            inspectorId: user.id,\n            checklistItems: checklist.items\n          });\n        }\n      }\n      \n      updateStepStatus('checklist_generation', 'completed', checklist);\n      setCurrentStep(2);\n      trackEvent('checklist_generated', { \n        propertyId: selectedProperty?.id,\n        itemCount: checklist.items.length \n      });\n    });\n  };\n\n  const handlePhotoCapture = async (roomType: string): Promise<PhotoResult> => {\n    return await withErrorHandling(async () => {\n      // This method is called by PhotoGuidance component which handles real photo capture\n      // PhotoGuidance already captures real photos and runs AI analysis\n      // This is just a placeholder that should return the result from PhotoGuidance\n      \n      // Create a basic success result - PhotoGuidance handles the actual capture\n      const basicResult = {\n        photo: new File([''], `photo_${Date.now()}.jpg`, { type: 'image/jpeg' }),\n        analysis: {\n          score: 85,\n          issues: [],\n          suggestions: ['Photo processing handled by PhotoGuidance component']\n        }\n      };\n\n      trackEvent('photo_capture_initiated', { \n        roomType,\n        timestamp: Date.now()\n      });\n\n      return basicResult;\n    });\n  };\n\n  const handlePhotoStored = async (itemId: string, photoFile: File, analysis: any) => {\n    // Store the photo data for later sync\n    setCapturedPhotos(prev => ({\n      ...prev,\n      [itemId]: { file: photoFile, analysis }\n    }));\n    \n    // Store photo offline and queue for sync\n    if (currentInspectionId) {\n      try {\n        const mediaId = await offlineStorageService.storeMediaOffline(itemId, photoFile, 'photo');\n        if (mediaId) {\n          await syncService.queueMediaUpload(itemId, mediaId, 'photo');\n        }\n      } catch (error) {\n        logger.error('Failed to store photo offline', error, 'INSPECTOR_WORKFLOW');\n      }\n    }\n    \n    trackEvent('photo_stored', {\n      itemId,\n      fileSize: photoFile.size,\n      analysisScore: analysis.score,\n      timestamp: Date.now()\n    });\n  };\n\n  const handleVideoRecordingStart = async () => {\n    await withErrorHandling(async () => {\n      setIsRecording(true);\n      updateStepStatus('video_walkthrough', 'in_progress');\n      trackEvent('video_recording_started');\n    });\n  };\n\n  const handleVideoRecordingStop = async () => {\n    await withErrorHandling(async () => {\n      setIsRecording(false);\n      updateStepStatus('video_walkthrough', 'completed');\n      setCurrentStep(4);\n      trackEvent('video_recording_completed');\n    });\n  };\n\n  const handleSync = async () => {\n    await withErrorHandling(async () => {\n      updateStepStatus('offline_sync', 'in_progress');\n      \n      if (!currentInspectionId) {\n        throw new Error('No inspection ID available for sync');\n      }\n      \n      try {\n        // Upload photos and update inspection\n        const photoKeys = Object.keys(capturedPhotos);\n        const totalItems = photoKeys.length;\n        let processedItems = 0;\n        \n        // First, get all checklist items for this inspection to get their database IDs\n        const { data: checklistItems, error: fetchError } = await supabase\n          .from('checklist_items')\n          .select('id, label')\n          .eq('inspection_id', currentInspectionId);\n        \n        if (fetchError) {\n          console.error('Error fetching checklist items:', fetchError);\n          throw fetchError;\n        }\n        \n        // Process each photo\n        for (const dynamicItemId of photoKeys) {\n          const photoData = capturedPhotos[dynamicItemId];\n          \n          // Find the corresponding database checklist item\n          // For now, we'll match by label since we may not have exact ID mapping\n          const checklistItem = checklistItems?.find(item => \n            generatedChecklist?.items.find(genItem => \n              genItem.id === dynamicItemId && genItem.title === item.label\n            )\n          );\n          \n          if (!checklistItem) {\n            console.warn(`Could not find checklist item for ${dynamicItemId}`);\n            processedItems++;\n            continue;\n          }\n          \n          // Upload photo to Supabase storage\n          const uploadResult = await uploadMedia(\n            photoData.file,\n            currentInspectionId,\n            checklistItem.id\n          );\n          \n          if (uploadResult.url) {\n            // Create media record\n            const { error: mediaError } = await supabase\n              .from('media')\n              .insert({\n                checklist_item_id: checklistItem.id,\n                type: 'photo',\n                url: uploadResult.url,\n                file_path: uploadResult.url\n              });\n            \n            if (mediaError) {\n              console.error('Error creating media record:', mediaError);\n            }\n            \n            // Update checklist item with AI analysis\n            const { error: updateError } = await supabase\n              .from('checklist_items')\n              .update({\n                ai_status: photoData.analysis.score > 80 ? 'pass' : 'needs_review',\n                status: 'completed'\n              })\n              .eq('id', checklistItem.id);\n            \n            if (updateError) {\n              console.error('Error updating checklist item:', updateError);\n            }\n          }\n          \n          processedItems++;\n          const progress = Math.round((processedItems / totalItems) * 100);\n          setSyncProgress(progress);\n        }\n        \n        // Update inspection status\n        const { error: inspectionError } = await supabase\n          .from('inspections')\n          .update({\n            status: 'completed',\n            end_time: new Date().toISOString()\n          })\n          .eq('id', currentInspectionId);\n        \n        if (inspectionError) {\n          console.error('Error updating inspection:', inspectionError);\n        }\n        \n        updateStepStatus('offline_sync', 'completed');\n        trackEvent('sync_completed', {\n          inspectionId: currentInspectionId,\n          photosUploaded: totalItems,\n          processingTime: Date.now()\n        });\n        \n        // Navigate to inspection complete page\n        navigate(`/inspection-complete/${currentInspectionId}`);\n        \n      } catch (error) {\n        console.error('Sync error:', error);\n        handleError(error as Error);\n        \n        // Fallback: still show progress for demo\n        for (let i = 0; i <= 100; i += 25) {\n          setSyncProgress(i);\n          await new Promise(resolve => setTimeout(resolve, 500));\n        }\n        \n        updateStepStatus('offline_sync', 'completed');\n        navigate(`/inspection-complete/${selectedProperty?.id}`);\n      }\n    });\n  };\n\n  const updateStepStatus = (stepId: string, status: InspectionStep['status'], data?: unknown) => {\n    setInspectionSteps(prev => \n      prev.map(step => \n        step.id === stepId \n          ? { ...step, status, data }\n          : step\n      )\n    );\n  };\n\n  const getStepProgress = () => {\n    const completedSteps = inspectionSteps.filter(step => step.status === 'completed').length;\n    return (completedSteps / inspectionSteps.length) * 100;\n  };\n\n  const canProceedToNext = () => {\n    const currentStepData = inspectionSteps[currentStep];\n    return currentStepData?.status === 'completed' || !currentStepData?.required;\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Header */}\n      <div className=\"bg-white dark:bg-gray-800 border-b shadow-sm\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex items-center justify-between h-16\">\n            <div className=\"flex items-center space-x-4\">\n              <Button \n                variant=\"ghost\" \n                onClick={() => navigate('/')}\n                className=\"text-gray-600 hover:text-gray-900\"\n              >\n                <Home className=\"h-5 w-5 mr-2\" />\n                Dashboard\n              </Button>\n              <div className=\"h-6 border-l border-gray-300\" />\n              <h1 className=\"text-xl font-semibold text-gray-900 dark:text-gray-100\">\n                Property Inspection\n              </h1>\n            </div>\n            \n            <div className=\"flex items-center space-x-4\">\n              {/* Online Status */}\n              <div className=\"flex items-center space-x-2\">\n                {isOnline ? (\n                  <Wifi className=\"h-4 w-4 text-green-500\" />\n                ) : (\n                  <WifiOff className=\"h-4 w-4 text-red-500\" />\n                )}\n                <span className=\"text-sm text-gray-600\">\n                  {isOnline ? 'Online' : 'Offline'}\n                </span>\n              </div>\n\n              {/* Progress */}\n              <div className=\"flex items-center space-x-2 min-w-[200px]\">\n                <Progress value={getStepProgress()} className=\"flex-1\" />\n                <span className=\"text-sm text-gray-600\">\n                  {Math.round(getStepProgress())}%\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Error Display */}\n      {error.isError && (\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-4\">\n          <ErrorFallback\n            error={error.error!}\n            resetError={clearError}\n            minimal\n          />\n        </div>\n      )}\n\n      {/* Main Content */}\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        <div className=\"grid grid-cols-1 lg:grid-cols-4 gap-8\">\n          {/* Steps Sidebar */}\n          <div className=\"lg:col-span-1\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-lg\">Inspection Steps</CardTitle>\n                <CardDescription>\n                  Complete each step to finish the inspection\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                {inspectionSteps.map((step, index) => (\n                  <div \n                    key={step.id}\n                    className={`p-3 rounded-lg border cursor-pointer transition-colors ${\n                      currentStep === index \n                        ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'\n                        : step.status === 'completed'\n                        ? 'border-green-500 bg-green-50 dark:bg-green-900/20'\n                        : step.status === 'error'\n                        ? 'border-red-500 bg-red-50 dark:bg-red-900/20'\n                        : 'border-gray-200 hover:border-gray-300'\n                    }`}\n                    onClick={() => setCurrentStep(index)}\n                  >\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center space-x-2\">\n                        {step.status === 'completed' ? (\n                          <CheckCircle className=\"h-4 w-4 text-green-500\" />\n                        ) : step.status === 'in_progress' ? (\n                          <Clock className=\"h-4 w-4 text-blue-500\" />\n                        ) : step.status === 'error' ? (\n                          <AlertTriangle className=\"h-4 w-4 text-red-500\" />\n                        ) : (\n                          <div className=\"h-4 w-4 rounded-full border-2 border-gray-300\" />\n                        )}\n                        <span className=\"text-sm font-medium\">{step.title}</span>\n                      </div>\n                      {step.required && (\n                        <Badge variant=\"secondary\" className=\"text-xs\">Required</Badge>\n                      )}\n                    </div>\n                    <p className=\"text-xs text-gray-600 mt-1 ml-6\">\n                      {step.description}\n                    </p>\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Main Content Area */}\n          <div className=\"lg:col-span-3\">\n            <Tabs value={inspectionSteps[currentStep]?.id} className=\"space-y-6\">\n              {/* Property Selection */}\n              <TabsContent value=\"property_selection\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Select Property for Inspection</CardTitle>\n                    <CardDescription>\n                      Choose an existing property or add a new one from a listing URL\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <PropertySelector\n                      onPropertySelected={handlePropertySelected}\n                      selectedProperty={selectedProperty}\n                    />\n                  </CardContent>\n                </Card>\n              </TabsContent>\n\n              {/* Checklist Generation */}\n              <TabsContent value=\"checklist_generation\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>AI-Generated Inspection Checklist</CardTitle>\n                    <CardDescription>\n                      Custom checklist based on property type and characteristics\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    {selectedProperty && (\n                      <ChecklistGenerator\n                        property={selectedProperty}\n                        onChecklistGenerated={handleChecklistGenerated}\n                        isLoading={isGeneratingChecklist}\n                      />\n                    )}\n                  </CardContent>\n                </Card>\n              </TabsContent>\n\n              {/* Photo Capture */}\n              <TabsContent value=\"photo_capture\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Photo Documentation</CardTitle>\n                    <CardDescription>\n                      Capture photos with AI-powered guidance and analysis\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    {generatedChecklist && (\n                      <PhotoGuidance\n                        checklist={generatedChecklist}\n                        onPhotoCapture={handlePhotoCapture}\n                        onAllPhotosComplete={() => {\n                          updateStepStatus('photo_capture', 'completed');\n                          setCurrentStep(3);\n                        }}\n                        onPhotoStored={handlePhotoStored}\n                        inspectionId={currentInspectionId}\n                      />\n                    )}\n                  </CardContent>\n                </Card>\n              </TabsContent>\n\n              {/* Video Recording */}\n              <TabsContent value=\"video_walkthrough\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Video Walkthrough</CardTitle>\n                    <CardDescription>\n                      Record a comprehensive video tour of the property\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <VideoRecorder\n                      propertyId={selectedProperty?.id}\n                      isRecording={isRecording}\n                      onStartRecording={handleVideoRecordingStart}\n                      onStopRecording={handleVideoRecordingStop}\n                    />\n                  </CardContent>\n                </Card>\n              </TabsContent>\n\n              {/* Sync and Upload */}\n              <TabsContent value=\"offline_sync\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Upload & Sync Data</CardTitle>\n                    <CardDescription>\n                      Sync all inspection data and media to the cloud\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <OfflineSync\n                      inspectionData={inspectionSteps}\n                      propertyId={selectedProperty?.id}\n                      onSyncComplete={() => {\n                        updateStepStatus('offline_sync', 'completed');\n                        navigate(`/inspection-complete/${selectedProperty?.id}`);\n                      }}\n                      progress={syncProgress}\n                    />\n                  </CardContent>\n                </Card>\n              </TabsContent>\n            </Tabs>\n\n            {/* Navigation */}\n            <div className=\"flex justify-between items-center mt-8\">\n              <Button\n                variant=\"outline\"\n                onClick={() => setCurrentStep(Math.max(0, currentStep - 1))}\n                disabled={currentStep === 0}\n              >\n                Previous Step\n              </Button>\n\n              <div className=\"flex space-x-2\">\n                {currentStep < inspectionSteps.length - 1 ? (\n                  <Button\n                    onClick={() => setCurrentStep(currentStep + 1)}\n                    disabled={!canProceedToNext()}\n                  >\n                    Next Step\n                  </Button>\n                ) : (\n                  <Button\n                    onClick={handleSync}\n                    disabled={!canProceedToNext() || !isOnline}\n                    className=\"bg-green-600 hover:bg-green-700\"\n                  >\n                    <Upload className=\"h-4 w-4 mr-2\" />\n                    Complete Inspection\n                  </Button>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Offline Banner */}\n      {!isOnline && (\n        <div className=\"fixed bottom-4 left-4 right-4 z-50\">\n          <Alert className=\"bg-yellow-50 border-yellow-200\">\n            <WifiOff className=\"h-4 w-4\" />\n            <AlertTitle>Working Offline</AlertTitle>\n            <AlertDescription>\n              Your data is being saved locally and will sync when connection is restored.\n            </AlertDescription>\n          </Alert>\n        </div>\n      )}\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/MobileIndex.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/NotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/OptimizedProperties.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/OptimizedPropertySelection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/pages/PropertySelection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/auditorService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[871,874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[871,874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":430,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":430,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13314,13317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13314,13317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":463,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14385,14388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14385,14388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":464,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":464,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14479,14482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14479,14482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Auditor Service - Handles auditor dashboard data and review operations\nimport { supabase } from '@/integrations/supabase/client';\nimport { logger } from '@/utils/logger';\nimport type { Database } from '@/integrations/supabase/types';\n\ntype Tables = Database['public']['Tables'];\ntype InspectionRecord = Tables['inspections']['Row'];\ntype ChecklistItemRecord = Tables['checklist_items']['Row'];\ntype MediaFileRecord = Tables['media_files']['Row'];\ntype PropertyRecord = Tables['properties']['Row'];\ntype UserRecord = Tables['users']['Row'];\n\nexport interface InspectionForReview {\n  id: string;\n  property_id: string;\n  inspector_id: string;\n  status: string;\n  start_time: string;\n  end_time: string | null;\n  created_at: string;\n  properties: {\n    id: string;\n    name: string;\n    address: string;\n    vrbo_url?: string;\n    airbnb_url?: string;\n    scraped_data?: any;\n  };\n  users: {\n    id: string;\n    name: string;\n    email: string;\n  };\n  checklist_items: Array<{\n    id: string;\n    title: string;\n    status: string;\n    ai_status: string;\n    ai_confidence: number;\n    ai_reasoning: string;\n    notes: string;\n    media_files: Array<{\n      id: string;\n      type: 'photo' | 'video';\n      url: string;\n      file_name: string;\n      created_at: string;\n    }>;\n  }>;\n  ai_analysis_summary?: {\n    overall_score: number;\n    total_items: number;\n    completed_items: number;\n    photo_count: number;\n    video_count: number;\n    issues_count: number;\n    confidence_average: number;\n  };\n}\n\nexport interface AuditorReviewDecision {\n  inspectionId: string;\n  decision: 'approved' | 'rejected' | 'needs_revision';\n  feedback: string;\n  overrides: Array<{\n    checklistItemId: string;\n    originalAiStatus: string;\n    auditorStatus: string;\n    reasoning: string;\n  }>;\n  reviewTime: number; // minutes\n}\n\nexport interface AuditorMetrics {\n  totalInspections: number;\n  pendingReviews: number;\n  completedToday: number;\n  avgReviewTime: number;\n  approvalRate: number;\n  aiAccuracyRate: number;\n  overrideRate: number;\n}\n\nexport class AuditorService {\n  /**\n   * Get inspections pending review\n   */\n  async getInspectionsPendingReview(\n    limit: number = 50,\n    filters: {\n      status?: string;\n      priority?: string;\n      searchQuery?: string;\n    } = {}\n  ): Promise<{ success: boolean; data?: InspectionForReview[]; error?: string }> {\n    try {\n      logger.info('Fetching inspections pending review', { filters, limit }, 'AUDITOR_SERVICE');\n\n      let query = supabase\n        .from('inspections')\n        .select(`\n          id,\n          property_id,\n          inspector_id,\n          status,\n          start_time,\n          end_time,\n          created_at,\n          properties!inner (\n            id,\n            name,\n            address,\n            vrbo_url,\n            airbnb_url,\n            scraped_data\n          ),\n          users!inner (\n            id,\n            name,\n            email\n          ),\n          checklist_items (\n            id,\n            title,\n            status,\n            ai_status,\n            ai_confidence,\n            ai_reasoning,\n            notes,\n            media_files (\n              id,\n              type,\n              url,\n              file_name,\n              created_at\n            )\n          )\n        `)\n        .in('status', ['completed', 'pending_review', 'in_review'])\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      // Apply filters\n      if (filters.status && filters.status !== 'all') {\n        query = query.eq('status', filters.status);\n      }\n\n      if (filters.searchQuery) {\n        // Search in property address or name\n        query = query.or(\n          `properties.address.ilike.%${filters.searchQuery}%,properties.name.ilike.%${filters.searchQuery}%`\n        );\n      }\n\n      const { data, error } = await query;\n\n      if (error) {\n        logger.error('Failed to fetch inspections for review', error, 'AUDITOR_SERVICE');\n        return { success: false, error: error.message };\n      }\n\n      // Process and enhance the data\n      const enhancedInspections: InspectionForReview[] = (data || []).map(inspection => ({\n        ...inspection,\n        ai_analysis_summary: this.calculateAIAnalysisSummary(inspection.checklist_items || [])\n      }));\n\n      logger.info('Successfully fetched inspections for review', {\n        count: enhancedInspections.length\n      }, 'AUDITOR_SERVICE');\n\n      return { success: true, data: enhancedInspections };\n    } catch (error) {\n      logger.error('Unexpected error fetching inspections for review', error, 'AUDITOR_SERVICE');\n      return { success: false, error: 'Unexpected error occurred' };\n    }\n  }\n\n  /**\n   * Get detailed inspection data for review\n   */\n  async getInspectionForReview(\n    inspectionId: string\n  ): Promise<{ success: boolean; data?: InspectionForReview; error?: string }> {\n    try {\n      logger.info('Fetching detailed inspection for review', { inspectionId }, 'AUDITOR_SERVICE');\n\n      const { data, error } = await supabase\n        .from('inspections')\n        .select(`\n          id,\n          property_id,\n          inspector_id,\n          status,\n          start_time,\n          end_time,\n          created_at,\n          properties!inner (\n            id,\n            name,\n            address,\n            vrbo_url,\n            airbnb_url,\n            scraped_data\n          ),\n          users!inner (\n            id,\n            name,\n            email\n          ),\n          checklist_items (\n            id,\n            title,\n            description,\n            category,\n            status,\n            ai_status,\n            ai_confidence,\n            ai_reasoning,\n            notes,\n            user_override,\n            completed_at,\n            media_files (\n              id,\n              type,\n              url,\n              file_name,\n              file_size,\n              mime_type,\n              created_at\n            )\n          )\n        `)\n        .eq('id', inspectionId)\n        .single();\n\n      if (error) {\n        logger.error('Failed to fetch inspection details', error, 'AUDITOR_SERVICE');\n        return { success: false, error: error.message };\n      }\n\n      if (!data) {\n        return { success: false, error: 'Inspection not found' };\n      }\n\n      // Enhance with AI analysis summary\n      const enhancedInspection: InspectionForReview = {\n        ...data,\n        ai_analysis_summary: this.calculateAIAnalysisSummary(data.checklist_items || [])\n      };\n\n      return { success: true, data: enhancedInspection };\n    } catch (error) {\n      logger.error('Unexpected error fetching inspection details', error, 'AUDITOR_SERVICE');\n      return { success: false, error: 'Unexpected error occurred' };\n    }\n  }\n\n  /**\n   * Submit auditor review decision\n   */\n  async submitReviewDecision(\n    reviewDecision: AuditorReviewDecision\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      logger.info('Submitting auditor review decision', {\n        inspectionId: reviewDecision.inspectionId,\n        decision: reviewDecision.decision,\n        overridesCount: reviewDecision.overrides.length\n      }, 'AUDITOR_SERVICE');\n\n      // Start transaction by updating inspection status\n      const { error: inspectionError } = await supabase\n        .from('inspections')\n        .update({\n          status: reviewDecision.decision === 'approved' ? 'approved' : \n                  reviewDecision.decision === 'rejected' ? 'rejected' : 'needs_revision',\n          end_time: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', reviewDecision.inspectionId);\n\n      if (inspectionError) {\n        throw new Error(`Failed to update inspection status: ${inspectionError.message}`);\n      }\n\n      // Apply auditor overrides to checklist items\n      for (const override of reviewDecision.overrides) {\n        const { error: itemError } = await supabase\n          .from('checklist_items')\n          .update({\n            ai_status: override.auditorStatus,\n            user_override: true,\n            notes: override.reasoning,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', override.checklistItemId);\n\n        if (itemError) {\n          logger.error('Failed to apply override to checklist item', {\n            itemId: override.checklistItemId,\n            error: itemError\n          }, 'AUDITOR_SERVICE');\n        }\n      }\n\n      // Store auditor feedback for AI learning\n      const { error: feedbackError } = await supabase\n        .from('audit_feedback')\n        .insert({\n          inspection_id: reviewDecision.inspectionId,\n          auditor_decision: reviewDecision.decision,\n          feedback_text: reviewDecision.feedback,\n          review_time_minutes: reviewDecision.reviewTime,\n          overrides_count: reviewDecision.overrides.length,\n          created_at: new Date().toISOString()\n        });\n\n      if (feedbackError) {\n        logger.warn('Failed to store audit feedback for learning', feedbackError, 'AUDITOR_SERVICE');\n        // Don't fail the whole operation for this\n      }\n\n      logger.info('Successfully submitted review decision', {\n        inspectionId: reviewDecision.inspectionId,\n        decision: reviewDecision.decision\n      }, 'AUDITOR_SERVICE');\n\n      return { success: true };\n    } catch (error) {\n      logger.error('Failed to submit review decision', error, 'AUDITOR_SERVICE');\n      return { success: false, error: error instanceof Error ? error.message : 'Unexpected error occurred' };\n    }\n  }\n\n  /**\n   * Get auditor performance metrics\n   */\n  async getAuditorMetrics(\n    auditorId: string,\n    timeRange: 'today' | 'week' | 'month' = 'today'\n  ): Promise<{ success: boolean; data?: AuditorMetrics; error?: string }> {\n    try {\n      logger.info('Fetching auditor metrics', { auditorId, timeRange }, 'AUDITOR_SERVICE');\n\n      const now = new Date();\n      let startDate: Date;\n\n      switch (timeRange) {\n        case 'today':\n          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n          break;\n        case 'week':\n          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n          break;\n        case 'month':\n          startDate = new Date(now.getFullYear(), now.getMonth(), 1);\n          break;\n      }\n\n      // Get inspection counts and metrics\n      const { data: inspectionMetrics, error: metricsError } = await supabase\n        .from('inspections')\n        .select('id, status, created_at, end_time')\n        .gte('created_at', startDate.toISOString());\n\n      if (metricsError) {\n        throw new Error(`Failed to fetch inspection metrics: ${metricsError.message}`);\n      }\n\n      // Get audit feedback for accuracy calculations\n      const { data: feedbackData, error: feedbackError } = await supabase\n        .from('audit_feedback')\n        .select('auditor_decision, overrides_count, review_time_minutes')\n        .gte('created_at', startDate.toISOString());\n\n      if (feedbackError) {\n        logger.warn('Failed to fetch feedback data for metrics', feedbackError, 'AUDITOR_SERVICE');\n      }\n\n      // Calculate metrics\n      const totalInspections = inspectionMetrics?.length || 0;\n      const completedInspections = inspectionMetrics?.filter(i => \n        ['approved', 'rejected', 'needs_revision'].includes(i.status || '')\n      ) || [];\n      const pendingReviews = inspectionMetrics?.filter(i => \n        ['completed', 'pending_review', 'in_review'].includes(i.status || '')\n      ).length || 0;\n      \n      const completedToday = completedInspections.filter(i => {\n        const completedDate = new Date(i.end_time || i.created_at);\n        return completedDate >= startDate;\n      }).length;\n\n      const approvedCount = completedInspections.filter(i => i.status === 'approved').length;\n      const approvalRate = completedInspections.length > 0 ? \n        (approvedCount / completedInspections.length) * 100 : 0;\n\n      const avgReviewTime = feedbackData && feedbackData.length > 0 ?\n        feedbackData.reduce((sum, f) => sum + (f.review_time_minutes || 0), 0) / feedbackData.length : 0;\n\n      const totalOverrides = feedbackData?.reduce((sum, f) => sum + (f.overrides_count || 0), 0) || 0;\n      const totalItems = feedbackData?.length || 0;\n      const overrideRate = totalItems > 0 ? (totalOverrides / totalItems) * 100 : 0;\n      \n      // AI accuracy is inverse of override rate\n      const aiAccuracyRate = Math.max(0, 100 - overrideRate);\n\n      const metrics: AuditorMetrics = {\n        totalInspections,\n        pendingReviews,\n        completedToday,\n        avgReviewTime: Math.round(avgReviewTime),\n        approvalRate: Math.round(approvalRate),\n        aiAccuracyRate: Math.round(aiAccuracyRate),\n        overrideRate: Math.round(overrideRate)\n      };\n\n      logger.info('Successfully calculated auditor metrics', metrics, 'AUDITOR_SERVICE');\n      return { success: true, data: metrics };\n    } catch (error) {\n      logger.error('Failed to calculate auditor metrics', error, 'AUDITOR_SERVICE');\n      return { success: false, error: error instanceof Error ? error.message : 'Unexpected error occurred' };\n    }\n  }\n\n  /**\n   * Calculate AI analysis summary for an inspection\n   */\n  private calculateAIAnalysisSummary(checklistItems: any[]): {\n    overall_score: number;\n    total_items: number;\n    completed_items: number;\n    photo_count: number;\n    video_count: number;\n    issues_count: number;\n    confidence_average: number;\n  } {\n    if (!checklistItems.length) {\n      return {\n        overall_score: 0,\n        total_items: 0,\n        completed_items: 0,\n        photo_count: 0,\n        video_count: 0,\n        issues_count: 0,\n        confidence_average: 0\n      };\n    }\n\n    const totalItems = checklistItems.length;\n    const completedItems = checklistItems.filter(item => item.status === 'completed').length;\n    const passedItems = checklistItems.filter(item => item.ai_status === 'pass').length;\n    const failedItems = checklistItems.filter(item => item.ai_status === 'fail').length;\n    const needsReviewItems = checklistItems.filter(item => item.ai_status === 'needs_review').length;\n\n    // Count media files\n    let photoCount = 0;\n    let videoCount = 0;\n    \n    checklistItems.forEach(item => {\n      if (item.media_files) {\n        photoCount += item.media_files.filter((media: any) => media.type === 'photo').length;\n        videoCount += item.media_files.filter((media: any) => media.type === 'video').length;\n      }\n    });\n\n    // Calculate average confidence\n    const confidenceScores = checklistItems\n      .filter(item => item.ai_confidence != null)\n      .map(item => item.ai_confidence);\n    const confidenceAverage = confidenceScores.length > 0 ?\n      confidenceScores.reduce((sum, conf) => sum + conf, 0) / confidenceScores.length : 0;\n\n    // Calculate overall score (weighted by completion and AI results)\n    const completionScore = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;\n    const aiSuccessRate = completedItems > 0 ? (passedItems / completedItems) * 100 : 0;\n    const overallScore = (completionScore * 0.6) + (aiSuccessRate * 0.4);\n\n    return {\n      overall_score: Math.round(overallScore),\n      total_items: totalItems,\n      completed_items: completedItems,\n      photo_count: photoCount,\n      video_count: videoCount,\n      issues_count: failedItems + needsReviewItems,\n      confidence_average: Math.round(confidenceAverage)\n    };\n  }\n}\n\n// Export singleton instance\nexport const auditorService = new AuditorService();","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/checklistAuditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/checklistDataService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/checklistPopulationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/checklistService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/checklistValidationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionCreationOptimizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionCreationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionDatabaseService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionRetryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/inspectionValidationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/mediaCompressionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/mediaRecordService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/mobileInspectionOptimizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/mobileInspectionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/offlineStorageService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[818,821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[818,821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1216,1219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1216,1219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11812,11815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11812,11815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":471,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":471,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13946,13949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13946,13949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":476,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":476,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14207,14210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14207,14210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":481,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":481,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14466,14469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14466,14469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Offline Storage Service - IndexedDB management for offline-first functionality\nimport { logger } from '@/utils/logger';\n\ninterface OfflineInspection {\n  id: string;\n  propertyId: string;\n  inspectorId: string;\n  status: 'draft' | 'in_progress' | 'completed';\n  currentStep: number;\n  startTime: string;\n  endTime?: string;\n  checklistItems: OfflineChecklistItem[];\n  syncStatus: 'pending' | 'syncing' | 'synced' | 'failed';\n  lastModified: string;\n  version: number;\n}\n\ninterface OfflineChecklistItem {\n  id: string;\n  title: string;\n  description: string;\n  category: string;\n  required: boolean;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  roomType?: string;\n  gptPrompt?: string;\n  referencePhoto?: string;\n  photos: OfflineMedia[];\n  videos: OfflineMedia[];\n  notes?: string;\n  aiAnalysis?: any;\n  lastModified: string;\n}\n\ninterface OfflineMedia {\n  id: string;\n  file: File;\n  url: string; // blob URL for preview\n  fileName: string;\n  fileSize: number;\n  mimeType: string;\n  uploaded: boolean;\n  uploadRetries: number;\n  timestamp: string;\n}\n\ninterface SyncQueue {\n  id: string;\n  type: 'inspection' | 'checklist_item' | 'media_upload';\n  action: 'create' | 'update' | 'delete';\n  data: any;\n  priority: 'high' | 'medium' | 'low';\n  retries: number;\n  lastAttempt?: string;\n  error?: string;\n  timestamp: string;\n}\n\nexport class OfflineStorageService {\n  private db: IDBDatabase | null = null;\n  private readonly DB_NAME = 'STRCertifiedOffline';\n  private readonly DB_VERSION = 1;\n\n  constructor() {\n    this.initDB();\n  }\n\n  /**\n   * Initialize IndexedDB\n   */\n  private async initDB(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n\n      request.onerror = () => {\n        logger.error('Failed to open IndexedDB', request.error, 'OFFLINE_STORAGE');\n        reject(request.error);\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        logger.info('IndexedDB initialized successfully', {}, 'OFFLINE_STORAGE');\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        // Create inspections store\n        if (!db.objectStoreNames.contains('inspections')) {\n          const inspectionStore = db.createObjectStore('inspections', { keyPath: 'id' });\n          inspectionStore.createIndex('propertyId', 'propertyId', { unique: false });\n          inspectionStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n          inspectionStore.createIndex('lastModified', 'lastModified', { unique: false });\n        }\n\n        // Create sync queue store\n        if (!db.objectStoreNames.contains('syncQueue')) {\n          const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id' });\n          syncStore.createIndex('type', 'type', { unique: false });\n          syncStore.createIndex('priority', 'priority', { unique: false });\n          syncStore.createIndex('timestamp', 'timestamp', { unique: false });\n        }\n\n        // Create media store for blob storage\n        if (!db.objectStoreNames.contains('media')) {\n          const mediaStore = db.createObjectStore('media', { keyPath: 'id' });\n          mediaStore.createIndex('checklistItemId', 'checklistItemId', { unique: false });\n          mediaStore.createIndex('uploaded', 'uploaded', { unique: false });\n        }\n\n        logger.info('IndexedDB schema created', {}, 'OFFLINE_STORAGE');\n      };\n    });\n  }\n\n  /**\n   * Store inspection data offline\n   */\n  async storeInspectionOffline(inspection: OfflineInspection): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['inspections'], 'readwrite');\n      const store = transaction.objectStore('inspections');\n      \n      inspection.lastModified = new Date().toISOString();\n      inspection.version = (inspection.version || 0) + 1;\n\n      await new Promise((resolve, reject) => {\n        const request = store.put(inspection);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      // Add to sync queue if not already synced\n      if (inspection.syncStatus !== 'synced') {\n        await this.addToSyncQueue({\n          id: `inspection_${inspection.id}_${Date.now()}`,\n          type: 'inspection',\n          action: 'create',\n          data: inspection,\n          priority: 'high',\n          retries: 0,\n          timestamp: new Date().toISOString()\n        });\n      }\n\n      logger.info('Inspection stored offline', { inspectionId: inspection.id }, 'OFFLINE_STORAGE');\n      return true;\n    } catch (error) {\n      logger.error('Failed to store inspection offline', error, 'OFFLINE_STORAGE');\n      return false;\n    }\n  }\n\n  /**\n   * Store media file offline\n   */\n  async storeMediaOffline(checklistItemId: string, file: File, type: 'photo' | 'video'): Promise<string | null> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const mediaId = `${checklistItemId}_${type}_${Date.now()}`;\n      const blobUrl = URL.createObjectURL(file);\n\n      const mediaData: OfflineMedia = {\n        id: mediaId,\n        file,\n        url: blobUrl,\n        fileName: file.name,\n        fileSize: file.size,\n        mimeType: file.type,\n        uploaded: false,\n        uploadRetries: 0,\n        timestamp: new Date().toISOString()\n      };\n\n      const transaction = this.db!.transaction(['media'], 'readwrite');\n      const store = transaction.objectStore('media');\n\n      await new Promise((resolve, reject) => {\n        const request = store.put({\n          id: mediaId,\n          checklistItemId,\n          type,\n          ...mediaData\n        });\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      // Add to sync queue\n      await this.addToSyncQueue({\n        id: `media_${mediaId}`,\n        type: 'media_upload',\n        action: 'create',\n        data: { checklistItemId, mediaId, type },\n        priority: 'medium',\n        retries: 0,\n        timestamp: new Date().toISOString()\n      });\n\n      logger.info('Media stored offline', { mediaId, checklistItemId, type }, 'OFFLINE_STORAGE');\n      return mediaId;\n    } catch (error) {\n      logger.error('Failed to store media offline', error, 'OFFLINE_STORAGE');\n      return null;\n    }\n  }\n\n  /**\n   * Get offline inspection by ID\n   */\n  async getOfflineInspection(inspectionId: string): Promise<OfflineInspection | null> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['inspections'], 'readonly');\n      const store = transaction.objectStore('inspections');\n\n      const result = await new Promise<OfflineInspection | null>((resolve, reject) => {\n        const request = store.get(inspectionId);\n        request.onsuccess = () => resolve(request.result || null);\n        request.onerror = () => reject(request.error);\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to get offline inspection', error, 'OFFLINE_STORAGE');\n      return null;\n    }\n  }\n\n  /**\n   * Get all offline inspections\n   */\n  async getAllOfflineInspections(): Promise<OfflineInspection[]> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['inspections'], 'readonly');\n      const store = transaction.objectStore('inspections');\n\n      const result = await new Promise<OfflineInspection[]>((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => resolve(request.result || []);\n        request.onerror = () => reject(request.error);\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to get all offline inspections', error, 'OFFLINE_STORAGE');\n      return [];\n    }\n  }\n\n  /**\n   * Add item to sync queue\n   */\n  async addToSyncQueue(item: SyncQueue): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['syncQueue'], 'readwrite');\n      const store = transaction.objectStore('syncQueue');\n\n      await new Promise((resolve, reject) => {\n        const request = store.put(item);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Failed to add to sync queue', error, 'OFFLINE_STORAGE');\n      return false;\n    }\n  }\n\n  /**\n   * Get sync queue items\n   */\n  async getSyncQueue(): Promise<SyncQueue[]> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['syncQueue'], 'readonly');\n      const store = transaction.objectStore('syncQueue');\n\n      const result = await new Promise<SyncQueue[]>((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => resolve(request.result || []);\n        request.onerror = () => reject(request.error);\n      });\n\n      // Sort by priority and timestamp\n      return result.sort((a, b) => {\n        const priorityOrder = { high: 3, medium: 2, low: 1 };\n        const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\n      });\n    } catch (error) {\n      logger.error('Failed to get sync queue', error, 'OFFLINE_STORAGE');\n      return [];\n    }\n  }\n\n  /**\n   * Update sync queue item\n   */\n  async updateSyncQueueItem(id: string, updates: Partial<SyncQueue>): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['syncQueue'], 'readwrite');\n      const store = transaction.objectStore('syncQueue');\n\n      // Get existing item\n      const existingItem = await new Promise<SyncQueue>((resolve, reject) => {\n        const request = store.get(id);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      if (!existingItem) {\n        return false;\n      }\n\n      // Update item\n      const updatedItem = { ...existingItem, ...updates };\n      await new Promise((resolve, reject) => {\n        const request = store.put(updatedItem);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Failed to update sync queue item', error, 'OFFLINE_STORAGE');\n      return false;\n    }\n  }\n\n  /**\n   * Remove sync queue item\n   */\n  async removeSyncQueueItem(id: string): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['syncQueue'], 'readwrite');\n      const store = transaction.objectStore('syncQueue');\n\n      await new Promise((resolve, reject) => {\n        const request = store.delete(id);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Failed to remove sync queue item', error, 'OFFLINE_STORAGE');\n      return false;\n    }\n  }\n\n  /**\n   * Get media file by ID\n   */\n  async getMediaFile(mediaId: string): Promise<{ file: File; url: string } | null> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['media'], 'readonly');\n      const store = transaction.objectStore('media');\n\n      const result = await new Promise<any>((resolve, reject) => {\n        const request = store.get(mediaId);\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      return {\n        file: result.file,\n        url: result.url\n      };\n    } catch (error) {\n      logger.error('Failed to get media file', error, 'OFFLINE_STORAGE');\n      return null;\n    }\n  }\n\n  /**\n   * Clear all offline data (useful for testing/cleanup)\n   */\n  async clearAllData(): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['inspections', 'syncQueue', 'media'], 'readwrite');\n      \n      await Promise.all([\n        new Promise<void>((resolve, reject) => {\n          const request = transaction.objectStore('inspections').clear();\n          request.onsuccess = () => resolve();\n          request.onerror = () => reject(request.error);\n        }),\n        new Promise<void>((resolve, reject) => {\n          const request = transaction.objectStore('syncQueue').clear();\n          request.onsuccess = () => resolve();\n          request.onerror = () => reject(request.error);\n        }),\n        new Promise<void>((resolve, reject) => {\n          const request = transaction.objectStore('media').clear();\n          request.onsuccess = () => resolve();\n          request.onerror = () => reject(request.error);\n        })\n      ]);\n\n      logger.info('All offline data cleared', {}, 'OFFLINE_STORAGE');\n      return true;\n    } catch (error) {\n      logger.error('Failed to clear offline data', error, 'OFFLINE_STORAGE');\n      return false;\n    }\n  }\n\n  /**\n   * Get storage stats\n   */\n  async getStorageStats(): Promise<{\n    inspections: number;\n    syncQueue: number;\n    media: number;\n    totalSize: number;\n  }> {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const transaction = this.db!.transaction(['inspections', 'syncQueue', 'media'], 'readonly');\n      \n      const [inspections, syncQueue, media] = await Promise.all([\n        new Promise<any[]>((resolve, reject) => {\n          const request = transaction.objectStore('inspections').getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => reject(request.error);\n        }),\n        new Promise<any[]>((resolve, reject) => {\n          const request = transaction.objectStore('syncQueue').getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => reject(request.error);\n        }),\n        new Promise<any[]>((resolve, reject) => {\n          const request = transaction.objectStore('media').getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => reject(request.error);\n        })\n      ]);\n\n      const totalSize = media.reduce((sum, item) => sum + (item.fileSize || 0), 0);\n\n      return {\n        inspections: inspections.length,\n        syncQueue: syncQueue.length,\n        media: media.length,\n        totalSize\n      };\n    } catch (error) {\n      logger.error('Failed to get storage stats', error, 'OFFLINE_STORAGE');\n      return { inspections: 0, syncQueue: 0, media: 0, totalSize: 0 };\n    }\n  }\n}\n\n// Export singleton instance\nexport const offlineStorageService = new OfflineStorageService();","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/robustMobileInspectionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/services/syncService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[997,1000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[997,1000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1074,1077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1074,1077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1093,1096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1093,1096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9117,9120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9117,9120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":342,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10038,10041],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10038,10041],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":373,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":373,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10967,10970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10967,10970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":421,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":421,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12585,12588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12585,12588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":521,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16052,16055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16052,16055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":593,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":593,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17963,17966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17963,17966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":652,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":652,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19620,19623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19620,19623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":660,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":660,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19912,19915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19912,19915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":693,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":693,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20917,20920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20917,20920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Sync Service - Handles synchronization between offline storage and database\nimport { supabase } from '@/integrations/supabase/client';\nimport { logger } from '@/utils/logger';\nimport { offlineStorageService } from './offlineStorageService';\nimport { inspectionService } from './inspectionService';\n\ninterface SyncStatus {\n  isOnline: boolean;\n  lastSync: Date | null;\n  pendingUploads: number;\n  failedUploads: number;\n  totalSyncItems: number;\n  batchProgress?: BatchProgress;\n}\n\ninterface SyncProgress {\n  current: number;\n  total: number;\n  status: 'idle' | 'syncing' | 'completed' | 'failed';\n  currentOperation: string;\n  errors: string[];\n  batchProgress?: BatchProgress;\n}\n\ninterface BatchProgress {\n  currentBatch: number;\n  totalBatches: number;\n  batchSize: number;\n  itemsInCurrentBatch: number;\n  totalItems: number;\n}\n\ninterface ConflictResolution {\n  strategy: 'client_wins' | 'server_wins' | 'merge' | 'manual';\n  clientVersion: number;\n  serverVersion: number;\n  resolvedData?: any;\n}\n\ninterface SyncConflict {\n  id: string;\n  type: string;\n  clientData: any;\n  serverData: any;\n  timestamp: string;\n  resolved: boolean;\n  resolution?: ConflictResolution;\n}\n\nexport class SyncService {\n  private isOnline = navigator.onLine;\n  private isSyncing = false;\n  private lastSyncTime: Date | null = null;\n  private readonly BATCH_SIZE = 10; // Process items in batches to avoid overwhelming the server\n  private readonly MAX_RETRIES = 3;\n  private readonly RETRY_DELAY = 1000; // 1 second base delay\n  private syncProgress: SyncProgress = {\n    current: 0,\n    total: 0,\n    status: 'idle',\n    currentOperation: '',\n    errors: []\n  };\n  private syncListeners: ((progress: SyncProgress) => void)[] = [];\n  private statusListeners: ((status: SyncStatus) => void)[] = [];\n  private conflictResolver: Map<string, SyncConflict> = new Map();\n\n  constructor() {\n    this.setupNetworkListeners();\n    this.startPeriodicSync();\n    this.startAdaptivePeriodicSync();\n  }\n\n  /**\n   * Setup network status listeners\n   */\n  private setupNetworkListeners() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      logger.info('Network connection restored', {}, 'SYNC_SERVICE');\n      this.triggerSync();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      logger.info('Network connection lost', {}, 'SYNC_SERVICE');\n      this.notifyStatusListeners();\n    });\n  }\n\n  /**\n   * Start periodic sync every 30 seconds when online\n   */\n  private startPeriodicSync() {\n    setInterval(() => {\n      if (this.isOnline && !this.isSyncing) {\n        this.triggerSync();\n      }\n    }, 30000);\n  }\n\n  /**\n   * Enhanced background sync with adaptive intervals\n   */\n  private startAdaptivePeriodicSync() {\n    let syncInterval = 30000; // Start with 30 seconds\n    const maxInterval = 300000; // Max 5 minutes\n    const minInterval = 10000; // Min 10 seconds\n    \n    const adaptiveSync = async () => {\n      if (this.isOnline && !this.isSyncing) {\n        const syncQueue = await offlineStorageService.getSyncQueue();\n        \n        if (syncQueue.length > 0) {\n          await this.triggerSync();\n          \n          // Decrease interval if there are items to sync\n          syncInterval = Math.max(minInterval, syncInterval * 0.8);\n        } else {\n          // Increase interval if no items to sync\n          syncInterval = Math.min(maxInterval, syncInterval * 1.2);\n        }\n      }\n      \n      setTimeout(adaptiveSync, syncInterval);\n    };\n    \n    adaptiveSync();\n  }\n\n  /**\n   * Add sync progress listener\n   */\n  addSyncListener(listener: (progress: SyncProgress) => void) {\n    this.syncListeners.push(listener);\n  }\n\n  /**\n   * Add sync status listener\n   */\n  addStatusListener(listener: (status: SyncStatus) => void) {\n    this.statusListeners.push(listener);\n  }\n\n  /**\n   * Remove sync progress listener\n   */\n  removeSyncListener(listener: (progress: SyncProgress) => void) {\n    this.syncListeners = this.syncListeners.filter(l => l !== listener);\n  }\n\n  /**\n   * Remove sync status listener\n   */\n  removeStatusListener(listener: (status: SyncStatus) => void) {\n    this.statusListeners = this.statusListeners.filter(l => l !== listener);\n  }\n\n  /**\n   * Notify sync progress listeners\n   */\n  private notifySyncListeners() {\n    this.syncListeners.forEach(listener => listener(this.syncProgress));\n  }\n\n  /**\n   * Notify status listeners\n   */\n  private async notifyStatusListeners() {\n    const status = await this.getSyncStatus();\n    this.statusListeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Get current sync status\n   */\n  async getSyncStatus(): Promise<SyncStatus> {\n    const syncQueue = await offlineStorageService.getSyncQueue();\n    const pendingUploads = syncQueue.filter(item => item.type === 'media_upload').length;\n    const failedUploads = syncQueue.filter(item => item.error).length;\n\n    return {\n      isOnline: this.isOnline,\n      lastSync: this.lastSyncTime,\n      pendingUploads,\n      failedUploads,\n      totalSyncItems: syncQueue.length,\n      batchProgress: this.syncProgress.batchProgress\n    };\n  }\n\n  /**\n   * Trigger sync if online and not already syncing\n   */\n  async triggerSync(): Promise<boolean> {\n    if (!this.isOnline || this.isSyncing) {\n      return false;\n    }\n\n    logger.info('Starting sync operation', {}, 'SYNC_SERVICE');\n    this.isSyncing = true;\n    this.syncProgress = {\n      current: 0,\n      total: 0,\n      status: 'syncing',\n      currentOperation: 'Preparing sync...',\n      errors: []\n    };\n\n    try {\n      const syncQueue = await offlineStorageService.getSyncQueue();\n      this.syncProgress.total = syncQueue.length;\n\n      if (syncQueue.length === 0) {\n        logger.info('No items to sync', {}, 'SYNC_SERVICE');\n        this.syncProgress.status = 'completed';\n        this.lastSyncTime = new Date();\n        this.notifySyncListeners();\n        return true;\n      }\n\n      // Process sync queue in batches to avoid overwhelming the server\n      const batches = this.createBatches(syncQueue, this.BATCH_SIZE);\n      this.syncProgress.batchProgress = {\n        currentBatch: 0,\n        totalBatches: batches.length,\n        batchSize: this.BATCH_SIZE,\n        itemsInCurrentBatch: 0,\n        totalItems: syncQueue.length\n      };\n\n      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\n        const batch = batches[batchIndex];\n        this.syncProgress.batchProgress.currentBatch = batchIndex + 1;\n        this.syncProgress.batchProgress.itemsInCurrentBatch = batch.length;\n        this.syncProgress.currentOperation = `Processing batch ${batchIndex + 1} of ${batches.length} (${batch.length} items)...`;\n        this.notifySyncListeners();\n\n        // Process batch items in parallel for better performance\n        const batchPromises = batch.map(async (item) => {\n          try {\n            await this.processSyncItemWithRetry(item);\n            this.syncProgress.current++;\n            this.notifySyncListeners();\n          } catch (error) {\n            logger.error('Failed to process sync item after retries', error, 'SYNC_SERVICE');\n            this.syncProgress.errors.push(`Failed to sync ${item.type}: ${error.message}`);\n            \n            // Update sync queue item with error\n            await offlineStorageService.updateSyncQueueItem(item.id, {\n              error: error.message,\n              retries: item.retries + 1,\n              lastAttempt: new Date().toISOString()\n            });\n          }\n        });\n\n        await Promise.allSettled(batchPromises);\n\n        // Add delay between batches to prevent rate limiting\n        if (batchIndex < batches.length - 1) {\n          await this.delay(500);\n        }\n      }\n\n      this.syncProgress.status = 'completed';\n      this.syncProgress.currentOperation = 'Sync completed';\n      this.lastSyncTime = new Date();\n      \n      logger.info('Sync operation completed', {\n        processed: this.syncProgress.current,\n        total: this.syncProgress.total,\n        errors: this.syncProgress.errors.length,\n        batches: batches.length\n      }, 'SYNC_SERVICE');\n\n      return true;\n    } catch (error) {\n      logger.error('Sync operation failed', error, 'SYNC_SERVICE');\n      this.syncProgress.status = 'failed';\n      this.syncProgress.currentOperation = `Sync failed: ${error.message}`;\n      this.syncProgress.errors.push(error.message);\n      return false;\n    } finally {\n      this.isSyncing = false;\n      this.notifySyncListeners();\n      this.notifyStatusListeners();\n    }\n  }\n\n  /**\n   * Create batches from sync queue items\n   */\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  /**\n   * Delay execution for specified milliseconds\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Process individual sync item with retry logic\n   */\n  private async processSyncItemWithRetry(item: any): Promise<void> {\n    let lastError: Error | null = null;\n    \n    for (let attempt = 0; attempt < this.MAX_RETRIES; attempt++) {\n      try {\n        await this.processSyncItem(item);\n        return; // Success - exit retry loop\n      } catch (error) {\n        lastError = error as Error;\n        logger.warn(`Sync item failed (attempt ${attempt + 1}/${this.MAX_RETRIES})`, {\n          itemId: item.id,\n          type: item.type,\n          error: error.message\n        }, 'SYNC_SERVICE');\n        \n        // Wait before retrying with exponential backoff\n        if (attempt < this.MAX_RETRIES - 1) {\n          const delay = this.RETRY_DELAY * Math.pow(2, attempt);\n          await this.delay(delay);\n        }\n      }\n    }\n    \n    // All retries failed\n    throw lastError || new Error('Sync item failed after all retries');\n  }\n\n  /**\n   * Process individual sync item\n   */\n  private async processSyncItem(item: any): Promise<void> {\n    this.syncProgress.currentOperation = `Syncing ${item.type}...`;\n    this.notifySyncListeners();\n\n    // Check for conflicts before processing\n    const conflictResolution = await this.checkForConflicts(item);\n    if (conflictResolution && !conflictResolution.resolved) {\n      throw new Error(`Sync conflict detected for ${item.type} ${item.id}`);\n    }\n\n    switch (item.type) {\n      case 'inspection':\n        await this.syncInspection(item);\n        break;\n      case 'checklist_item':\n        await this.syncChecklistItem(item);\n        break;\n      case 'media_upload':\n        await this.syncMediaUpload(item);\n        break;\n      default:\n        throw new Error(`Unknown sync item type: ${item.type}`);\n    }\n\n    // Remove successful item from queue\n    await offlineStorageService.removeSyncQueueItem(item.id);\n  }\n\n  /**\n   * Sync inspection data\n   */\n  private async syncInspection(item: any): Promise<void> {\n    const inspectionData = item.data;\n    \n    if (item.action === 'create') {\n      // Create inspection in database\n      const result = await inspectionService.createInspection({\n        propertyId: inspectionData.propertyId,\n        inspectorId: inspectionData.inspectorId,\n        checklistItems: inspectionData.checklistItems.map(item => ({\n          title: item.title,\n          description: item.description,\n          category: item.category,\n          required: item.required,\n          room_type: item.roomType,\n          gpt_prompt: item.gptPrompt,\n          reference_photo: item.referencePhoto\n        }))\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || 'Failed to create inspection');\n      }\n\n      // Update offline inspection with server ID\n      inspectionData.syncStatus = 'synced';\n      await offlineStorageService.storeInspectionOffline(inspectionData);\n    } else if (item.action === 'update') {\n      // Update inspection progress\n      const result = await inspectionService.updateInspectionProgress({\n        inspectionId: inspectionData.id,\n        currentStep: inspectionData.currentStep,\n        status: inspectionData.status,\n        checklistItemUpdates: inspectionData.checklistItems.map(item => ({\n          id: item.id,\n          status: item.status,\n          notes: item.notes\n        }))\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || 'Failed to update inspection');\n      }\n    }\n  }\n\n  /**\n   * Sync checklist item data with conflict resolution\n   */\n  private async syncChecklistItem(item: any): Promise<void> {\n    let checklistData = item.data;\n    \n    // Check for server-side changes first\n    const { data: serverData, error: fetchError } = await supabase\n      .from('checklist_items')\n      .select('*')\n      .eq('id', checklistData.id)\n      .single();\n\n    if (fetchError && fetchError.code !== 'PGRST116') { // PGRST116 = not found\n      throw new Error(`Failed to fetch checklist item: ${fetchError.message}`);\n    }\n\n    // If server data exists, check for conflicts\n    if (serverData) {\n      const serverUpdateTime = new Date(serverData.updated_at);\n      const clientUpdateTime = new Date(checklistData.completedAt || checklistData.lastModified);\n      \n      if (serverUpdateTime > clientUpdateTime) {\n        // Server has newer data - potential conflict\n        const conflict: SyncConflict = {\n          id: `checklist_${checklistData.id}`,\n          type: 'checklist_item',\n          clientData: checklistData,\n          serverData,\n          timestamp: new Date().toISOString(),\n          resolved: false\n        };\n        \n        this.conflictResolver.set(conflict.id, conflict);\n        \n        // Auto-resolve based on completion status\n        if (checklistData.status === 'completed' && serverData.status !== 'completed') {\n          // Client completion wins\n          conflict.resolution = {\n            strategy: 'client_wins',\n            clientVersion: 1,\n            serverVersion: 1,\n            resolvedData: checklistData\n          };\n        } else if (serverData.status === 'completed' && checklistData.status !== 'completed') {\n          // Server completion wins\n          conflict.resolution = {\n            strategy: 'server_wins',\n            clientVersion: 1,\n            serverVersion: 1,\n            resolvedData: serverData\n          };\n          \n          // Update offline data with server data\n          await this.updateOfflineWithServerData(checklistData.id, serverData);\n          return;\n        } else {\n          // Merge approach - combine data\n          conflict.resolution = {\n            strategy: 'merge',\n            clientVersion: 1,\n            serverVersion: 1,\n            resolvedData: {\n              ...serverData,\n              ...checklistData,\n              // Preserve server completion if it exists\n              status: serverData.status === 'completed' ? 'completed' : checklistData.status,\n              // Combine notes\n              notes: serverData.notes && checklistData.notes ? \n                `${serverData.notes}\\n\\n${checklistData.notes}` : \n                checklistData.notes || serverData.notes\n            }\n          };\n        }\n        \n        conflict.resolved = true;\n        checklistData = conflict.resolution.resolvedData;\n      }\n    }\n    \n    // Update checklist item in database\n    const { error } = await supabase\n      .from('checklist_items')\n      .update({\n        status: checklistData.status,\n        notes: checklistData.notes,\n        ai_status: checklistData.aiStatus,\n        ai_confidence: checklistData.aiConfidence,\n        ai_reasoning: checklistData.aiReasoning,\n        user_override: checklistData.userOverride,\n        completed_at: checklistData.completedAt,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', checklistData.id);\n\n    if (error) {\n      throw new Error(`Failed to update checklist item: ${error.message}`);\n    }\n  }\n\n  /**\n   * Sync media upload\n   */\n  private async syncMediaUpload(item: any): Promise<void> {\n    const { checklistItemId, mediaId, type } = item.data;\n    \n    // Get media file from offline storage\n    const mediaFile = await offlineStorageService.getMediaFile(mediaId);\n    if (!mediaFile) {\n      throw new Error(`Media file not found: ${mediaId}`);\n    }\n\n    // Upload to Supabase storage\n    const fileName = `${checklistItemId}/${type}s/${Date.now()}-${mediaFile.file.name}`;\n    const { data: uploadData, error: uploadError } = await supabase.storage\n      .from('media')\n      .upload(fileName, mediaFile.file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Failed to upload media: ${uploadError.message}`);\n    }\n\n    // Get public URL\n    const { data: { publicUrl } } = supabase.storage\n      .from('media')\n      .getPublicUrl(fileName);\n\n    // Create media record in database\n    const { error: recordError } = await supabase\n      .from('media')\n      .insert({\n        checklist_item_id: checklistItemId,\n        type: type as 'photo' | 'video',\n        url: publicUrl,\n        file_path: fileName,\n        created_at: new Date().toISOString()\n      });\n\n    if (recordError) {\n      throw new Error(`Failed to create media record: ${recordError.message}`);\n    }\n\n    logger.info('Media uploaded successfully', {\n      mediaId,\n      checklistItemId,\n      type,\n      url: publicUrl\n    }, 'SYNC_SERVICE');\n  }\n\n  /**\n   * Force sync now (called by user action)\n   */\n  async forceSyncNow(): Promise<boolean> {\n    if (!this.isOnline) {\n      throw new Error('Cannot sync while offline');\n    }\n\n    logger.info('Force sync requested', {}, 'SYNC_SERVICE');\n    return await this.triggerSync();\n  }\n\n  /**\n   * Get sync progress\n   */\n  getSyncProgress(): SyncProgress {\n    return { ...this.syncProgress };\n  }\n\n  /**\n   * Queue inspection for sync\n   */\n  async queueInspectionSync(inspectionData: any, action: 'create' | 'update' = 'create'): Promise<void> {\n    const syncItem = {\n      id: `inspection_${inspectionData.id}_${Date.now()}`,\n      type: 'inspection' as const,\n      action,\n      data: inspectionData,\n      priority: 'high' as const,\n      retries: 0,\n      timestamp: new Date().toISOString()\n    };\n\n    await offlineStorageService.addToSyncQueue(syncItem);\n    \n    // Trigger sync if online\n    if (this.isOnline) {\n      setTimeout(() => this.triggerSync(), 1000);\n    }\n  }\n\n  /**\n   * Queue media upload for sync\n   */\n  async queueMediaUpload(checklistItemId: string, mediaId: string, type: 'photo' | 'video'): Promise<void> {\n    const syncItem = {\n      id: `media_${mediaId}`,\n      type: 'media_upload' as const,\n      action: 'create' as const,\n      data: { checklistItemId, mediaId, type },\n      priority: 'medium' as const,\n      retries: 0,\n      timestamp: new Date().toISOString()\n    };\n\n    await offlineStorageService.addToSyncQueue(syncItem);\n    \n    // Trigger sync if online\n    if (this.isOnline) {\n      setTimeout(() => this.triggerSync(), 2000);\n    }\n  }\n\n  /**\n   * Clear failed sync items\n   */\n  async clearFailedSyncItems(): Promise<void> {\n    const syncQueue = await offlineStorageService.getSyncQueue();\n    const failedItems = syncQueue.filter(item => item.error);\n    \n    for (const item of failedItems) {\n      await offlineStorageService.removeSyncQueueItem(item.id);\n    }\n    \n    logger.info('Cleared failed sync items', { count: failedItems.length }, 'SYNC_SERVICE');\n    this.notifyStatusListeners();\n  }\n\n  /**\n   * Check for sync conflicts\n   */\n  private async checkForConflicts(item: any): Promise<SyncConflict | null> {\n    const conflictId = `${item.type}_${item.data.id || item.id}`;\n    return this.conflictResolver.get(conflictId) || null;\n  }\n\n  /**\n   * Update offline data with server data\n   */\n  private async updateOfflineWithServerData(itemId: string, serverData: any): Promise<void> {\n    // Update offline storage with server data\n    // This is a simplified implementation - in practice, you'd update the specific offline record\n    logger.info('Updating offline data with server data', { itemId }, 'SYNC_SERVICE');\n  }\n\n  /**\n   * Get sync conflicts\n   */\n  getSyncConflicts(): SyncConflict[] {\n    return Array.from(this.conflictResolver.values());\n  }\n\n  /**\n   * Resolve sync conflict manually\n   */\n  async resolveSyncConflict(conflictId: string, resolution: ConflictResolution): Promise<boolean> {\n    const conflict = this.conflictResolver.get(conflictId);\n    if (!conflict) {\n      return false;\n    }\n\n    conflict.resolution = resolution;\n    conflict.resolved = true;\n\n    logger.info('Sync conflict resolved', {\n      conflictId,\n      strategy: resolution.strategy\n    }, 'SYNC_SERVICE');\n\n    // Re-queue the item for sync\n    await offlineStorageService.addToSyncQueue({\n      id: `resolved_${conflictId}_${Date.now()}`,\n      type: conflict.type as any,\n      action: 'update',\n      data: resolution.resolvedData,\n      priority: 'high',\n      retries: 0,\n      timestamp: new Date().toISOString()\n    });\n\n    return true;\n  }\n\n  /**\n   * Retry failed sync items\n   */\n  async retryFailedSyncItems(): Promise<void> {\n    const syncQueue = await offlineStorageService.getSyncQueue();\n    const failedItems = syncQueue.filter(item => item.error && item.retries < this.MAX_RETRIES);\n    \n    for (const item of failedItems) {\n      await offlineStorageService.updateSyncQueueItem(item.id, {\n        error: undefined,\n        lastAttempt: undefined\n      });\n    }\n    \n    logger.info('Reset failed sync items for retry', { count: failedItems.length }, 'SYNC_SERVICE');\n    \n    // Trigger sync if online\n    if (this.isOnline) {\n      setTimeout(() => this.triggerSync(), 1000);\n    }\n  }\n}\n\n// Export singleton instance\nexport const syncService = new SyncService();","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/categories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[398,401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[398,401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Type exports for better organization\nexport * from './categories';\nexport * from './inspection';\nexport * from './propertySubmission';\n\n// Common types\nexport interface AppError {\n  message: string;\n  code?: string;\n  details?: unknown;\n}\n\nexport interface PaginationOptions {\n  page: number;\n  limit: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface APIResponse<T = any> {\n  data: T;\n  error?: AppError;\n  pagination?: {\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/inspection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/learning.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[333,336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[333,336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[454,457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[454,457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5602,5605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5602,5605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5623,5626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5623,5626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":299,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7139,7142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7139,7142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7595,7598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7595,7598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7622,7625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7622,7625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Learning System Types for STR Certified\n\nexport interface AuditorFeedback {\n  id: string;\n  inspectionId: string;\n  auditorId: string;\n  timestamp: Date;\n  feedbackType: 'correction' | 'validation' | 'suggestion' | 'issue';\n  category: FeedbackCategory;\n  \n  // AI prediction vs auditor correction\n  aiPrediction: {\n    value: any;\n    confidence: number;\n    reasoning?: string;\n    modelVersion: string;\n  };\n  \n  auditorCorrection: {\n    value: any;\n    confidence: number;\n    reasoning: string;\n  };\n  \n  // Additional context\n  context: {\n    propertyType: string;\n    roomType?: string;\n    checklistItem?: string;\n    photoId?: string;\n    videoTimestamp?: number;\n  };\n  \n  // Learning metadata\n  learningMetadata: {\n    processed: boolean;\n    processedAt?: Date;\n    impactScore: number; // 0-100, how much this feedback impacts the model\n    patterns?: string[]; // Identified patterns from this feedback\n  };\n}\n\nexport type FeedbackCategory = \n  | 'photo_quality'\n  | 'object_detection'\n  | 'room_classification'\n  | 'damage_assessment'\n  | 'completeness_check'\n  | 'safety_compliance'\n  | 'amenity_verification'\n  | 'measurement_accuracy'\n  | 'condition_rating';\n\nexport interface LearningMetrics {\n  periodStart: Date;\n  periodEnd: Date;\n  \n  // Overall metrics\n  accuracyTrend: TrendData;\n  confidenceImprovement: TrendData;\n  feedbackVolume: number;\n  feedbackProcessed: number;\n  \n  // Category-specific performance\n  categoryPerformance: Map<FeedbackCategory, CategoryMetrics>;\n  \n  // Property type performance\n  propertyTypePerformance: Map<string, PropertyTypeMetrics>;\n  \n  // Model improvements\n  modelUpdates: ModelUpdate[];\n  \n  // Key insights\n  insights: LearningInsight[];\n}\n\nexport interface TrendData {\n  dataPoints: Array<{\n    timestamp: Date;\n    value: number;\n  }>;\n  trend: 'improving' | 'declining' | 'stable';\n  changePercent: number;\n  forecast?: number; // Predicted next value\n}\n\nexport interface CategoryMetrics {\n  category: FeedbackCategory;\n  totalFeedback: number;\n  corrections: number;\n  validations: number;\n  accuracy: number; // 0-100\n  confidenceAvg: number; // 0-100\n  commonErrors: Array<{\n    type: string;\n    frequency: number;\n    examples: string[];\n  }>;\n  improvementRate: number; // % improvement over period\n}\n\nexport interface PropertyTypeMetrics {\n  propertyType: string;\n  inspectionCount: number;\n  feedbackCount: number;\n  accuracy: number;\n  specificChallenges: string[];\n  learningProgress: {\n    learned: string[];\n    inProgress: string[];\n    needsMoreData: string[];\n  };\n}\n\nexport interface ModelUpdate {\n  version: string;\n  timestamp: Date;\n  trigger: 'scheduled' | 'threshold' | 'manual';\n  feedbackIncorporated: number;\n  improvements: Array<{\n    category: FeedbackCategory;\n    metric: string;\n    before: number;\n    after: number;\n  }>;\n  validationResults: {\n    testSetAccuracy: number;\n    crossValidation: number;\n    auditorApproval?: number;\n  };\n}\n\nexport interface LearningInsight {\n  id: string;\n  type: 'pattern' | 'anomaly' | 'recommendation' | 'achievement';\n  severity: 'info' | 'warning' | 'critical' | 'success';\n  title: string;\n  description: string;\n  affectedCategories: FeedbackCategory[];\n  suggestedActions?: string[];\n  metrics?: Record<string, number>;\n  createdAt: Date;\n}\n\n// Knowledge Base Types\n\nexport interface KnowledgeEntry {\n  id: string;\n  category: KnowledgeCategory;\n  title: string;\n  content: string;\n  source: string;\n  \n  // Vector embeddings for RAG\n  embeddings: {\n    vector: number[];\n    model: string;\n    dimension: number;\n  };\n  \n  // Metadata\n  metadata: {\n    regulationType?: 'building_code' | 'safety' | 'ada' | 'fire' | 'electrical' | 'plumbing';\n    jurisdiction?: string;\n    applicablePropertyTypes?: string[];\n    tags: string[];\n    version: string;\n    effectiveDate: Date;\n    expirationDate?: Date;\n  };\n  \n  // Usage tracking\n  usage: {\n    queryCount: number;\n    lastQueried?: Date;\n    relevanceScore: number; // Based on auditor feedback\n    citationCount: number;\n  };\n  \n  lastUpdated: Date;\n  status: 'active' | 'deprecated' | 'draft';\n}\n\nexport type KnowledgeCategory = \n  | 'building_codes'\n  | 'safety_regulations'\n  | 'ada_compliance'\n  | 'fire_safety'\n  | 'electrical_standards'\n  | 'plumbing_codes'\n  | 'hvac_requirements'\n  | 'structural_integrity'\n  | 'environmental_health'\n  | 'best_practices'\n  | 'local_ordinances';\n\n// Learning Configuration\nexport interface LearningConfig {\n  // Feedback processing\n  minFeedbackForUpdate: number; // Minimum feedback items before model update\n  confidenceThreshold: number; // Minimum confidence for automatic acceptance\n  feedbackAggregationWindow: number; // Hours to aggregate feedback\n  \n  // Model update settings\n  updateFrequency: 'realtime' | 'hourly' | 'daily' | 'weekly';\n  validationSplitRatio: number; // Percentage for validation set\n  minAccuracyImprovement: number; // Minimum improvement to deploy new model\n  \n  // Knowledge base settings\n  embeddingModel: string;\n  vectorDimension: number;\n  similarityThreshold: number;\n  maxRetrievalResults: number;\n  \n  // Performance thresholds\n  criticalAccuracyThreshold: number; // Below this triggers alerts\n  targetAccuracy: number; // Goal accuracy\n  confidenceDecayRate: number; // How fast confidence decreases without feedback\n}\n\n// Feedback Collection Types\nexport interface FeedbackFormData {\n  inspectionId: string;\n  feedbackItems: FeedbackItem[];\n  overallRating: number; // 1-5\n  comments?: string;\n  suggestedImprovements?: string[];\n}\n\nexport interface FeedbackItem {\n  id: string;\n  type: FeedbackCategory;\n  aiValue: any;\n  correctValue: any;\n  confidenceRating: number; // 0-100\n  severity: 'minor' | 'moderate' | 'major';\n  explanation?: string;\n  evidence?: {\n    photoIds?: string[];\n    videoTimestamp?: number;\n    checklistItemId?: string;\n  };\n}\n\n// Learning Progress Types\nexport interface LearningProgress {\n  modelVersion: string;\n  startDate: Date;\n  currentDate: Date;\n  \n  // Overall progress\n  overallAccuracy: number;\n  overallImprovement: number; // % improvement since start\n  feedbackProcessed: number;\n  \n  // Category progress\n  categoryProgress: Map<FeedbackCategory, {\n    startAccuracy: number;\n    currentAccuracy: number;\n    improvement: number;\n    dataPoints: number;\n    nextMilestone: {\n      target: number;\n      estimatedDate?: Date;\n      requiredFeedback: number;\n    };\n  }>;\n  \n  // Milestones achieved\n  achievements: Array<{\n    type: 'accuracy' | 'volume' | 'consistency' | 'speed';\n    category?: FeedbackCategory;\n    milestone: string;\n    achievedAt: Date;\n    metric: number;\n  }>;\n  \n  // Predictions\n  predictions: {\n    nextWeekAccuracy: number;\n    nextMonthAccuracy: number;\n    timeToTarget: number; // Days to reach target accuracy\n    bottlenecks: string[]; // Areas slowing progress\n  };\n}\n\n// Pattern Recognition Types\nexport interface LearningPattern {\n  id: string;\n  name: string;\n  description: string;\n  category: FeedbackCategory;\n  \n  // Pattern definition\n  pattern: {\n    conditions: Array<{\n      field: string;\n      operator: 'equals' | 'contains' | 'gt' | 'lt' | 'regex';\n      value: any;\n    }>;\n    frequency: number; // Minimum occurrences\n    timeWindow?: number; // Hours\n  };\n  \n  // Pattern metadata\n  metadata: {\n    firstDetected: Date;\n    lastSeen: Date;\n    occurrences: number;\n    affectedInspections: string[];\n    severity: 'low' | 'medium' | 'high';\n  };\n  \n  // Recommended actions\n  recommendations: {\n    immediate: string[];\n    longTerm: string[];\n    modelAdjustments?: {\n      parameter: string;\n      currentValue: any;\n      suggestedValue: any;\n    }[];\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/photo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/property.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/propertySubmission.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/types/video.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2887,2890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2887,2890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Video Recording and Processing Types for STR Certified\n\nexport interface VideoRecording {\n  id: string;\n  propertyId: string;\n  inspectorId: string;\n  file: File | Blob;\n  duration: number; // seconds\n  size: number; // bytes\n  format: string;\n  resolution: VideoResolution;\n  quality: VideoQuality;\n  timestamps: VideoTimestamp[];\n  metadata: VideoMetadata;\n  status: VideoStatus;\n  createdAt: Date;\n  uploadedAt?: Date;\n  processedAt?: Date;\n}\n\nexport interface VideoResolution {\n  width: number;\n  height: number;\n  aspectRatio: string;\n}\n\nexport interface VideoQuality {\n  overall: number; // 0-100\n  stability: number; // 0-100 (lower is more shaky)\n  brightness: number; // 0-100\n  focus: number; // 0-100\n  audioQuality?: number; // 0-100\n  bitrate: number; // kbps\n  fps: number;\n}\n\nexport interface VideoTimestamp {\n  id: string;\n  time: number; // seconds from start\n  sceneType: SceneType;\n  roomDetected?: string;\n  features: string[];\n  description: string;\n  thumbnail?: string; // base64 or URL\n  confidence: number; // 0-100\n  isKeyFrame: boolean;\n  annotations?: VideoAnnotation[];\n}\n\nexport type SceneType = \n  | 'room_entry'\n  | 'room_overview'\n  | 'detail_shot'\n  | 'transition'\n  | 'exterior'\n  | 'amenity_focus'\n  | 'issue_documentation';\n\nexport interface VideoAnnotation {\n  type: 'text' | 'arrow' | 'box' | 'circle';\n  content: string;\n  position: { x: number; y: number };\n  style?: {\n    color?: string;\n    fontSize?: number;\n    strokeWidth?: number;\n  };\n}\n\nexport interface VideoMetadata {\n  deviceInfo: {\n    model: string;\n    os: string;\n    browser?: string;\n  };\n  location?: {\n    latitude: number;\n    longitude: number;\n  };\n  propertyDetails: {\n    address: string;\n    unitNumber?: string;\n    propertyType: string;\n  };\n  recordingConditions: {\n    lighting: string;\n    weather?: string;\n    timeOfDay: string;\n  };\n  inspectionType: string;\n  notes?: string;\n}\n\nexport type VideoStatus = \n  | 'recording'\n  | 'paused'\n  | 'stopped'\n  | 'processing'\n  | 'uploading'\n  | 'uploaded'\n  | 'analyzing'\n  | 'completed'\n  | 'failed';\n\nexport interface VideoAnalysisResult {\n  videoId: string;\n  scenes: SceneAnalysis[];\n  qualityMetrics: VideoQualityMetrics;\n  featureDetection: FeatureDetectionResult[];\n  roomSequence: RoomSequence[];\n  issues: VideoIssue[];\n  summary: AnalysisSummary;\n  processingTime: number;\n  aiConfidence: number;\n}\n\nexport interface SceneAnalysis {\n  startTime: number;\n  endTime: number;\n  sceneType: SceneType;\n  roomType?: string;\n  keyFrames: KeyFrame[];\n  objects: DetectedObject[];\n  quality: SceneQuality;\n  transitions: SceneTransition[];\n}\n\nexport interface KeyFrame {\n  timestamp: number;\n  frameUrl: string;\n  quality: number;\n  isRepresentative: boolean;\n  features: string[];\n}\n\nexport interface DetectedObject {\n  type: string;\n  confidence: number;\n  boundingBox: BoundingBox;\n  attributes?: Record<string, any>;\n}\n\nexport interface BoundingBox {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface SceneQuality {\n  sharpness: number;\n  stability: number;\n  lighting: number;\n  framing: number;\n  overall: number;\n}\n\nexport interface SceneTransition {\n  fromScene: number;\n  toScene: number;\n  type: 'cut' | 'pan' | 'zoom' | 'fade';\n  duration: number;\n  smooth: boolean;\n}\n\nexport interface VideoQualityMetrics {\n  averageQuality: number;\n  stabilityScore: number;\n  consistencyScore: number;\n  coverageScore: number; // How well the property was covered\n  technicalIssues: TechnicalIssue[];\n  recommendations: string[];\n}\n\nexport interface TechnicalIssue {\n  type: 'shaky' | 'dark' | 'blurry' | 'audio' | 'framerate';\n  severity: 'low' | 'medium' | 'high';\n  timestamp: number;\n  duration: number;\n  description: string;\n}\n\nexport interface FeatureDetectionResult {\n  feature: string;\n  detected: boolean;\n  confidence: number;\n  timestamps: number[];\n  evidence: string[];\n}\n\nexport interface RoomSequence {\n  roomId: string;\n  roomType: string;\n  startTime: number;\n  endTime: number;\n  coverage: 'complete' | 'partial' | 'minimal';\n  keyMoments: VideoTimestamp[];\n}\n\nexport interface VideoIssue {\n  type: 'missing_room' | 'poor_quality' | 'incomplete_coverage' | 'technical';\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  affectedTimestamps: number[];\n  suggestedAction?: string;\n}\n\nexport interface AnalysisSummary {\n  totalDuration: number;\n  roomsCovered: string[];\n  roomsMissing: string[];\n  overallQuality: number;\n  keyFindings: string[];\n  recommendedActions: string[];\n  readyForSubmission: boolean;\n}\n\n// Video processing configuration\nexport interface VideoProcessingConfig {\n  extractFrameInterval: number; // seconds\n  keyFrameQualityThreshold: number; // 0-100\n  sceneChangeThreshold: number; // 0-1\n  maxProcessingTime: number; // seconds\n  enableAudioAnalysis: boolean;\n  targetFrameRate: number;\n  compressionQuality: number; // 0-1\n}\n\n// Video recording configuration\nexport interface VideoRecordingConfig {\n  maxDuration: number; // seconds\n  targetResolution: VideoResolution;\n  targetBitrate: number; // kbps\n  audioEnabled: boolean;\n  stabilizationEnabled: boolean;\n  autoFocusEnabled: boolean;\n  lowLightEnhancement: boolean;\n}\n\n// Video upload configuration\nexport interface VideoUploadConfig {\n  chunkSize: number; // bytes\n  maxRetries: number;\n  retryDelay: number; // milliseconds\n  compressionEnabled: boolean;\n  wifiOnlyUpload: boolean;\n  backgroundUpload: boolean;\n}\n\n// Video player state\nexport interface VideoPlayerState {\n  currentTime: number;\n  duration: number;\n  isPlaying: boolean;\n  isBuffering: boolean;\n  playbackRate: number;\n  volume: number;\n  selectedTimestamp?: VideoTimestamp;\n  activeAnnotations: VideoAnnotation[];\n}\n\n// Video recording stats\nexport interface VideoRecordingStats {\n  duration: number;\n  fileSize: number;\n  framesRecorded: number;\n  droppedFrames: number;\n  averageFps: number;\n  storageUsed: number;\n  storageAvailable: number;\n  batteryLevel?: number;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/cache.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport const CACHE_KEYS = {\n  CHECKLIST_ITEMS: (inspectionId: string) => `checklist-items-${inspectionId}`,\n  INSPECTION: (inspectionId: string) => `inspection-${inspectionId}`,\n  PROPERTIES: 'properties-list',\n  USER_PROFILE: (userId: string) => `user-profile-${userId}`\n} as const;\n\nexport const CACHE_TTL = {\n  SHORT: 60000,    // 1 minute\n  MEDIUM: 300000,  // 5 minutes\n  LONG: 900000     // 15 minutes\n} as const;\n\ninterface CacheItem<T> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n}\n\nclass SimpleCache {\n  private cache = new Map<string, CacheItem<any>>();\n\n  set<T>(key: string, data: T, ttl: number = CACHE_TTL.MEDIUM): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  get<T>(key: string): T | null {\n    const item = this.cache.get(key);\n    \n    if (!item) {\n      return null;\n    }\n\n    const now = Date.now();\n    const isExpired = (now - item.timestamp) > item.ttl;\n\n    if (isExpired) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return item.data as T;\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys())\n    };\n  }\n}\n\nexport const cache = new SimpleCache();\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/categoryMapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/categoryUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/debugLogger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[167,170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[167,170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[323,326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[323,326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[955,958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[955,958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1062,1065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1062,1065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1168,1171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1168,1171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1275,1278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1275,1278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface DebugLogEntry {\n  timestamp: string;\n  level: LogLevel;\n  context: string;\n  message: string;\n  data?: any;\n}\n\nclass DebugLogger {\n  private logs: DebugLogEntry[] = [];\n  private maxLogs = 500;\n\n  log(level: LogLevel, context: string, message: string, data?: any) {\n    const entry: DebugLogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      context,\n      message,\n      data\n    };\n\n    this.logs.push(entry);\n    \n    // Keep only recent logs\n    if (this.logs.length > this.maxLogs) {\n      this.logs = this.logs.slice(-this.maxLogs);\n    }\n\n    // Console output with context\n    const consoleMethod = level === 'error' ? 'error' : \n                         level === 'warn' ? 'warn' : 'log';\n    \n    console[consoleMethod](\n      `ðŸ” [${level.toUpperCase()}] [${context}] ${message}`,\n      data || ''\n    );\n  }\n\n  debug(context: string, message: string, data?: any) {\n    this.log('debug', context, message, data);\n  }\n\n  info(context: string, message: string, data?: any) {\n    this.log('info', context, message, data);\n  }\n\n  warn(context: string, message: string, data?: any) {\n    this.log('warn', context, message, data);\n  }\n\n  error(context: string, message: string, data?: any) {\n    this.log('error', context, message, data);\n  }\n\n  getRecentLogs(count = 50): DebugLogEntry[] {\n    return this.logs.slice(-count);\n  }\n\n  clearLogs() {\n    this.logs = [];\n  }\n}\n\nexport const debugLogger = new DebugLogger();\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/fileValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[143,146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[143,146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[410,413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[410,413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1413,1416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1413,1416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1610,1613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1610,1613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1766,1769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1766,1769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1923,1926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1923,1926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3274,3277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3274,3277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3442,3445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3442,3445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  data?: any;\n  context?: string;\n  userId?: string;\n}\n\nclass Logger {\n  private logs: LogEntry[] = [];\n  private maxLogs = 1000;\n  private isDevelopment = process.env.NODE_ENV === 'development';\n\n  private createLogEntry(\n    level: LogLevel,\n    message: string,\n    data?: any,\n    context?: string\n  ): LogEntry {\n    return {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      data,\n      context,\n      userId: this.getCurrentUserId()\n    };\n  }\n\n  private getCurrentUserId(): string | undefined {\n    // This would be implemented based on your auth system\n    // For now, return undefined\n    return undefined;\n  }\n\n  private addLog(entry: LogEntry) {\n    this.logs.push(entry);\n    \n    // Keep only the most recent logs\n    if (this.logs.length > this.maxLogs) {\n      this.logs = this.logs.slice(-this.maxLogs);\n    }\n\n    // In development, also log to console\n    if (this.isDevelopment) {\n      const consoleMethod = entry.level === 'error' ? 'error' : \n                           entry.level === 'warn' ? 'warn' : 'log';\n      \n      console[consoleMethod](\n        `[${entry.level.toUpperCase()}] ${entry.context ? `[${entry.context}] ` : ''}${entry.message}`,\n        entry.data || ''\n      );\n    }\n  }\n\n  debug(message: string, data?: any, context?: string) {\n    if (this.isDevelopment) {\n      const entry = this.createLogEntry('debug', message, data, context);\n      this.addLog(entry);\n    }\n  }\n\n  info(message: string, data?: any, context?: string) {\n    const entry = this.createLogEntry('info', message, data, context);\n    this.addLog(entry);\n  }\n\n  warn(message: string, data?: any, context?: string) {\n    const entry = this.createLogEntry('warn', message, data, context);\n    this.addLog(entry);\n  }\n\n  error(message: string, data?: any, context?: string) {\n    const entry = this.createLogEntry('error', message, data, context);\n    this.addLog(entry);\n\n    // In production, you might want to send errors to a monitoring service\n    if (!this.isDevelopment) {\n      this.sendToMonitoringService(entry);\n    }\n  }\n\n  private async sendToMonitoringService(entry: LogEntry) {\n    // TODO: Integrate with error monitoring service like Sentry\n    try {\n      // Example implementation:\n      // await fetch('/api/log', {\n      //   method: 'POST',\n      //   headers: { 'Content-Type': 'application/json' },\n      //   body: JSON.stringify(entry)\n      // });\n    } catch (error) {\n      console.error('Failed to send log to monitoring service:', error);\n    }\n  }\n\n  // Get recent logs for debugging\n  getRecentLogs(count = 50): LogEntry[] {\n    return this.logs.slice(-count);\n  }\n\n  // Get logs by level\n  getLogsByLevel(level: LogLevel): LogEntry[] {\n    return this.logs.filter(log => log.level === level);\n  }\n\n  // Clear logs\n  clearLogs() {\n    this.logs = [];\n  }\n\n  // Export logs for debugging\n  exportLogs(): string {\n    return JSON.stringify(this.logs, null, 2);\n  }\n\n  // Performance timing\n  time(label: string) {\n    console.time(label);\n  }\n\n  timeEnd(label: string) {\n    console.timeEnd(label);\n  }\n\n  // User action tracking\n  trackUserAction(action: string, data?: any) {\n    this.info(`User action: ${action}`, data, 'USER_ACTION');\n  }\n\n  // API call tracking\n  trackApiCall(method: string, url: string, duration?: number, error?: any) {\n    const message = `API ${method} ${url}${duration ? ` (${duration}ms)` : ''}`;\n    \n    if (error) {\n      this.error(message, { error, duration }, 'API');\n    } else {\n      this.info(message, { duration }, 'API');\n    }\n  }\n}\n\n// Create singleton instance\nexport const logger = new Logger();\n\n// Convenience exports for common patterns\nexport const logApiCall = logger.trackApiCall.bind(logger);\nexport const logUserAction = logger.trackUserAction.bind(logger);\nexport const logError = logger.error.bind(logger);\nexport const logInfo = logger.info.bind(logger);\nexport const logWarn = logger.warn.bind(logger);\nexport const logDebug = logger.debug.bind(logger);\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/mobileCache.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":5,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[128,131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[128,131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// Mobile-optimized cache with performance monitoring\nclass MobileCacheManager {\n  private cache = new Map<string, {\n    data: any;\n    timestamp: number;\n    ttl: number;\n    accessCount: number;\n  }>();\n  \n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes for mobile\n  private readonly MAX_CACHE_SIZE = 50; // Limit cache size for mobile memory\n\n  set<T>(key: string, data: T, ttl: number = this.DEFAULT_TTL): void {\n    // Clear old entries if cache is full\n    if (this.cache.size >= this.MAX_CACHE_SIZE) {\n      this.evictOldEntries();\n    }\n\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl,\n      accessCount: 0\n    });\n  }\n\n  get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    // Update access count for LRU tracking\n    entry.accessCount++;\n    \n    return entry.data as T;\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  private evictOldEntries(): void {\n    // Remove expired entries first\n    for (const [key, entry] of this.cache.entries()) {\n      if (Date.now() - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n\n    // If still full, remove least recently used\n    if (this.cache.size >= this.MAX_CACHE_SIZE) {\n      const entries = Array.from(this.cache.entries());\n      entries.sort((a, b) => a[1].accessCount - b[1].accessCount);\n      \n      // Remove bottom 20%\n      const toRemove = Math.floor(entries.length * 0.2);\n      for (let i = 0; i < toRemove; i++) {\n        this.cache.delete(entries[i][0]);\n      }\n    }\n  }\n\n  getStats() {\n    return {\n      size: this.cache.size,\n      maxSize: this.MAX_CACHE_SIZE,\n      entries: Array.from(this.cache.keys())\n    };\n  }\n}\n\nexport const mobileCache = new MobileCacheManager();\n\n// Cache key generators\nexport const MOBILE_CACHE_KEYS = {\n  PROPERTIES: (userId?: string) => `mobile_properties_${userId || 'all'}`,\n  INSPECTION: (inspectionId: string) => `mobile_inspection_${inspectionId}`,\n  CHECKLIST_ITEMS: (inspectionId: string) => `mobile_checklist_${inspectionId}`,\n  PROPERTY_STATUS: (propertyId: string) => `mobile_property_status_${propertyId}`,\n  USER_ROLE: (userId: string) => `mobile_user_role_${userId}`,\n} as const;\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/mobileCacheUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/propertyDeletion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/utils/propertySubmissionErrors.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[168,171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[168,171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useToast } from \"@/hooks/use-toast\";\n\nexport const usePropertyErrorHandler = () => {\n  const { toast } = useToast();\n\n  const handleSubmissionError = (error: any, isEditing: boolean) => {\n    console.log('ðŸ” Analyzing submission error:', {\n      code: error.code,\n      message: error.message,\n      details: error.details,\n      hint: error.hint\n    });\n\n    let errorMessage = \"An error occurred while saving the property.\";\n    let isTemporary = false;\n    \n    // Network and timeout errors\n    if (error.code === 'PGRST301' || \n        error.code === 'PGRST504' ||\n        error.message?.includes('timeout') ||\n        error.message?.includes('network') ||\n        error.message?.includes('connection')) {\n      errorMessage = \"Network connection error. Please check your internet connection and try again.\";\n      isTemporary = true;\n    }\n    // Authentication errors\n    else if (error.code === '42501' || error.message?.includes('JWT')) {\n      errorMessage = \"Your session has expired. Please log in again.\";\n      isTemporary = true;\n    }\n    // Permission errors\n    else if (error.message?.includes('violates row-level security')) {\n      errorMessage = \"You don't have permission to access this property. Please contact your administrator.\";\n    }\n    // Unique constraint violations\n    else if (error.code === '23505') {\n      if (error.message?.includes('properties_name')) {\n        errorMessage = \"A property with this name already exists. Please choose a different name.\";\n      } else if (error.message?.includes('properties_vrbo_url')) {\n        errorMessage = \"This Vrbo URL is already registered. Please check if the property already exists.\";\n      } else if (error.message?.includes('properties_airbnb_url')) {\n        errorMessage = \"This Airbnb URL is already registered. Please check if the property already exists.\";\n      } else {\n        errorMessage = \"This property information conflicts with an existing property.\";\n      }\n    }\n    // Not found errors\n    else if (error.code === 'PGRST116') {\n      errorMessage = \"The property could not be found. It may have been deleted by another user.\";\n    }\n    // Foreign key violations\n    else if (error.code === '23503') {\n      errorMessage = \"Invalid reference data. Please refresh the page and try again.\";\n      isTemporary = true;\n    }\n    // Database constraint violations\n    else if (error.code === '23514') {\n      errorMessage = \"Invalid property data. Please check all fields and try again.\";\n    }\n    // NULL constraint violations\n    else if (error.code === '23502') {\n      if (error.message?.includes('added_by')) {\n        errorMessage = \"Authentication error: Please try logging out and back in.\";\n        isTemporary = true;\n      } else {\n        errorMessage = \"Required information is missing. Please fill in all required fields.\";\n      }\n    }\n\n    console.log('ðŸ“‹ Error analysis result:', {\n      originalError: error.code,\n      userMessage: errorMessage,\n      isTemporary,\n      shouldRetry: isTemporary\n    });\n\n    toast({\n      title: `Error ${isEditing ? 'Updating' : 'Creating'} Property`,\n      description: errorMessage,\n      variant: \"destructive\",\n    });\n\n    return { errorMessage, isTemporary };\n  };\n\n  const handleUnexpectedError = () => {\n    console.error('ðŸ’¥ Handling unexpected error');\n    \n    toast({\n      title: \"Unexpected Error\",\n      description: \"An unexpected error occurred. Please try again or contact support if the problem persists.\",\n      variant: \"destructive\",\n    });\n  };\n\n  const handleSuccess = (propertyName: string, isEditing: boolean) => {\n    console.log('ðŸŽ‰ Handling successful submission:', {\n      propertyName,\n      operation: isEditing ? 'update' : 'create'\n    });\n\n    toast({\n      title: `Property ${isEditing ? 'Updated' : 'Added'}`,\n      description: `The property \"${propertyName}\" has been ${isEditing ? 'updated' : 'added'} successfully.`,\n    });\n  };\n\n  return { \n    handleSubmissionError, \n    handleUnexpectedError, \n    handleSuccess \n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/tailwind.config.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":95,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":95,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Config } from \"tailwindcss\";\n\nexport default {\n\tdarkMode: [\"class\"],\n\tcontent: [\n\t\t\"./pages/**/*.{ts,tsx}\",\n\t\t\"./components/**/*.{ts,tsx}\",\n\t\t\"./app/**/*.{ts,tsx}\",\n\t\t\"./src/**/*.{ts,tsx}\",\n\t],\n\tprefix: \"\",\n\ttheme: {\n\t\tcontainer: {\n\t\t\tcenter: true,\n\t\t\tpadding: '2rem',\n\t\t\tscreens: {\n\t\t\t\t'2xl': '1400px'\n\t\t\t}\n\t\t},\n\t\textend: {\n\t\t\tcolors: {\n\t\t\t\tborder: 'hsl(var(--border))',\n\t\t\t\tinput: 'hsl(var(--input))',\n\t\t\t\tring: 'hsl(var(--ring))',\n\t\t\t\tbackground: 'hsl(var(--background))',\n\t\t\t\tforeground: 'hsl(var(--foreground))',\n\t\t\t\tprimary: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--primary))',\n\t\t\t\t\tforeground: 'hsl(var(--primary-foreground))'\n\t\t\t\t},\n\t\t\t\tsecondary: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--secondary))',\n\t\t\t\t\tforeground: 'hsl(var(--secondary-foreground))'\n\t\t\t\t},\n\t\t\t\tdestructive: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--destructive))',\n\t\t\t\t\tforeground: 'hsl(var(--destructive-foreground))'\n\t\t\t\t},\n\t\t\t\tmuted: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--muted))',\n\t\t\t\t\tforeground: 'hsl(var(--muted-foreground))'\n\t\t\t\t},\n\t\t\t\taccent: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--accent))',\n\t\t\t\t\tforeground: 'hsl(var(--accent-foreground))'\n\t\t\t\t},\n\t\t\t\tpopover: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--popover))',\n\t\t\t\t\tforeground: 'hsl(var(--popover-foreground))'\n\t\t\t\t},\n\t\t\t\tcard: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--card))',\n\t\t\t\t\tforeground: 'hsl(var(--card-foreground))'\n\t\t\t\t},\n\t\t\t\tsidebar: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--sidebar-background))',\n\t\t\t\t\tforeground: 'hsl(var(--sidebar-foreground))',\n\t\t\t\t\tprimary: 'hsl(var(--sidebar-primary))',\n\t\t\t\t\t'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',\n\t\t\t\t\taccent: 'hsl(var(--sidebar-accent))',\n\t\t\t\t\t'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',\n\t\t\t\t\tborder: 'hsl(var(--sidebar-border))',\n\t\t\t\t\tring: 'hsl(var(--sidebar-ring))'\n\t\t\t\t}\n\t\t\t},\n\t\t\tborderRadius: {\n\t\t\t\tlg: 'var(--radius)',\n\t\t\t\tmd: 'calc(var(--radius) - 2px)',\n\t\t\t\tsm: 'calc(var(--radius) - 4px)'\n\t\t\t},\n\t\t\tkeyframes: {\n\t\t\t\t'accordion-down': {\n\t\t\t\t\tfrom: {\n\t\t\t\t\t\theight: '0'\n\t\t\t\t\t},\n\t\t\t\t\tto: {\n\t\t\t\t\t\theight: 'var(--radix-accordion-content-height)'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'accordion-up': {\n\t\t\t\t\tfrom: {\n\t\t\t\t\t\theight: 'var(--radix-accordion-content-height)'\n\t\t\t\t\t},\n\t\t\t\t\tto: {\n\t\t\t\t\t\theight: '0'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation: {\n\t\t\t\t'accordion-down': 'accordion-down 0.2s ease-out',\n\t\t\t\t'accordion-up': 'accordion-up 0.2s ease-out'\n\t\t\t}\n\t\t}\n\t},\n\tplugins: [require(\"tailwindcss-animate\")],\n} satisfies Config;\n","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/test-static-photo-extraction.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[382,385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[382,385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[577,580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[577,580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[774,777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[774,777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[960,963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[960,963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Test script to demonstrate static photo extraction vs browser automation\n// This shows the difference between the original working method and the enhanced approach\n\nimport { extractVRBOPhotosStatic, createStaticVRBOPhotoExtractor } from './src/lib/scrapers/static-vrbo-photo-extractor';\n\n// Mock logger to avoid dependencies\nconst mockLogger = {\n  info: (message: string, data?: any, context?: string) => {\n    console.log(`[INFO] ${context || 'TEST'}: ${message}`);\n    if (data) console.log('  Data:', JSON.stringify(data, null, 2));\n  },\n  warn: (message: string, data?: any, context?: string) => {\n    console.log(`[WARN] ${context || 'TEST'}: ${message}`);\n    if (data) console.log('  Data:', JSON.stringify(data, null, 2));\n  },\n  error: (message: string, error?: any, context?: string) => {\n    console.log(`[ERROR] ${context || 'TEST'}: ${message}`);\n    if (error) console.log('  Error:', error);\n  }\n};\n\n// Replace the logger globally\n(global as any).logger = mockLogger;\n\nasync function testStaticPhotoExtraction() {\n  console.log('ðŸ” Testing Static VRBO Photo Extraction');\n  console.log('========================================\\n');\n\n  // Test URLs (these would be real VRBO URLs in actual testing)\n  const testUrls = [\n    'https://www.vrbo.com/1234567', // Mock URL 1\n    'https://www.vrbo.com/2345678', // Mock URL 2\n    'https://www.vrbo.com/3456789'  // Mock URL 3\n  ];\n\n  console.log('ðŸ“ NOTE: Testing with mock URLs - replace with real VRBO URLs for actual testing\\n');\n\n  for (const url of testUrls) {\n    console.log(`ðŸ” Testing URL: ${url}`);\n    console.log(''.padEnd(60, '-'));\n\n    try {\n      const startTime = Date.now();\n      \n      // Create extractor with optimized settings\n      const extractor = createStaticVRBOPhotoExtractor({\n        maxImages: 30,\n        includeHighRes: true,\n        includeThumbnails: true,\n        deduplicateImages: true,\n        timeout: 30000\n      });\n\n      // Extract photos using static method\n      const result = await extractor.extractPhotos(url);\n      \n      const duration = Date.now() - startTime;\n\n      if (result.success) {\n        const data = result.data!;\n        \n        console.log('âœ… SUCCESS!');\n        console.log(`â±ï¸  Duration: ${duration}ms`);\n        console.log(`ðŸ“¸ Total Photos: ${data.photos.length}`);\n        console.log(`ðŸ“Š Extraction Stats:`);\n        console.log(`   Static Images: ${data.extractionStats.staticImages}`);\n        console.log(`   Lazy Images: ${data.extractionStats.lazyImages}`);\n        console.log(`   Gallery Images: ${data.extractionStats.galleryImages}`);\n        console.log(`   JSON-LD Images: ${data.extractionStats.jsonLdImages}`);\n        console.log(`   Total Found: ${data.extractionStats.totalFound}`);\n        console.log(`   Duplicates Removed: ${data.extractionStats.duplicatesRemoved}`);\n\n        // Show sample photos\n        if (data.photos.length > 0) {\n          console.log(`\\nðŸ“· Sample Photos:`);\n          data.photos.slice(0, 5).forEach((photo, index) => {\n            console.log(`   ${index + 1}. ${photo.category} - ${photo.url}`);\n          });\n          \n          if (data.photos.length > 5) {\n            console.log(`   ... and ${data.photos.length - 5} more photos`);\n          }\n        }\n\n        // Show data completeness\n        console.log(`\\nðŸ“Š Data Completeness: ${result.metadata.dataCompleteness}%`);\n        \n      } else {\n        console.log('âŒ FAILED!');\n        console.log(`â±ï¸  Duration: ${duration}ms`);\n        console.log(`ðŸ’¥ Errors: ${result.errors.length}`);\n        result.errors.forEach((error, index) => {\n          console.log(`   ${index + 1}. ${error.code}: ${error.message}`);\n        });\n      }\n\n    } catch (error) {\n      console.log('âŒ EXCEPTION!');\n      console.log(`ðŸ’¥ Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    console.log(''); // Empty line between tests\n  }\n\n  // Summary and comparison\n  console.log('\\nðŸ“Š STATIC PHOTO EXTRACTION ANALYSIS');\n  console.log('====================================');\n  \n  console.log('ðŸŽ¯ Static Method Strengths:');\n  console.log('  âœ… Fast execution (< 5 seconds)');\n  console.log('  âœ… No browser dependencies');\n  console.log('  âœ… Reliable for static content');\n  console.log('  âœ… Extracts images from multiple sources:');\n  console.log('     - Standard img tags');\n  console.log('     - Lazy loading attributes');\n  console.log('     - JavaScript variables');\n  console.log('     - JSON-LD structured data');\n  console.log('  âœ… Good for thumbnails and preview images');\n  console.log('');\n\n  console.log('âš ï¸  Static Method Limitations:');\n  console.log('  âŒ Cannot trigger dynamic gallery loading');\n  console.log('  âŒ Misses photos that require user interaction');\n  console.log('  âŒ Cannot simulate clicking on photo galleries');\n  console.log('  âŒ Limited to initially loaded content');\n  console.log('  âŒ May get 5-10 photos vs 20-30 with browser automation');\n  console.log('');\n\n  console.log('ðŸ¤– Browser Automation Advantages:');\n  console.log('  ðŸš€ Can click on photos to open galleries');\n  console.log('  ðŸš€ Can scroll through gallery to load more images');\n  console.log('  ðŸš€ Executes JavaScript to reveal hidden content');\n  console.log('  ðŸš€ Simulates real user interactions');\n  console.log('  ðŸš€ Accesses dynamically loaded content');\n  console.log('  ðŸš€ Should extract 20-30 photos vs 5-10 static');\n  console.log('');\n\n  console.log('ðŸ’¡ HYBRID APPROACH BENEFITS:');\n  console.log('==============================');\n  console.log('1. Use static method as baseline (fast, reliable)');\n  console.log('2. Enhance with browser automation for galleries');\n  console.log('3. Combine results for maximum photo coverage');\n  console.log('4. Fallback to static if browser automation fails');\n  console.log('5. Best of both worlds: speed + completeness');\n  console.log('');\n\n  console.log('ðŸ§ª NEXT TESTING STEPS:');\n  console.log('======================');\n  console.log('1. Test with real VRBO URLs to see actual photo counts');\n  console.log('2. Compare static vs browser automation results');\n  console.log('3. Measure performance differences');\n  console.log('4. Optimize hybrid approach based on results');\n  console.log('');\n\n  console.log('ðŸŽ¯ EXPECTED RESULTS WITH REAL URLS:');\n  console.log('===================================');\n  console.log('Static Method: 5-10 photos (thumbnails + hero images)');\n  console.log('Browser Automation: 20-30 photos (full gallery)');\n  console.log('Hybrid Approach: 25-35 photos (all sources combined)');\n  console.log('');\n\n  console.log('âœ… CONCLUSION:');\n  console.log('==============');\n  console.log('The static photo extraction method IS working and well-implemented.');\n  console.log('The issue is that VRBO requires user interaction for full galleries.');\n  console.log('Browser automation is the key to accessing the complete photo set.');\n  console.log('The hybrid approach preserves the working static method while adding');\n  console.log('browser automation for maximum photo extraction coverage.');\n}\n\n// Run the test\nif (require.main === module) {\n  testStaticPhotoExtraction().catch(console.error);\n}\n\nexport { testStaticPhotoExtraction };","usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/test-vrbo-photo-extraction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/test-vrbo-scraper.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/vite.admin.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/vite.inspector.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/ryanrabideau/doublecheck-field-view/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]